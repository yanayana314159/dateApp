"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/userpage/makeplans/page",{

/***/ "(app-pages-browser)/./app/components/calculateFreeTime.tsx":
/*!**********************************************!*\
  !*** ./app/components/calculateFreeTime.tsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ calculateFreeTime; }\n/* harmony export */ });\nfunction calculateFreeTime(events) {\n    // 取得したカレンダーから空き時間を2進数形式で抽出\n    const bitEmptyTimeOfDays = calculateEmptyTimeOfDays(events);\n    // Date形式に戻す\n    const emptyTimeOfDays = changeBitToDate(bitEmptyTimeOfDays);\n    // 出力\n    const freeTime = displayDays(emptyTimeOfDays);\n    return freeTime;\n// 日毎に、空き時間が「10:00-11:30,14:15-15:45」のような形式で出力される\n}\n/**\n * 空き日程をbit形式で返却\n */ function calculateEmptyTimeOfDays(events) {\n    const bitDays = [];\n    events.map((event)=>{\n        const bitDay = changeDateToBit(event);\n        const { key, value } = bitDay;\n        if (bitDays[key] !== undefined) {\n            // 論理和を取る\n            // 追記：BigInt型にキャストして演算を行う\n            bitDays[key] = \"0b\" + (BigInt(bitDays[key]) | BigInt(value)).toString(2).padStart(56, \"0\");\n        } else {\n            bitDays[key] = value;\n        }\n    });\n    return bitDays;\n}\n/**\n * bit形式に変換\n * @return {\"key\": key, \"value\": value}, key = 日付, value = bit\n * bit定義 → 15分区切りで表現、0 = 予定なし、1 = 予定あり\n * 例（_は実際には含まれない）：11:00-12:15予定あり → 「0000_0000_1111_1000_0000_0000_0000_0000_0000_0000_0000」\n * 4 * 11 = 44bit→56bit\n */ function changeDateToBit(event) {\n    const start = event.start;\n    const end = event.end;\n    // 対象の時間\n    const clockIn = new Date(start.getFullYear(), start.getMonth(), start.getDate(), 9, 0);\n    const clockOut = new Date(start.getFullYear(), start.getMonth(), start.getDate(), 23, 0);\n    let dateBit = \"0b\";\n    let checkDuration = new Date(clockIn);\n    for(let i = 0; i < 56; i++){\n        if (start <= checkDuration && checkDuration < end) {\n            dateBit += \"1\";\n        } else {\n            dateBit += \"0\";\n        }\n        if (checkDuration >= clockOut) {\n            break;\n        }\n        checkDuration.setMinutes(checkDuration.getMinutes() + 15);\n    }\n    const dateKey = getDateLabel(start);\n    return {\n        key: dateKey,\n        value: dateBit\n    };\n}\n/**\n * Bit形式の日付をDate型に戻す\n * @return {<日付> : {\"start\": <日時>, \"end\": <日時>}[]}[]\n */ function changeBitToDate(bitDays) {\n    const freeTimes = {};\n    Object.keys(bitDays).forEach((key)=>{\n        // 先頭の「0b」除去\n        const dateBit = bitDays[key].replace(/^0b/, \"\");\n        // 範囲の始点を設定\n        const clockIn = new Date(key);\n        clockIn.setHours(9);\n        clockIn.setMinutes(0);\n        let start;\n        let end;\n        const freeDurations = [];\n        for(let i = 0; i < dateBit.length; i++){\n            const bit = dateBit.charAt(i);\n            if (!start) {\n                if (bit === \"0\") {\n                    start = new Date(clockIn);\n                    start.setMinutes(start.getMinutes() + 15 * i);\n                }\n            } else {\n                if (bit === \"1\" || i === dateBit.length - 1) {\n                    if (bit === \"1\") {\n                        end = new Date(clockIn);\n                        end.setMinutes(end.getMinutes() + 15 * i);\n                    } else {\n                        end = new Date(clockIn);\n                        end.setMinutes(end.getMinutes() + 15 * (i + 1));\n                    }\n                    freeDurations.push({\n                        start: getDateTimeLabel(start),\n                        end: getDateTimeLabel(end)\n                    });\n                    // リセット\n                    start = undefined;\n                    end = undefined;\n                }\n            }\n        }\n        freeTimes[key] = freeDurations;\n    });\n    return freeTimes;\n}\n/**\n * 日時をシートに表示\n * @param days {<日付> : {\"start\": <日時>, \"end\": <日時>}[]}[]\n */ function displayDays(days) {\n    const freeTime = [];\n    Object.keys(days).forEach((key, i)=>{\n        let value = \"\";\n        days[key].forEach((e)=>{\n            value += \"\".concat(e.start, \"-\").concat(e.end) + \",\";\n        });\n        // 出力\n        freeTime.push(value.slice(0, -1));\n    });\n    return freeTime;\n}\n/**\n * YYYY/MM/DDを返す\n */ function getDateLabel(date) {\n    return \"\".concat(date.getFullYear(), \"/\").concat((\"0\" + (date.getMonth() + 1)).slice(-2), \"/\").concat((\"0\" + date.getDate()).slice(-2));\n}\n/**\n * hh:mmを返す\n */ function getTimeLabel(date) {\n    return \"\".concat((\"0\" + date.getHours()).slice(-2), \":\").concat((\"0\" + date.getMinutes()).slice(-2));\n}\n/**\n * YYYY/MM/DD hh:mmを返す\n */ function getDateTimeLabel(date) {\n    return \"\".concat(date.getFullYear(), \"/\").concat((\"0\" + (date.getMonth() + 1)).slice(-2), \"/\").concat((\"0\" + date.getDate()).slice(-2), \" \").concat((\"0\" + date.getHours()).slice(-2), \":\").concat((\"0\" + date.getMinutes()).slice(-2));\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL2NhbGN1bGF0ZUZyZWVUaW1lLnRzeCIsIm1hcHBpbmdzIjoiOzs7O0FBRWUsU0FBU0Esa0JBQWtCQyxNQUFXO0lBQ25ELDJCQUEyQjtJQUMzQixNQUFNQyxxQkFBcUJDLHlCQUF5QkY7SUFFcEQsWUFBWTtJQUNaLE1BQU1HLGtCQUFrQkMsZ0JBQWdCSDtJQUN4QyxLQUFLO0lBQ0wsTUFBTUksV0FBV0MsWUFBWUg7SUFFN0IsT0FBT0U7QUFFUCxpREFBaUQ7QUFDbkQ7QUFFQTs7Q0FFQyxHQUVELFNBQVNILHlCQUF5QkYsTUFBb0M7SUFDcEUsTUFBTU8sVUFBNEIsRUFBRTtJQUVwQ1AsT0FBT1EsR0FBRyxDQUFDLENBQUNDO1FBQ1YsTUFBTUMsU0FBU0MsZ0JBQWdCRjtRQUMvQixNQUFNLEVBQUVHLEdBQUcsRUFBRUMsS0FBSyxFQUFFLEdBQW1DSDtRQUV2RCxJQUFJSCxPQUFPLENBQUNLLElBQUksS0FBS0UsV0FBVztZQUM5QixTQUFTO1lBQ1QseUJBQXlCO1lBQ3pCUCxPQUFPLENBQUNLLElBQUksR0FDVixPQUNBLENBQUNHLE9BQU9SLE9BQU8sQ0FBQ0ssSUFBSSxJQUFJRyxPQUFPRixNQUFLLEVBQUdHLFFBQVEsQ0FBQyxHQUFHQyxRQUFRLENBQUMsSUFBSTtRQUNwRSxPQUFPO1lBQ0xWLE9BQU8sQ0FBQ0ssSUFBSSxHQUFHQztRQUNqQjtJQUNGO0lBRUEsT0FBT047QUFDVDtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNJLGdCQUFnQkYsS0FBaUM7SUFDeEQsTUFBTVMsUUFBUVQsTUFBTVMsS0FBSztJQUN6QixNQUFNQyxNQUFNVixNQUFNVSxHQUFHO0lBRXJCLFFBQVE7SUFDUixNQUFNQyxVQUFVLElBQUlDLEtBQ2xCSCxNQUFNSSxXQUFXLElBQ2pCSixNQUFNSyxRQUFRLElBQ2RMLE1BQU1NLE9BQU8sSUFDYixHQUNBO0lBRUYsTUFBTUMsV0FBVyxJQUFJSixLQUNuQkgsTUFBTUksV0FBVyxJ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LEVBQUd3QixLQUFLLENBQUMsQ0FBQyxJQUFHLEtBRTVELE9BRitELENBQ3pFLE1BQU1DLEtBQUt4QixPQUFPLEVBQUMsRUFDbkJ1QixLQUFLLENBQUMsQ0FBQztBQUNYO0FBRUE7O0NBRUMsR0FDRCxTQUFTRSxhQUFhRCxJQUFJO0lBQ3hCLE9BQU8sR0FBd0MsT0FBckMsQ0FBQyxNQUFNQSxLQUFLRSxRQUFRLEVBQUMsRUFBR0gsS0FBSyxDQUFDLENBQUMsSUFBRyxLQUVoQyxPQUZtQyxDQUM3QyxNQUFNQyxLQUFLbEIsVUFBVSxFQUFDLEVBQ3RCaUIsS0FBSyxDQUFDLENBQUM7QUFDWDtBQUVBOztDQUVDLEdBQ0QsU0FBU0gsaUJBQWlCSSxJQUFJO0lBQzVCLE9BQU8sR0FBeUIsT0FBdEJBLEtBQUsxQixXQUFXLElBQUcsS0FBOEMsT0FBM0MsQ0FBQyxNQUFPMEIsQ0FBQUEsS0FBS3pCLFFBQVEsS0FBSyxFQUFDLEVBQUd3QixLQUFLLENBQUMsQ0FBQyxJQUFHLEtBRXpELE9BRjRELENBQ3pFLE1BQU1DLEtBQUt4QixPQUFPLEVBQUMsRUFDbkJ1QixLQUFLLENBQUMsQ0FBQyxJQUFHLEtBQXdDLE9BQXJDLENBQUMsTUFBTUMsS0FBS0UsUUFBUSxFQUFDLEVBQUdILEtBQUssQ0FBQyxDQUFDLElBQUcsS0FFckMsT0FGd0MsQ0FDbEQsTUFBTUMsS0FBS2xCLFVBQVUsRUFBQyxFQUN0QmlCLEtBQUssQ0FBQyxDQUFDO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2NvbXBvbmVudHMvY2FsY3VsYXRlRnJlZVRpbWUudHN4PzFjYjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3RyaW5nIH0gZnJvbSBcInlhcmdzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNhbGN1bGF0ZUZyZWVUaW1lKGV2ZW50czogYW55KSB7XG4gIC8vIOWPluW+l+OBl+OBn+OCq+ODrOODs+ODgOODvOOBi+OCieepuuOBjeaZgumWk+OCkjLpgLLmlbDlvaLlvI/jgafmir3lh7pcbiAgY29uc3QgYml0RW1wdHlUaW1lT2ZEYXlzID0gY2FsY3VsYXRlRW1wdHlUaW1lT2ZEYXlzKGV2ZW50cyk7XG5cbiAgLy8gRGF0ZeW9ouW8j+OBq+aIu+OBmVxuICBjb25zdCBlbXB0eVRpbWVPZkRheXMgPSBjaGFuZ2VCaXRUb0RhdGUoYml0RW1wdHlUaW1lT2ZEYXlzKTtcbiAgLy8g5Ye65YqbXG4gIGNvbnN0IGZyZWVUaW1lID0gZGlzcGxheURheXMoZW1wdHlUaW1lT2ZEYXlzKTtcblxuICByZXR1cm4gZnJlZVRpbWU7XG5cbiAgLy8g5pel5q+O44Gr44CB56m644GN5pmC6ZaT44GM44CMMTA6MDAtMTE6MzAsMTQ6MTUtMTU6NDXjgI3jga7jgojjgYbjgarlvaLlvI/jgaflh7rlipvjgZXjgozjgotcbn1cblxuLyoqXG4gKiDnqbrjgY3ml6XnqIvjgpJiaXTlvaLlvI/jgafov5TljbRcbiAqL1xuXG5mdW5jdGlvbiBjYWxjdWxhdGVFbXB0eVRpbWVPZkRheXMoZXZlbnRzOiB7IHN0YXJ0OiBEYXRlOyBlbmQ6IERhdGUgfVtdKSB7XG4gIGNvbnN0IGJpdERheXM6IFtzdHJpbmcsIHN0cmluZ10gPSBbXTtcblxuICBldmVudHMubWFwKChldmVudCkgPT4ge1xuICAgIGNvbnN0IGJpdERheSA9IGNoYW5nZURhdGVUb0JpdChldmVudCk7XG4gICAgY29uc3QgeyBrZXksIHZhbHVlIH06IHsga2V5OiBzdHJpbmc7IHZhbHVlOiBzdHJpbmcgfSA9IGJpdERheTtcblxuICAgIGlmIChiaXREYXlzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8g6KuW55CG5ZKM44KS5Y+W44KLXG4gICAgICAvLyDov73oqJjvvJpCaWdJbnTlnovjgavjgq3jg6Pjgrnjg4jjgZfjgabmvJTnrpfjgpLooYzjgYZcbiAgICAgIGJpdERheXNba2V5XSA9XG4gICAgICAgIFwiMGJcIiArXG4gICAgICAgIChCaWdJbnQoYml0RGF5c1trZXldKSB8IEJpZ0ludCh2YWx1ZSkpLnRvU3RyaW5nKDIpLnBhZFN0YXJ0KDU2LCBcIjBcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJpdERheXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGJpdERheXM7XG59XG5cbi8qKlxuICogYml05b2i5byP44Gr5aSJ5o+bXG4gKiBAcmV0dXJuIHtcImtleVwiOiBrZXksIFwidmFsdWVcIjogdmFsdWV9LCBrZXkgPSDml6Xku5gsIHZhbHVlID0gYml0XG4gKiBiaXTlrprnvqkg4oaSIDE15YiG5Yy65YiH44KK44Gn6KGo54++44CBMCA9IOS6iOWumuOBquOBl+OAgTEgPSDkuojlrprjgYLjgopcbiAqIOS+i++8iF/jga/lrp/pmpvjgavjga/lkKvjgb7jgozjgarjgYTvvInvvJoxMTowMC0xMjoxNeS6iOWumuOBguOCiiDihpIg44CMMDAwMF8wMDAwXzExMTFfMTAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAw44CNXG4gKiA0ICogMTEgPSA0NGJpdOKGkjU2Yml0XG4gKi9cbmZ1bmN0aW9uIGNoYW5nZURhdGVUb0JpdChldmVudDogeyBzdGFydDogRGF0ZTsgZW5kOiBEYXRlIH0pIHtcbiAgY29uc3Qgc3RhcnQgPSBldmVudC5zdGFydDtcbiAgY29uc3QgZW5kID0gZXZlbnQuZW5kO1xuXG4gIC8vIOWvvuixoeOBruaZgumWk1xuICBjb25zdCBjbG9ja0luID0gbmV3IERhdGUoXG4gICAgc3RhcnQuZ2V0RnVsbFllYXIoKSxcbiAgICBzdGFydC5nZXRNb250aCgpLFxuICAgIHN0YXJ0LmdldERhdGUoKSxcbiAgICA5LFxuICAgIDBcbiAgKTtcbiAgY29uc3QgY2xvY2tPdXQgPSBuZXcgRGF0ZShcbiAgICBzdGFydC5nZXRGdWxsWWVhcigpLFxuICAgIHN0YXJ0LmdldE1vbnRoKCksXG4gICAgc3RhcnQuZ2V0RGF0ZSgpLFxuICAgIDIzLFxuICAgIDBcbiAgKTtcblxuICBsZXQgZGF0ZUJpdDogc3RyaW5nID0gXCIwYlwiO1xuICBsZXQgY2hlY2tEdXJhdGlvbiA9IG5ldyBEYXRlKGNsb2NrSW4pO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNTY7IGkrKykge1xuICAgIGlmIChzdGFydCA8PSBjaGVja0R1cmF0aW9uICYmIGNoZWNrRHVyYXRpb24gPCBlbmQpIHtcbiAgICAgIGRhdGVCaXQgKz0gXCIxXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGVCaXQgKz0gXCIwXCI7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrRHVyYXRpb24gPj0gY2xvY2tPdXQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjaGVja0R1cmF0aW9uLnNldE1pbnV0ZXMoY2hlY2tEdXJhdGlvbi5nZXRNaW51dGVzKCkgKyAxNSk7XG4gIH1cblxuICBjb25zdCBkYXRlS2V5OiBzdHJpbmcgPSBnZXREYXRlTGFiZWwoc3RhcnQpO1xuICByZXR1cm4geyBrZXk6IGRhdGVLZXksIHZhbHVlOiBkYXRlQml0IH07XG59XG5cbi8qKlxuICogQml05b2i5byP44Gu5pel5LuY44KSRGF0ZeWei+OBq+aIu+OBmVxuICogQHJldHVybiB7POaXpeS7mD4gOiB7XCJzdGFydFwiOiA85pel5pmCPiwgXCJlbmRcIjogPOaXpeaZgj59W119W11cbiAqL1xuZnVuY3Rpb24gY2hhbmdlQml0VG9EYXRlKGJpdERheXM6IFtzdHJpbmcsIHN0cmluZ10pIHtcbiAgY29uc3QgZnJlZVRpbWVzID0ge307XG5cbiAgT2JqZWN0LmtleXMoYml0RGF5cykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgLy8g5YWI6aCt44Gu44CMMGLjgI3pmaTljrtcbiAgICBjb25zdCBkYXRlQml0ID0gYml0RGF5c1trZXldLnJlcGxhY2UoL14wYi8sIFwiXCIpO1xuXG4gICAgLy8g56+E5Zuy44Gu5aeL54K544KS6Kit5a6aXG4gICAgY29uc3QgY2xvY2tJbiA9IG5ldyBEYXRlKGtleSk7XG4gICAgY2xvY2tJbi5zZXRIb3Vycyg5KTtcbiAgICBjbG9ja0luLnNldE1pbnV0ZXMoMCk7XG5cbiAgICBsZXQgc3RhcnQ7XG4gICAgbGV0IGVuZDtcbiAgICBjb25zdCBmcmVlRHVyYXRpb25zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRlQml0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBiaXQgPSBkYXRlQml0LmNoYXJBdChpKTtcbiAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgaWYgKGJpdCA9PT0gXCIwXCIpIHtcbiAgICAgICAgICBzdGFydCA9IG5ldyBEYXRlKGNsb2NrSW4pO1xuICAgICAgICAgIHN0YXJ0LnNldE1pbnV0ZXMoc3RhcnQuZ2V0TWludXRlcygpICsgMTUgKiBpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGJpdCA9PT0gXCIxXCIgfHwgaSA9PT0gZGF0ZUJpdC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgaWYgKGJpdCA9PT0gXCIxXCIpIHtcbiAgICAgICAgICAgIGVuZCA9IG5ldyBEYXRlKGNsb2NrSW4pO1xuICAgICAgICAgICAgZW5kLnNldE1pbnV0ZXMoZW5kLmdldE1pbnV0ZXMoKSArIDE1ICogaSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuZCA9IG5ldyBEYXRlKGNsb2NrSW4pO1xuICAgICAgICAgICAgZW5kLnNldE1pbnV0ZXMoZW5kLmdldE1pbnV0ZXMoKSArIDE1ICogKGkgKyAxKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyZWVEdXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBzdGFydDogZ2V0RGF0ZVRpbWVMYWJlbChzdGFydCksXG4gICAgICAgICAgICBlbmQ6IGdldERhdGVUaW1lTGFiZWwoZW5kKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyDjg6rjgrvjg4Pjg4hcbiAgICAgICAgICBzdGFydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBlbmQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnJlZVRpbWVzW2tleV0gPSBmcmVlRHVyYXRpb25zO1xuICB9KTtcblxuICByZXR1cm4gZnJlZVRpbWVzO1xufVxuXG4vKipcbiAqIOaXpeaZguOCkuOCt+ODvOODiOOBq+ihqOekulxuICogQHBhcmFtIGRheXMgezzml6Xku5g+IDoge1wic3RhcnRcIjogPOaXpeaZgj4sIFwiZW5kXCI6IDzml6XmmYI+fVtdfVtdXG4gKi9cbmZ1bmN0aW9uIGRpc3BsYXlEYXlzKGRheXMpIHtcbiAgY29uc3QgZnJlZVRpbWUgPSBbXTtcbiAgT2JqZWN0LmtleXMoZGF5cykuZm9yRWFjaCgoa2V5LCBpKSA9PiB7XG4gICAgbGV0IHZhbHVlID0gXCJcIjtcbiAgICBkYXlzW2tleV0uZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgdmFsdWUgKz0gYCR7ZS5zdGFydH0tJHtlLmVuZH1gICsgXCIsXCI7XG4gICAgfSk7XG4gICAgLy8g5Ye65YqbXG4gICAgZnJlZVRpbWUucHVzaCh2YWx1ZS5zbGljZSgwLCAtMSkpO1xuICB9KTtcbiAgcmV0dXJuIGZyZWVUaW1lO1xufVxuXG4vKipcbiAqIFlZWVkvTU0vRETjgpLov5TjgZlcbiAqL1xuZnVuY3Rpb24gZ2V0RGF0ZUxhYmVsKGRhdGUpIHtcbiAgcmV0dXJuIGAke2RhdGUuZ2V0RnVsbFllYXIoKX0vJHsoXCIwXCIgKyAoZGF0ZS5nZXRNb250aCgpICsgMSkpLnNsaWNlKC0yKX0vJHsoXG4gICAgXCIwXCIgKyBkYXRlLmdldERhdGUoKVxuICApLnNsaWNlKC0yKX1gO1xufVxuXG4vKipcbiAqIGhoOm1t44KS6L+U44GZXG4gKi9cbmZ1bmN0aW9uIGdldFRpbWVMYWJlbChkYXRlKSB7XG4gIHJldHVybiBgJHsoXCIwXCIgKyBkYXRlLmdldEhvdXJzKCkpLnNsaWNlKC0yKX06JHsoXG4gICAgXCIwXCIgKyBkYXRlLmdldE1pbnV0ZXMoKVxuICApLnNsaWNlKC0yKX1gO1xufVxuXG4vKipcbiAqIFlZWVkvTU0vREQgaGg6bW3jgpLov5TjgZlcbiAqL1xuZnVuY3Rpb24gZ2V0RGF0ZVRpbWVMYWJlbChkYXRlKSB7XG4gIHJldHVybiBgJHtkYXRlLmdldEZ1bGxZZWFyKCl9LyR7KFwiMFwiICsgKGRhdGUuZ2V0TW9udGgoKSArIDEpKS5zbGljZSgtMil9LyR7KFxuICAgIFwiMFwiICsgZGF0ZS5nZXREYXRlKClcbiAgKS5zbGljZSgtMil9ICR7KFwiMFwiICsgZGF0ZS5nZXRIb3VycygpKS5zbGljZSgtMil9OiR7KFxuICAgIFwiMFwiICsgZGF0ZS5nZXRNaW51dGVzKClcbiAgKS5zbGljZSgtMil9YDtcbn1cbiJdLCJuYW1lcyI6WyJjYWxjdWxhdGVGcmVlVGltZSIsImV2ZW50cyIsImJpdEVtcHR5VGltZU9mRGF5cyIsImNhbGN1bGF0ZUVtcHR5VGltZU9mRGF5cyIsImVtcHR5VGltZU9mRGF5cyIsImNoYW5nZUJpdFRvRGF0ZSIsImZyZWVUaW1lIiwiZGlzcGxheURheXMiLCJiaXREYXlzIiwibWFwIiwiZXZlbnQiLCJiaXREYXkiLCJjaGFuZ2VEYXRlVG9CaXQiLCJrZXkiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsIkJpZ0ludCIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJzdGFydCIsImVuZCIsImNsb2NrSW4iLCJEYXRlIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJjbG9ja091dCIsImRhdGVCaXQiLCJjaGVja0R1cmF0aW9uIiwiaSIsInNldE1pbnV0ZXMiLCJnZXRNaW51dGVzIiwiZGF0ZUtleSIsImdldERhdGVMYWJlbCIsImZyZWVUaW1lcyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwicmVwbGFjZSIsInNldEhvdXJzIiwiZnJlZUR1cmF0aW9ucyIsImxlbmd0aCIsImJpdCIsImNoYXJBdCIsInB1c2giLCJnZXREYXRlVGltZUxhYmVsIiwiZGF5cyIsImUiLCJzbGljZSIsImRhdGUiLCJnZXRUaW1lTGFiZWwiLCJnZXRIb3VycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/calculateFreeTime.tsx\n"));

/***/ })

});