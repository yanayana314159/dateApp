"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/userpage/makeplans/page",{

/***/ "(app-pages-browser)/./app/components/calculateFreeTime.tsx":
/*!**********************************************!*\
  !*** ./app/components/calculateFreeTime.tsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ calculateFreeTime; }\n/* harmony export */ });\nfunction calculateFreeTime(events) {\n    // 取得したカレンダーから空き時間を2進数形式で抽出\n    const bitEmptyTimeOfDays = calculateEmptyTimeOfDays(events);\n    // Date形式に戻す\n    const emptyTimeOfDays = changeBitToDate(bitEmptyTimeOfDays);\n    // 出力\n    const freeTime = displayDays(emptyTimeOfDays);\n    return freeTime;\n// 日毎に、空き時間が「10:00-11:30,14:15-15:45」のような形式で出力される\n}\n/**\n * 空き日程をbit形式で返却\n */ function calculateEmptyTimeOfDays(events) {\n    const bitDays = [];\n    events.map((event)=>{\n        const bitDay = changeDateToBit(event);\n        const { key, value } = bitDay;\n        if (bitDays[key] !== undefined) {\n            // 論理和を取る\n            // 追記：BigInt型にキャストして演算を行う\n            bitDays[key] = \"0b\" + (BigInt(bitDays[key]) | BigInt(value)).toString(2).padStart(56, \"0\");\n        } else {\n            bitDays[key] = value;\n        }\n    });\n    return bitDays;\n}\n/**\n * bit形式に変換\n * @return {\"key\": key, \"value\": value}, key = 日付, value = bit\n * bit定義 → 15分区切りで表現、0 = 予定なし、1 = 予定あり\n * 例（_は実際には含まれない）：11:00-12:15予定あり → 「0000_0000_1111_1000_0000_0000_0000_0000_0000_0000_0000」\n * 4 * 11 = 44bit→56bit\n */ function changeDateToBit(event) {\n    const start = event.start;\n    const end = event.end;\n    // 対象の時間\n    const clockIn = new Date(start.getFullYear(), start.getMonth(), start.getDate(), 9, 0);\n    const clockOut = new Date(start.getFullYear(), start.getMonth(), start.getDate(), 23, 0);\n    let dateBit = \"0b\";\n    let checkDuration = new Date(clockIn);\n    for(let i = 0; i < 56; i++){\n        if (start <= checkDuration && checkDuration < end) {\n            dateBit += \"1\";\n        } else {\n            dateBit += \"0\";\n        }\n        if (checkDuration >= clockOut) {\n            break;\n        }\n        checkDuration.setMinutes(checkDuration.getMinutes() + 15);\n    }\n    const dateKey = getDateLabel(start);\n    return {\n        key: dateKey,\n        value: dateBit\n    };\n}\n/**\n * Bit形式の日付をDate型に戻す\n * @return {<日付> : {\"start\": <日時>, \"end\": <日時>}[]}[]\n */ function changeBitToDate(bitDays) {\n    const freeTimes = {};\n    Object.keys(bitDays).forEach((key)=>{\n        // 先頭の「0b」除去\n        const dateBit = bitDays[key].replace(/^0b/, \"\");\n        // 範囲の始点を設定\n        const clockIn = new Date(key);\n        clockIn.setHours(9);\n        clockIn.setMinutes(0);\n        let start;\n        let end;\n        const freeDurations = [];\n        for(let i = 0; i < dateBit.length; i++){\n            const bit = dateBit.charAt(i);\n            if (!start) {\n                if (bit === \"0\") {\n                    start = new Date(clockIn);\n                    start.setMinutes(start.getMinutes() + 15 * i);\n                }\n            } else {\n                if (bit === \"1\" || i === dateBit.length - 1) {\n                    if (bit === \"1\") {\n                        end = new Date(clockIn);\n                        end.setMinutes(end.getMinutes() + 15 * i);\n                    } else {\n                        end = new Date(clockIn);\n                        end.setMinutes(end.getMinutes() + 15 * (i + 1));\n                    }\n                    freeDurations.push({\n                        start: getDateTimeLabel(start),\n                        end: getDateTimeLabel(end)\n                    });\n                    // リセット\n                    start = undefined;\n                    end = undefined;\n                }\n            }\n        }\n        freeTimes[key] = freeDurations;\n    });\n    return freeTimes;\n}\n/**\n * 日時をシートに表示\n * @param days {<日付> : {\"start\": <日時>, \"end\": <日時>}[]}[]\n */ function displayDays(days) {\n    const freeTime = [];\n    Object.keys(days).forEach((key, i)=>{\n        let value = \"\";\n        days[key].forEach((e)=>{\n            value += \"\".concat(e.start, \"-\").concat(e.end, \"\\n\");\n        });\n        // 出力\n        freeTime.push(value.slice(0, -1));\n    });\n    return freeTime;\n}\n/**\n * YYYY/MM/DDを返す\n */ function getDateLabel(date) {\n    return \"\".concat(date.getFullYear(), \"/\").concat((\"0\" + (date.getMonth() + 1)).slice(-2), \"/\").concat((\"0\" + date.getDate()).slice(-2));\n}\n/**\n * hh:mmを返す\n */ function getTimeLabel(date) {\n    return \"\".concat((\"0\" + date.getHours()).slice(-2), \":\").concat((\"0\" + date.getMinutes()).slice(-2));\n}\n/**\n * YYYY/MM/DD hh:mmを返す\n */ function getDateTimeLabel(date) {\n    return \"\".concat(date.getFullYear(), \"/\").concat((\"0\" + (date.getMonth() + 1)).slice(-2), \"/\").concat((\"0\" + date.getDate()).slice(-2), \" \").concat((\"0\" + date.getHours()).slice(-2), \":\").concat((\"0\" + date.getMinutes()).slice(-2));\n}\nfunction test(events) {\n    const bitDays = [];\n    events.map((e)=>{\n        const bitDay = changeDateToBit(e);\n        const { key, value } = bitDay;\n        if (bitDays[key] !== undefined) {\n            // 論理和を取る！\n            // 追記：BigInt型にキャストして演算を行う\n            bitDays[key] = \"0b\" + (BigInt(bitDays[key]) | BigInt(value)).toString(2).padStart(56, \"0\");\n        } else {\n            bitDays[key] = value;\n        }\n    });\n    return bitDays;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL2NhbGN1bGF0ZUZyZWVUaW1lLnRzeCIsIm1hcHBpbmdzIjoiOzs7O0FBRWUsU0FBU0Esa0JBQWtCQyxNQUFXO0lBQ25ELDJCQUEyQjtJQUMzQixNQUFNQyxxQkFBcUJDLHlCQUF5QkY7SUFFcEQsWUFBWTtJQUNaLE1BQU1HLGtCQUFrQkMsZ0JBQWdCSDtJQUN4QyxLQUFLO0lBQ0wsTUFBTUksV0FBV0MsWUFBWUg7SUFFN0IsT0FBT0U7QUFFUCxpREFBaUQ7QUFDbkQ7QUFFQTs7Q0FFQyxHQUVELFNBQVNILHlCQUF5QkYsTUFBb0M7SUFDcEUsTUFBTU8sVUFBNEIsRUFBRTtJQUVwQ1AsT0FBT1EsR0FBRyxDQUFDLENBQUNDO1FBQ1YsTUFBTUMsU0FBU0MsZ0JBQWdCRjtRQUMvQixNQUFNLEVBQUVHLEdBQUcsRUFBRUMsS0FBSyxFQUFFLEdBQW1DSDtRQUV2RCxJQUFJSCxPQUFPLENBQUNLLElBQUksS0FBS0UsV0FBVztZQUM5QixTQUFTO1lBQ1QseUJBQXlCO1lBQ3pCUCxPQUFPLENBQUNLLElBQUksR0FDVixPQUNBLENBQUNHLE9BQU9SLE9BQU8sQ0FBQ0ssSUFBSSxJQUFJRyxPQUFPRixNQUFLLEVBQUdHLFFBQVEsQ0FBQyxHQUFHQyxRQUFRLENBQUMsSUFBSTtRQUNwRSxPQUFPO1lBQ0xWLE9BQU8sQ0FBQ0ssSUFBSSxHQUFHQztRQUNqQjtJQUNGO0lBRUEsT0FBT047QUFDVDtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNJLGdCQUFnQkYsS0FBaUM7SUFDeEQsTUFBTVMsUUFBUVQsTUFBTVMsS0FBSztJQUN6QixNQUFNQyxNQUFNVixNQUFNVSxHQUFHO0lBRXJCLFFBQVE7SUFDUixNQUFNQyxVQUFVLElBQUlDLEtBQ2xCSCxNQUFNSSxXQUFXLElBQ2pCSixNQUFNSyxRQUFRLElBQ2RMLE1BQU1NLE9BQU8sSUFDYixHQUNBO0lBRUYsTUFBTUMsV0FBVyxJQUFJSixLQUNuQkgsTUFBTUksV0FBVyxJQUNqQkosTUFBTUssUUFBUSxJQUNkTCxNQUFNTSxPQUFPLElBQ2IsSUFDQTtJQUdGLElBQUlFLFVBQWtCO0lBQ3RCLElBQUlDLGdCQUFnQixJQUFJTixLQUFLRDtJQUU3QixJQUFLLElBQUlRLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO1FBQzNCLElBQUlWLFNBQVNTLGlCQUFpQkEsZ0JBQWdCUixLQUFLO1lBQ2pETyxXQUFXO1FBQ2IsT0FBTztZQUNMQSxXQUFXO1FBQ2I7UUFFQSxJQUFJQyxpQkFBaUJGLFVBQVU7WUFDN0I7UUFDRjtRQUNBRSxjQUFjRSxVQUFVLENBQUNGLGNBQWNHLFVBQVUsS0FBSztJQUN4RDtJQUVBLE1BQU1DLFVBQWtCQyxhQUFhZDtJQUNyQyxPQUFPO1FBQUVOLEtBQUttQjtRQUFTbEIsT0FBT2E7SUFBUTtBQUN4QztBQUVBOzs7Q0FHQyxHQUNELFNBQVN0QixnQkFBZ0JHLE9BQXlCO0lBQ2hELE1BQU0wQixZQUFZLENBQUM7SUFFbkJDLE9BQU9DLElBQUksQ0FBQzVCLFNBQVM2QixPQUFPLENBQUMsQ0FBQ3hCO1FBQzVCLFlBQVk7UUFDWixNQUFNYyxVQUFVbkIsT0FBTyxDQUFDSyxJQUFJLENBQUN5QixPQUFPLENBQUMsT0FBTztRQUU1QyxXQUFXO1FBQ1gsTUFBTWpCLFVBQVUsSUFBSUMsS0FBS1Q7UUFDekJRLFFBQVFrQixRQUFRLENBQUM7UUFDakJsQixRQUFRUyxVQUFVLENBQUM7UUFFbkIsSUFBSVg7UUFDSixJQUFJQztRQUNKLE1BQU1vQixnQkFBZ0IsRUFBRTtRQUN4QixJQUFLLElBQUlYLElBQUksR0FBR0EsSUFBSUYsUUFBUWMsTUFBTSxFQUFFWixJQUFLO1lBQ3ZDLE1BQU1hLE1BQU1mLFFBQVFnQixNQUFNLENBQUNkO1lBQzNCLElBQUksQ0FBQ1YsT0FBTztnQkFDVixJQUFJdUIsUUFBUSxLQUFLO29CQUNmdkIsUUFBUSxJQUFJRyxLQUFLRDtvQkFDakJGLE1BQU1XLFVBQVUsQ0FBQ1gsTUFBTVksVUFBVSxLQUFLLEtBQUtGO2dCQUM3QztZQUNGLE9BQU87Z0JBQ0wsSUFBSWEsUUFBUSxPQUFPYixNQUFNRixRQUFRYyxNQUFNLEdBQUcsR0FBRztvQkFDM0MsSUFBSUMsUUFBUSxLQUFLO3dCQUNmdEIsTUFBTSxJQUFJRSxLQUFLRDt3QkFDZkQsSUFBSVUsVUFBVSxDQUFDVixJQUFJVyxVQUFVLEtBQUssS0FBS0Y7b0JBQ3pDLE9BQU87d0JBQ0xULE1BQU0sSUFBSUUsS0FBS0Q7d0JBQ2ZELElBQUlVLFVBQVUsQ0FBQ1YsSUFBSVcsVUFBVSxLQUFLLEtBQU1GLENBQUFBLElBQUk7b0JBQzlDO29CQUNBVyxjQUFjSSxJQUFJLENBQUM7d0JBQ2pCekIsT0FBTzBCLGlCQUFpQjFCO3dCQUN4QkMsS0FBS3lCLGlCQUFpQnpCO29CQUN4QjtvQkFDQSxPQUFPO29CQUNQRCxRQUFRSjtvQkFDUkssTUFBTUw7Z0JBQ1I7WUFDRjtRQUNGO1FBQ0FtQixTQUFTLENBQUNyQixJQUFJLEdBQUcyQjtJQUNuQjtJQUVBLE9BQU9OO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDRCxTQUFTM0IsWUFBWXVDLElBQUk7SUFDdkIsTUFBTXhDLFdBQVcsRUFBRTtJQUNuQjZCLE9BQU9DLElBQUksQ0FBQ1UsTUFBTVQsT0FBTyxDQUFDLENBQUN4QixLQUFLZ0I7UUFDOUIsSUFBSWYsUUFBUTtRQUNaZ0MsSUFBSSxDQUFDakMsSUFBSSxDQUFDd0IsT0FBTyxDQUFDLENBQUNVO1lBQ2pCakMsU0FBUyxHQUFjaUMsT0FBWEEsRUFBRTVCLEtBQUssRUFBQyxLQUFTLE9BQU40QixFQUFFM0IsR0FBRyxFQUFDO1FBQy9CO1FBQ0EsS0FBSztRQUNMZCxTQUFTc0MsSUFBSSxDQUFDOUIsTUFBTWtDLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFDaEM7SUFDQSxPQUFPMUM7QUFDVDtBQUVBOztDQUVDLEdBQ0QsU0FBUzJCLGFBQWFnQixJQUFJO0lBQ3hCLE9BQU8sR0FBeUIsT0FBdEJBLEtBQUsxQixXQUFXLElBQUcsS0FBOEMsT0FBM0MsQ0FBQyxNQUFPMEIsQ0FBQUEsS0FBS3pCLFFBQVEsS0FBSyxFQUFDLEVBQUd3QixLQUFLLENBQUMsQ0FBQyxJQUFHLEtBRTVELE9BRitELENBQ3pFLE1BQU1DLEtBQUt4QixPQUFPLEVBQUMsRUFDbkJ1QixLQUFLLENBQUMsQ0FBQztBQUNYO0FBRUE7O0NBRUMsR0FDRCxTQUFTRSxhQUFhRCxJQUFJO0lBQ3hCLE9BQU8sR0FBd0MsT0FBckMsQ0FBQyxNQUFNQSxLQUFLRSxRQUFRLEVBQUMsRUFBR0gsS0FBSyxDQUFDLENBQUMsSUFBRyxLQUVoQyxPQUZtQyxDQUM3QyxNQUFNQyxLQUFLbEIsVUFBVSxFQUFDLEVBQ3RCaUIsS0FBSyxDQUFDLENBQUM7QUFDWDtBQUVBOztDQUVDLEdBQ0QsU0FBU0gsaUJBQWlCSSxJQUFJO0lBQzVCLE9BQU8sR0FBeUIsT0FBdEJBLEtBQUsxQixXQUFXLElBQUcsS0FBOEMsT0FBM0MsQ0FBQyxNQUFPMEIsQ0FBQUEsS0FBS3pCLFFBQVEsS0FBSyxFQUFDLEVBQUd3QixLQUFLLENBQUMsQ0FBQyxJQUFHLEtBRXpELE9BRjRELENBQ3pFLE1BQU1DLEtBQUt4QixPQUFPLEVBQUMsRUFDbkJ1QixLQUFLLENBQUMsQ0FBQyxJQUFHLEtBQXdDLE9BQXJDLENBQUMsTUFBTUMsS0FBS0UsUUFBUSxFQUFDLEVBQUdILEtBQUssQ0FBQyxDQUFDLElBQUcsS0FFckMsT0FGd0MsQ0FDbEQsTUFBTUMsS0FBS2xCLFVBQVUsRUFBQyxFQUN0QmlCLEtBQUssQ0FBQyxDQUFDO0FBQ1g7QUFFQSxTQUFTSSxLQUFLbkQsTUFBb0M7SUFDaEQsTUFBTU8sVUFBb0IsRUFBRTtJQUU1QlAsT0FBT1EsR0FBRyxDQUFDLENBQUNzQztRQUNWLE1BQU1wQyxTQUFTQyxnQkFBZ0JtQztRQUMvQixNQUFNLEVBQUVsQyxHQUFHLEVBQUVDLEtBQUssRUFBRSxHQUFHSDtRQUV2QixJQUFJSCxPQUFPLENBQUNLLElBQUksS0FBS0UsV0FBVztZQUM5QixVQUFVO1lBQ1YseUJBQXlCO1lBQ3pCUCxPQUFPLENBQUNLLElBQUksR0FDVixPQUNBLENBQUNHLE9BQU9SLE9BQU8sQ0FBQ0ssSUFBSSxJQUFJRyxPQUFPRixNQUFLLEVBQUdHLFFBQVEsQ0FBQyxHQUFHQyxRQUFRLENBQUMsSUFBSTtRQUNwRSxPQUFPO1lBQ0xWLE9BQU8sQ0FBQ0ssSUFBSSxHQUFHQztRQUNqQjtJQUNGO0lBRUEsT0FBT047QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvY29tcG9uZW50cy9jYWxjdWxhdGVGcmVlVGltZS50c3g/MWNiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHJpbmcgfSBmcm9tIFwieWFyZ3NcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2FsY3VsYXRlRnJlZVRpbWUoZXZlbnRzOiBhbnkpIHtcbiAgLy8g5Y+W5b6X44GX44Gf44Kr44Os44Oz44OA44O844GL44KJ56m644GN5pmC6ZaT44KSMumAsuaVsOW9ouW8j+OBp+aKveWHulxuICBjb25zdCBiaXRFbXB0eVRpbWVPZkRheXMgPSBjYWxjdWxhdGVFbXB0eVRpbWVPZkRheXMoZXZlbnRzKTtcblxuICAvLyBEYXRl5b2i5byP44Gr5oi744GZXG4gIGNvbnN0IGVtcHR5VGltZU9mRGF5cyA9IGNoYW5nZUJpdFRvRGF0ZShiaXRFbXB0eVRpbWVPZkRheXMpO1xuICAvLyDlh7rliptcbiAgY29uc3QgZnJlZVRpbWUgPSBkaXNwbGF5RGF5cyhlbXB0eVRpbWVPZkRheXMpO1xuXG4gIHJldHVybiBmcmVlVGltZTtcblxuICAvLyDml6Xmr47jgavjgIHnqbrjgY3mmYLplpPjgYzjgIwxMDowMC0xMTozMCwxNDoxNS0xNTo0NeOAjeOBruOCiOOBhuOBquW9ouW8j+OBp+WHuuWKm+OBleOCjOOCi1xufVxuXG4vKipcbiAqIOepuuOBjeaXpeeoi+OCkmJpdOW9ouW8j+OBp+i/lOWNtFxuICovXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUVtcHR5VGltZU9mRGF5cyhldmVudHM6IHsgc3RhcnQ6IERhdGU7IGVuZDogRGF0ZSB9W10pIHtcbiAgY29uc3QgYml0RGF5czogW3N0cmluZywgc3RyaW5nXSA9IFtdO1xuXG4gIGV2ZW50cy5tYXAoKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgYml0RGF5ID0gY2hhbmdlRGF0ZVRvQml0KGV2ZW50KTtcbiAgICBjb25zdCB7IGtleSwgdmFsdWUgfTogeyBrZXk6IHN0cmluZzsgdmFsdWU6IHN0cmluZyB9ID0gYml0RGF5O1xuXG4gICAgaWYgKGJpdERheXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyDoq5bnkIblkozjgpLlj5bjgotcbiAgICAgIC8vIOi/veiomO+8mkJpZ0ludOWei+OBq+OCreODo+OCueODiOOBl+OBpua8lOeul+OCkuihjOOBhlxuICAgICAgYml0RGF5c1trZXldID1cbiAgICAgICAgXCIwYlwiICtcbiAgICAgICAgKEJpZ0ludChiaXREYXlzW2tleV0pIHwgQmlnSW50KHZhbHVlKSkudG9TdHJpbmcoMikucGFkU3RhcnQoNTYsIFwiMFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYml0RGF5c1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gYml0RGF5cztcbn1cblxuLyoqXG4gKiBiaXTlvaLlvI/jgavlpInmj5tcbiAqIEByZXR1cm4ge1wia2V5XCI6IGtleSwgXCJ2YWx1ZVwiOiB2YWx1ZX0sIGtleSA9IOaXpeS7mCwgdmFsdWUgPSBiaXRcbiAqIGJpdOWumue+qSDihpIgMTXliIbljLrliIfjgorjgafooajnj77jgIEwID0g5LqI5a6a44Gq44GX44CBMSA9IOS6iOWumuOBguOCilxuICog5L6L77yIX+OBr+Wun+mam+OBq+OBr+WQq+OBvuOCjOOBquOBhO+8ie+8mjExOjAwLTEyOjE15LqI5a6a44GC44KKIOKGkiDjgIwwMDAwXzAwMDBfMTExMV8xMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDDjgI1cbiAqIDQgKiAxMSA9IDQ0Yml04oaSNTZiaXRcbiAqL1xuZnVuY3Rpb24gY2hhbmdlRGF0ZVRvQml0KGV2ZW50OiB7IHN0YXJ0OiBEYXRlOyBlbmQ6IERhdGUgfSkge1xuICBjb25zdCBzdGFydCA9IGV2ZW50LnN0YXJ0O1xuICBjb25zdCBlbmQgPSBldmVudC5lbmQ7XG5cbiAgLy8g5a++6LGh44Gu5pmC6ZaTXG4gIGNvbnN0IGNsb2NrSW4gPSBuZXcgRGF0ZShcbiAgICBzdGFydC5nZXRGdWxsWWVhcigpLFxuICAgIHN0YXJ0LmdldE1vbnRoKCksXG4gICAgc3RhcnQuZ2V0RGF0ZSgpLFxuICAgIDksXG4gICAgMFxuICApO1xuICBjb25zdCBjbG9ja091dCA9IG5ldyBEYXRlKFxuICAgIHN0YXJ0LmdldEZ1bGxZZWFyKCksXG4gICAgc3RhcnQuZ2V0TW9udGgoKSxcbiAgICBzdGFydC5nZXREYXRlKCksXG4gICAgMjMsXG4gICAgMFxuICApO1xuXG4gIGxldCBkYXRlQml0OiBzdHJpbmcgPSBcIjBiXCI7XG4gIGxldCBjaGVja0R1cmF0aW9uID0gbmV3IERhdGUoY2xvY2tJbik7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA1NjsgaSsrKSB7XG4gICAgaWYgKHN0YXJ0IDw9IGNoZWNrRHVyYXRpb24gJiYgY2hlY2tEdXJhdGlvbiA8IGVuZCkge1xuICAgICAgZGF0ZUJpdCArPSBcIjFcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0ZUJpdCArPSBcIjBcIjtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tEdXJhdGlvbiA+PSBjbG9ja091dCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNoZWNrRHVyYXRpb24uc2V0TWludXRlcyhjaGVja0R1cmF0aW9uLmdldE1pbnV0ZXMoKSArIDE1KTtcbiAgfVxuXG4gIGNvbnN0IGRhdGVLZXk6IHN0cmluZyA9IGdldERhdGVMYWJlbChzdGFydCk7XG4gIHJldHVybiB7IGtleTogZGF0ZUtleSwgdmFsdWU6IGRhdGVCaXQgfTtcbn1cblxuLyoqXG4gKiBCaXTlvaLlvI/jga7ml6Xku5jjgpJEYXRl5Z6L44Gr5oi744GZXG4gKiBAcmV0dXJuIHs85pel5LuYPiA6IHtcInN0YXJ0XCI6IDzml6XmmYI+LCBcImVuZFwiOiA85pel5pmCPn1bXX1bXVxuICovXG5mdW5jdGlvbiBjaGFuZ2VCaXRUb0RhdGUoYml0RGF5czogW3N0cmluZywgc3RyaW5nXSkge1xuICBjb25zdCBmcmVlVGltZXMgPSB7fTtcblxuICBPYmplY3Qua2V5cyhiaXREYXlzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAvLyDlhYjpoK3jga7jgIwwYuOAjemZpOWOu1xuICAgIGNvbnN0IGRhdGVCaXQgPSBiaXREYXlzW2tleV0ucmVwbGFjZSgvXjBiLywgXCJcIik7XG5cbiAgICAvLyDnr4Tlm7Ljga7lp4vngrnjgpLoqK3lrppcbiAgICBjb25zdCBjbG9ja0luID0gbmV3IERhdGUoa2V5KTtcbiAgICBjbG9ja0luLnNldEhvdXJzKDkpO1xuICAgIGNsb2NrSW4uc2V0TWludXRlcygwKTtcblxuICAgIGxldCBzdGFydDtcbiAgICBsZXQgZW5kO1xuICAgIGNvbnN0IGZyZWVEdXJhdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGVCaXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGJpdCA9IGRhdGVCaXQuY2hhckF0KGkpO1xuICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICBpZiAoYml0ID09PSBcIjBcIikge1xuICAgICAgICAgIHN0YXJ0ID0gbmV3IERhdGUoY2xvY2tJbik7XG4gICAgICAgICAgc3RhcnQuc2V0TWludXRlcyhzdGFydC5nZXRNaW51dGVzKCkgKyAxNSAqIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYml0ID09PSBcIjFcIiB8fCBpID09PSBkYXRlQml0Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBpZiAoYml0ID09PSBcIjFcIikge1xuICAgICAgICAgICAgZW5kID0gbmV3IERhdGUoY2xvY2tJbik7XG4gICAgICAgICAgICBlbmQuc2V0TWludXRlcyhlbmQuZ2V0TWludXRlcygpICsgMTUgKiBpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW5kID0gbmV3IERhdGUoY2xvY2tJbik7XG4gICAgICAgICAgICBlbmQuc2V0TWludXRlcyhlbmQuZ2V0TWludXRlcygpICsgMTUgKiAoaSArIDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnJlZUR1cmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHN0YXJ0OiBnZXREYXRlVGltZUxhYmVsKHN0YXJ0KSxcbiAgICAgICAgICAgIGVuZDogZ2V0RGF0ZVRpbWVMYWJlbChlbmQpLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIOODquOCu+ODg+ODiFxuICAgICAgICAgIHN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGVuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmcmVlVGltZXNba2V5XSA9IGZyZWVEdXJhdGlvbnM7XG4gIH0pO1xuXG4gIHJldHVybiBmcmVlVGltZXM7XG59XG5cbi8qKlxuICog5pel5pmC44KS44K344O844OI44Gr6KGo56S6XG4gKiBAcGFyYW0gZGF5cyB7POaXpeS7mD4gOiB7XCJzdGFydFwiOiA85pel5pmCPiwgXCJlbmRcIjogPOaXpeaZgj59W119W11cbiAqL1xuZnVuY3Rpb24gZGlzcGxheURheXMoZGF5cykge1xuICBjb25zdCBmcmVlVGltZSA9IFtdO1xuICBPYmplY3Qua2V5cyhkYXlzKS5mb3JFYWNoKChrZXksIGkpID0+IHtcbiAgICBsZXQgdmFsdWUgPSBcIlwiO1xuICAgIGRheXNba2V5XS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICB2YWx1ZSArPSBgJHtlLnN0YXJ0fS0ke2UuZW5kfVxcbmA7XG4gICAgfSk7XG4gICAgLy8g5Ye65YqbXG4gICAgZnJlZVRpbWUucHVzaCh2YWx1ZS5zbGljZSgwLCAtMSkpO1xuICB9KTtcbiAgcmV0dXJuIGZyZWVUaW1lO1xufVxuXG4vKipcbiAqIFlZWVkvTU0vRETjgpLov5TjgZlcbiAqL1xuZnVuY3Rpb24gZ2V0RGF0ZUxhYmVsKGRhdGUpIHtcbiAgcmV0dXJuIGAke2RhdGUuZ2V0RnVsbFllYXIoKX0vJHsoXCIwXCIgKyAoZGF0ZS5nZXRNb250aCgpICsgMSkpLnNsaWNlKC0yKX0vJHsoXG4gICAgXCIwXCIgKyBkYXRlLmdldERhdGUoKVxuICApLnNsaWNlKC0yKX1gO1xufVxuXG4vKipcbiAqIGhoOm1t44KS6L+U44GZXG4gKi9cbmZ1bmN0aW9uIGdldFRpbWVMYWJlbChkYXRlKSB7XG4gIHJldHVybiBgJHsoXCIwXCIgKyBkYXRlLmdldEhvdXJzKCkpLnNsaWNlKC0yKX06JHsoXG4gICAgXCIwXCIgKyBkYXRlLmdldE1pbnV0ZXMoKVxuICApLnNsaWNlKC0yKX1gO1xufVxuXG4vKipcbiAqIFlZWVkvTU0vREQgaGg6bW3jgpLov5TjgZlcbiAqL1xuZnVuY3Rpb24gZ2V0RGF0ZVRpbWVMYWJlbChkYXRlKSB7XG4gIHJldHVybiBgJHtkYXRlLmdldEZ1bGxZZWFyKCl9LyR7KFwiMFwiICsgKGRhdGUuZ2V0TW9udGgoKSArIDEpKS5zbGljZSgtMil9LyR7KFxuICAgIFwiMFwiICsgZGF0ZS5nZXREYXRlKClcbiAgKS5zbGljZSgtMil9ICR7KFwiMFwiICsgZGF0ZS5nZXRIb3VycygpKS5zbGljZSgtMil9OiR7KFxuICAgIFwiMFwiICsgZGF0ZS5nZXRNaW51dGVzKClcbiAgKS5zbGljZSgtMil9YDtcbn1cblxuZnVuY3Rpb24gdGVzdChldmVudHM6IHsgc3RhcnQ6IERhdGU7IGVuZDogRGF0ZSB9W10pIHtcbiAgY29uc3QgYml0RGF5czogQmlnSW50W10gPSBbXTtcblxuICBldmVudHMubWFwKChlKSA9PiB7XG4gICAgY29uc3QgYml0RGF5ID0gY2hhbmdlRGF0ZVRvQml0KGUpO1xuICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gYml0RGF5O1xuXG4gICAgaWYgKGJpdERheXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyDoq5bnkIblkozjgpLlj5bjgovvvIFcbiAgICAgIC8vIOi/veiomO+8mkJpZ0ludOWei+OBq+OCreODo+OCueODiOOBl+OBpua8lOeul+OCkuihjOOBhlxuICAgICAgYml0RGF5c1trZXldID1cbiAgICAgICAgXCIwYlwiICtcbiAgICAgICAgKEJpZ0ludChiaXREYXlzW2tleV0pIHwgQmlnSW50KHZhbHVlKSkudG9TdHJpbmcoMikucGFkU3RhcnQoNTYsIFwiMFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYml0RGF5c1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gYml0RGF5cztcbn1cbiJdLCJuYW1lcyI6WyJjYWxjdWxhdGVGcmVlVGltZSIsImV2ZW50cyIsImJpdEVtcHR5VGltZU9mRGF5cyIsImNhbGN1bGF0ZUVtcHR5VGltZU9mRGF5cyIsImVtcHR5VGltZU9mRGF5cyIsImNoYW5nZUJpdFRvRGF0ZSIsImZyZWVUaW1lIiwiZGlzcGxheURheXMiLCJiaXREYXlzIiwibWFwIiwiZXZlbnQiLCJiaXREYXkiLCJjaGFuZ2VEYXRlVG9CaXQiLCJrZXkiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsIkJpZ0ludCIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJzdGFydCIsImVuZCIsImNsb2NrSW4iLCJEYXRlIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJjbG9ja091dCIsImRhdGVCaXQiLCJjaGVja0R1cmF0aW9uIiwiaSIsInNldE1pbnV0ZXMiLCJnZXRNaW51dGVzIiwiZGF0ZUtleSIsImdldERhdGVMYWJlbCIsImZyZWVUaW1lcyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwicmVwbGFjZSIsInNldEhvdXJzIiwiZnJlZUR1cmF0aW9ucyIsImxlbmd0aCIsImJpdCIsImNoYXJBdCIsInB1c2giLCJnZXREYXRlVGltZUxhYmVsIiwiZGF5cyIsImUiLCJzbGljZSIsImRhdGUiLCJnZXRUaW1lTGFiZWwiLCJnZXRIb3VycyIsInRlc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/calculateFreeTime.tsx\n"));

/***/ })

});