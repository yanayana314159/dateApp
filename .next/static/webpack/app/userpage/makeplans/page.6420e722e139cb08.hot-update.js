"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/userpage/makeplans/page",{

/***/ "(app-pages-browser)/./app/components/calculateFreeTime.tsx":
/*!**********************************************!*\
  !*** ./app/components/calculateFreeTime.tsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ calculateFreeTime; }\n/* harmony export */ });\nfunction calculateFreeTime(events) {\n    // 取得したカレンダーから空き時間を2進数形式で抽出\n    const bitEmptyTimeOfDays = calculateEmptyTimeOfDays(events);\n    // Date形式に戻す\n    const emptyTimeOfDays = changeBitToDate(bitEmptyTimeOfDays);\n    // 出力\n    const freeTime = displayDays(emptyTimeOfDays);\n    return freeTime;\n// 日毎に、空き時間が「10:00-11:30,14:15-15:45」のような形式で出力される\n}\n/**\n * 空き日程をbit形式で返却\n */ function calculateEmptyTimeOfDays(events) {\n    const bitDays = [];\n    events.map((event)=>{\n        const bitDay = changeDateToBit(event);\n        const { key, value } = bitDay;\n        if (bitDays[key] !== undefined) {\n            // 論理和を取る\n            // 追記：BigInt型にキャストして演算を行う\n            bitDays[key] = \"0b\" + (BigInt(bitDays[key]) | BigInt(value)).toString(2).padStart(56, \"0\");\n        } else {\n            bitDays[key] = value;\n        }\n    });\n    return bitDays;\n}\n/**\n * bit形式に変換\n * @return {\"key\": key, \"value\": value}, key = 日付, value = bit\n * bit定義 → 15分区切りで表現、0 = 予定なし、1 = 予定あり\n * 例（_は実際には含まれない）：11:00-12:15予定あり → 「0000_0000_1111_1000_0000_0000_0000_0000_0000_0000_0000」\n * 4 * 11 = 44bit→56bit\n */ function changeDateToBit(event) {\n    const start = event.start;\n    const end = event.end;\n    // 対象の時間\n    const clockIn = new Date(start.getFullYear(), start.getMonth(), start.getDate(), 9, 0);\n    const clockOut = new Date(start.getFullYear(), start.getMonth(), start.getDate(), 23, 0);\n    let dateBit = \"0b\";\n    let checkDuration = new Date(clockIn);\n    for(let i = 0; i < 56; i++){\n        if (start <= checkDuration && checkDuration < end) {\n            dateBit += \"1\";\n        } else {\n            dateBit += \"0\";\n        }\n        if (checkDuration >= clockOut) {\n            break;\n        }\n        checkDuration.setMinutes(checkDuration.getMinutes() + 15);\n    }\n    const dateKey = getDateLabel(start);\n    return {\n        key: dateKey,\n        value: dateBit\n    };\n}\n/**\n * Bit形式の日付をDate型に戻す\n * @return {<日付> : {\"start\": <日時>, \"end\": <日時>}[]}[]\n */ function changeBitToDate(bitDays) {\n    const freeTimes = {};\n    Object.keys(bitDays).forEach((key)=>{\n        // 先頭の「0b」除去\n        const dateBit = bitDays[key].replace(/^0b/, \"\");\n        // 範囲の始点を設定\n        const clockIn = new Date(key);\n        clockIn.setHours(9);\n        clockIn.setMinutes(0);\n        let start;\n        let end;\n        const freeDurations = [];\n        for(let i = 0; i < dateBit.length; i++){\n            const bit = dateBit.charAt(i);\n            if (!start) {\n                if (bit === \"0\") {\n                    start = new Date(clockIn);\n                    start.setMinutes(start.getMinutes() + 15 * i);\n                }\n            } else {\n                if (bit === \"1\" || i === dateBit.length - 1) {\n                    if (bit === \"1\") {\n                        end = new Date(clockIn);\n                        end.setMinutes(end.getMinutes() + 15 * i);\n                    } else {\n                        end = new Date(clockIn);\n                        end.setMinutes(end.getMinutes() + 15 * (i + 1));\n                    }\n                    freeDurations.push({\n                        start: getDateTimeLabel(start),\n                        end: getDateTimeLabel(end)\n                    });\n                    // リセット\n                    start = undefined;\n                    end = undefined;\n                }\n            }\n        }\n        freeTimes[key] = freeDurations;\n    });\n    return freeTimes;\n}\n/**\n * 日時をシートに表示\n * @param days {<日付> : {\"start\": <日時>, \"end\": <日時>}[]}[]\n */ function displayDays(days) {\n    const freeTime = [];\n    Object.keys(days).forEach((key, i)=>{\n        let value = \"\";\n        days[key].forEach((e)=>{\n            value += \"\".concat(e.start, \"-\").concat(e.end, \"\\n\") + \"\";\n        });\n        // 出力\n        freeTime.push(value.slice(0, -1));\n    });\n    return freeTime;\n}\n/**\n * YYYY/MM/DDを返す\n */ function getDateLabel(date) {\n    return \"\".concat(date.getFullYear(), \"/\").concat((\"0\" + (date.getMonth() + 1)).slice(-2), \"/\").concat((\"0\" + date.getDate()).slice(-2));\n}\n/**\n * hh:mmを返す\n */ function getTimeLabel(date) {\n    return \"\".concat((\"0\" + date.getHours()).slice(-2), \":\").concat((\"0\" + date.getMinutes()).slice(-2));\n}\n/**\n * YYYY/MM/DD hh:mmを返す\n */ function getDateTimeLabel(date) {\n    return \"\".concat(date.getFullYear(), \"/\").concat((\"0\" + (date.getMonth() + 1)).slice(-2), \"/\").concat((\"0\" + date.getDate()).slice(-2), \" \").concat((\"0\" + date.getHours()).slice(-2), \":\").concat((\"0\" + date.getMinutes()).slice(-2));\n}\nfunction test(events) {\n    const bitDays = [];\n    events.map((e)=>{\n        const bitDay = changeDateToBit(e);\n        const { key, value } = bitDay;\n        if (bitDays[key] !== undefined) {\n            // 論理和を取る！\n            // 追記：BigInt型にキャストして演算を行う\n            bitDays[key] = \"0b\" + (BigInt(bitDays[key]) | BigInt(value)).toString(2).padStart(56, \"0\");\n        } else {\n            bitDays[key] = value;\n        }\n    });\n    return bitDays;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL2NhbGN1bGF0ZUZyZWVUaW1lLnRzeCIsIm1hcHBpbmdzIjoiOzs7O0FBRWUsU0FBU0Esa0JBQWtCQyxNQUFXO0lBQ25ELDJCQUEyQjtJQUMzQixNQUFNQyxxQkFBcUJDLHlCQUF5QkY7SUFFcEQsWUFBWTtJQUNaLE1BQU1HLGtCQUFrQkMsZ0JBQWdCSDtJQUN4QyxLQUFLO0lBQ0wsTUFBTUksV0FBV0MsWUFBWUg7SUFFN0IsT0FBT0U7QUFFUCxpREFBaUQ7QUFDbkQ7QUFFQTs7Q0FFQyxHQUVELFNBQVNILHlCQUF5QkYsTUFBb0M7SUFDcEUsTUFBTU8sVUFBNEIsRUFBRTtJQUVwQ1AsT0FBT1EsR0FBRyxDQUFDLENBQUNDO1FBQ1YsTUFBTUMsU0FBU0MsZ0JBQWdCRjtRQUMvQixNQUFNLEVBQUVHLEdBQUcsRUFBRUMsS0FBSyxFQUFFLEdBQW1DSDtRQUV2RCxJQUFJSCxPQUFPLENBQUNLLElBQUksS0FBS0UsV0FBVztZQUM5QixTQUFTO1lBQ1QseUJBQXlCO1lBQ3pCUCxPQUFPLENBQUNLLElBQUksR0FDVixPQUNBLENBQUNHLE9BQU9SLE9BQU8sQ0FBQ0ssSUFBSSxJQUFJRyxPQUFPRixNQUFLLEVBQUdHLFFBQVEsQ0FBQyxHQUFHQyxRQUFRLENBQUMsSUFBSTtRQUNwRSxPQUFPO1lBQ0xWLE9BQU8sQ0FBQ0ssSUFBSSxHQUFHQztRQUNqQjtJQUNGO0lBRUEsT0FBT047QUFDVDtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNJLGdCQUFnQkYsS0FBaUM7SUFDeEQsTUFBTVMsUUFBUVQsTUFBTVMsS0FBSztJQUN6QixNQUFNQyxNQUFNVixNQUFNVSxHQUFHO0lBRXJCLFFBQVE7SUFDUixNQUFNQyxVQUFVLElBQUlDLEtBQ2xCSCxNQUFNSSxXQUFXLElBQ2pCSixNQUFNSyxRQUFRLElBQ2RMLE1BQU1NLE9BQU8sSUFDYixHQUNBO0lBRUYsTUFBTUMsV0FBVyxJQUFJSixLQUNuQkgsTUFBTUksV0FBVyxJ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QUFDSyxJQUFJLElBQUlHLE9BQU9GLE1BQUssRUFBR0csUUFBUSxDQUFDLEdBQUdDLFFBQVEsQ0FBQyxJQUFJO1FBQ3BFLE9BQU87WUFDTFYsT0FBTyxDQUFDSyxJQUFJLEdBQUdDO1FBQ2pCO0lBQ0Y7SUFFQSxPQUFPTjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9jb21wb25lbnRzL2NhbGN1bGF0ZUZyZWVUaW1lLnRzeD8xY2I4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0cmluZyB9IGZyb20gXCJ5YXJnc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjYWxjdWxhdGVGcmVlVGltZShldmVudHM6IGFueSkge1xuICAvLyDlj5blvpfjgZfjgZ/jgqvjg6zjg7Pjg4Djg7zjgYvjgonnqbrjgY3mmYLplpPjgpIy6YCy5pWw5b2i5byP44Gn5oq95Ye6XG4gIGNvbnN0IGJpdEVtcHR5VGltZU9mRGF5cyA9IGNhbGN1bGF0ZUVtcHR5VGltZU9mRGF5cyhldmVudHMpO1xuXG4gIC8vIERhdGXlvaLlvI/jgavmiLvjgZlcbiAgY29uc3QgZW1wdHlUaW1lT2ZEYXlzID0gY2hhbmdlQml0VG9EYXRlKGJpdEVtcHR5VGltZU9mRGF5cyk7XG4gIC8vIOWHuuWKm1xuICBjb25zdCBmcmVlVGltZSA9IGRpc3BsYXlEYXlzKGVtcHR5VGltZU9mRGF5cyk7XG5cbiAgcmV0dXJuIGZyZWVUaW1lO1xuXG4gIC8vIOaXpeavjuOBq+OAgeepuuOBjeaZgumWk+OBjOOAjDEwOjAwLTExOjMwLDE0OjE1LTE1OjQ144CN44Gu44KI44GG44Gq5b2i5byP44Gn5Ye65Yqb44GV44KM44KLXG59XG5cbi8qKlxuICog56m644GN5pel56iL44KSYml05b2i5byP44Gn6L+U5Y20XG4gKi9cblxuZnVuY3Rpb24gY2FsY3VsYXRlRW1wdHlUaW1lT2ZEYXlzKGV2ZW50czogeyBzdGFydDogRGF0ZTsgZW5kOiBEYXRlIH1bXSkge1xuICBjb25zdCBiaXREYXlzOiBbc3RyaW5nLCBzdHJpbmddID0gW107XG5cbiAgZXZlbnRzLm1hcCgoZXZlbnQpID0+IHtcbiAgICBjb25zdCBiaXREYXkgPSBjaGFuZ2VEYXRlVG9CaXQoZXZlbnQpO1xuICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9OiB7IGtleTogc3RyaW5nOyB2YWx1ZTogc3RyaW5nIH0gPSBiaXREYXk7XG5cbiAgICBpZiAoYml0RGF5c1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIOirlueQhuWSjOOCkuWPluOCi1xuICAgICAgLy8g6L+96KiY77yaQmlnSW505Z6L44Gr44Kt44Oj44K544OI44GX44Gm5ryU566X44KS6KGM44GGXG4gICAgICBiaXREYXlzW2tleV0gPVxuICAgICAgICBcIjBiXCIgK1xuICAgICAgICAoQmlnSW50KGJpdERheXNba2V5XSkgfCBCaWdJbnQodmFsdWUpKS50b1N0cmluZygyKS5wYWRTdGFydCg1NiwgXCIwXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiaXREYXlzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBiaXREYXlzO1xufVxuXG4vKipcbiAqIGJpdOW9ouW8j+OBq+WkieaPm1xuICogQHJldHVybiB7XCJrZXlcIjoga2V5LCBcInZhbHVlXCI6IHZhbHVlfSwga2V5ID0g5pel5LuYLCB2YWx1ZSA9IGJpdFxuICogYml05a6a576pIOKGkiAxNeWIhuWMuuWIh+OCiuOBp+ihqOePvuOAgTAgPSDkuojlrprjgarjgZfjgIExID0g5LqI5a6a44GC44KKXG4gKiDkvovvvIhf44Gv5a6f6Zqb44Gr44Gv5ZCr44G+44KM44Gq44GE77yJ77yaMTE6MDAtMTI6MTXkuojlrprjgYLjgoog4oaSIOOAjDAwMDBfMDAwMF8xMTExXzEwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMOOAjVxuICogNCAqIDExID0gNDRiaXTihpI1NmJpdFxuICovXG5mdW5jdGlvbiBjaGFuZ2VEYXRlVG9CaXQoZXZlbnQ6IHsgc3RhcnQ6IERhdGU7IGVuZDogRGF0ZSB9KSB7XG4gIGNvbnN0IHN0YXJ0ID0gZXZlbnQuc3RhcnQ7XG4gIGNvbnN0IGVuZCA9IGV2ZW50LmVuZDtcblxuICAvLyDlr77osaHjga7mmYLplpNcbiAgY29uc3QgY2xvY2tJbiA9IG5ldyBEYXRlKFxuICAgIHN0YXJ0LmdldEZ1bGxZZWFyKCksXG4gICAgc3RhcnQuZ2V0TW9udGgoKSxcbiAgICBzdGFydC5nZXREYXRlKCksXG4gICAgOSxcbiAgICAwXG4gICk7XG4gIGNvbnN0IGNsb2NrT3V0ID0gbmV3IERhdGUoXG4gICAgc3RhcnQuZ2V0RnVsbFllYXIoKSxcbiAgICBzdGFydC5nZXRNb250aCgpLFxuICAgIHN0YXJ0LmdldERhdGUoKSxcbiAgICAyMyxcbiAgICAwXG4gICk7XG5cbiAgbGV0IGRhdGVCaXQ6IHN0cmluZyA9IFwiMGJcIjtcbiAgbGV0IGNoZWNrRHVyYXRpb24gPSBuZXcgRGF0ZShjbG9ja0luKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IDU2OyBpKyspIHtcbiAgICBpZiAoc3RhcnQgPD0gY2hlY2tEdXJhdGlvbiAmJiBjaGVja0R1cmF0aW9uIDwgZW5kKSB7XG4gICAgICBkYXRlQml0ICs9IFwiMVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRlQml0ICs9IFwiMFwiO1xuICAgIH1cblxuICAgIGlmIChjaGVja0R1cmF0aW9uID49IGNsb2NrT3V0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2hlY2tEdXJhdGlvbi5zZXRNaW51dGVzKGNoZWNrRHVyYXRpb24uZ2V0TWludXRlcygpICsgMTUpO1xuICB9XG5cbiAgY29uc3QgZGF0ZUtleTogc3RyaW5nID0gZ2V0RGF0ZUxhYmVsKHN0YXJ0KTtcbiAgcmV0dXJuIHsga2V5OiBkYXRlS2V5LCB2YWx1ZTogZGF0ZUJpdCB9O1xufVxuXG4vKipcbiAqIEJpdOW9ouW8j+OBruaXpeS7mOOCkkRhdGXlnovjgavmiLvjgZlcbiAqIEByZXR1cm4gezzml6Xku5g+IDoge1wic3RhcnRcIjogPOaXpeaZgj4sIFwiZW5kXCI6IDzml6XmmYI+fVtdfVtdXG4gKi9cbmZ1bmN0aW9uIGNoYW5nZUJpdFRvRGF0ZShiaXREYXlzOiBbc3RyaW5nLCBzdHJpbmddKSB7XG4gIGNvbnN0IGZyZWVUaW1lcyA9IHt9O1xuXG4gIE9iamVjdC5rZXlzKGJpdERheXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIC8vIOWFiOmgreOBruOAjDBi44CN6Zmk5Y67XG4gICAgY29uc3QgZGF0ZUJpdCA9IGJpdERheXNba2V5XS5yZXBsYWNlKC9eMGIvLCBcIlwiKTtcblxuICAgIC8vIOevhOWbsuOBruWni+eCueOCkuioreWumlxuICAgIGNvbnN0IGNsb2NrSW4gPSBuZXcgRGF0ZShrZXkpO1xuICAgIGNsb2NrSW4uc2V0SG91cnMoOSk7XG4gICAgY2xvY2tJbi5zZXRNaW51dGVzKDApO1xuXG4gICAgbGV0IHN0YXJ0O1xuICAgIGxldCBlbmQ7XG4gICAgY29uc3QgZnJlZUR1cmF0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0ZUJpdC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYml0ID0gZGF0ZUJpdC5jaGFyQXQoaSk7XG4gICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgIGlmIChiaXQgPT09IFwiMFwiKSB7XG4gICAgICAgICAgc3RhcnQgPSBuZXcgRGF0ZShjbG9ja0luKTtcbiAgICAgICAgICBzdGFydC5zZXRNaW51dGVzKHN0YXJ0LmdldE1pbnV0ZXMoKSArIDE1ICogaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChiaXQgPT09IFwiMVwiIHx8IGkgPT09IGRhdGVCaXQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGlmIChiaXQgPT09IFwiMVwiKSB7XG4gICAgICAgICAgICBlbmQgPSBuZXcgRGF0ZShjbG9ja0luKTtcbiAgICAgICAgICAgIGVuZC5zZXRNaW51dGVzKGVuZC5nZXRNaW51dGVzKCkgKyAxNSAqIGkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmQgPSBuZXcgRGF0ZShjbG9ja0luKTtcbiAgICAgICAgICAgIGVuZC5zZXRNaW51dGVzKGVuZC5nZXRNaW51dGVzKCkgKyAxNSAqIChpICsgMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmcmVlRHVyYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgc3RhcnQ6IGdldERhdGVUaW1lTGFiZWwoc3RhcnQpLFxuICAgICAgICAgICAgZW5kOiBnZXREYXRlVGltZUxhYmVsKGVuZCksXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8g44Oq44K744OD44OIXG4gICAgICAgICAgc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZW5kID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZyZWVUaW1lc1trZXldID0gZnJlZUR1cmF0aW9ucztcbiAgfSk7XG5cbiAgcmV0dXJuIGZyZWVUaW1lcztcbn1cblxuLyoqXG4gKiDml6XmmYLjgpLjgrfjg7zjg4jjgavooajnpLpcbiAqIEBwYXJhbSBkYXlzIHs85pel5LuYPiA6IHtcInN0YXJ0XCI6IDzml6XmmYI+LCBcImVuZFwiOiA85pel5pmCPn1bXX1bXVxuICovXG5mdW5jdGlvbiBkaXNwbGF5RGF5cyhkYXlzKSB7XG4gIGNvbnN0IGZyZWVUaW1lID0gW107XG4gIE9iamVjdC5rZXlzKGRheXMpLmZvckVhY2goKGtleSwgaSkgPT4ge1xuICAgIGxldCB2YWx1ZSA9IFwiXCI7XG4gICAgZGF5c1trZXldLmZvckVhY2goKGUpID0+IHtcbiAgICAgIHZhbHVlICs9IGAke2Uuc3RhcnR9LSR7ZS5lbmR9XFxuYCArIGBgO1xuICAgIH0pO1xuICAgIC8vIOWHuuWKm1xuICAgIGZyZWVUaW1lLnB1c2godmFsdWUuc2xpY2UoMCwgLTEpKTtcbiAgfSk7XG4gIHJldHVybiBmcmVlVGltZTtcbn1cblxuLyoqXG4gKiBZWVlZL01NL0RE44KS6L+U44GZXG4gKi9cbmZ1bmN0aW9uIGdldERhdGVMYWJlbChkYXRlKSB7XG4gIHJldHVybiBgJHtkYXRlLmdldEZ1bGxZZWFyKCl9LyR7KFwiMFwiICsgKGRhdGUuZ2V0TW9udGgoKSArIDEpKS5zbGljZSgtMil9LyR7KFxuICAgIFwiMFwiICsgZGF0ZS5nZXREYXRlKClcbiAgKS5zbGljZSgtMil9YDtcbn1cblxuLyoqXG4gKiBoaDptbeOCkui/lOOBmVxuICovXG5mdW5jdGlvbiBnZXRUaW1lTGFiZWwoZGF0ZSkge1xuICByZXR1cm4gYCR7KFwiMFwiICsgZGF0ZS5nZXRIb3VycygpKS5zbGljZSgtMil9OiR7KFxuICAgIFwiMFwiICsgZGF0ZS5nZXRNaW51dGVzKClcbiAgKS5zbGljZSgtMil9YDtcbn1cblxuLyoqXG4gKiBZWVlZL01NL0REIGhoOm1t44KS6L+U44GZXG4gKi9cbmZ1bmN0aW9uIGdldERhdGVUaW1lTGFiZWwoZGF0ZSkge1xuICByZXR1cm4gYCR7ZGF0ZS5nZXRGdWxsWWVhcigpfS8keyhcIjBcIiArIChkYXRlLmdldE1vbnRoKCkgKyAxKSkuc2xpY2UoLTIpfS8keyhcbiAgICBcIjBcIiArIGRhdGUuZ2V0RGF0ZSgpXG4gICkuc2xpY2UoLTIpfSAkeyhcIjBcIiArIGRhdGUuZ2V0SG91cnMoKSkuc2xpY2UoLTIpfTokeyhcbiAgICBcIjBcIiArIGRhdGUuZ2V0TWludXRlcygpXG4gICkuc2xpY2UoLTIpfWA7XG59XG5cbmZ1bmN0aW9uIHRlc3QoZXZlbnRzOiB7IHN0YXJ0OiBEYXRlOyBlbmQ6IERhdGUgfVtdKSB7XG4gIGNvbnN0IGJpdERheXM6IEJpZ0ludFtdID0gW107XG5cbiAgZXZlbnRzLm1hcCgoZSkgPT4ge1xuICAgIGNvbnN0IGJpdERheSA9IGNoYW5nZURhdGVUb0JpdChlKTtcbiAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IGJpdERheTtcblxuICAgIGlmIChiaXREYXlzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8g6KuW55CG5ZKM44KS5Y+W44KL77yBXG4gICAgICAvLyDov73oqJjvvJpCaWdJbnTlnovjgavjgq3jg6Pjgrnjg4jjgZfjgabmvJTnrpfjgpLooYzjgYZcbiAgICAgIGJpdERheXNba2V5XSA9XG4gICAgICAgIFwiMGJcIiArXG4gICAgICAgIChCaWdJbnQoYml0RGF5c1trZXldKSB8IEJpZ0ludCh2YWx1ZSkpLnRvU3RyaW5nKDIpLnBhZFN0YXJ0KDU2LCBcIjBcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJpdERheXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGJpdERheXM7XG59XG4iXSwibmFtZXMiOlsiY2FsY3VsYXRlRnJlZVRpbWUiLCJldmVudHMiLCJiaXRFbXB0eVRpbWVPZkRheXMiLCJjYWxjdWxhdGVFbXB0eVRpbWVPZkRheXMiLCJlbXB0eVRpbWVPZkRheXMiLCJjaGFuZ2VCaXRUb0RhdGUiLCJmcmVlVGltZSIsImRpc3BsYXlEYXlzIiwiYml0RGF5cyIsIm1hcCIsImV2ZW50IiwiYml0RGF5IiwiY2hhbmdlRGF0ZVRvQml0Iiwia2V5IiwidmFsdWUiLCJ1bmRlZmluZWQiLCJCaWdJbnQiLCJ0b1N0cmluZyIsInBhZFN0YXJ0Iiwic3RhcnQiLCJlbmQiLCJjbG9ja0luIiwiRGF0ZSIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiY2xvY2tPdXQiLCJkYXRlQml0IiwiY2hlY2tEdXJhdGlvbiIsImkiLCJzZXRNaW51dGVzIiwiZ2V0TWludXRlcyIsImRhdGVLZXkiLCJnZXREYXRlTGFiZWwiLCJmcmVlVGltZXMiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsInJlcGxhY2UiLCJzZXRIb3VycyIsImZyZWVEdXJhdGlvbnMiLCJsZW5ndGgiLCJiaXQiLCJjaGFyQXQiLCJwdXNoIiwiZ2V0RGF0ZVRpbWVMYWJlbCIsImRheXMiLCJlIiwic2xpY2UiLCJkYXRlIiwiZ2V0VGltZUxhYmVsIiwiZ2V0SG91cnMiLCJ0ZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/calculateFreeTime.tsx\n"));

/***/ })

});