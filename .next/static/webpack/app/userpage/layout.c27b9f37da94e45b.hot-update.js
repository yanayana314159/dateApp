/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/userpage/layout",{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fyanahiro%2FTechTrain%2FdateApp%2Fapp%2Fcomponents%2FauthButtonClient.tsx&modules=%2FUsers%2Fyanahiro%2FTechTrain%2FdateApp%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Flegacy%2Fimage.js&modules=%2FUsers%2Fyanahiro%2FTechTrain%2FdateApp%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%22path%22%3A%22app%2Fuserpage%2Flayout.tsx%22%2C%22import%22%3A%22Inter%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%7D%5D%2C%22variableName%22%3A%22inter%22%7D&server=false!":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fyanahiro%2FTechTrain%2FdateApp%2Fapp%2Fcomponents%2FauthButtonClient.tsx&modules=%2FUsers%2Fyanahiro%2FTechTrain%2FdateApp%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Flegacy%2Fimage.js&modules=%2FUsers%2Fyanahiro%2FTechTrain%2FdateApp%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%22path%22%3A%22app%2Fuserpage%2Flayout.tsx%22%2C%22import%22%3A%22Inter%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%7D%5D%2C%22variableName%22%3A%22inter%22%7D&server=false! ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/components/authButtonClient.tsx */ \"(app-pages-browser)/./app/components/authButtonClient.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/legacy/image.js */ \"(app-pages-browser)/./node_modules/next/dist/client/legacy/image.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/font/google/target.css?{\"path\":\"app/userpage/layout.tsx\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app/userpage/layout.tsx\\\",\\\"import\\\":\\\"Inter\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"]}],\\\"variableName\\\":\\\"inter\\\"}\", 23))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZVc2VycyUyRnlhbmFoaXJvJTJGVGVjaFRyYWluJTJGZGF0ZUFwcCUyRmFwcCUyRmNvbXBvbmVudHMlMkZhdXRoQnV0dG9uQ2xpZW50LnRzeCZtb2R1bGVzPSUyRlVzZXJzJTJGeWFuYWhpcm8lMkZUZWNoVHJhaW4lMkZkYXRlQXBwJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZsZWdhY3klMkZpbWFnZS5qcyZtb2R1bGVzPSUyRlVzZXJzJTJGeWFuYWhpcm8lMkZUZWNoVHJhaW4lMkZkYXRlQXBwJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmZvbnQlMkZnb29nbGUlMkZ0YXJnZXQuY3NzJTNGJTdCJTIycGF0aCUyMiUzQSUyMmFwcCUyRnVzZXJwYWdlJTJGbGF5b3V0LnRzeCUyMiUyQyUyMmltcG9ydCUyMiUzQSUyMkludGVyJTIyJTJDJTIyYXJndW1lbnRzJTIyJTNBJTVCJTdCJTIyc3Vic2V0cyUyMiUzQSU1QiUyMmxhdGluJTIyJTVEJTdEJTVEJTJDJTIydmFyaWFibGVOYW1lJTIyJTNBJTIyaW50ZXIlMjIlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSxvTUFBMEc7QUFDMUcsOE5BQW9IO0FBQ3BIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/MzViNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy95YW5haGlyby9UZWNoVHJhaW4vZGF0ZUFwcC9hcHAvY29tcG9uZW50cy9hdXRoQnV0dG9uQ2xpZW50LnRzeFwiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL3lhbmFoaXJvL1RlY2hUcmFpbi9kYXRlQXBwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xlZ2FjeS9pbWFnZS5qc1wiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL3lhbmFoaXJvL1RlY2hUcmFpbi9kYXRlQXBwL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1xcXCJwYXRoXFxcIjpcXFwiYXBwL3VzZXJwYWdlL2xheW91dC50c3hcXFwiLFxcXCJpbXBvcnRcXFwiOlxcXCJJbnRlclxcXCIsXFxcImFyZ3VtZW50c1xcXCI6W3tcXFwic3Vic2V0c1xcXCI6W1xcXCJsYXRpblxcXCJdfV0sXFxcInZhcmlhYmxlTmFtZVxcXCI6XFxcImludGVyXFxcIn1cIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fyanahiro%2FTechTrain%2FdateApp%2Fapp%2Fcomponents%2FauthButtonClient.tsx&modules=%2FUsers%2Fyanahiro%2FTechTrain%2FdateApp%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Flegacy%2Fimage.js&modules=%2FUsers%2Fyanahiro%2FTechTrain%2FdateApp%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%22path%22%3A%22app%2Fuserpage%2Flayout.tsx%22%2C%22import%22%3A%22Inter%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%7D%5D%2C%22variableName%22%3A%22inter%22%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/legacy/image.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/legacy/image.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return Image;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../shared/lib/head */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\"));\nconst _imageconfig = __webpack_require__(/*! ../../shared/lib/image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst _useintersection = __webpack_require__(/*! ../use-intersection */ \"(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js\");\nconst _imageconfigcontextsharedruntime = __webpack_require__(/*! ../../shared/lib/image-config-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nconst _warnonce = __webpack_require__(/*! ../../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _normalizetrailingslash = __webpack_require__(/*! ../normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nfunction normalizeSrc(src) {\n    return src[0] === \"/\" ? src.slice(1) : src;\n}\nconst configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]};\nconst loadedImageURLs = new Set();\nconst allImgs = new Map();\nlet perfObserver;\nconst emptyDataURL = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\nif (false) {}\nconst VALID_LOADING_VALUES = [\n    \"lazy\",\n    \"eager\",\n    undefined\n];\nfunction imgixLoader(param) {\n    let { config, src, width, quality } = param;\n    // Demo: https://static.imgix.net/daisy.png?auto=format&fit=max&w=300\n    const url = new URL(\"\" + config.path + normalizeSrc(src));\n    const params = url.searchParams;\n    // auto params can be combined with comma separation, or reiteration\n    params.set(\"auto\", params.getAll(\"auto\").join(\",\") || \"format\");\n    params.set(\"fit\", params.get(\"fit\") || \"max\");\n    params.set(\"w\", params.get(\"w\") || width.toString());\n    if (quality) {\n        params.set(\"q\", quality.toString());\n    }\n    return url.href;\n}\nfunction akamaiLoader(param) {\n    let { config, src, width } = param;\n    return \"\" + config.path + normalizeSrc(src) + \"?imwidth=\" + width;\n}\nfunction cloudinaryLoader(param) {\n    let { config, src, width, quality } = param;\n    // Demo: https://res.cloudinary.com/demo/image/upload/w_300,c_limit,q_auto/turtles.jpg\n    const params = [\n        \"f_auto\",\n        \"c_limit\",\n        \"w_\" + width,\n        \"q_\" + (quality || \"auto\")\n    ];\n    const paramsString = params.join(\",\") + \"/\";\n    return \"\" + config.path + paramsString + normalizeSrc(src);\n}\nfunction customLoader(param) {\n    let { src } = param;\n    throw new Error('Image with src \"' + src + '\" is missing \"loader\" prop.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n}\nfunction defaultLoader(param) {\n    let { config, src, width, quality } = param;\n    if (true) {\n        const missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push(\"src\");\n        if (!width) missingValues.push(\"width\");\n        if (missingValues.length > 0) {\n            throw new Error(\"Next Image Optimization requires \" + missingValues.join(\", \") + \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \" + JSON.stringify({\n                src,\n                width,\n                quality\n            }));\n        }\n        if (src.startsWith(\"//\")) {\n            throw new Error('Failed to parse src \"' + src + '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)');\n        }\n        if (!src.startsWith(\"/\") && (config.domains || config.remotePatterns)) {\n            let parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw new Error('Failed to parse src \"' + src + '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)');\n            }\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasMatch } = __webpack_require__(/*! ../../shared/lib/match-remote-pattern */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\");\n                if (!hasMatch(config.domains, config.remotePatterns, parsedSrc)) {\n                    throw new Error(\"Invalid src prop (\" + src + ') on `next/image`, hostname \"' + parsedSrc.hostname + '\" is not configured under images in your `next.config.js`\\n' + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n                }\n            }\n        }\n    }\n    if (src.endsWith(\".svg\") && !config.dangerouslyAllowSVG) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        return src;\n    }\n    return (0, _normalizetrailingslash.normalizePathTrailingSlash)(config.path) + \"?url=\" + encodeURIComponent(src) + \"&w=\" + width + \"&q=\" + (quality || 75);\n}\nconst loaders = new Map([\n    [\n        \"default\",\n        defaultLoader\n    ],\n    [\n        \"imgix\",\n        imgixLoader\n    ],\n    [\n        \"cloudinary\",\n        cloudinaryLoader\n    ],\n    [\n        \"akamai\",\n        akamaiLoader\n    ],\n    [\n        \"custom\",\n        customLoader\n    ]\n]);\nconst VALID_LAYOUT_VALUES = [\n    \"fill\",\n    \"fixed\",\n    \"intrinsic\",\n    \"responsive\",\n    undefined\n];\nfunction isStaticRequire(src) {\n    return src.default !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return typeof src === \"object\" && (isStaticRequire(src) || isStaticImageData(src));\n}\nfunction getWidths(param, width, layout, sizes) {\n    let { deviceSizes, allSizes } = param;\n    if (sizes && (layout === \"fill\" || layout === \"responsive\")) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        const viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        const percentSizes = [];\n        for(let match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            const smallestRatio = Math.min(...percentSizes) * 0.01;\n            return {\n                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),\n                kind: \"w\"\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: \"w\"\n        };\n    }\n    if (typeof width !== \"number\" || layout === \"fill\" || layout === \"responsive\") {\n        return {\n            widths: deviceSizes,\n            kind: \"w\"\n        };\n    }\n    const widths = [\n        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n        // > blue colors. Showing a 3x resolution image in the app vs a 2x\n        // > resolution image will be visually the same, though the 3x image\n        // > takes significantly more data. Even true 3x resolution screens are\n        // > wasteful as the human eye cannot see that level of detail without\n        // > something like a magnifying glass.\n        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n        [\n            width,\n            width * 2 /*, width * 3*/ \n        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))\n    ];\n    return {\n        widths,\n        kind: \"x\"\n    };\n}\nfunction generateImgAttrs(param) {\n    let { config, src, unoptimized, layout, width, quality, sizes, loader } = param;\n    if (unoptimized) {\n        return {\n            src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    const { widths, kind } = getWidths(config, width, layout, sizes);\n    const last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === \"w\" ? \"100vw\" : sizes,\n        srcSet: widths.map((w, i)=>loader({\n                config,\n                src,\n                quality,\n                width: w\n            }) + \" \" + (kind === \"w\" ? w : i + 1) + kind).join(\", \"),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config,\n            src,\n            quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getInt(x) {\n    if (typeof x === \"number\") {\n        return x;\n    }\n    if (typeof x === \"string\") {\n        return parseInt(x, 10);\n    }\n    return undefined;\n}\nfunction defaultImageLoader(loaderProps) {\n    var _loaderProps_config;\n    const loaderKey = ((_loaderProps_config = loaderProps.config) == null ? void 0 : _loaderProps_config.loader) || \"default\";\n    const load = loaders.get(loaderKey);\n    if (load) {\n        return load(loaderProps);\n    }\n    throw new Error('Unknown \"loader\" found in \"next.config.js\". Expected: ' + _imageconfig.VALID_LOADERS.join(\", \") + \". Received: \" + loaderKey);\n}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, src, layout, placeholder, onLoadingCompleteRef, setBlurComplete) {\n    if (!img || img.src === emptyDataURL || img[\"data-loaded-src\"] === src) {\n        return;\n    }\n    img[\"data-loaded-src\"] = src;\n    const p = \"decode\" in img ? img.decode() : Promise.resolve();\n    p.catch(()=>{}).then(()=>{\n        if (!img.parentNode) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        loadedImageURLs.add(src);\n        if (placeholder === \"blur\") {\n            setBlurComplete(true);\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            const { naturalWidth, naturalHeight } = img;\n            // Pass back read-only primitive values but not the\n            // underlying DOM element because it could be misused.\n            onLoadingCompleteRef.current({\n                naturalWidth,\n                naturalHeight\n            });\n        }\n        if (true) {\n            var _img_parentElement;\n            if ((_img_parentElement = img.parentElement) == null ? void 0 : _img_parentElement.parentElement) {\n                const parent = getComputedStyle(img.parentElement.parentElement);\n                if (!parent.position) {\n                // The parent has not been rendered to the dom yet and therefore it has no position. Skip the warnings for such cases.\n                } else if (layout === \"responsive\" && parent.display === \"flex\") {\n                    (0, _warnonce.warnOnce)('Image with src \"' + src + '\" may not render properly as a child of a flex container. Consider wrapping the image with a div to configure the width.');\n                } else if (layout === \"fill\" && parent.position !== \"relative\" && parent.position !== \"fixed\" && parent.position !== \"absolute\") {\n                    (0, _warnonce.warnOnce)('Image with src \"' + src + '\" may not render properly with a parent using position:\"' + parent.position + '\". Consider changing the parent style to position:\"relative\" with a width and height.');\n                }\n            }\n        }\n    });\n}\nconst ImageElement = (param)=>{\n    let { imgAttributes, heightInt, widthInt, qualityInt, layout, className, imgStyle, blurStyle, isLazy, placeholder, loading, srcString, config, unoptimized, loader, onLoadingCompleteRef, setBlurComplete, setIntersection, onLoad, onError, isVisible, noscriptSizes, ...rest } = param;\n    loading = isLazy ? \"lazy\" : loading;\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(\"img\", {\n        ...rest,\n        ...imgAttributes,\n        decoding: \"async\",\n        \"data-nimg\": layout,\n        className: className,\n        style: {\n            ...imgStyle,\n            ...blurStyle\n        },\n        ref: (0, _react.useCallback)((img)=>{\n            if (true) {\n                if (img && !srcString) {\n                    console.error('Image is missing required \"src\" property:', img);\n                }\n            }\n            setIntersection(img);\n            if (img == null ? void 0 : img.complete) {\n                handleLoading(img, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete);\n            }\n        }, [\n            setIntersection,\n            srcString,\n            layout,\n            placeholder,\n            onLoadingCompleteRef,\n            setBlurComplete\n        ]),\n        onLoad: (event)=>{\n            const img = event.currentTarget;\n            handleLoading(img, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete);\n            if (onLoad) {\n                onLoad(event);\n            }\n        },\n        onError: (event)=>{\n            if (placeholder === \"blur\") {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    }), (isLazy || placeholder === \"blur\") && /*#__PURE__*/ _react.default.createElement(\"noscript\", null, /*#__PURE__*/ _react.default.createElement(\"img\", {\n        ...rest,\n        // @ts-ignore - TODO: upgrade to `@types/react@17`\n        loading: loading,\n        decoding: \"async\",\n        \"data-nimg\": layout,\n        style: imgStyle,\n        className: className,\n        ...generateImgAttrs({\n            config,\n            src: srcString,\n            unoptimized,\n            layout,\n            width: widthInt,\n            quality: qualityInt,\n            sizes: noscriptSizes,\n            loader\n        })\n    })));\n};\n_c = ImageElement;\nfunction Image(param) {\n    _s();\n    let { src, sizes, unoptimized = false, priority = false, loading, lazyRoot = null, lazyBoundary, className, quality, width, height, style, objectFit, objectPosition, onLoadingComplete, placeholder = \"empty\", blurDataURL, ...all } = param;\n    const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);\n    const config = (0, _react.useMemo)(()=>{\n        const c = configEnv || configContext || _imageconfig.imageConfigDefault;\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        return {\n            ...c,\n            allSizes,\n            deviceSizes\n        };\n    }, [\n        configContext\n    ]);\n    let rest = all;\n    let layout = sizes ? \"responsive\" : \"intrinsic\";\n    if (\"layout\" in rest) {\n        // Override default layout if the user specified one:\n        if (rest.layout) layout = rest.layout;\n        // Remove property so it's not spread on <img>:\n        delete rest.layout;\n    }\n    let loader = defaultImageLoader;\n    if (\"loader\" in rest) {\n        if (rest.loader) {\n            const customImageLoader = rest.loader;\n            loader = (obj)=>{\n                const { config: _, ...opts } = obj;\n                // The config object is internal only so we must\n                // not pass it to the user-defined loader()\n                return customImageLoader(opts);\n            };\n        }\n        // Remove property so it's not spread on <img>\n        delete rest.loader;\n    }\n    let staticSrc = \"\";\n    if (isStaticImport(src)) {\n        const staticImageData = isStaticRequire(src) ? src.default : src;\n        if (!staticImageData.src) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \" + JSON.stringify(staticImageData));\n        }\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!layout || layout !== \"fill\") {\n            height = height || staticImageData.height;\n            width = width || staticImageData.width;\n            if (!staticImageData.height || !staticImageData.width) {\n                throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \" + JSON.stringify(staticImageData));\n            }\n        }\n    }\n    src = typeof src === \"string\" ? src : staticSrc;\n    let isLazy = !priority && (loading === \"lazy\" || typeof loading === \"undefined\");\n    if (src.startsWith(\"data:\") || src.startsWith(\"blob:\")) {\n        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if ( true && loadedImageURLs.has(src)) {\n        isLazy = false;\n    }\n    if (config.unoptimized) {\n        unoptimized = true;\n    }\n    const [blurComplete, setBlurComplete] = (0, _react.useState)(false);\n    const [setIntersection, isIntersected, resetIntersected] = (0, _useintersection.useIntersection)({\n        rootRef: lazyRoot,\n        rootMargin: lazyBoundary || \"200px\",\n        disabled: !isLazy\n    });\n    const isVisible = !isLazy || isIntersected;\n    const wrapperStyle = {\n        boxSizing: \"border-box\",\n        display: \"block\",\n        overflow: \"hidden\",\n        width: \"initial\",\n        height: \"initial\",\n        background: \"none\",\n        opacity: 1,\n        border: 0,\n        margin: 0,\n        padding: 0\n    };\n    const sizerStyle = {\n        boxSizing: \"border-box\",\n        display: \"block\",\n        width: \"initial\",\n        height: \"initial\",\n        background: \"none\",\n        opacity: 1,\n        border: 0,\n        margin: 0,\n        padding: 0\n    };\n    let hasSizer = false;\n    let sizerSvgUrl;\n    const layoutStyle = {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        bottom: 0,\n        right: 0,\n        boxSizing: \"border-box\",\n        padding: 0,\n        border: \"none\",\n        margin: \"auto\",\n        display: \"block\",\n        width: 0,\n        height: 0,\n        minWidth: \"100%\",\n        maxWidth: \"100%\",\n        minHeight: \"100%\",\n        maxHeight: \"100%\",\n        objectFit,\n        objectPosition\n    };\n    let widthInt = getInt(width);\n    let heightInt = getInt(height);\n    const qualityInt = getInt(quality);\n    if (true) {\n        if (!src) {\n            // React doesn't show the stack trace and there's\n            // no `src` to help identify which image, so we\n            // instead console.error(ref) during mount.\n            widthInt = widthInt || 1;\n            heightInt = heightInt || 1;\n            unoptimized = true;\n        } else {\n            if (!VALID_LAYOUT_VALUES.includes(layout)) {\n                throw new Error('Image with src \"' + src + '\" has invalid \"layout\" property. Provided \"' + layout + '\" should be one of ' + VALID_LAYOUT_VALUES.map(String).join(\",\") + \".\");\n            }\n            if (typeof widthInt !== \"undefined\" && isNaN(widthInt) || typeof heightInt !== \"undefined\" && isNaN(heightInt)) {\n                throw new Error('Image with src \"' + src + '\" has invalid \"width\" or \"height\" property. These should be numeric values.');\n            }\n            if (layout === \"fill\" && (width || height)) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" and \"layout=\\'fill\\'\" has unused properties assigned. Please remove \"width\" and \"height\".');\n            }\n            if (!VALID_LOADING_VALUES.includes(loading)) {\n                throw new Error('Image with src \"' + src + '\" has invalid \"loading\" property. Provided \"' + loading + '\" should be one of ' + VALID_LOADING_VALUES.map(String).join(\",\") + \".\");\n            }\n            if (priority && loading === \"lazy\") {\n                throw new Error('Image with src \"' + src + '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.');\n            }\n            if (sizes && layout !== \"fill\" && layout !== \"responsive\") {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has \"sizes\" property but it will be ignored. Only use \"sizes\" with \"layout=\\'fill\\'\" or \"layout=\\'responsive\\'\"');\n            }\n            if (placeholder === \"blur\") {\n                if (layout !== \"fill\" && (widthInt || 0) * (heightInt || 0) < 1600) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is smaller than 40x40. Consider removing the \"placeholder=\\'blur\\'\" property to improve performance.');\n                }\n                if (!blurDataURL) {\n                    const VALID_BLUR_EXT = [\n                        \"jpeg\",\n                        \"png\",\n                        \"webp\",\n                        \"avif\"\n                    ] // should match next-image-loader\n                    ;\n                    throw new Error('Image with src \"' + src + '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n          Possible solutions:\\n            - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n            - Change the \"src\" property to a static import with one of the supported file types: ' + VALID_BLUR_EXT.join(\",\") + ' (animated images not supported)\\n            - Remove the \"placeholder\" property, effectively no blur effect\\n          Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url');\n                }\n            }\n            if (\"ref\" in rest) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using unsupported \"ref\" property. Consider using the \"onLoadingComplete\" property instead.');\n            }\n            if (!unoptimized && loader !== defaultImageLoader) {\n                const urlStr = loader({\n                    config,\n                    src,\n                    width: widthInt || 400,\n                    quality: qualityInt || 75\n                });\n                let url;\n                try {\n                    url = new URL(urlStr);\n                } catch (err) {}\n                if (urlStr === src || url && url.pathname === src && !url.search) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n                }\n            }\n            if (style) {\n                let overwrittenStyles = Object.keys(style).filter((key)=>key in layoutStyle);\n                if (overwrittenStyles.length) {\n                    (0, _warnonce.warnOnce)(\"Image with src \" + src + \" is assigned the following styles, which are overwritten by automatically-generated styles: \" + overwrittenStyles.join(\", \"));\n                }\n            }\n            if ( true && !perfObserver && window.PerformanceObserver) {\n                perfObserver = new PerformanceObserver((entryList)=>{\n                    for (const entry of entryList.getEntries()){\n                        var _entry_element;\n                        // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                        const imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || \"\";\n                        const lcpImage = allImgs.get(imgSrc);\n                        if (lcpImage && !lcpImage.priority && lcpImage.placeholder !== \"blur\" && !lcpImage.src.startsWith(\"data:\") && !lcpImage.src.startsWith(\"blob:\")) {\n                            // https://web.dev/lcp/#measure-lcp-in-javascript\n                            (0, _warnonce.warnOnce)('Image with src \"' + lcpImage.src + '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.' + \"\\nRead more: https://nextjs.org/docs/api-reference/next/legacy/image#priority\");\n                        }\n                    }\n                });\n                try {\n                    perfObserver.observe({\n                        type: \"largest-contentful-paint\",\n                        buffered: true\n                    });\n                } catch (err) {\n                    // Log error but don't crash the app\n                    console.error(err);\n                }\n            }\n        }\n    }\n    const imgStyle = Object.assign({}, style, layoutStyle);\n    const blurStyle = placeholder === \"blur\" && !blurComplete ? {\n        backgroundSize: objectFit || \"cover\",\n        backgroundPosition: objectPosition || \"0% 0%\",\n        filter: \"blur(20px)\",\n        backgroundImage: 'url(\"' + blurDataURL + '\")'\n    } : {};\n    if (layout === \"fill\") {\n        // <Image src=\"i.png\" layout=\"fill\" />\n        wrapperStyle.display = \"block\";\n        wrapperStyle.position = \"absolute\";\n        wrapperStyle.top = 0;\n        wrapperStyle.left = 0;\n        wrapperStyle.bottom = 0;\n        wrapperStyle.right = 0;\n    } else if (typeof widthInt !== \"undefined\" && typeof heightInt !== \"undefined\") {\n        // <Image src=\"i.png\" width=\"100\" height=\"100\" />\n        const quotient = heightInt / widthInt;\n        const paddingTop = isNaN(quotient) ? \"100%\" : \"\" + quotient * 100 + \"%\";\n        if (layout === \"responsive\") {\n            // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"responsive\" />\n            wrapperStyle.display = \"block\";\n            wrapperStyle.position = \"relative\";\n            hasSizer = true;\n            sizerStyle.paddingTop = paddingTop;\n        } else if (layout === \"intrinsic\") {\n            // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"intrinsic\" />\n            wrapperStyle.display = \"inline-block\";\n            wrapperStyle.position = \"relative\";\n            wrapperStyle.maxWidth = \"100%\";\n            hasSizer = true;\n            sizerStyle.maxWidth = \"100%\";\n            sizerSvgUrl = \"data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27\" + widthInt + \"%27%20height=%27\" + heightInt + \"%27/%3e\";\n        } else if (layout === \"fixed\") {\n            // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"fixed\" />\n            wrapperStyle.display = \"inline-block\";\n            wrapperStyle.position = \"relative\";\n            wrapperStyle.width = widthInt;\n            wrapperStyle.height = heightInt;\n        }\n    } else {\n        // <Image src=\"i.png\" />\n        if (true) {\n            throw new Error('Image with src \"' + src + '\" must use \"width\" and \"height\" properties or \"layout=\\'fill\\'\" property.');\n        }\n    }\n    let imgAttributes = {\n        src: emptyDataURL,\n        srcSet: undefined,\n        sizes: undefined\n    };\n    if (isVisible) {\n        imgAttributes = generateImgAttrs({\n            config,\n            src,\n            unoptimized,\n            layout,\n            width: widthInt,\n            quality: qualityInt,\n            sizes,\n            loader\n        });\n    }\n    let srcString = src;\n    if (true) {\n        if (true) {\n            let fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src,\n                priority,\n                placeholder\n            });\n        }\n    }\n    const linkProps = {\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: rest.crossOrigin,\n        referrerPolicy: rest.referrerPolicy\n    };\n    const useLayoutEffect =  false ? 0 : _react.default.useLayoutEffect;\n    const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);\n    const previousImageSrc = (0, _react.useRef)(src);\n    (0, _react.useEffect)(()=>{\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    useLayoutEffect(()=>{\n        if (previousImageSrc.current !== src) {\n            resetIntersected();\n            previousImageSrc.current = src;\n        }\n    }, [\n        resetIntersected,\n        src\n    ]);\n    const imgElementArgs = {\n        isLazy,\n        imgAttributes,\n        heightInt,\n        widthInt,\n        qualityInt,\n        layout,\n        className,\n        imgStyle,\n        blurStyle,\n        loading,\n        config,\n        unoptimized,\n        placeholder,\n        loader,\n        srcString,\n        onLoadingCompleteRef,\n        setBlurComplete,\n        setIntersection,\n        isVisible,\n        noscriptSizes: sizes,\n        ...rest\n    };\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(\"span\", {\n        style: wrapperStyle\n    }, hasSizer ? /*#__PURE__*/ _react.default.createElement(\"span\", {\n        style: sizerStyle\n    }, sizerSvgUrl ? /*#__PURE__*/ _react.default.createElement(\"img\", {\n        style: {\n            display: \"block\",\n            maxWidth: \"100%\",\n            width: \"initial\",\n            height: \"initial\",\n            background: \"none\",\n            opacity: 1,\n            border: 0,\n            margin: 0,\n            padding: 0\n        },\n        alt: \"\",\n        \"aria-hidden\": true,\n        src: sizerSvgUrl\n    }) : null) : null, /*#__PURE__*/ _react.default.createElement(ImageElement, imgElementArgs)), priority ? // for browsers that do not support `imagesrcset`, and in those cases\n    // it would likely cause the incorrect image to be preloaded.\n    //\n    // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n    /*#__PURE__*/ _react.default.createElement(_head.default, null, /*#__PURE__*/ _react.default.createElement(\"link\", {\n        key: \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes,\n        rel: \"preload\",\n        as: \"image\",\n        href: imgAttributes.srcSet ? undefined : imgAttributes.src,\n        ...linkProps\n    })) : null);\n}\n_s(Image, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n_c1 = Image;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=image.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"ImageElement\");\n$RefreshReg$(_c1, \"Image\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xlZ2FjeS9pbWFnZS5qcyIsIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0FBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCwyQ0FBMEM7SUFDdENJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQywyQkFBMkJDLG1CQUFPQSxDQUFDLGdJQUF5QztBQUNsRixNQUFNQyw0QkFBNEJELG1CQUFPQSxDQUFDLGtJQUEwQztBQUNwRixNQUFNRSxTQUFTLFdBQVcsR0FBR0QsMEJBQTBCRSxDQUFDLENBQUNILG1CQUFPQSxDQUFDLG1GQUFPO0FBQ3hFLE1BQU1JLFFBQVEsV0FBVyxHQUFHTCx5QkFBeUJJLENBQUMsQ0FBQ0gsbUJBQU9BLENBQUMsOEZBQXVCO0FBQ3RGLE1BQU1LLGVBQWVMLG1CQUFPQSxDQUFDLDhHQUErQjtBQUM1RCxNQUFNTSxtQkFBbUJOLG1CQUFPQSxDQUFDLG9HQUFxQjtBQUN0RCxNQUFNTyxtQ0FBbUNQLG1CQUFPQSxDQUFDLDRKQUFzRDtBQUN2RyxNQUFNUSxZQUFZUixtQkFBT0EsQ0FBQyxvSEFBa0M7QUFDNUQsTUFBTVMsMEJBQTBCVCxtQkFBT0EsQ0FBQyxvSEFBNkI7QUFDckUsU0FBU1UsYUFBYUMsR0FBRztJQUNyQixPQUFPQSxHQUFHLENBQUMsRUFBRSxLQUFLLE1BQU1BLElBQUlDLEtBQUssQ0FBQyxLQUFLRDtBQUMzQztBQUNBLE1BQU1FLFlBQVlDLDBOQUE2QjtBQUMvQyxNQUFNRyxrQkFBa0IsSUFBSUM7QUFDNUIsTUFBTUMsVUFBVSxJQUFJQztBQUNwQixJQUFJQztBQUNKLE1BQU1DLGVBQWU7QUFDckIsSUFBSSxLQUE2QixFQUFFLEVBRWxDO0FBQ0QsTUFBTUcsdUJBQXVCO0lBQ3pCO0lBQ0E7SUFDQUM7Q0FDSDtBQUNELFNBQVNDLFlBQVlDLEtBQUs7SUFDdEIs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LEVBQUU7SUFDRiw4RUFBOEU7SUFDOUUsV0FBVyxHQUFHMUosT0FBT29FLE9BQU8sQ0FBQzZFLGFBQWEsQ0FBQy9JLE1BQU1rRSxPQUFPLEVBQUUsTUFBTSxXQUFXLEdBQUdwRSxPQUFPb0UsT0FBTyxDQUFDNkUsYUFBYSxDQUFDLFFBQVE7UUFDL0d1RSxLQUFLLFlBQVl2RixjQUFjeEgsR0FBRyxHQUFHd0gsY0FBY2xDLE1BQU0sR0FBR2tDLGNBQWN4RCxLQUFLO1FBQy9FK0ssS0FBSztRQUNMQyxJQUFJO1FBQ0psTixNQUFNMEYsY0FBY2xDLE1BQU0sR0FBR3ZFLFlBQVl5RyxjQUFjeEgsR0FBRztRQUMxRCxHQUFHcU8sU0FBUztJQUNoQixNQUFNO0FBQ1Y7R0FuWFNsUDtNQUFBQTtBQXFYVCxJQUFJLENBQUMsT0FBT0osUUFBUTRFLE9BQU8sS0FBSyxjQUFlLE9BQU81RSxRQUFRNEUsT0FBTyxLQUFLLFlBQVk1RSxRQUFRNEUsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPNUUsUUFBUTRFLE9BQU8sQ0FBQ3NMLFVBQVUsS0FBSyxhQUFhO0lBQ3JLcFEsT0FBT0MsY0FBYyxDQUFDQyxRQUFRNEUsT0FBTyxFQUFFLGNBQWM7UUFBRTNFLE9BQU87SUFBSztJQUNuRUgsT0FBTytPLE1BQU0sQ0FBQzdPLFFBQVE0RSxPQUFPLEVBQUU1RTtJQUMvQm1RLE9BQU9uUSxPQUFPLEdBQUdBLFFBQVE0RSxPQUFPO0FBQ2xDLEVBRUEsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xlZ2FjeS9pbWFnZS5qcz9iNWZhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEltYWdlO1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZFwiKTtcbmNvbnN0IF9yZWFjdCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBfaGVhZCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvaGVhZFwiKSk7XG5jb25zdCBfaW1hZ2Vjb25maWcgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9pbWFnZS1jb25maWdcIik7XG5jb25zdCBfdXNlaW50ZXJzZWN0aW9uID0gcmVxdWlyZShcIi4uL3VzZS1pbnRlcnNlY3Rpb25cIik7XG5jb25zdCBfaW1hZ2Vjb25maWdjb250ZXh0c2hhcmVkcnVudGltZSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0LnNoYXJlZC1ydW50aW1lXCIpO1xuY29uc3QgX3dhcm5vbmNlID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvdXRpbHMvd2Fybi1vbmNlXCIpO1xuY29uc3QgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi4vbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoXCIpO1xuZnVuY3Rpb24gbm9ybWFsaXplU3JjKHNyYykge1xuICAgIHJldHVybiBzcmNbMF0gPT09IFwiL1wiID8gc3JjLnNsaWNlKDEpIDogc3JjO1xufVxuY29uc3QgY29uZmlnRW52ID0gcHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFM7XG5jb25zdCBsb2FkZWRJbWFnZVVSTHMgPSBuZXcgU2V0KCk7XG5jb25zdCBhbGxJbWdzID0gbmV3IE1hcCgpO1xubGV0IHBlcmZPYnNlcnZlcjtcbmNvbnN0IGVtcHR5RGF0YVVSTCA9IFwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95SDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUJSQUE3XCI7XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGdsb2JhbFRoaXMuX19ORVhUX0lNQUdFX0lNUE9SVEVEID0gdHJ1ZTtcbn1cbmNvbnN0IFZBTElEX0xPQURJTkdfVkFMVUVTID0gW1xuICAgIFwibGF6eVwiLFxuICAgIFwiZWFnZXJcIixcbiAgICB1bmRlZmluZWRcbl07XG5mdW5jdGlvbiBpbWdpeExvYWRlcihwYXJhbSkge1xuICAgIGxldCB7IGNvbmZpZywgc3JjLCB3aWR0aCwgcXVhbGl0eSB9ID0gcGFyYW07XG4gICAgLy8gRGVtbzogaHR0cHM6Ly9zdGF0aWMuaW1naXgubmV0L2RhaXN5LnBuZz9hdXRvPWZvcm1hdCZmaXQ9bWF4Jnc9MzAwXG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChcIlwiICsgY29uZmlnLnBhdGggKyBub3JtYWxpemVTcmMoc3JjKSk7XG4gICAgY29uc3QgcGFyYW1zID0gdXJsLnNlYXJjaFBhcmFtcztcbiAgICAvLyBhdXRvIHBhcmFtcyBjYW4gYmUgY29tYmluZWQgd2l0aCBjb21tYSBzZXBhcmF0aW9uLCBvciByZWl0ZXJhdGlvblxuICAgIHBhcmFtcy5zZXQoXCJhdXRvXCIsIHBhcmFtcy5nZXRBbGwoXCJhdXRvXCIpLmpvaW4oXCIsXCIpIHx8IFwiZm9ybWF0XCIpO1xuICAgIHBhcmFtcy5zZXQoXCJmaXRcIiwgcGFyYW1zLmdldChcImZpdFwiKSB8fCBcIm1heFwiKTtcbiAgICBwYXJhbXMuc2V0KFwid1wiLCBwYXJhbXMuZ2V0KFwid1wiKSB8fCB3aWR0aC50b1N0cmluZygpKTtcbiAgICBpZiAocXVhbGl0eSkge1xuICAgICAgICBwYXJhbXMuc2V0KFwicVwiLCBxdWFsaXR5LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsLmhyZWY7XG59XG5mdW5jdGlvbiBha2FtYWlMb2FkZXIocGFyYW0pIHtcbiAgICBsZXQgeyBjb25maWcsIHNyYywgd2lkdGggfSA9IHBhcmFtO1xuICAgIHJldHVybiBcIlwiICsgY29uZmlnLnBhdGggKyBub3JtYWxpemVTcmMoc3JjKSArIFwiP2ltd2lkdGg9XCIgKyB3aWR0aDtcbn1cbmZ1bmN0aW9uIGNsb3VkaW5hcnlMb2FkZXIocGFyYW0pIHtcbiAgICBsZXQgeyBjb25maWcsIHNyYywgd2lkdGgsIHF1YWxpdHkgfSA9IHBhcmFtO1xuICAgIC8vIERlbW86IGh0dHBzOi8vcmVzLmNsb3VkaW5hcnkuY29tL2RlbW8vaW1hZ2UvdXBsb2FkL3dfMzAwLGNfbGltaXQscV9hdXRvL3R1cnRsZXMuanBnXG4gICAgY29uc3QgcGFyYW1zID0gW1xuICAgICAgICBcImZfYXV0b1wiLFxuICAgICAgICBcImNfbGltaXRcIixcbiAgICAgICAgXCJ3X1wiICsgd2lkdGgsXG4gICAgICAgIFwicV9cIiArIChxdWFsaXR5IHx8IFwiYXV0b1wiKVxuICAgIF07XG4gICAgY29uc3QgcGFyYW1zU3RyaW5nID0gcGFyYW1zLmpvaW4oXCIsXCIpICsgXCIvXCI7XG4gICAgcmV0dXJuIFwiXCIgKyBjb25maWcucGF0aCArIHBhcmFtc1N0cmluZyArIG5vcm1hbGl6ZVNyYyhzcmMpO1xufVxuZnVuY3Rpb24gY3VzdG9tTG9hZGVyKHBhcmFtKSB7XG4gICAgbGV0IHsgc3JjIH0gPSBwYXJhbTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBpcyBtaXNzaW5nIFwibG9hZGVyXCIgcHJvcC4nICsgXCJcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtbWlzc2luZy1sb2FkZXJcIik7XG59XG5mdW5jdGlvbiBkZWZhdWx0TG9hZGVyKHBhcmFtKSB7XG4gICAgbGV0IHsgY29uZmlnLCBzcmMsIHdpZHRoLCBxdWFsaXR5IH0gPSBwYXJhbTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdWYWx1ZXMgPSBbXTtcbiAgICAgICAgLy8gdGhlc2Ugc2hvdWxkIGFsd2F5cyBiZSBwcm92aWRlZCBidXQgbWFrZSBzdXJlIHRoZXkgYXJlXG4gICAgICAgIGlmICghc3JjKSBtaXNzaW5nVmFsdWVzLnB1c2goXCJzcmNcIik7XG4gICAgICAgIGlmICghd2lkdGgpIG1pc3NpbmdWYWx1ZXMucHVzaChcIndpZHRoXCIpO1xuICAgICAgICBpZiAobWlzc2luZ1ZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZXh0IEltYWdlIE9wdGltaXphdGlvbiByZXF1aXJlcyBcIiArIG1pc3NpbmdWYWx1ZXMuam9pbihcIiwgXCIpICsgXCIgdG8gYmUgcHJvdmlkZWQuIE1ha2Ugc3VyZSB5b3UgcGFzcyB0aGVtIGFzIHByb3BzIHRvIHRoZSBgbmV4dC9pbWFnZWAgY29tcG9uZW50LiBSZWNlaXZlZDogXCIgKyBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIHF1YWxpdHlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3JjLnN0YXJ0c1dpdGgoXCIvL1wiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2Ugc3JjIFwiJyArIHNyYyArICdcIiBvbiBgbmV4dC9pbWFnZWAsIHByb3RvY29sLXJlbGF0aXZlIFVSTCAoLy8pIG11c3QgYmUgY2hhbmdlZCB0byBhbiBhYnNvbHV0ZSBVUkwgKGh0dHA6Ly8gb3IgaHR0cHM6Ly8pJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzcmMuc3RhcnRzV2l0aChcIi9cIikgJiYgKGNvbmZpZy5kb21haW5zIHx8IGNvbmZpZy5yZW1vdGVQYXR0ZXJucykpIHtcbiAgICAgICAgICAgIGxldCBwYXJzZWRTcmM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBhcnNlZFNyYyA9IG5ldyBVUkwoc3JjKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBzcmMgXCInICsgc3JjICsgJ1wiIG9uIGBuZXh0L2ltYWdlYCwgaWYgdXNpbmcgcmVsYXRpdmUgaW1hZ2UgaXQgbXVzdCBzdGFydCB3aXRoIGEgbGVhZGluZyBzbGFzaCBcIi9cIiBvciBiZSBhbiBhYnNvbHV0ZSBVUkwgKGh0dHA6Ly8gb3IgaHR0cHM6Ly8pJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwidGVzdFwiICYmIC8vIG1pY3JvbWF0Y2ggaXNuJ3QgY29tcGF0aWJsZSB3aXRoIGVkZ2UgcnVudGltZVxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FICE9PSBcImVkZ2VcIikge1xuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSBkeW5hbWljIHJlcXVpcmUgYmVjYXVzZSB0aGlzIHNob3VsZCBvbmx5IGVycm9yIGluIGRldmVsb3BtZW50XG4gICAgICAgICAgICAgICAgY29uc3QgeyBoYXNNYXRjaCB9ID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvbWF0Y2gtcmVtb3RlLXBhdHRlcm5cIik7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNNYXRjaChjb25maWcuZG9tYWlucywgY29uZmlnLnJlbW90ZVBhdHRlcm5zLCBwYXJzZWRTcmMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3JjIHByb3AgKFwiICsgc3JjICsgJykgb24gYG5leHQvaW1hZ2VgLCBob3N0bmFtZSBcIicgKyBwYXJzZWRTcmMuaG9zdG5hbWUgKyAnXCIgaXMgbm90IGNvbmZpZ3VyZWQgdW5kZXIgaW1hZ2VzIGluIHlvdXIgYG5leHQuY29uZmlnLmpzYFxcbicgKyBcIlNlZSBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtdW5jb25maWd1cmVkLWhvc3RcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzcmMuZW5kc1dpdGgoXCIuc3ZnXCIpICYmICFjb25maWcuZGFuZ2Vyb3VzbHlBbGxvd1NWRykge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgdG8gbWFrZSBzdmcgc2VydmUgYXMtaXMgdG8gYXZvaWQgcHJveHlpbmdcbiAgICAgICAgLy8gdGhyb3VnaCB0aGUgYnVpbHQtaW4gSW1hZ2UgT3B0aW1pemF0aW9uIEFQSS5cbiAgICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG4gICAgcmV0dXJuICgwLCBfbm9ybWFsaXpldHJhaWxpbmdzbGFzaC5ub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCkoY29uZmlnLnBhdGgpICsgXCI/dXJsPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHNyYykgKyBcIiZ3PVwiICsgd2lkdGggKyBcIiZxPVwiICsgKHF1YWxpdHkgfHwgNzUpO1xufVxuY29uc3QgbG9hZGVycyA9IG5ldyBNYXAoW1xuICAgIFtcbiAgICAgICAgXCJkZWZhdWx0XCIsXG4gICAgICAgIGRlZmF1bHRMb2FkZXJcbiAgICBdLFxuICAgIFtcbiAgICAgICAgXCJpbWdpeFwiLFxuICAgICAgICBpbWdpeExvYWRlclxuICAgIF0sXG4gICAgW1xuICAgICAgICBcImNsb3VkaW5hcnlcIixcbiAgICAgICAgY2xvdWRpbmFyeUxvYWRlclxuICAgIF0sXG4gICAgW1xuICAgICAgICBcImFrYW1haVwiLFxuICAgICAgICBha2FtYWlMb2FkZXJcbiAgICBdLFxuICAgIFtcbiAgICAgICAgXCJjdXN0b21cIixcbiAgICAgICAgY3VzdG9tTG9hZGVyXG4gICAgXVxuXSk7XG5jb25zdCBWQUxJRF9MQVlPVVRfVkFMVUVTID0gW1xuICAgIFwiZmlsbFwiLFxuICAgIFwiZml4ZWRcIixcbiAgICBcImludHJpbnNpY1wiLFxuICAgIFwicmVzcG9uc2l2ZVwiLFxuICAgIHVuZGVmaW5lZFxuXTtcbmZ1bmN0aW9uIGlzU3RhdGljUmVxdWlyZShzcmMpIHtcbiAgICByZXR1cm4gc3JjLmRlZmF1bHQgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzU3RhdGljSW1hZ2VEYXRhKHNyYykge1xuICAgIHJldHVybiBzcmMuc3JjICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc1N0YXRpY0ltcG9ydChzcmMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHNyYyA9PT0gXCJvYmplY3RcIiAmJiAoaXNTdGF0aWNSZXF1aXJlKHNyYykgfHwgaXNTdGF0aWNJbWFnZURhdGEoc3JjKSk7XG59XG5mdW5jdGlvbiBnZXRXaWR0aHMocGFyYW0sIHdpZHRoLCBsYXlvdXQsIHNpemVzKSB7XG4gICAgbGV0IHsgZGV2aWNlU2l6ZXMsIGFsbFNpemVzIH0gPSBwYXJhbTtcbiAgICBpZiAoc2l6ZXMgJiYgKGxheW91dCA9PT0gXCJmaWxsXCIgfHwgbGF5b3V0ID09PSBcInJlc3BvbnNpdmVcIikpIHtcbiAgICAgICAgLy8gRmluZCBhbGwgdGhlIFwidndcIiBwZXJjZW50IHNpemVzIHVzZWQgaW4gdGhlIHNpemVzIHByb3BcbiAgICAgICAgY29uc3Qgdmlld3BvcnRXaWR0aFJlID0gLyhefFxccykoMT9cXGQ/XFxkKXZ3L2c7XG4gICAgICAgIGNvbnN0IHBlcmNlbnRTaXplcyA9IFtdO1xuICAgICAgICBmb3IobGV0IG1hdGNoOyBtYXRjaCA9IHZpZXdwb3J0V2lkdGhSZS5leGVjKHNpemVzKTsgbWF0Y2gpe1xuICAgICAgICAgICAgcGVyY2VudFNpemVzLnB1c2gocGFyc2VJbnQobWF0Y2hbMl0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGVyY2VudFNpemVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc21hbGxlc3RSYXRpbyA9IE1hdGgubWluKC4uLnBlcmNlbnRTaXplcykgKiAwLjAxO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aHM6IGFsbFNpemVzLmZpbHRlcigocyk9PnMgPj0gZGV2aWNlU2l6ZXNbMF0gKiBzbWFsbGVzdFJhdGlvKSxcbiAgICAgICAgICAgICAgICBraW5kOiBcIndcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGhzOiBhbGxTaXplcyxcbiAgICAgICAgICAgIGtpbmQ6IFwid1wiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2lkdGggIT09IFwibnVtYmVyXCIgfHwgbGF5b3V0ID09PSBcImZpbGxcIiB8fCBsYXlvdXQgPT09IFwicmVzcG9uc2l2ZVwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aHM6IGRldmljZVNpemVzLFxuICAgICAgICAgICAga2luZDogXCJ3XCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGhzID0gW1xuICAgICAgICAuLi5uZXcgU2V0KC8vID4gVGhpcyBtZWFucyB0aGF0IG1vc3QgT0xFRCBzY3JlZW5zIHRoYXQgc2F5IHRoZXkgYXJlIDN4IHJlc29sdXRpb24sXG4gICAgICAgIC8vID4gYXJlIGFjdHVhbGx5IDN4IGluIHRoZSBncmVlbiBjb2xvciwgYnV0IG9ubHkgMS41eCBpbiB0aGUgcmVkIGFuZFxuICAgICAgICAvLyA+IGJsdWUgY29sb3JzLiBTaG93aW5nIGEgM3ggcmVzb2x1dGlvbiBpbWFnZSBpbiB0aGUgYXBwIHZzIGEgMnhcbiAgICAgICAgLy8gPiByZXNvbHV0aW9uIGltYWdlIHdpbGwgYmUgdmlzdWFsbHkgdGhlIHNhbWUsIHRob3VnaCB0aGUgM3ggaW1hZ2VcbiAgICAgICAgLy8gPiB0YWtlcyBzaWduaWZpY2FudGx5IG1vcmUgZGF0YS4gRXZlbiB0cnVlIDN4IHJlc29sdXRpb24gc2NyZWVucyBhcmVcbiAgICAgICAgLy8gPiB3YXN0ZWZ1bCBhcyB0aGUgaHVtYW4gZXllIGNhbm5vdCBzZWUgdGhhdCBsZXZlbCBvZiBkZXRhaWwgd2l0aG91dFxuICAgICAgICAvLyA+IHNvbWV0aGluZyBsaWtlIGEgbWFnbmlmeWluZyBnbGFzcy5cbiAgICAgICAgLy8gaHR0cHM6Ly9ibG9nLnR3aXR0ZXIuY29tL2VuZ2luZWVyaW5nL2VuX3VzL3RvcGljcy9pbmZyYXN0cnVjdHVyZS8yMDE5L2NhcHBpbmctaW1hZ2UtZmlkZWxpdHktb24tdWx0cmEtaGlnaC1yZXNvbHV0aW9uLWRldmljZXMuaHRtbFxuICAgICAgICBbXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIHdpZHRoICogMiAvKiwgd2lkdGggKiAzKi8gXG4gICAgICAgIF0ubWFwKCh3KT0+YWxsU2l6ZXMuZmluZCgocCk9PnAgPj0gdykgfHwgYWxsU2l6ZXNbYWxsU2l6ZXMubGVuZ3RoIC0gMV0pKVxuICAgIF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGhzLFxuICAgICAgICBraW5kOiBcInhcIlxuICAgIH07XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltZ0F0dHJzKHBhcmFtKSB7XG4gICAgbGV0IHsgY29uZmlnLCBzcmMsIHVub3B0aW1pemVkLCBsYXlvdXQsIHdpZHRoLCBxdWFsaXR5LCBzaXplcywgbG9hZGVyIH0gPSBwYXJhbTtcbiAgICBpZiAodW5vcHRpbWl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgIHNyY1NldDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2l6ZXM6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB7IHdpZHRocywga2luZCB9ID0gZ2V0V2lkdGhzKGNvbmZpZywgd2lkdGgsIGxheW91dCwgc2l6ZXMpO1xuICAgIGNvbnN0IGxhc3QgPSB3aWR0aHMubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaXplczogIXNpemVzICYmIGtpbmQgPT09IFwid1wiID8gXCIxMDB2d1wiIDogc2l6ZXMsXG4gICAgICAgIHNyY1NldDogd2lkdGhzLm1hcCgodywgaSk9PmxvYWRlcih7XG4gICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICBxdWFsaXR5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3XG4gICAgICAgICAgICB9KSArIFwiIFwiICsgKGtpbmQgPT09IFwid1wiID8gdyA6IGkgKyAxKSArIGtpbmQpLmpvaW4oXCIsIFwiKSxcbiAgICAgICAgLy8gSXQncyBpbnRlbmRlZCB0byBrZWVwIGBzcmNgIHRoZSBsYXN0IGF0dHJpYnV0ZSBiZWNhdXNlIFJlYWN0IHVwZGF0ZXNcbiAgICAgICAgLy8gYXR0cmlidXRlcyBpbiBvcmRlci4gSWYgd2Uga2VlcCBgc3JjYCB0aGUgZmlyc3Qgb25lLCBTYWZhcmkgd2lsbFxuICAgICAgICAvLyBpbW1lZGlhdGVseSBzdGFydCB0byBmZXRjaCBgc3JjYCwgYmVmb3JlIGBzaXplc2AgYW5kIGBzcmNTZXRgIGFyZSBldmVuXG4gICAgICAgIC8vIHVwZGF0ZWQgYnkgUmVhY3QuIFRoYXQgY2F1c2VzIG11bHRpcGxlIHVubmVjZXNzYXJ5IHJlcXVlc3RzIGlmIGBzcmNTZXRgXG4gICAgICAgIC8vIGFuZCBgc2l6ZXNgIGFyZSBkZWZpbmVkLlxuICAgICAgICAvLyBUaGlzIGJ1ZyBjYW5ub3QgYmUgcmVwcm9kdWNlZCBpbiBDaHJvbWUgb3IgRmlyZWZveC5cbiAgICAgICAgc3JjOiBsb2FkZXIoe1xuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgcXVhbGl0eSxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aHNbbGFzdF1cbiAgICAgICAgfSlcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0SW50KHgpIHtcbiAgICBpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoeCwgMTApO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZGVmYXVsdEltYWdlTG9hZGVyKGxvYWRlclByb3BzKSB7XG4gICAgdmFyIF9sb2FkZXJQcm9wc19jb25maWc7XG4gICAgY29uc3QgbG9hZGVyS2V5ID0gKChfbG9hZGVyUHJvcHNfY29uZmlnID0gbG9hZGVyUHJvcHMuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX2xvYWRlclByb3BzX2NvbmZpZy5sb2FkZXIpIHx8IFwiZGVmYXVsdFwiO1xuICAgIGNvbnN0IGxvYWQgPSBsb2FkZXJzLmdldChsb2FkZXJLZXkpO1xuICAgIGlmIChsb2FkKSB7XG4gICAgICAgIHJldHVybiBsb2FkKGxvYWRlclByb3BzKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIFwibG9hZGVyXCIgZm91bmQgaW4gXCJuZXh0LmNvbmZpZy5qc1wiLiBFeHBlY3RlZDogJyArIF9pbWFnZWNvbmZpZy5WQUxJRF9MT0FERVJTLmpvaW4oXCIsIFwiKSArIFwiLiBSZWNlaXZlZDogXCIgKyBsb2FkZXJLZXkpO1xufVxuLy8gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8zOTc3NzgzMy8yNjY1MzUgZm9yIHdoeSB3ZSB1c2UgdGhpcyByZWZcbi8vIGhhbmRsZXIgaW5zdGVhZCBvZiB0aGUgaW1nJ3Mgb25Mb2FkIGF0dHJpYnV0ZS5cbmZ1bmN0aW9uIGhhbmRsZUxvYWRpbmcoaW1nLCBzcmMsIGxheW91dCwgcGxhY2Vob2xkZXIsIG9uTG9hZGluZ0NvbXBsZXRlUmVmLCBzZXRCbHVyQ29tcGxldGUpIHtcbiAgICBpZiAoIWltZyB8fCBpbWcuc3JjID09PSBlbXB0eURhdGFVUkwgfHwgaW1nW1wiZGF0YS1sb2FkZWQtc3JjXCJdID09PSBzcmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbWdbXCJkYXRhLWxvYWRlZC1zcmNcIl0gPSBzcmM7XG4gICAgY29uc3QgcCA9IFwiZGVjb2RlXCIgaW4gaW1nID8gaW1nLmRlY29kZSgpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgcC5jYXRjaCgoKT0+e30pLnRoZW4oKCk9PntcbiAgICAgICAgaWYgKCFpbWcucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBpbiBjYXNlIG9mIHJhY2UgY29uZGl0aW9uOlxuICAgICAgICAgICAgLy8gLSBvbmxvYWQoKSBpcyBjYWxsZWRcbiAgICAgICAgICAgIC8vIC0gZGVjb2RlKCkgaXMgY2FsbGVkIGJ1dCBpbmNvbXBsZXRlXG4gICAgICAgICAgICAvLyAtIHVubW91bnQgaXMgY2FsbGVkXG4gICAgICAgICAgICAvLyAtIGRlY29kZSgpIGNvbXBsZXRlc1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvYWRlZEltYWdlVVJMcy5hZGQoc3JjKTtcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyID09PSBcImJsdXJcIikge1xuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkxvYWRpbmdDb21wbGV0ZVJlZiA9PSBudWxsID8gdm9pZCAwIDogb25Mb2FkaW5nQ29tcGxldGVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY29uc3QgeyBuYXR1cmFsV2lkdGgsIG5hdHVyYWxIZWlnaHQgfSA9IGltZztcbiAgICAgICAgICAgIC8vIFBhc3MgYmFjayByZWFkLW9ubHkgcHJpbWl0aXZlIHZhbHVlcyBidXQgbm90IHRoZVxuICAgICAgICAgICAgLy8gdW5kZXJseWluZyBET00gZWxlbWVudCBiZWNhdXNlIGl0IGNvdWxkIGJlIG1pc3VzZWQuXG4gICAgICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50KHtcbiAgICAgICAgICAgICAgICBuYXR1cmFsV2lkdGgsXG4gICAgICAgICAgICAgICAgbmF0dXJhbEhlaWdodFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIF9pbWdfcGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIGlmICgoX2ltZ19wYXJlbnRFbGVtZW50ID0gaW1nLnBhcmVudEVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfaW1nX3BhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGdldENvbXB1dGVkU3R5bGUoaW1nLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnQucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcGFyZW50IGhhcyBub3QgYmVlbiByZW5kZXJlZCB0byB0aGUgZG9tIHlldCBhbmQgdGhlcmVmb3JlIGl0IGhhcyBubyBwb3NpdGlvbi4gU2tpcCB0aGUgd2FybmluZ3MgZm9yIHN1Y2ggY2FzZXMuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYXlvdXQgPT09IFwicmVzcG9uc2l2ZVwiICYmIHBhcmVudC5kaXNwbGF5ID09PSBcImZsZXhcIikge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3dhcm5vbmNlLndhcm5PbmNlKSgnSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIG1heSBub3QgcmVuZGVyIHByb3Blcmx5IGFzIGEgY2hpbGQgb2YgYSBmbGV4IGNvbnRhaW5lci4gQ29uc2lkZXIgd3JhcHBpbmcgdGhlIGltYWdlIHdpdGggYSBkaXYgdG8gY29uZmlndXJlIHRoZSB3aWR0aC4nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxheW91dCA9PT0gXCJmaWxsXCIgJiYgcGFyZW50LnBvc2l0aW9uICE9PSBcInJlbGF0aXZlXCIgJiYgcGFyZW50LnBvc2l0aW9uICE9PSBcImZpeGVkXCIgJiYgcGFyZW50LnBvc2l0aW9uICE9PSBcImFic29sdXRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBtYXkgbm90IHJlbmRlciBwcm9wZXJseSB3aXRoIGEgcGFyZW50IHVzaW5nIHBvc2l0aW9uOlwiJyArIHBhcmVudC5wb3NpdGlvbiArICdcIi4gQ29uc2lkZXIgY2hhbmdpbmcgdGhlIHBhcmVudCBzdHlsZSB0byBwb3NpdGlvbjpcInJlbGF0aXZlXCIgd2l0aCBhIHdpZHRoIGFuZCBoZWlnaHQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5jb25zdCBJbWFnZUVsZW1lbnQgPSAocGFyYW0pPT57XG4gICAgbGV0IHsgaW1nQXR0cmlidXRlcywgaGVpZ2h0SW50LCB3aWR0aEludCwgcXVhbGl0eUludCwgbGF5b3V0LCBjbGFzc05hbWUsIGltZ1N0eWxlLCBibHVyU3R5bGUsIGlzTGF6eSwgcGxhY2Vob2xkZXIsIGxvYWRpbmcsIHNyY1N0cmluZywgY29uZmlnLCB1bm9wdGltaXplZCwgbG9hZGVyLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgc2V0Qmx1ckNvbXBsZXRlLCBzZXRJbnRlcnNlY3Rpb24sIG9uTG9hZCwgb25FcnJvciwgaXNWaXNpYmxlLCBub3NjcmlwdFNpemVzLCAuLi5yZXN0IH0gPSBwYXJhbTtcbiAgICBsb2FkaW5nID0gaXNMYXp5ID8gXCJsYXp5XCIgOiBsb2FkaW5nO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLCB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIC4uLmltZ0F0dHJpYnV0ZXMsXG4gICAgICAgIGRlY29kaW5nOiBcImFzeW5jXCIsXG4gICAgICAgIFwiZGF0YS1uaW1nXCI6IGxheW91dCxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAuLi5pbWdTdHlsZSxcbiAgICAgICAgICAgIC4uLmJsdXJTdHlsZVxuICAgICAgICB9LFxuICAgICAgICByZWY6ICgwLCBfcmVhY3QudXNlQ2FsbGJhY2spKChpbWcpPT57XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGltZyAmJiAhc3JjU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ltYWdlIGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJzcmNcIiBwcm9wZXJ0eTonLCBpbWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEludGVyc2VjdGlvbihpbWcpO1xuICAgICAgICAgICAgaWYgKGltZyA9PSBudWxsID8gdm9pZCAwIDogaW1nLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlTG9hZGluZyhpbWcsIHNyY1N0cmluZywgbGF5b3V0LCBwbGFjZWhvbGRlciwgb25Mb2FkaW5nQ29tcGxldGVSZWYsIHNldEJsdXJDb21wbGV0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtcbiAgICAgICAgICAgIHNldEludGVyc2VjdGlvbixcbiAgICAgICAgICAgIHNyY1N0cmluZyxcbiAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGVcbiAgICAgICAgXSksXG4gICAgICAgIG9uTG9hZDogKGV2ZW50KT0+e1xuICAgICAgICAgICAgY29uc3QgaW1nID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgIGhhbmRsZUxvYWRpbmcoaW1nLCBzcmNTdHJpbmcsIGxheW91dCwgcGxhY2Vob2xkZXIsIG9uTG9hZGluZ0NvbXBsZXRlUmVmLCBzZXRCbHVyQ29tcGxldGUpO1xuICAgICAgICAgICAgaWYgKG9uTG9hZCkge1xuICAgICAgICAgICAgICAgIG9uTG9hZChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChldmVudCk9PntcbiAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlciA9PT0gXCJibHVyXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVhbCBpbWFnZSBmYWlscyB0byBsb2FkLCB0aGlzIHdpbGwgc3RpbGwgcmVtb3ZlIHRoZSBwbGFjZWhvbGRlci5cbiAgICAgICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSksIChpc0xhenkgfHwgcGxhY2Vob2xkZXIgPT09IFwiYmx1clwiKSAmJiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJub3NjcmlwdFwiLCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiwge1xuICAgICAgICAuLi5yZXN0LFxuICAgICAgICAvLyBAdHMtaWdub3JlIC0gVE9ETzogdXBncmFkZSB0byBgQHR5cGVzL3JlYWN0QDE3YFxuICAgICAgICBsb2FkaW5nOiBsb2FkaW5nLFxuICAgICAgICBkZWNvZGluZzogXCJhc3luY1wiLFxuICAgICAgICBcImRhdGEtbmltZ1wiOiBsYXlvdXQsXG4gICAgICAgIHN0eWxlOiBpbWdTdHlsZSxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIC4uLmdlbmVyYXRlSW1nQXR0cnMoe1xuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgc3JjOiBzcmNTdHJpbmcsXG4gICAgICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aEludCxcbiAgICAgICAgICAgIHF1YWxpdHk6IHF1YWxpdHlJbnQsXG4gICAgICAgICAgICBzaXplczogbm9zY3JpcHRTaXplcyxcbiAgICAgICAgICAgIGxvYWRlclxuICAgICAgICB9KVxuICAgIH0pKSk7XG59O1xuZnVuY3Rpb24gSW1hZ2UocGFyYW0pIHtcbiAgICBsZXQgeyBzcmMsIHNpemVzLCB1bm9wdGltaXplZCA9IGZhbHNlLCBwcmlvcml0eSA9IGZhbHNlLCBsb2FkaW5nLCBsYXp5Um9vdCA9IG51bGwsIGxhenlCb3VuZGFyeSwgY2xhc3NOYW1lLCBxdWFsaXR5LCB3aWR0aCwgaGVpZ2h0LCBzdHlsZSwgb2JqZWN0Rml0LCBvYmplY3RQb3NpdGlvbiwgb25Mb2FkaW5nQ29tcGxldGUsIHBsYWNlaG9sZGVyID0gXCJlbXB0eVwiLCBibHVyRGF0YVVSTCwgLi4uYWxsIH0gPSBwYXJhbTtcbiAgICBjb25zdCBjb25maWdDb250ZXh0ID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShfaW1hZ2Vjb25maWdjb250ZXh0c2hhcmVkcnVudGltZS5JbWFnZUNvbmZpZ0NvbnRleHQpO1xuICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBfcmVhY3QudXNlTWVtbykoKCk9PntcbiAgICAgICAgY29uc3QgYyA9IGNvbmZpZ0VudiB8fCBjb25maWdDb250ZXh0IHx8IF9pbWFnZWNvbmZpZy5pbWFnZUNvbmZpZ0RlZmF1bHQ7XG4gICAgICAgIGNvbnN0IGFsbFNpemVzID0gW1xuICAgICAgICAgICAgLi4uYy5kZXZpY2VTaXplcyxcbiAgICAgICAgICAgIC4uLmMuaW1hZ2VTaXplc1xuICAgICAgICBdLnNvcnQoKGEsIGIpPT5hIC0gYik7XG4gICAgICAgIGNvbnN0IGRldmljZVNpemVzID0gYy5kZXZpY2VTaXplcy5zb3J0KChhLCBiKT0+YSAtIGIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uYyxcbiAgICAgICAgICAgIGFsbFNpemVzLFxuICAgICAgICAgICAgZGV2aWNlU2l6ZXNcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGNvbmZpZ0NvbnRleHRcbiAgICBdKTtcbiAgICBsZXQgcmVzdCA9IGFsbDtcbiAgICBsZXQgbGF5b3V0ID0gc2l6ZXMgPyBcInJlc3BvbnNpdmVcIiA6IFwiaW50cmluc2ljXCI7XG4gICAgaWYgKFwibGF5b3V0XCIgaW4gcmVzdCkge1xuICAgICAgICAvLyBPdmVycmlkZSBkZWZhdWx0IGxheW91dCBpZiB0aGUgdXNlciBzcGVjaWZpZWQgb25lOlxuICAgICAgICBpZiAocmVzdC5sYXlvdXQpIGxheW91dCA9IHJlc3QubGF5b3V0O1xuICAgICAgICAvLyBSZW1vdmUgcHJvcGVydHkgc28gaXQncyBub3Qgc3ByZWFkIG9uIDxpbWc+OlxuICAgICAgICBkZWxldGUgcmVzdC5sYXlvdXQ7XG4gICAgfVxuICAgIGxldCBsb2FkZXIgPSBkZWZhdWx0SW1hZ2VMb2FkZXI7XG4gICAgaWYgKFwibG9hZGVyXCIgaW4gcmVzdCkge1xuICAgICAgICBpZiAocmVzdC5sb2FkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbUltYWdlTG9hZGVyID0gcmVzdC5sb2FkZXI7XG4gICAgICAgICAgICBsb2FkZXIgPSAob2JqKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29uZmlnOiBfLCAuLi5vcHRzIH0gPSBvYmo7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvbmZpZyBvYmplY3QgaXMgaW50ZXJuYWwgb25seSBzbyB3ZSBtdXN0XG4gICAgICAgICAgICAgICAgLy8gbm90IHBhc3MgaXQgdG8gdGhlIHVzZXItZGVmaW5lZCBsb2FkZXIoKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXN0b21JbWFnZUxvYWRlcihvcHRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHByb3BlcnR5IHNvIGl0J3Mgbm90IHNwcmVhZCBvbiA8aW1nPlxuICAgICAgICBkZWxldGUgcmVzdC5sb2FkZXI7XG4gICAgfVxuICAgIGxldCBzdGF0aWNTcmMgPSBcIlwiO1xuICAgIGlmIChpc1N0YXRpY0ltcG9ydChzcmMpKSB7XG4gICAgICAgIGNvbnN0IHN0YXRpY0ltYWdlRGF0YSA9IGlzU3RhdGljUmVxdWlyZShzcmMpID8gc3JjLmRlZmF1bHQgOiBzcmM7XG4gICAgICAgIGlmICghc3RhdGljSW1hZ2VEYXRhLnNyYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW4gb2JqZWN0IHNob3VsZCBvbmx5IGJlIHBhc3NlZCB0byB0aGUgaW1hZ2UgY29tcG9uZW50IHNyYyBwYXJhbWV0ZXIgaWYgaXQgY29tZXMgZnJvbSBhIHN0YXRpYyBpbWFnZSBpbXBvcnQuIEl0IG11c3QgaW5jbHVkZSBzcmMuIFJlY2VpdmVkIFwiICsgSlNPTi5zdHJpbmdpZnkoc3RhdGljSW1hZ2VEYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgYmx1ckRhdGFVUkwgPSBibHVyRGF0YVVSTCB8fCBzdGF0aWNJbWFnZURhdGEuYmx1ckRhdGFVUkw7XG4gICAgICAgIHN0YXRpY1NyYyA9IHN0YXRpY0ltYWdlRGF0YS5zcmM7XG4gICAgICAgIGlmICghbGF5b3V0IHx8IGxheW91dCAhPT0gXCJmaWxsXCIpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCB8fCBzdGF0aWNJbWFnZURhdGEuaGVpZ2h0O1xuICAgICAgICAgICAgd2lkdGggPSB3aWR0aCB8fCBzdGF0aWNJbWFnZURhdGEud2lkdGg7XG4gICAgICAgICAgICBpZiAoIXN0YXRpY0ltYWdlRGF0YS5oZWlnaHQgfHwgIXN0YXRpY0ltYWdlRGF0YS53aWR0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuIG9iamVjdCBzaG91bGQgb25seSBiZSBwYXNzZWQgdG8gdGhlIGltYWdlIGNvbXBvbmVudCBzcmMgcGFyYW1ldGVyIGlmIGl0IGNvbWVzIGZyb20gYSBzdGF0aWMgaW1hZ2UgaW1wb3J0LiBJdCBtdXN0IGluY2x1ZGUgaGVpZ2h0IGFuZCB3aWR0aC4gUmVjZWl2ZWQgXCIgKyBKU09OLnN0cmluZ2lmeShzdGF0aWNJbWFnZURhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzcmMgPSB0eXBlb2Ygc3JjID09PSBcInN0cmluZ1wiID8gc3JjIDogc3RhdGljU3JjO1xuICAgIGxldCBpc0xhenkgPSAhcHJpb3JpdHkgJiYgKGxvYWRpbmcgPT09IFwibGF6eVwiIHx8IHR5cGVvZiBsb2FkaW5nID09PSBcInVuZGVmaW5lZFwiKTtcbiAgICBpZiAoc3JjLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSB8fCBzcmMuc3RhcnRzV2l0aChcImJsb2I6XCIpKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0hUVFAvQmFzaWNzX29mX0hUVFAvRGF0YV9VUklzXG4gICAgICAgIHVub3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgaXNMYXp5ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIGxvYWRlZEltYWdlVVJMcy5oYXMoc3JjKSkge1xuICAgICAgICBpc0xhenkgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy51bm9wdGltaXplZCkge1xuICAgICAgICB1bm9wdGltaXplZCA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IFtibHVyQ29tcGxldGUsIHNldEJsdXJDb21wbGV0ZV0gPSAoMCwgX3JlYWN0LnVzZVN0YXRlKShmYWxzZSk7XG4gICAgY29uc3QgW3NldEludGVyc2VjdGlvbiwgaXNJbnRlcnNlY3RlZCwgcmVzZXRJbnRlcnNlY3RlZF0gPSAoMCwgX3VzZWludGVyc2VjdGlvbi51c2VJbnRlcnNlY3Rpb24pKHtcbiAgICAgICAgcm9vdFJlZjogbGF6eVJvb3QsXG4gICAgICAgIHJvb3RNYXJnaW46IGxhenlCb3VuZGFyeSB8fCBcIjIwMHB4XCIsXG4gICAgICAgIGRpc2FibGVkOiAhaXNMYXp5XG4gICAgfSk7XG4gICAgY29uc3QgaXNWaXNpYmxlID0gIWlzTGF6eSB8fCBpc0ludGVyc2VjdGVkO1xuICAgIGNvbnN0IHdyYXBwZXJTdHlsZSA9IHtcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgd2lkdGg6IFwiaW5pdGlhbFwiLFxuICAgICAgICBoZWlnaHQ6IFwiaW5pdGlhbFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIm5vbmVcIixcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIHBhZGRpbmc6IDBcbiAgICB9O1xuICAgIGNvbnN0IHNpemVyU3R5bGUgPSB7XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgd2lkdGg6IFwiaW5pdGlhbFwiLFxuICAgICAgICBoZWlnaHQ6IFwiaW5pdGlhbFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIm5vbmVcIixcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIHBhZGRpbmc6IDBcbiAgICB9O1xuICAgIGxldCBoYXNTaXplciA9IGZhbHNlO1xuICAgIGxldCBzaXplclN2Z1VybDtcbiAgICBjb25zdCBsYXlvdXRTdHlsZSA9IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICBtYXJnaW46IFwiYXV0b1wiLFxuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIG1pbldpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgbWF4V2lkdGg6IFwiMTAwJVwiLFxuICAgICAgICBtaW5IZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBtYXhIZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBvYmplY3RGaXQsXG4gICAgICAgIG9iamVjdFBvc2l0aW9uXG4gICAgfTtcbiAgICBsZXQgd2lkdGhJbnQgPSBnZXRJbnQod2lkdGgpO1xuICAgIGxldCBoZWlnaHRJbnQgPSBnZXRJbnQoaGVpZ2h0KTtcbiAgICBjb25zdCBxdWFsaXR5SW50ID0gZ2V0SW50KHF1YWxpdHkpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKCFzcmMpIHtcbiAgICAgICAgICAgIC8vIFJlYWN0IGRvZXNuJ3Qgc2hvdyB0aGUgc3RhY2sgdHJhY2UgYW5kIHRoZXJlJ3NcbiAgICAgICAgICAgIC8vIG5vIGBzcmNgIHRvIGhlbHAgaWRlbnRpZnkgd2hpY2ggaW1hZ2UsIHNvIHdlXG4gICAgICAgICAgICAvLyBpbnN0ZWFkIGNvbnNvbGUuZXJyb3IocmVmKSBkdXJpbmcgbW91bnQuXG4gICAgICAgICAgICB3aWR0aEludCA9IHdpZHRoSW50IHx8IDE7XG4gICAgICAgICAgICBoZWlnaHRJbnQgPSBoZWlnaHRJbnQgfHwgMTtcbiAgICAgICAgICAgIHVub3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghVkFMSURfTEFZT1VUX1ZBTFVFUy5pbmNsdWRlcyhsYXlvdXQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIGludmFsaWQgXCJsYXlvdXRcIiBwcm9wZXJ0eS4gUHJvdmlkZWQgXCInICsgbGF5b3V0ICsgJ1wiIHNob3VsZCBiZSBvbmUgb2YgJyArIFZBTElEX0xBWU9VVF9WQUxVRVMubWFwKFN0cmluZykuam9pbihcIixcIikgKyBcIi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpZHRoSW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGlzTmFOKHdpZHRoSW50KSB8fCB0eXBlb2YgaGVpZ2h0SW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGlzTmFOKGhlaWdodEludCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgaW52YWxpZCBcIndpZHRoXCIgb3IgXCJoZWlnaHRcIiBwcm9wZXJ0eS4gVGhlc2Ugc2hvdWxkIGJlIG51bWVyaWMgdmFsdWVzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxheW91dCA9PT0gXCJmaWxsXCIgJiYgKHdpZHRoIHx8IGhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3dhcm5vbmNlLndhcm5PbmNlKSgnSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGFuZCBcImxheW91dD1cXCdmaWxsXFwnXCIgaGFzIHVudXNlZCBwcm9wZXJ0aWVzIGFzc2lnbmVkLiBQbGVhc2UgcmVtb3ZlIFwid2lkdGhcIiBhbmQgXCJoZWlnaHRcIi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghVkFMSURfTE9BRElOR19WQUxVRVMuaW5jbHVkZXMobG9hZGluZykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgaW52YWxpZCBcImxvYWRpbmdcIiBwcm9wZXJ0eS4gUHJvdmlkZWQgXCInICsgbG9hZGluZyArICdcIiBzaG91bGQgYmUgb25lIG9mICcgKyBWQUxJRF9MT0FESU5HX1ZBTFVFUy5tYXAoU3RyaW5nKS5qb2luKFwiLFwiKSArIFwiLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmlvcml0eSAmJiBsb2FkaW5nID09PSBcImxhenlcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBib3RoIFwicHJpb3JpdHlcIiBhbmQgXCJsb2FkaW5nPVxcJ2xhenlcXCdcIiBwcm9wZXJ0aWVzLiBPbmx5IG9uZSBzaG91bGQgYmUgdXNlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaXplcyAmJiBsYXlvdXQgIT09IFwiZmlsbFwiICYmIGxheW91dCAhPT0gXCJyZXNwb25zaXZlXCIpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3dhcm5vbmNlLndhcm5PbmNlKSgnSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBcInNpemVzXCIgcHJvcGVydHkgYnV0IGl0IHdpbGwgYmUgaWdub3JlZC4gT25seSB1c2UgXCJzaXplc1wiIHdpdGggXCJsYXlvdXQ9XFwnZmlsbFxcJ1wiIG9yIFwibGF5b3V0PVxcJ3Jlc3BvbnNpdmVcXCdcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyID09PSBcImJsdXJcIikge1xuICAgICAgICAgICAgICAgIGlmIChsYXlvdXQgIT09IFwiZmlsbFwiICYmICh3aWR0aEludCB8fCAwKSAqIChoZWlnaHRJbnQgfHwgMCkgPCAxNjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaXMgc21hbGxlciB0aGFuIDQweDQwLiBDb25zaWRlciByZW1vdmluZyB0aGUgXCJwbGFjZWhvbGRlcj1cXCdibHVyXFwnXCIgcHJvcGVydHkgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFibHVyRGF0YVVSTCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBWQUxJRF9CTFVSX0VYVCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwianBlZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJwbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2VicFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhdmlmXCJcbiAgICAgICAgICAgICAgICAgICAgXSAvLyBzaG91bGQgbWF0Y2ggbmV4dC1pbWFnZS1sb2FkZXJcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgXCJwbGFjZWhvbGRlcj1cXCdibHVyXFwnXCIgcHJvcGVydHkgYnV0IGlzIG1pc3NpbmcgdGhlIFwiYmx1ckRhdGFVUkxcIiBwcm9wZXJ0eS5cXG4gICAgICAgICAgUG9zc2libGUgc29sdXRpb25zOlxcbiAgICAgICAgICAgIC0gQWRkIGEgXCJibHVyRGF0YVVSTFwiIHByb3BlcnR5LCB0aGUgY29udGVudHMgc2hvdWxkIGJlIGEgc21hbGwgRGF0YSBVUkwgdG8gcmVwcmVzZW50IHRoZSBpbWFnZVxcbiAgICAgICAgICAgIC0gQ2hhbmdlIHRoZSBcInNyY1wiIHByb3BlcnR5IHRvIGEgc3RhdGljIGltcG9ydCB3aXRoIG9uZSBvZiB0aGUgc3VwcG9ydGVkIGZpbGUgdHlwZXM6ICcgKyBWQUxJRF9CTFVSX0VYVC5qb2luKFwiLFwiKSArICcgKGFuaW1hdGVkIGltYWdlcyBub3Qgc3VwcG9ydGVkKVxcbiAgICAgICAgICAgIC0gUmVtb3ZlIHRoZSBcInBsYWNlaG9sZGVyXCIgcHJvcGVydHksIGVmZmVjdGl2ZWx5IG5vIGJsdXIgZWZmZWN0XFxuICAgICAgICAgIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcGxhY2Vob2xkZXItYmx1ci1kYXRhLXVybCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcInJlZlwiIGluIHJlc3QpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3dhcm5vbmNlLndhcm5PbmNlKSgnSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGlzIHVzaW5nIHVuc3VwcG9ydGVkIFwicmVmXCIgcHJvcGVydHkuIENvbnNpZGVyIHVzaW5nIHRoZSBcIm9uTG9hZGluZ0NvbXBsZXRlXCIgcHJvcGVydHkgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdW5vcHRpbWl6ZWQgJiYgbG9hZGVyICE9PSBkZWZhdWx0SW1hZ2VMb2FkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmxTdHIgPSBsb2FkZXIoe1xuICAgICAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoSW50IHx8IDQwMCxcbiAgICAgICAgICAgICAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCB8fCA3NVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxldCB1cmw7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gbmV3IFVSTCh1cmxTdHIpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICBpZiAodXJsU3RyID09PSBzcmMgfHwgdXJsICYmIHVybC5wYXRobmFtZSA9PT0gc3JjICYmICF1cmwuc2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIGEgXCJsb2FkZXJcIiBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IGltcGxlbWVudCB3aWR0aC4gUGxlYXNlIGltcGxlbWVudCBpdCBvciB1c2UgdGhlIFwidW5vcHRpbWl6ZWRcIiBwcm9wZXJ0eSBpbnN0ZWFkLicgKyBcIlxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1pbWFnZS1taXNzaW5nLWxvYWRlci13aWR0aFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgb3ZlcndyaXR0ZW5TdHlsZXMgPSBPYmplY3Qua2V5cyhzdHlsZSkuZmlsdGVyKChrZXkpPT5rZXkgaW4gbGF5b3V0U3R5bGUpO1xuICAgICAgICAgICAgICAgIGlmIChvdmVyd3JpdHRlblN0eWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoXCJJbWFnZSB3aXRoIHNyYyBcIiArIHNyYyArIFwiIGlzIGFzc2lnbmVkIHRoZSBmb2xsb3dpbmcgc3R5bGVzLCB3aGljaCBhcmUgb3ZlcndyaXR0ZW4gYnkgYXV0b21hdGljYWxseS1nZW5lcmF0ZWQgc3R5bGVzOiBcIiArIG92ZXJ3cml0dGVuU3R5bGVzLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgIXBlcmZPYnNlcnZlciAmJiB3aW5kb3cuUGVyZm9ybWFuY2VPYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIHBlcmZPYnNlcnZlciA9IG5ldyBQZXJmb3JtYW5jZU9ic2VydmVyKChlbnRyeUxpc3QpPT57XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cnlMaXN0LmdldEVudHJpZXMoKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2VudHJ5X2VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gbWlzc2luZyBcIkxhcmdlc3RDb250ZW50ZnVsUGFpbnRcIiBjbGFzcyB3aXRoIFwiZWxlbWVudFwiIHByb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltZ1NyYyA9IChlbnRyeSA9PSBudWxsID8gdm9pZCAwIDogKF9lbnRyeV9lbGVtZW50ID0gZW50cnkuZWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbnRyeV9lbGVtZW50LnNyYykgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxjcEltYWdlID0gYWxsSW1ncy5nZXQoaW1nU3JjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsY3BJbWFnZSAmJiAhbGNwSW1hZ2UucHJpb3JpdHkgJiYgbGNwSW1hZ2UucGxhY2Vob2xkZXIgIT09IFwiYmx1clwiICYmICFsY3BJbWFnZS5zcmMuc3RhcnRzV2l0aChcImRhdGE6XCIpICYmICFsY3BJbWFnZS5zcmMuc3RhcnRzV2l0aChcImJsb2I6XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93ZWIuZGV2L2xjcC8jbWVhc3VyZS1sY3AtaW4tamF2YXNjcmlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBsY3BJbWFnZS5zcmMgKyAnXCIgd2FzIGRldGVjdGVkIGFzIHRoZSBMYXJnZXN0IENvbnRlbnRmdWwgUGFpbnQgKExDUCkuIFBsZWFzZSBhZGQgdGhlIFwicHJpb3JpdHlcIiBwcm9wZXJ0eSBpZiB0aGlzIGltYWdlIGlzIGFib3ZlIHRoZSBmb2xkLicgKyBcIlxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2xlZ2FjeS9pbWFnZSNwcmlvcml0eVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHBlcmZPYnNlcnZlci5vYnNlcnZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibGFyZ2VzdC1jb250ZW50ZnVsLXBhaW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJlZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9nIGVycm9yIGJ1dCBkb24ndCBjcmFzaCB0aGUgYXBwXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW1nU3R5bGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdHlsZSwgbGF5b3V0U3R5bGUpO1xuICAgIGNvbnN0IGJsdXJTdHlsZSA9IHBsYWNlaG9sZGVyID09PSBcImJsdXJcIiAmJiAhYmx1ckNvbXBsZXRlID8ge1xuICAgICAgICBiYWNrZ3JvdW5kU2l6ZTogb2JqZWN0Rml0IHx8IFwiY292ZXJcIixcbiAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiBvYmplY3RQb3NpdGlvbiB8fCBcIjAlIDAlXCIsXG4gICAgICAgIGZpbHRlcjogXCJibHVyKDIwcHgpXCIsXG4gICAgICAgIGJhY2tncm91bmRJbWFnZTogJ3VybChcIicgKyBibHVyRGF0YVVSTCArICdcIiknXG4gICAgfSA6IHt9O1xuICAgIGlmIChsYXlvdXQgPT09IFwiZmlsbFwiKSB7XG4gICAgICAgIC8vIDxJbWFnZSBzcmM9XCJpLnBuZ1wiIGxheW91dD1cImZpbGxcIiAvPlxuICAgICAgICB3cmFwcGVyU3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgd3JhcHBlclN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICB3cmFwcGVyU3R5bGUudG9wID0gMDtcbiAgICAgICAgd3JhcHBlclN0eWxlLmxlZnQgPSAwO1xuICAgICAgICB3cmFwcGVyU3R5bGUuYm90dG9tID0gMDtcbiAgICAgICAgd3JhcHBlclN0eWxlLnJpZ2h0ID0gMDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aWR0aEludCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgaGVpZ2h0SW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIDxJbWFnZSBzcmM9XCJpLnBuZ1wiIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgLz5cbiAgICAgICAgY29uc3QgcXVvdGllbnQgPSBoZWlnaHRJbnQgLyB3aWR0aEludDtcbiAgICAgICAgY29uc3QgcGFkZGluZ1RvcCA9IGlzTmFOKHF1b3RpZW50KSA/IFwiMTAwJVwiIDogXCJcIiArIHF1b3RpZW50ICogMTAwICsgXCIlXCI7XG4gICAgICAgIGlmIChsYXlvdXQgPT09IFwicmVzcG9uc2l2ZVwiKSB7XG4gICAgICAgICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIGxheW91dD1cInJlc3BvbnNpdmVcIiAvPlxuICAgICAgICAgICAgd3JhcHBlclN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICAgICAgICBoYXNTaXplciA9IHRydWU7XG4gICAgICAgICAgICBzaXplclN0eWxlLnBhZGRpbmdUb3AgPSBwYWRkaW5nVG9wO1xuICAgICAgICB9IGVsc2UgaWYgKGxheW91dCA9PT0gXCJpbnRyaW5zaWNcIikge1xuICAgICAgICAgICAgLy8gPEltYWdlIHNyYz1cImkucG5nXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiBsYXlvdXQ9XCJpbnRyaW5zaWNcIiAvPlxuICAgICAgICAgICAgd3JhcHBlclN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgICAgICAgICAgd3JhcHBlclN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICAgICAgd3JhcHBlclN0eWxlLm1heFdpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgICAgICBoYXNTaXplciA9IHRydWU7XG4gICAgICAgICAgICBzaXplclN0eWxlLm1heFdpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgICAgICBzaXplclN2Z1VybCA9IFwiZGF0YTppbWFnZS9zdmcreG1sLCUzY3N2ZyUyMHhtbG5zPSUyN2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJTI3JTIwdmVyc2lvbj0lMjcxLjElMjclMjB3aWR0aD0lMjdcIiArIHdpZHRoSW50ICsgXCIlMjclMjBoZWlnaHQ9JTI3XCIgKyBoZWlnaHRJbnQgKyBcIiUyNy8lM2VcIjtcbiAgICAgICAgfSBlbHNlIGlmIChsYXlvdXQgPT09IFwiZml4ZWRcIikge1xuICAgICAgICAgICAgLy8gPEltYWdlIHNyYz1cImkucG5nXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiBsYXlvdXQ9XCJmaXhlZFwiIC8+XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUud2lkdGggPSB3aWR0aEludDtcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5oZWlnaHQgPSBoZWlnaHRJbnQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiAvPlxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBtdXN0IHVzZSBcIndpZHRoXCIgYW5kIFwiaGVpZ2h0XCIgcHJvcGVydGllcyBvciBcImxheW91dD1cXCdmaWxsXFwnXCIgcHJvcGVydHkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGltZ0F0dHJpYnV0ZXMgPSB7XG4gICAgICAgIHNyYzogZW1wdHlEYXRhVVJMLFxuICAgICAgICBzcmNTZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgc2l6ZXM6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgaWYgKGlzVmlzaWJsZSkge1xuICAgICAgICBpbWdBdHRyaWJ1dGVzID0gZ2VuZXJhdGVJbWdBdHRycyh7XG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aEludCxcbiAgICAgICAgICAgIHF1YWxpdHk6IHF1YWxpdHlJbnQsXG4gICAgICAgICAgICBzaXplcyxcbiAgICAgICAgICAgIGxvYWRlclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV0IHNyY1N0cmluZyA9IHNyYztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBsZXQgZnVsbFVybDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZnVsbFVybCA9IG5ldyBVUkwoaW1nQXR0cmlidXRlcy5zcmMpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGZ1bGxVcmwgPSBuZXcgVVJMKGltZ0F0dHJpYnV0ZXMuc3JjLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbGxJbWdzLnNldChmdWxsVXJsLmhyZWYsIHtcbiAgICAgICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICAgICAgcHJpb3JpdHksXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxpbmtQcm9wcyA9IHtcbiAgICAgICAgaW1hZ2VTcmNTZXQ6IGltZ0F0dHJpYnV0ZXMuc3JjU2V0LFxuICAgICAgICBpbWFnZVNpemVzOiBpbWdBdHRyaWJ1dGVzLnNpemVzLFxuICAgICAgICBjcm9zc09yaWdpbjogcmVzdC5jcm9zc09yaWdpbixcbiAgICAgICAgcmVmZXJyZXJQb2xpY3k6IHJlc3QucmVmZXJyZXJQb2xpY3lcbiAgICB9O1xuICAgIGNvbnN0IHVzZUxheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBfcmVhY3QuZGVmYXVsdC51c2VFZmZlY3QgOiBfcmVhY3QuZGVmYXVsdC51c2VMYXlvdXRFZmZlY3Q7XG4gICAgY29uc3Qgb25Mb2FkaW5nQ29tcGxldGVSZWYgPSAoMCwgX3JlYWN0LnVzZVJlZikob25Mb2FkaW5nQ29tcGxldGUpO1xuICAgIGNvbnN0IHByZXZpb3VzSW1hZ2VTcmMgPSAoMCwgX3JlYWN0LnVzZVJlZikoc3JjKTtcbiAgICAoMCwgX3JlYWN0LnVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYuY3VycmVudCA9IG9uTG9hZGluZ0NvbXBsZXRlO1xuICAgIH0sIFtcbiAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVcbiAgICBdKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKHByZXZpb3VzSW1hZ2VTcmMuY3VycmVudCAhPT0gc3JjKSB7XG4gICAgICAgICAgICByZXNldEludGVyc2VjdGVkKCk7XG4gICAgICAgICAgICBwcmV2aW91c0ltYWdlU3JjLmN1cnJlbnQgPSBzcmM7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIHJlc2V0SW50ZXJzZWN0ZWQsXG4gICAgICAgIHNyY1xuICAgIF0pO1xuICAgIGNvbnN0IGltZ0VsZW1lbnRBcmdzID0ge1xuICAgICAgICBpc0xhenksXG4gICAgICAgIGltZ0F0dHJpYnV0ZXMsXG4gICAgICAgIGhlaWdodEludCxcbiAgICAgICAgd2lkdGhJbnQsXG4gICAgICAgIHF1YWxpdHlJbnQsXG4gICAgICAgIGxheW91dCxcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICBpbWdTdHlsZSxcbiAgICAgICAgYmx1clN0eWxlLFxuICAgICAgICBsb2FkaW5nLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHVub3B0aW1pemVkLFxuICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgbG9hZGVyLFxuICAgICAgICBzcmNTdHJpbmcsXG4gICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLFxuICAgICAgICBzZXRCbHVyQ29tcGxldGUsXG4gICAgICAgIHNldEludGVyc2VjdGlvbixcbiAgICAgICAgaXNWaXNpYmxlLFxuICAgICAgICBub3NjcmlwdFNpemVzOiBzaXplcyxcbiAgICAgICAgLi4ucmVzdFxuICAgIH07XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgIHN0eWxlOiB3cmFwcGVyU3R5bGVcbiAgICB9LCBoYXNTaXplciA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICBzdHlsZTogc2l6ZXJTdHlsZVxuICAgIH0sIHNpemVyU3ZnVXJsID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgICAgIG1heFdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgICAgIHdpZHRoOiBcImluaXRpYWxcIixcbiAgICAgICAgICAgIGhlaWdodDogXCJpbml0aWFsXCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBcIm5vbmVcIixcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICBwYWRkaW5nOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGFsdDogXCJcIixcbiAgICAgICAgXCJhcmlhLWhpZGRlblwiOiB0cnVlLFxuICAgICAgICBzcmM6IHNpemVyU3ZnVXJsXG4gICAgfSkgOiBudWxsKSA6IG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChJbWFnZUVsZW1lbnQsIGltZ0VsZW1lbnRBcmdzKSksIHByaW9yaXR5ID8gLy8gTm90ZSBob3cgd2Ugb21pdCB0aGUgYGhyZWZgIGF0dHJpYnV0ZSwgYXMgaXQgd291bGQgb25seSBiZSByZWxldmFudFxuICAgIC8vIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGBpbWFnZXNyY3NldGAsIGFuZCBpbiB0aG9zZSBjYXNlc1xuICAgIC8vIGl0IHdvdWxkIGxpa2VseSBjYXVzZSB0aGUgaW5jb3JyZWN0IGltYWdlIHRvIGJlIHByZWxvYWRlZC5cbiAgICAvL1xuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI2F0dHItbGluay1pbWFnZXNyY3NldFxuICAgIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfaGVhZC5kZWZhdWx0LCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIHtcbiAgICAgICAga2V5OiBcIl9fbmltZy1cIiArIGltZ0F0dHJpYnV0ZXMuc3JjICsgaW1nQXR0cmlidXRlcy5zcmNTZXQgKyBpbWdBdHRyaWJ1dGVzLnNpemVzLFxuICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICBhczogXCJpbWFnZVwiLFxuICAgICAgICBocmVmOiBpbWdBdHRyaWJ1dGVzLnNyY1NldCA/IHVuZGVmaW5lZCA6IGltZ0F0dHJpYnV0ZXMuc3JjLFxuICAgICAgICAuLi5saW5rUHJvcHNcbiAgICB9KSkgOiBudWxsKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIkltYWdlIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfcmVhY3QiLCJfIiwiX2hlYWQiLCJfaW1hZ2Vjb25maWciLCJfdXNlaW50ZXJzZWN0aW9uIiwiX2ltYWdlY29uZmlnY29udGV4dHNoYXJlZHJ1bnRpbWUiLCJfd2Fybm9uY2UiLCJfbm9ybWFsaXpldHJhaWxpbmdzbGFzaCIsIm5vcm1hbGl6ZVNyYyIsInNyYyIsInNsaWNlIiwiY29uZmlnRW52IiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JTUFHRV9PUFRTIiwibG9hZGVkSW1hZ2VVUkxzIiwiU2V0IiwiYWxsSW1ncyIsIk1hcCIsInBlcmZPYnNlcnZlciIsImVtcHR5RGF0YVVSTCIsImdsb2JhbFRoaXMiLCJfX05FWFRfSU1BR0VfSU1QT1JURUQiLCJWQUxJRF9MT0FESU5HX1ZBTFVFUyIsInVuZGVmaW5lZCIsImltZ2l4TG9hZGVyIiwicGFyYW0iLCJjb25maWciLCJ3aWR0aCIsInF1YWxpdHkiLCJ1cmwiLCJVUkwiLCJwYXRoIiwicGFyYW1zIiwic2VhcmNoUGFyYW1zIiwic2V0IiwiZ2V0QWxsIiwiam9pbiIsInRvU3RyaW5nIiwiaHJlZiIsImFrYW1haUxvYWRlciIsImNsb3VkaW5hcnlMb2FkZXIiLCJwYXJhbXNTdHJpbmciLCJjdXN0b21Mb2FkZXIiLCJFcnJvciIsImRlZmF1bHRMb2FkZXIiLCJtaXNzaW5nVmFsdWVzIiwicHVzaCIsImxlbmd0aCIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdGFydHNXaXRoIiwiZG9tYWlucyIsInJlbW90ZVBhdHRlcm5zIiwicGFyc2VkU3JjIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwiTkVYVF9SVU5USU1FIiwiaGFzTWF0Y2giLCJob3N0bmFtZSIsImVuZHNXaXRoIiwiZGFuZ2Vyb3VzbHlBbGxvd1NWRyIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwibG9hZGVycyIsIlZBTElEX0xBWU9VVF9WQUxVRVMiLCJpc1N0YXRpY1JlcXVpcmUiLCJkZWZhdWx0IiwiaXNTdGF0aWNJbWFnZURhdGEiLCJpc1N0YXRpY0ltcG9ydCIsImdldFdpZHRocyIsImxheW91dCIsInNpemVzIiwiZGV2aWNlU2l6ZXMiLCJhbGxTaXplcyIsInZpZXdwb3J0V2lkdGhSZSIsInBlcmNlbnRTaXplcyIsIm1hdGNoIiwiZXhlYyIsInBhcnNlSW50Iiwic21hbGxlc3RSYXRpbyIsIk1hdGgiLCJtaW4iLCJ3aWR0aHMiLCJmaWx0ZXIiLCJzIiwia2luZCIsIm1hcCIsInciLCJmaW5kIiwicCIsImdlbmVyYXRlSW1nQXR0cnMiLCJ1bm9wdGltaXplZCIsImxvYWRlciIsInNyY1NldCIsImxhc3QiLCJpIiwiZ2V0SW50IiwieCIsImRlZmF1bHRJbWFnZUxvYWRlciIsImxvYWRlclByb3BzIiwiX2xvYWRlclByb3BzX2NvbmZpZyIsImxvYWRlcktleSIsImxvYWQiLCJWQUxJRF9MT0FERVJTIiwiaGFuZGxlTG9hZGluZyIsImltZyIsInBsYWNlaG9sZGVyIiwib25Mb2FkaW5nQ29tcGxldGVSZWYiLCJzZXRCbHVyQ29tcGxldGUiLCJkZWNvZGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNhdGNoIiwidGhlbiIsInBhcmVudE5vZGUiLCJhZGQiLCJjdXJyZW50IiwibmF0dXJhbFdpZHRoIiwibmF0dXJhbEhlaWdodCIsIl9pbWdfcGFyZW50RWxlbWVudCIsInBhcmVudEVsZW1lbnQiLCJwYXJlbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJkaXNwbGF5Iiwid2Fybk9uY2UiLCJJbWFnZUVsZW1lbnQiLCJpbWdBdHRyaWJ1dGVzIiwiaGVpZ2h0SW50Iiwid2lkdGhJbnQiLCJxdWFsaXR5SW50IiwiY2xhc3NOYW1lIiwiaW1nU3R5bGUiLCJibHVyU3R5bGUiLCJpc0xhenkiLCJsb2FkaW5nIiwic3JjU3RyaW5nIiwic2V0SW50ZXJzZWN0aW9uIiwib25Mb2FkIiwib25FcnJvciIsImlzVmlzaWJsZSIsIm5vc2NyaXB0U2l6ZXMiLCJyZXN0IiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwiZGVjb2RpbmciLCJzdHlsZSIsInJlZiIsInVzZUNhbGxiYWNrIiwiY29tcGxldGUiLCJldmVudCIsImN1cnJlbnRUYXJnZXQiLCJwcmlvcml0eSIsImxhenlSb290IiwibGF6eUJvdW5kYXJ5IiwiaGVpZ2h0Iiwib2JqZWN0Rml0Iiwib2JqZWN0UG9zaXRpb24iLCJvbkxvYWRpbmdDb21wbGV0ZSIsImJsdXJEYXRhVVJMIiwiYWxsIiwiY29uZmlnQ29udGV4dCIsInVzZUNvbnRleHQiLCJJbWFnZUNvbmZpZ0NvbnRleHQiLCJ1c2VNZW1vIiwiYyIsImltYWdlQ29uZmlnRGVmYXVsdCIsImltYWdlU2l6ZXMiLCJzb3J0IiwiYSIsImIiLCJjdXN0b21JbWFnZUxvYWRlciIsIm9iaiIsIm9wdHMiLCJzdGF0aWNTcmMiLCJzdGF0aWNJbWFnZURhdGEiLCJoYXMiLCJibHVyQ29tcGxldGUiLCJ1c2VTdGF0ZSIsImlzSW50ZXJzZWN0ZWQiLCJyZXNldEludGVyc2VjdGVkIiwidXNlSW50ZXJzZWN0aW9uIiwicm9vdFJlZiIsInJvb3RNYXJnaW4iLCJkaXNhYmxlZCIsIndyYXBwZXJTdHlsZSIsImJveFNpemluZyIsIm92ZXJmbG93IiwiYmFja2dyb3VuZCIsIm9wYWNpdHkiLCJib3JkZXIiLCJtYXJnaW4iLCJwYWRkaW5nIiwic2l6ZXJTdHlsZSIsImhhc1NpemVyIiwic2l6ZXJTdmdVcmwiLCJsYXlvdXRTdHlsZSIsInRvcCIsImxlZnQiLCJib3R0b20iLCJyaWdodCIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJtaW5IZWlnaHQiLCJtYXhIZWlnaHQiLCJpbmNsdWRlcyIsIlN0cmluZyIsImlzTmFOIiwiVkFMSURfQkxVUl9FWFQiLCJ1cmxTdHIiLCJwYXRobmFtZSIsInNlYXJjaCIsIm92ZXJ3cml0dGVuU3R5bGVzIiwia2V5cyIsImtleSIsIndpbmRvdyIsIlBlcmZvcm1hbmNlT2JzZXJ2ZXIiLCJlbnRyeUxpc3QiLCJlbnRyeSIsImdldEVudHJpZXMiLCJfZW50cnlfZWxlbWVudCIsImltZ1NyYyIsImVsZW1lbnQiLCJsY3BJbWFnZSIsIm9ic2VydmUiLCJ0eXBlIiwiYnVmZmVyZWQiLCJhc3NpZ24iLCJiYWNrZ3JvdW5kU2l6ZSIsImJhY2tncm91bmRQb3NpdGlvbiIsImJhY2tncm91bmRJbWFnZSIsInF1b3RpZW50IiwicGFkZGluZ1RvcCIsImZ1bGxVcmwiLCJlIiwibG9jYXRpb24iLCJsaW5rUHJvcHMiLCJpbWFnZVNyY1NldCIsImNyb3NzT3JpZ2luIiwicmVmZXJyZXJQb2xpY3kiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJwcmV2aW91c0ltYWdlU3JjIiwiaW1nRWxlbWVudEFyZ3MiLCJhbHQiLCJyZWwiLCJhcyIsIl9fZXNNb2R1bGUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/legacy/image.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    requestIdleCallback: function() {\n        return requestIdleCallback;\n    },\n    cancelIdleCallback: function() {\n        return cancelIdleCallback;\n    }\n});\nconst requestIdleCallback = typeof self !== \"undefined\" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    let start = Date.now();\n    return self.setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nconst cancelIdleCallback = typeof self !== \"undefined\" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=request-idle-callback.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcscUJBQXFCO1FBQ2pCLE9BQU9BO0lBQ1g7SUFDQUMsb0JBQW9CO1FBQ2hCLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1ELHNCQUFzQixPQUFPUSxTQUFTLGVBQWVBLEtBQUtSLG1CQUFtQixJQUFJUSxLQUFLUixtQkFBbUIsQ0FBQ1MsSUFBSSxDQUFDQyxXQUFXLFNBQVNDLEVBQUU7SUFDdkksSUFBSUMsUUFBUUMsS0FBS0MsR0FBRztJQUNwQixPQUFPTixLQUFLTyxVQUFVLENBQUM7UUFDbkJKLEdBQUc7WUFDQ0ssWUFBWTtZQUNaQyxlQUFlO2dCQUNYLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLEtBQU1OLENBQUFBLEtBQUtDLEdBQUcsS0FBS0YsS0FBSTtZQUM5QztRQUNKO0lBQ0osR0FBRztBQUNQO0FBQ0EsTUFBTVgscUJBQXFCLE9BQU9PLFNBQVMsZUFBZUEsS0FBS1Asa0JBQWtCLElBQUlPLEtBQUtQLGtCQUFrQixDQUFDUSxJQUFJLENBQUNDLFdBQVcsU0FBU1UsRUFBRTtJQUNwSSxPQUFPQyxhQUFhRDtBQUN4QjtBQUVBLElBQUksQ0FBQyxPQUFPdkIsUUFBUXlCLE9BQU8sS0FBSyxjQUFlLE9BQU96QixRQUFReUIsT0FBTyxLQUFLLFlBQVl6QixRQUFReUIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPekIsUUFBUXlCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcks1QixPQUFPQyxjQUFjLENBQUNDLFFBQVF5QixPQUFPLEVBQUUsY0FBYztRQUFFeEIsT0FBTztJQUFLO0lBQ25FSCxPQUFPNkIsTUFBTSxDQUFDM0IsUUFBUXlCLE9BQU8sRUFBRXpCO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLFFBQVF5QixPQUFPO0FBQ2xDLEVBRUEsaURBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcz8xZTIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcmVxdWVzdElkbGVDYWxsYmFjazogbnVsbCxcbiAgICBjYW5jZWxJZGxlQ2FsbGJhY2s6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgcmVxdWVzdElkbGVDYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0SWRsZUNhbGxiYWNrO1xuICAgIH0sXG4gICAgY2FuY2VsSWRsZUNhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNhbmNlbElkbGVDYWxsYmFjaztcbiAgICB9XG59KTtcbmNvbnN0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgPSB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnJlcXVlc3RJZGxlQ2FsbGJhY2sgJiYgc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSB8fCBmdW5jdGlvbihjYikge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIHNlbGYuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgY2Ioe1xuICAgICAgICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICAgICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgNTAgLSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIDEpO1xufTtcbmNvbnN0IGNhbmNlbElkbGVDYWxsYmFjayA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSB8fCBmdW5jdGlvbihpZCkge1xuICAgIHJldHVybiBjbGVhclRpbWVvdXQoaWQpO1xufTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdC1pZGxlLWNhbGxiYWNrLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJzZWxmIiwiYmluZCIsIndpbmRvdyIsImNiIiwic3RhcnQiLCJEYXRlIiwibm93Iiwic2V0VGltZW91dCIsImRpZFRpbWVvdXQiLCJ0aW1lUmVtYWluaW5nIiwiTWF0aCIsIm1heCIsImlkIiwiY2xlYXJUaW1lb3V0IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useIntersection\", ({\n    enumerable: true,\n    get: function() {\n        return useIntersection;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\");\nconst hasIntersectionObserver = typeof IntersectionObserver === \"function\";\nconst observers = new Map();\nconst idList = [];\nfunction createObserver(options) {\n    const id = {\n        root: options.root || null,\n        margin: options.rootMargin || \"\"\n    };\n    const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);\n    let instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id,\n        observer,\n        elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    const { id, observer, elements } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection(param) {\n    let { rootRef, rootMargin, disabled } = param;\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const [visible, setVisible] = (0, _react.useState)(false);\n    const elementRef = (0, _react.useRef)(null);\n    const setElement = (0, _react.useCallback)((element)=>{\n        elementRef.current = element;\n    }, []);\n    (0, _react.useEffect)(()=>{\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            const element = elementRef.current;\n            if (element && element.tagName) {\n                const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                const idleCallback = (0, _requestidlecallback.requestIdleCallback)(()=>setVisible(true));\n                return ()=>(0, _requestidlecallback.cancelIdleCallback)(idleCallback);\n            }\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible,\n        elementRef.current\n    ]);\n    const resetVisible = (0, _react.useCallback)(()=>{\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILG1EQUFrRDtJQUM5Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLFNBQVNDLG1CQUFPQSxDQUFDLG1GQUFPO0FBQzlCLE1BQU1DLHVCQUF1QkQsbUJBQU9BLENBQUMsNkdBQXlCO0FBQzlELE1BQU1FLDBCQUEwQixPQUFPQyx5QkFBeUI7QUFDaEUsTUFBTUMsWUFBWSxJQUFJQztBQUN0QixNQUFNQyxTQUFTLEVBQUU7QUFDakIsU0FBU0MsZUFBZUMsT0FBTztJQUMzQixNQUFNQyxLQUFLO1FBQ1BDLE1BQU1GLFFBQVFFLElBQUksSUFBSTtRQUN0QkMsUUFBUUgsUUFBUUksVUFBVSxJQUFJO0lBQ2xDO0lBQ0EsTUFBTUMsV0FBV1AsT0FBT1EsSUFBSSxDQUFDLENBQUNDLE1BQU1BLElBQUlMLElBQUksS0FBS0QsR0FBR0MsSUFBSSxJQUFJSyxJQUFJSixNQUFNLEtBQUtGLEdBQUdFLE1BQU07SUFDcEYsSUFBSUs7SUFDSixJQUFJSCxVQUFVO1FBQ1ZHLFdBQVdaLFVBQVVQLEdBQUcsQ0FBQ2dCO1FBQ3pCLElBQUlHLFVBQVU7WUFDVixPQUFPQTtRQUNYO0lBQ0o7SUFDQSxNQUFNQyxXQUFXLElBQUlaO0lBQ3JCLE1BQU1hLFdBQVcsSUFBSWYscUJBQXFCLENBQUNnQjtRQUN2Q0EsUUFBUUMsT0FBTyxDQUFDLENBQUNDO1lBQ2IsTUFBTUMsV0FBV0wsU0FBU3BCLEdBQUcsQ0FBQ3dCLE1BQU1FLE1BQU07WUFDMUMsTUFBTUMsWUFBWUgsTUFBTUksY0FBYyxJQUFJSixNQUFNSyxpQkFBaUIsR0FBRztZQUNwRSxJQUFJSixZQUFZRSxXQUFXO2dCQUN2QkYsU0FBU0U7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LFFBQVE4RCxPQUFPLEVBQUU5RDtJQUMvQmlFLE9BQU9qRSxPQUFPLEdBQUdBLFFBQVE4RCxPQUFPO0FBQ2xDLEVBRUEsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanM/ZmQ5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVzZUludGVyc2VjdGlvblwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXNlSW50ZXJzZWN0aW9uO1xuICAgIH1cbn0pO1xuY29uc3QgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuY29uc3QgX3JlcXVlc3RpZGxlY2FsbGJhY2sgPSByZXF1aXJlKFwiLi9yZXF1ZXN0LWlkbGUtY2FsbGJhY2tcIik7XG5jb25zdCBoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3Qgb2JzZXJ2ZXJzID0gbmV3IE1hcCgpO1xuY29uc3QgaWRMaXN0ID0gW107XG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZlcihvcHRpb25zKSB7XG4gICAgY29uc3QgaWQgPSB7XG4gICAgICAgIHJvb3Q6IG9wdGlvbnMucm9vdCB8fCBudWxsLFxuICAgICAgICBtYXJnaW46IG9wdGlvbnMucm9vdE1hcmdpbiB8fCBcIlwiXG4gICAgfTtcbiAgICBjb25zdCBleGlzdGluZyA9IGlkTGlzdC5maW5kKChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW4pO1xuICAgIGxldCBpbnN0YW5jZTtcbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgaW5zdGFuY2UgPSBvYnNlcnZlcnMuZ2V0KGV4aXN0aW5nKTtcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpPT57XG4gICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpPT57XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGVsZW1lbnRzLmdldChlbnRyeS50YXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gZW50cnkuaXNJbnRlcnNlY3RpbmcgfHwgZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPiAwO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIGlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGlzVmlzaWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIG9wdGlvbnMpO1xuICAgIGluc3RhbmNlID0ge1xuICAgICAgICBpZCxcbiAgICAgICAgb2JzZXJ2ZXIsXG4gICAgICAgIGVsZW1lbnRzXG4gICAgfTtcbiAgICBpZExpc3QucHVzaChpZCk7XG4gICAgb2JzZXJ2ZXJzLnNldChpZCwgaW5zdGFuY2UpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIG9ic2VydmUoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGlkLCBvYnNlcnZlciwgZWxlbWVudHMgfSA9IGNyZWF0ZU9ic2VydmVyKG9wdGlvbnMpO1xuICAgIGVsZW1lbnRzLnNldChlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5vYnNlcnZlKCkge1xuICAgICAgICBlbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgLy8gRGVzdHJveSBvYnNlcnZlciB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHdhdGNoOlxuICAgICAgICBpZiAoZWxlbWVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGlkTGlzdC5maW5kSW5kZXgoKG9iaik9Pm9iai5yb290ID09PSBpZC5yb290ICYmIG9iai5tYXJnaW4gPT09IGlkLm1hcmdpbik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGlkTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVzZUludGVyc2VjdGlvbihwYXJhbSkge1xuICAgIGxldCB7IHJvb3RSZWYsIHJvb3RNYXJnaW4sIGRpc2FibGVkIH0gPSBwYXJhbTtcbiAgICBjb25zdCBpc0Rpc2FibGVkID0gZGlzYWJsZWQgfHwgIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyO1xuICAgIGNvbnN0IFt2aXNpYmxlLCBzZXRWaXNpYmxlXSA9ICgwLCBfcmVhY3QudXNlU3RhdGUpKGZhbHNlKTtcbiAgICBjb25zdCBlbGVtZW50UmVmID0gKDAsIF9yZWFjdC51c2VSZWYpKG51bGwpO1xuICAgIGNvbnN0IHNldEVsZW1lbnQgPSAoMCwgX3JlYWN0LnVzZUNhbGxiYWNrKSgoZWxlbWVudCk9PntcbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50ID0gZWxlbWVudDtcbiAgICB9LCBbXSk7XG4gICAgKDAsIF9yZWFjdC51c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmIChoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgdmlzaWJsZSkgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQudGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVub2JzZXJ2ZSA9IG9ic2VydmUoZWxlbWVudCwgKGlzVmlzaWJsZSk9PmlzVmlzaWJsZSAmJiBzZXRWaXNpYmxlKGlzVmlzaWJsZSksIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdDogcm9vdFJlZiA9PSBudWxsID8gdm9pZCAwIDogcm9vdFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICByb290TWFyZ2luXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVub2JzZXJ2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkbGVDYWxsYmFjayA9ICgwLCBfcmVxdWVzdGlkbGVjYWxsYmFjay5yZXF1ZXN0SWRsZUNhbGxiYWNrKSgoKT0+c2V0VmlzaWJsZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpPT4oMCwgX3JlcXVlc3RpZGxlY2FsbGJhY2suY2FuY2VsSWRsZUNhbGxiYWNrKShpZGxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtcbiAgICAgICAgaXNEaXNhYmxlZCxcbiAgICAgICAgcm9vdE1hcmdpbixcbiAgICAgICAgcm9vdFJlZixcbiAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50XG4gICAgXSk7XG4gICAgY29uc3QgcmVzZXRWaXNpYmxlID0gKDAsIF9yZWFjdC51c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHNldEVsZW1lbnQsXG4gICAgICAgIHZpc2libGUsXG4gICAgICAgIHJlc2V0VmlzaWJsZVxuICAgIF07XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1pbnRlcnNlY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsInVzZUludGVyc2VjdGlvbiIsIl9yZWFjdCIsInJlcXVpcmUiLCJfcmVxdWVzdGlkbGVjYWxsYmFjayIsImhhc0ludGVyc2VjdGlvbk9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlcnMiLCJNYXAiLCJpZExpc3QiLCJjcmVhdGVPYnNlcnZlciIsIm9wdGlvbnMiLCJpZCIsInJvb3QiLCJtYXJnaW4iLCJyb290TWFyZ2luIiwiZXhpc3RpbmciLCJmaW5kIiwib2JqIiwiaW5zdGFuY2UiLCJlbGVtZW50cyIsIm9ic2VydmVyIiwiZW50cmllcyIsImZvckVhY2giLCJlbnRyeSIsImNhbGxiYWNrIiwidGFyZ2V0IiwiaXNWaXNpYmxlIiwiaXNJbnRlcnNlY3RpbmciLCJpbnRlcnNlY3Rpb25SYXRpbyIsInB1c2giLCJzZXQiLCJvYnNlcnZlIiwiZWxlbWVudCIsInVub2JzZXJ2ZSIsImRlbGV0ZSIsInNpemUiLCJkaXNjb25uZWN0IiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJwYXJhbSIsInJvb3RSZWYiLCJkaXNhYmxlZCIsImlzRGlzYWJsZWQiLCJ2aXNpYmxlIiwic2V0VmlzaWJsZSIsInVzZVN0YXRlIiwiZWxlbWVudFJlZiIsInVzZVJlZiIsInNldEVsZW1lbnQiLCJ1c2VDYWxsYmFjayIsImN1cnJlbnQiLCJ1c2VFZmZlY3QiLCJ0YWdOYW1lIiwiaWRsZUNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsImNhbmNlbElkbGVDYWxsYmFjayIsInJlc2V0VmlzaWJsZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js\n"));

/***/ })

});