"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@fullcalendar";
exports.ids = ["vendor-chunks/@fullcalendar"];
exports.modules = {

/***/ "(ssr)/./node_modules/@fullcalendar/core/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@fullcalendar/core/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Calendar: () => (/* binding */ Calendar),\n/* harmony export */   JsonRequestError: () => (/* reexport safe */ _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.ag),\n/* harmony export */   createPlugin: () => (/* binding */ createPlugin),\n/* harmony export */   formatDate: () => (/* binding */ formatDate),\n/* harmony export */   formatRange: () => (/* binding */ formatRange),\n/* harmony export */   globalLocales: () => (/* binding */ globalLocales),\n/* harmony export */   globalPlugins: () => (/* binding */ globalPlugins),\n/* harmony export */   sliceEvents: () => (/* binding */ sliceEvents),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var _internal_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal-common.js */ \"(ssr)/./node_modules/@fullcalendar/core/internal-common.js\");\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact */ \"(ssr)/./node_modules/@fullcalendar/core/node_modules/preact/dist/preact.mjs\");\n/* harmony import */ var preact_compat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! preact/compat */ \"(ssr)/./node_modules/@fullcalendar/core/node_modules/preact/compat/dist/compat.mjs\");\n\n\n\n\nconst globalLocales = [];\nconst MINIMAL_RAW_EN_LOCALE = {\n    code: \"en\",\n    week: {\n        dow: 0,\n        doy: 4\n    },\n    direction: \"ltr\",\n    buttonText: {\n        prev: \"prev\",\n        next: \"next\",\n        prevYear: \"prev year\",\n        nextYear: \"next year\",\n        year: \"year\",\n        today: \"today\",\n        month: \"month\",\n        week: \"week\",\n        day: \"day\",\n        list: \"list\"\n    },\n    weekText: \"W\",\n    weekTextLong: \"Week\",\n    closeHint: \"Close\",\n    timeHint: \"Time\",\n    eventHint: \"Event\",\n    allDayText: \"all-day\",\n    moreLinkText: \"more\",\n    noEventsText: \"No events to display\"\n};\nconst RAW_EN_LOCALE = Object.assign(Object.assign({}, MINIMAL_RAW_EN_LOCALE), {\n    // Includes things we don't want other locales to inherit,\n    // things that derive from other translatable strings.\n    buttonHints: {\n        prev: \"Previous $0\",\n        next: \"Next $0\",\n        today (buttonText, unit) {\n            return unit === \"day\" ? \"Today\" : `This ${buttonText}`;\n        }\n    },\n    viewHint: \"$0 view\",\n    navLinkHint: \"Go to $0\",\n    moreLinkHint (eventCnt) {\n        return `Show ${eventCnt} more event${eventCnt === 1 ? \"\" : \"s\"}`;\n    }\n});\nfunction organizeRawLocales(explicitRawLocales) {\n    let defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : \"en\";\n    let allRawLocales = globalLocales.concat(explicitRawLocales);\n    let rawLocaleMap = {\n        en: RAW_EN_LOCALE\n    };\n    for (let rawLocale of allRawLocales){\n        rawLocaleMap[rawLocale.code] = rawLocale;\n    }\n    return {\n        map: rawLocaleMap,\n        defaultCode\n    };\n}\nfunction buildLocale(inputSingular, available) {\n    if (typeof inputSingular === \"object\" && !Array.isArray(inputSingular)) {\n        return parseLocale(inputSingular.code, [\n            inputSingular.code\n        ], inputSingular);\n    }\n    return queryLocale(inputSingular, available);\n}\nfunction queryLocale(codeArg, available) {\n    let codes = [].concat(codeArg || []); // will convert to array\n    let raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;\n    return parseLocale(codeArg, codes, raw);\n}\nfunction queryRawLocale(codes, available) {\n    for(let i = 0; i < codes.length; i += 1){\n        let parts = codes[i].toLocaleLowerCase().split(\"-\");\n        for(let j = parts.length; j > 0; j -= 1){\n            let simpleId = parts.slice(0, j).join(\"-\");\n            if (available[simpleId]) {\n                return available[simpleId];\n            }\n        }\n    }\n    return null;\n}\nfunction parseLocale(codeArg, codes, raw) {\n    let merged = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.m)([\n        MINIMAL_RAW_EN_LOCALE,\n        raw\n    ], [\n        \"buttonText\"\n    ]);\n    delete merged.code; // don't want this part of the options\n    let { week } = merged;\n    delete merged.week;\n    return {\n        codeArg,\n        codes,\n        week,\n        simpleNumberFormat: new Intl.NumberFormat(codeArg),\n        options: merged\n    };\n}\n// TODO: easier way to add new hooks? need to update a million things\nfunction createPlugin(input) {\n    return {\n        id: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.g)(),\n        name: input.name,\n        premiumReleaseDate: input.premiumReleaseDate ? new Date(input.premiumReleaseDate) : undefined,\n        deps: input.deps || [],\n        reducers: input.reducers || [],\n        isLoadingFuncs: input.isLoadingFuncs || [],\n        contextInit: [].concat(input.contextInit || []),\n        eventRefiners: input.eventRefiners || {},\n        eventDefMemberAdders: input.eventDefMemberAdders || [],\n        eventSourceRefiners: input.eventSourceRefiners || {},\n        isDraggableTransformers: input.isDraggableTransformers || [],\n        eventDragMutationMassagers: input.eventDragMutationMassagers || [],\n        eventDefMutationAppliers: input.eventDefMutationAppliers || [],\n        dateSelectionTransformers: input.dateSelectionTransformers || [],\n        datePointTransforms: input.datePointTransforms || [],\n        dateSpanTransforms: input.dateSpanTransforms || [],\n        views: input.views || {},\n        viewPropsTransformers: input.viewPropsTransformers || [],\n        isPropsValid: input.isPropsValid || null,\n        externalDefTransforms: input.externalDefTransforms || [],\n        viewContainerAppends: input.viewContainerAppends || [],\n        eventDropTransformers: input.eventDropTransformers || [],\n        componentInteractions: input.componentInteractions || [],\n        calendarInteractions: input.calendarInteractions || [],\n        themeClasses: input.themeClasses || {},\n        eventSourceDefs: input.eventSourceDefs || [],\n        cmdFormatter: input.cmdFormatter,\n        recurringTypes: input.recurringTypes || [],\n        namedTimeZonedImpl: input.namedTimeZonedImpl,\n        initialView: input.initialView || \"\",\n        elementDraggingImpl: input.elementDraggingImpl,\n        optionChangeHandlers: input.optionChangeHandlers || {},\n        scrollGridImpl: input.scrollGridImpl || null,\n        listenerRefiners: input.listenerRefiners || {},\n        optionRefiners: input.optionRefiners || {},\n        propSetHandlers: input.propSetHandlers || {}\n    };\n}\nfunction buildPluginHooks(pluginDefs, globalDefs) {\n    let currentPluginIds = {};\n    let hooks = {\n        premiumReleaseDate: undefined,\n        reducers: [],\n        isLoadingFuncs: [],\n        contextInit: [],\n        eventRefiners: {},\n        eventDefMemberAdders: [],\n        eventSourceRefiners: {},\n        isDraggableTransformers: [],\n        eventDragMutationMassagers: [],\n        eventDefMutationAppliers: [],\n        dateSelectionTransformers: [],\n        datePointTransforms: [],\n        dateSpanTransforms: [],\n        views: {},\n        viewPropsTransformers: [],\n        isPropsValid: null,\n        externalDefTransforms: [],\n        viewContainerAppends: [],\n        eventDropTransformers: [],\n        componentInteractions: [],\n        calendarInteractions: [],\n        themeClasses: {},\n        eventSourceDefs: [],\n        cmdFormatter: null,\n        recurringTypes: [],\n        namedTimeZonedImpl: null,\n        initialView: \"\",\n        elementDraggingImpl: null,\n        optionChangeHandlers: {},\n        scrollGridImpl: null,\n        listenerRefiners: {},\n        optionRefiners: {},\n        propSetHandlers: {}\n    };\n    function addDefs(defs) {\n        for (let def of defs){\n            const pluginName = def.name;\n            const currentId = currentPluginIds[pluginName];\n            if (currentId === undefined) {\n                currentPluginIds[pluginName] = def.id;\n                addDefs(def.deps);\n                hooks = combineHooks(hooks, def);\n            } else if (currentId !== def.id) {\n                // different ID than the one already added\n                console.warn(`Duplicate plugin '${pluginName}'`);\n            }\n        }\n    }\n    if (pluginDefs) {\n        addDefs(pluginDefs);\n    }\n    addDefs(globalDefs);\n    return hooks;\n}\nfunction buildBuildPluginHooks() {\n    let currentOverrideDefs = [];\n    let currentGlobalDefs = [];\n    let currentHooks;\n    return (overrideDefs, globalDefs)=>{\n        if (!currentHooks || !(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.i)(overrideDefs, currentOverrideDefs) || !(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.i)(globalDefs, currentGlobalDefs)) {\n            currentHooks = buildPluginHooks(overrideDefs, globalDefs);\n        }\n        currentOverrideDefs = overrideDefs;\n        currentGlobalDefs = globalDefs;\n        return currentHooks;\n    };\n}\nfunction combineHooks(hooks0, hooks1) {\n    return {\n        premiumReleaseDate: compareOptionalDates(hooks0.premiumReleaseDate, hooks1.premiumReleaseDate),\n        reducers: hooks0.reducers.concat(hooks1.reducers),\n        isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),\n        contextInit: hooks0.contextInit.concat(hooks1.contextInit),\n        eventRefiners: Object.assign(Object.assign({}, hooks0.eventRefiners), hooks1.eventRefiners),\n        eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),\n        eventSourceRefiners: Object.assign(Object.assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),\n        isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),\n        eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),\n        eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),\n        dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),\n        datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),\n        dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),\n        views: Object.assign(Object.assign({}, hooks0.views), hooks1.views),\n        viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),\n        isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,\n        externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),\n        viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),\n        eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),\n        calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),\n        componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),\n        themeClasses: Object.assign(Object.assign({}, hooks0.themeClasses), hooks1.themeClasses),\n        eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),\n        cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,\n        recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),\n        namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,\n        initialView: hooks0.initialView || hooks1.initialView,\n        elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,\n        optionChangeHandlers: Object.assign(Object.assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),\n        scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,\n        listenerRefiners: Object.assign(Object.assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),\n        optionRefiners: Object.assign(Object.assign({}, hooks0.optionRefiners), hooks1.optionRefiners),\n        propSetHandlers: Object.assign(Object.assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers)\n    };\n}\nfunction compareOptionalDates(date0, date1) {\n    if (date0 === undefined) {\n        return date1;\n    }\n    if (date1 === undefined) {\n        return date0;\n    }\n    return new Date(Math.max(date0.valueOf(), date1.valueOf()));\n}\nclass StandardTheme extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.T {\n}\nStandardTheme.prototype.classes = {\n    root: \"fc-theme-standard\",\n    tableCellShaded: \"fc-cell-shaded\",\n    buttonGroup: \"fc-button-group\",\n    button: \"fc-button fc-button-primary\",\n    buttonActive: \"fc-button-active\"\n};\nStandardTheme.prototype.baseIconClass = \"fc-icon\";\nStandardTheme.prototype.iconClasses = {\n    close: \"fc-icon-x\",\n    prev: \"fc-icon-chevron-left\",\n    next: \"fc-icon-chevron-right\",\n    prevYear: \"fc-icon-chevrons-left\",\n    nextYear: \"fc-icon-chevrons-right\"\n};\nStandardTheme.prototype.rtlIconClasses = {\n    prev: \"fc-icon-chevron-right\",\n    next: \"fc-icon-chevron-left\",\n    prevYear: \"fc-icon-chevrons-right\",\n    nextYear: \"fc-icon-chevrons-left\"\n};\nStandardTheme.prototype.iconOverrideOption = \"buttonIcons\"; // TODO: make TS-friendly\nStandardTheme.prototype.iconOverrideCustomButtonOption = \"icon\";\nStandardTheme.prototype.iconOverridePrefix = \"fc-icon-\";\nfunction compileViewDefs(defaultConfigs, overrideConfigs) {\n    let hash = {};\n    let viewType;\n    for(viewType in defaultConfigs){\n        ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n    }\n    for(viewType in overrideConfigs){\n        ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n    }\n    return hash;\n}\nfunction ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n    if (hash[viewType]) {\n        return hash[viewType];\n    }\n    let viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n    if (viewDef) {\n        hash[viewType] = viewDef;\n    }\n    return viewDef;\n}\nfunction buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n    let defaultConfig = defaultConfigs[viewType];\n    let overrideConfig = overrideConfigs[viewType];\n    let queryProp = (name)=>defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;\n    let theComponent = queryProp(\"component\");\n    let superType = queryProp(\"superType\");\n    let superDef = null;\n    if (superType) {\n        if (superType === viewType) {\n            throw new Error(\"Can't have a custom view type that references itself\");\n        }\n        superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);\n    }\n    if (!theComponent && superDef) {\n        theComponent = superDef.component;\n    }\n    if (!theComponent) {\n        return null; // don't throw a warning, might be settings for a single-unit view\n    }\n    return {\n        type: viewType,\n        component: theComponent,\n        defaults: Object.assign(Object.assign({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),\n        overrides: Object.assign(Object.assign({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})\n    };\n}\nfunction parseViewConfigs(inputs) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a)(inputs, parseViewConfig);\n}\nfunction parseViewConfig(input) {\n    let rawOptions = typeof input === \"function\" ? {\n        component: input\n    } : input;\n    let { component } = rawOptions;\n    if (rawOptions.content) {\n        // TODO: remove content/classNames/didMount/etc from options?\n        component = createViewHookComponent(rawOptions);\n    } else if (component && !(component.prototype instanceof _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.B)) {\n        // WHY?: people were using `component` property for `content`\n        // TODO: converge on one setting name\n        component = createViewHookComponent(Object.assign(Object.assign({}, rawOptions), {\n            content: component\n        }));\n    }\n    return {\n        superType: rawOptions.type,\n        component: component,\n        rawOptions\n    };\n}\nfunction createViewHookComponent(options) {\n    return (viewProps)=>(0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.V.Consumer, null, (context)=>(0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.C, {\n                elTag: \"div\",\n                elClasses: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.b)(context.viewSpec),\n                renderProps: Object.assign(Object.assign({}, viewProps), {\n                    nextDayThreshold: context.options.nextDayThreshold\n                }),\n                generatorName: undefined,\n                customGenerator: options.content,\n                classNameGenerator: options.classNames,\n                didMount: options.didMount,\n                willUnmount: options.willUnmount\n            }));\n}\nfunction buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n    let defaultConfigs = parseViewConfigs(defaultInputs);\n    let overrideConfigs = parseViewConfigs(optionOverrides.views);\n    let viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a)(viewDefs, (viewDef)=>buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults));\n}\nfunction buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n    let durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;\n    let duration = null;\n    let durationUnit = \"\";\n    let singleUnit = \"\";\n    let singleUnitOverrides = {};\n    if (durationInput) {\n        duration = createDurationCached(durationInput);\n        if (duration) {\n            let denom = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.c)(duration);\n            durationUnit = denom.unit;\n            if (denom.value === 1) {\n                singleUnit = durationUnit;\n                singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};\n            }\n        }\n    }\n    let queryButtonText = (optionsSubset)=>{\n        let buttonTextMap = optionsSubset.buttonText || {};\n        let buttonTextKey = viewDef.defaults.buttonTextKey;\n        if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {\n            return buttonTextMap[buttonTextKey];\n        }\n        if (buttonTextMap[viewDef.type] != null) {\n            return buttonTextMap[viewDef.type];\n        }\n        if (buttonTextMap[singleUnit] != null) {\n            return buttonTextMap[singleUnit];\n        }\n        return null;\n    };\n    let queryButtonTitle = (optionsSubset)=>{\n        let buttonHints = optionsSubset.buttonHints || {};\n        let buttonKey = viewDef.defaults.buttonTextKey; // use same key as text\n        if (buttonKey != null && buttonHints[buttonKey] != null) {\n            return buttonHints[buttonKey];\n        }\n        if (buttonHints[viewDef.type] != null) {\n            return buttonHints[viewDef.type];\n        }\n        if (buttonHints[singleUnit] != null) {\n            return buttonHints[singleUnit];\n        }\n        return null;\n    };\n    return {\n        type: viewDef.type,\n        component: viewDef.component,\n        duration,\n        durationUnit,\n        singleUnit,\n        optionDefaults: viewDef.defaults,\n        optionOverrides: Object.assign(Object.assign({}, singleUnitOverrides), viewDef.overrides),\n        buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence\n        viewDef.overrides.buttonText,\n        buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e) || viewDef.type,\n        // not DRY\n        buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) || queryButtonTitle(optionOverrides) || viewDef.overrides.buttonHint,\n        buttonTitleDefault: queryButtonTitle(localeDefaults) || viewDef.defaults.buttonHint || queryButtonTitle(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e)\n    };\n}\n// hack to get memoization working\nlet durationInputMap = {};\nfunction createDurationCached(durationInput) {\n    let json = JSON.stringify(durationInput);\n    let res = durationInputMap[json];\n    if (res === undefined) {\n        res = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.d)(durationInput);\n        durationInputMap[json] = res;\n    }\n    return res;\n}\nfunction reduceViewType(viewType, action) {\n    switch(action.type){\n        case \"CHANGE_VIEW_TYPE\":\n            viewType = action.viewType;\n    }\n    return viewType;\n}\nfunction reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {\n    switch(action.type){\n        case \"SET_OPTION\":\n            return Object.assign(Object.assign({}, dynamicOptionOverrides), {\n                [action.optionName]: action.rawOptionValue\n            });\n        default:\n            return dynamicOptionOverrides;\n    }\n}\nfunction reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {\n    let dp;\n    switch(action.type){\n        case \"CHANGE_VIEW_TYPE\":\n            return dateProfileGenerator.build(action.dateMarker || currentDate);\n        case \"CHANGE_DATE\":\n            return dateProfileGenerator.build(action.dateMarker);\n        case \"PREV\":\n            dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);\n            if (dp.isValid) {\n                return dp;\n            }\n            break;\n        case \"NEXT\":\n            dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);\n            if (dp.isValid) {\n                return dp;\n            }\n            break;\n    }\n    return currentDateProfile;\n}\nfunction initEventSources(calendarOptions, dateProfile, context) {\n    let activeRange = dateProfile ? dateProfile.activeRange : null;\n    return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);\n}\nfunction reduceEventSources(eventSources, action, dateProfile, context) {\n    let activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n    switch(action.type){\n        case \"ADD_EVENT_SOURCES\":\n            return addSources(eventSources, action.sources, activeRange, context);\n        case \"REMOVE_EVENT_SOURCE\":\n            return removeSource(eventSources, action.sourceId);\n        case \"PREV\":\n        case \"NEXT\":\n        case \"CHANGE_DATE\":\n        case \"CHANGE_VIEW_TYPE\":\n            if (dateProfile) {\n                return fetchDirtySources(eventSources, activeRange, context);\n            }\n            return eventSources;\n        case \"FETCH_EVENT_SOURCES\":\n            return fetchSourcesByIds(eventSources, action.sourceIds ? (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.f)(action.sourceIds) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);\n        case \"RECEIVE_EVENTS\":\n        case \"RECEIVE_EVENT_ERROR\":\n            return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);\n        case \"REMOVE_ALL_EVENT_SOURCES\":\n            return {};\n        default:\n            return eventSources;\n    }\n}\nfunction reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {\n    let activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n    return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);\n}\nfunction computeEventSourcesLoading(eventSources) {\n    for(let sourceId in eventSources){\n        if (eventSources[sourceId].isFetching) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction addSources(eventSourceHash, sources, fetchRange, context) {\n    let hash = {};\n    for (let source of sources){\n        hash[source.sourceId] = source;\n    }\n    if (fetchRange) {\n        hash = fetchDirtySources(hash, fetchRange, context);\n    }\n    return Object.assign(Object.assign({}, eventSourceHash), hash);\n}\nfunction removeSource(eventSourceHash, sourceId) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.h)(eventSourceHash, (eventSource)=>eventSource.sourceId !== sourceId);\n}\nfunction fetchDirtySources(sourceHash, fetchRange, context) {\n    return fetchSourcesByIds(sourceHash, (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.h)(sourceHash, (eventSource)=>isSourceDirty(eventSource, fetchRange, context)), fetchRange, false, context);\n}\nfunction isSourceDirty(eventSource, fetchRange, context) {\n    if (!doesSourceNeedRange(eventSource, context)) {\n        return !eventSource.latestFetchId;\n    }\n    return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches\n    fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;\n}\nfunction fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {\n    let nextSources = {};\n    for(let sourceId in prevSources){\n        let source = prevSources[sourceId];\n        if (sourceIdHash[sourceId]) {\n            nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);\n        } else {\n            nextSources[sourceId] = source;\n        }\n    }\n    return nextSources;\n}\nfunction fetchSource(eventSource, fetchRange, isRefetch, context) {\n    let { options, calendarApi } = context;\n    let sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];\n    let fetchId = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.g)();\n    sourceDef.fetch({\n        eventSource,\n        range: fetchRange,\n        isRefetch,\n        context\n    }, (res)=>{\n        let { rawEvents } = res;\n        if (options.eventSourceSuccess) {\n            rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.response) || rawEvents;\n        }\n        if (eventSource.success) {\n            rawEvents = eventSource.success.call(calendarApi, rawEvents, res.response) || rawEvents;\n        }\n        context.dispatch({\n            type: \"RECEIVE_EVENTS\",\n            sourceId: eventSource.sourceId,\n            fetchId,\n            fetchRange,\n            rawEvents\n        });\n    }, (error)=>{\n        let errorHandled = false;\n        if (options.eventSourceFailure) {\n            options.eventSourceFailure.call(calendarApi, error);\n            errorHandled = true;\n        }\n        if (eventSource.failure) {\n            eventSource.failure(error);\n            errorHandled = true;\n        }\n        if (!errorHandled) {\n            console.warn(error.message, error);\n        }\n        context.dispatch({\n            type: \"RECEIVE_EVENT_ERROR\",\n            sourceId: eventSource.sourceId,\n            fetchId,\n            fetchRange,\n            error\n        });\n    });\n    return Object.assign(Object.assign({}, eventSource), {\n        isFetching: true,\n        latestFetchId: fetchId\n    });\n}\nfunction receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {\n    let eventSource = sourceHash[sourceId];\n    if (eventSource && // not already removed\n    fetchId === eventSource.latestFetchId) {\n        return Object.assign(Object.assign({}, sourceHash), {\n            [sourceId]: Object.assign(Object.assign({}, eventSource), {\n                isFetching: false,\n                fetchRange\n            })\n        });\n    }\n    return sourceHash;\n}\nfunction excludeStaticSources(eventSources, context) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.h)(eventSources, (eventSource)=>doesSourceNeedRange(eventSource, context));\n}\nfunction parseInitialSources(rawOptions, context) {\n    let refiners = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.j)(context);\n    let rawSources = [].concat(rawOptions.eventSources || []);\n    let sources = []; // parsed\n    if (rawOptions.initialEvents) {\n        rawSources.unshift(rawOptions.initialEvents);\n    }\n    if (rawOptions.events) {\n        rawSources.unshift(rawOptions.events);\n    }\n    for (let rawSource of rawSources){\n        let source = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.p)(rawSource, context, refiners);\n        if (source) {\n            sources.push(source);\n        }\n    }\n    return sources;\n}\nfunction doesSourceNeedRange(eventSource, context) {\n    let defs = context.pluginHooks.eventSourceDefs;\n    return !defs[eventSource.sourceDefId].ignoreRange;\n}\nfunction reduceDateSelection(currentSelection, action) {\n    switch(action.type){\n        case \"UNSELECT_DATES\":\n            return null;\n        case \"SELECT_DATES\":\n            return action.selection;\n        default:\n            return currentSelection;\n    }\n}\nfunction reduceSelectedEvent(currentInstanceId, action) {\n    switch(action.type){\n        case \"UNSELECT_EVENT\":\n            return \"\";\n        case \"SELECT_EVENT\":\n            return action.eventInstanceId;\n        default:\n            return currentInstanceId;\n    }\n}\nfunction reduceEventDrag(currentDrag, action) {\n    let newDrag;\n    switch(action.type){\n        case \"UNSET_EVENT_DRAG\":\n            return null;\n        case \"SET_EVENT_DRAG\":\n            newDrag = action.state;\n            return {\n                affectedEvents: newDrag.affectedEvents,\n                mutatedEvents: newDrag.mutatedEvents,\n                isEvent: newDrag.isEvent\n            };\n        default:\n            return currentDrag;\n    }\n}\nfunction reduceEventResize(currentResize, action) {\n    let newResize;\n    switch(action.type){\n        case \"UNSET_EVENT_RESIZE\":\n            return null;\n        case \"SET_EVENT_RESIZE\":\n            newResize = action.state;\n            return {\n                affectedEvents: newResize.affectedEvents,\n                mutatedEvents: newResize.mutatedEvents,\n                isEvent: newResize.isEvent\n            };\n        default:\n            return currentResize;\n    }\n}\nfunction parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n    let header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n    let footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n    return {\n        header,\n        footer\n    };\n}\nfunction parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n    let sectionWidgets = {};\n    let viewsWithButtons = [];\n    let hasTitle = false;\n    for(let sectionName in sectionStrHash){\n        let sectionStr = sectionStrHash[sectionName];\n        let sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);\n        sectionWidgets[sectionName] = sectionRes.widgets;\n        viewsWithButtons.push(...sectionRes.viewsWithButtons);\n        hasTitle = hasTitle || sectionRes.hasTitle;\n    }\n    return {\n        sectionWidgets,\n        viewsWithButtons,\n        hasTitle\n    };\n}\n/*\nBAD: querying icons and text here. should be done at render time\n*/ function parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n    let isRtl = calendarOptions.direction === \"rtl\";\n    let calendarCustomButtons = calendarOptions.customButtons || {};\n    let calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};\n    let calendarButtonText = calendarOptions.buttonText || {};\n    let calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};\n    let calendarButtonHints = calendarOptions.buttonHints || {};\n    let sectionSubstrs = sectionStr ? sectionStr.split(\" \") : [];\n    let viewsWithButtons = [];\n    let hasTitle = false;\n    let widgets = sectionSubstrs.map((buttonGroupStr)=>buttonGroupStr.split(\",\").map((buttonName)=>{\n            if (buttonName === \"title\") {\n                hasTitle = true;\n                return {\n                    buttonName\n                };\n            }\n            let customButtonProps;\n            let viewSpec;\n            let buttonClick;\n            let buttonIcon; // only one of these will be set\n            let buttonText; // \"\n            let buttonHint;\n            // ^ for the title=\"\" attribute, for accessibility\n            if (customButtonProps = calendarCustomButtons[buttonName]) {\n                buttonClick = (ev)=>{\n                    if (customButtonProps.click) {\n                        customButtonProps.click.call(ev.target, ev, ev.target); // TODO: use Calendar this context?\n                    }\n                };\n                (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);\n                buttonHint = customButtonProps.hint || customButtonProps.text;\n            } else if (viewSpec = viewSpecs[buttonName]) {\n                viewsWithButtons.push(buttonName);\n                buttonClick = ()=>{\n                    calendarApi.changeView(buttonName);\n                };\n                (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);\n                let textFallback = viewSpec.buttonTextOverride || viewSpec.buttonTextDefault;\n                buttonHint = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.k)(viewSpec.buttonTitleOverride || viewSpec.buttonTitleDefault || calendarOptions.viewHint, [\n                    textFallback,\n                    buttonName\n                ], textFallback);\n            } else if (calendarApi[buttonName]) {\n                buttonClick = ()=>{\n                    calendarApi[buttonName]();\n                };\n                (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]); // everything else is considered default\n                if (buttonName === \"prevYear\" || buttonName === \"nextYear\") {\n                    let prevOrNext = buttonName === \"prevYear\" ? \"prev\" : \"next\";\n                    buttonHint = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.k)(calendarButtonHintOverrides[prevOrNext] || calendarButtonHints[prevOrNext], [\n                        calendarButtonText.year || \"year\",\n                        \"year\"\n                    ], calendarButtonText[buttonName]);\n                } else {\n                    buttonHint = (navUnit)=>(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.k)(calendarButtonHintOverrides[buttonName] || calendarButtonHints[buttonName], [\n                            calendarButtonText[navUnit] || navUnit,\n                            navUnit\n                        ], calendarButtonText[buttonName]);\n                }\n            }\n            return {\n                buttonName,\n                buttonClick,\n                buttonIcon,\n                buttonText,\n                buttonHint\n            };\n        }));\n    return {\n        widgets,\n        viewsWithButtons,\n        hasTitle\n    };\n}\n// always represents the current view. otherwise, it'd need to change value every time date changes\nclass ViewImpl {\n    constructor(type, getCurrentData, dateEnv){\n        this.type = type;\n        this.getCurrentData = getCurrentData;\n        this.dateEnv = dateEnv;\n    }\n    get calendar() {\n        return this.getCurrentData().calendarApi;\n    }\n    get title() {\n        return this.getCurrentData().viewTitle;\n    }\n    get activeStart() {\n        return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);\n    }\n    get activeEnd() {\n        return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);\n    }\n    get currentStart() {\n        return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);\n    }\n    get currentEnd() {\n        return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);\n    }\n    getOption(name) {\n        return this.getCurrentData().options[name]; // are the view-specific options\n    }\n}\nlet eventSourceDef$2 = {\n    ignoreRange: true,\n    parseMeta (refined) {\n        if (Array.isArray(refined.events)) {\n            return refined.events;\n        }\n        return null;\n    },\n    fetch (arg, successCallback) {\n        successCallback({\n            rawEvents: arg.eventSource.meta\n        });\n    }\n};\nconst arrayEventSourcePlugin = createPlugin({\n    name: \"array-event-source\",\n    eventSourceDefs: [\n        eventSourceDef$2\n    ]\n});\nlet eventSourceDef$1 = {\n    parseMeta (refined) {\n        if (typeof refined.events === \"function\") {\n            return refined.events;\n        }\n        return null;\n    },\n    fetch (arg, successCallback, errorCallback) {\n        const { dateEnv } = arg.context;\n        const func = arg.eventSource.meta;\n        (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.u)(func.bind(null, (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.l)(arg.range, dateEnv)), (rawEvents)=>successCallback({\n                rawEvents\n            }), errorCallback);\n    }\n};\nconst funcEventSourcePlugin = createPlugin({\n    name: \"func-event-source\",\n    eventSourceDefs: [\n        eventSourceDef$1\n    ]\n});\nconst JSON_FEED_EVENT_SOURCE_REFINERS = {\n    method: String,\n    extraParams: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.n,\n    startParam: String,\n    endParam: String,\n    timeZoneParam: String\n};\nlet eventSourceDef = {\n    parseMeta (refined) {\n        if (refined.url && (refined.format === \"json\" || !refined.format)) {\n            return {\n                url: refined.url,\n                format: \"json\",\n                method: (refined.method || \"GET\").toUpperCase(),\n                extraParams: refined.extraParams,\n                startParam: refined.startParam,\n                endParam: refined.endParam,\n                timeZoneParam: refined.timeZoneParam\n            };\n        }\n        return null;\n    },\n    fetch (arg, successCallback, errorCallback) {\n        const { meta } = arg.eventSource;\n        const requestParams = buildRequestParams(meta, arg.range, arg.context);\n        (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.r)(meta.method, meta.url, requestParams).then(([rawEvents, response])=>{\n            successCallback({\n                rawEvents,\n                response\n            });\n        }, errorCallback);\n    }\n};\nconst jsonFeedEventSourcePlugin = createPlugin({\n    name: \"json-event-source\",\n    eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,\n    eventSourceDefs: [\n        eventSourceDef\n    ]\n});\nfunction buildRequestParams(meta, range, context) {\n    let { dateEnv, options } = context;\n    let startParam;\n    let endParam;\n    let timeZoneParam;\n    let customRequestParams;\n    let params = {};\n    startParam = meta.startParam;\n    if (startParam == null) {\n        startParam = options.startParam;\n    }\n    endParam = meta.endParam;\n    if (endParam == null) {\n        endParam = options.endParam;\n    }\n    timeZoneParam = meta.timeZoneParam;\n    if (timeZoneParam == null) {\n        timeZoneParam = options.timeZoneParam;\n    }\n    // retrieve any outbound GET/POST data from the options\n    if (typeof meta.extraParams === \"function\") {\n        // supplied as a function that returns a key/value object\n        customRequestParams = meta.extraParams();\n    } else {\n        // probably supplied as a straight key/value object\n        customRequestParams = meta.extraParams || {};\n    }\n    Object.assign(params, customRequestParams);\n    params[startParam] = dateEnv.formatIso(range.start);\n    params[endParam] = dateEnv.formatIso(range.end);\n    if (dateEnv.timeZone !== \"local\") {\n        params[timeZoneParam] = dateEnv.timeZone;\n    }\n    return params;\n}\nconst SIMPLE_RECURRING_REFINERS = {\n    daysOfWeek: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.n,\n    startTime: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.d,\n    endTime: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.d,\n    duration: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.d,\n    startRecur: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.n,\n    endRecur: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.n\n};\nlet recurring = {\n    parse (refined, dateEnv) {\n        if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {\n            let recurringData = {\n                daysOfWeek: refined.daysOfWeek || null,\n                startTime: refined.startTime || null,\n                endTime: refined.endTime || null,\n                startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,\n                endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null\n            };\n            let duration;\n            if (refined.duration) {\n                duration = refined.duration;\n            }\n            if (!duration && refined.startTime && refined.endTime) {\n                duration = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.s)(refined.endTime, refined.startTime);\n            }\n            return {\n                allDayGuess: Boolean(!refined.startTime && !refined.endTime),\n                duration,\n                typeData: recurringData\n            };\n        }\n        return null;\n    },\n    expand (typeData, framingRange, dateEnv) {\n        let clippedFramingRange = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.o)(framingRange, {\n            start: typeData.startRecur,\n            end: typeData.endRecur\n        });\n        if (clippedFramingRange) {\n            return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);\n        }\n        return [];\n    }\n};\nconst simpleRecurringEventsPlugin = createPlugin({\n    name: \"simple-recurring-event\",\n    recurringTypes: [\n        recurring\n    ],\n    eventRefiners: SIMPLE_RECURRING_REFINERS\n});\nfunction expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {\n    let dowHash = daysOfWeek ? (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.f)(daysOfWeek) : null;\n    let dayMarker = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.q)(framingRange.start);\n    let endMarker = framingRange.end;\n    let instanceStarts = [];\n    while(dayMarker < endMarker){\n        let instanceStart;\n        // if everyday, or this particular day-of-week\n        if (!dowHash || dowHash[dayMarker.getUTCDay()]) {\n            if (startTime) {\n                instanceStart = dateEnv.add(dayMarker, startTime);\n            } else {\n                instanceStart = dayMarker;\n            }\n            instanceStarts.push(instanceStart);\n        }\n        dayMarker = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.t)(dayMarker, 1);\n    }\n    return instanceStarts;\n}\nconst changeHandlerPlugin = createPlugin({\n    name: \"change-handler\",\n    optionChangeHandlers: {\n        events (events, context) {\n            handleEventSources([\n                events\n            ], context);\n        },\n        eventSources: handleEventSources\n    }\n});\n/*\nBUG: if `event` was supplied, all previously-given `eventSources` will be wiped out\n*/ function handleEventSources(inputs, context) {\n    let unfoundSources = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.v)(context.getCurrentData().eventSources);\n    if (unfoundSources.length === 1 && inputs.length === 1 && Array.isArray(unfoundSources[0]._raw) && Array.isArray(inputs[0])) {\n        context.dispatch({\n            type: \"RESET_RAW_EVENTS\",\n            sourceId: unfoundSources[0].sourceId,\n            rawEvents: inputs[0]\n        });\n        return;\n    }\n    let newInputs = [];\n    for (let input of inputs){\n        let inputFound = false;\n        for(let i = 0; i < unfoundSources.length; i += 1){\n            if (unfoundSources[i]._raw === input) {\n                unfoundSources.splice(i, 1); // delete\n                inputFound = true;\n                break;\n            }\n        }\n        if (!inputFound) {\n            newInputs.push(input);\n        }\n    }\n    for (let unfoundSource of unfoundSources){\n        context.dispatch({\n            type: \"REMOVE_EVENT_SOURCE\",\n            sourceId: unfoundSource.sourceId\n        });\n    }\n    for (let newInput of newInputs){\n        context.calendarApi.addEventSource(newInput);\n    }\n}\nfunction handleDateProfile(dateProfile, context) {\n    context.emitter.trigger(\"datesSet\", Object.assign(Object.assign({}, (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.l)(dateProfile.activeRange, context.dateEnv)), {\n        view: context.viewApi\n    }));\n}\nfunction handleEventStore(eventStore, context) {\n    let { emitter } = context;\n    if (emitter.hasHandlers(\"eventsSet\")) {\n        emitter.trigger(\"eventsSet\", (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.w)(eventStore, context));\n    }\n}\n/*\nthis array is exposed on the root namespace so that UMD plugins can add to it.\nsee the rollup-bundles script.\n*/ const globalPlugins = [\n    arrayEventSourcePlugin,\n    funcEventSourcePlugin,\n    jsonFeedEventSourcePlugin,\n    simpleRecurringEventsPlugin,\n    changeHandlerPlugin,\n    createPlugin({\n        name: \"misc\",\n        isLoadingFuncs: [\n            (state)=>computeEventSourcesLoading(state.eventSources)\n        ],\n        propSetHandlers: {\n            dateProfile: handleDateProfile,\n            eventStore: handleEventStore\n        }\n    })\n];\nclass TaskRunner {\n    constructor(runTaskOption, drainedOption){\n        this.runTaskOption = runTaskOption;\n        this.drainedOption = drainedOption;\n        this.queue = [];\n        this.delayedRunner = new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.D(this.drain.bind(this));\n    }\n    request(task, delay) {\n        this.queue.push(task);\n        this.delayedRunner.request(delay);\n    }\n    pause(scope) {\n        this.delayedRunner.pause(scope);\n    }\n    resume(scope, force) {\n        this.delayedRunner.resume(scope, force);\n    }\n    drain() {\n        let { queue } = this;\n        while(queue.length){\n            let completedTasks = [];\n            let task;\n            while(task = queue.shift()){\n                this.runTask(task);\n                completedTasks.push(task);\n            }\n            this.drained(completedTasks);\n        } // keep going, in case new tasks were added in the drained handler\n    }\n    runTask(task) {\n        if (this.runTaskOption) {\n            this.runTaskOption(task);\n        }\n    }\n    drained(completedTasks) {\n        if (this.drainedOption) {\n            this.drainedOption(completedTasks);\n        }\n    }\n}\n// Computes what the title at the top of the calendarApi should be for this view\nfunction buildTitle(dateProfile, viewOptions, dateEnv) {\n    let range;\n    // for views that span a large unit of time, show the proper interval, ignoring stray days before and after\n    if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {\n        range = dateProfile.currentRange;\n    } else {\n        range = dateProfile.activeRange;\n    }\n    return dateEnv.formatRange(range.start, range.end, (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.x)(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {\n        isEndExclusive: dateProfile.isRangeAllDay,\n        defaultSeparator: viewOptions.titleRangeSeparator\n    });\n}\n// Generates the format string that should be used to generate the title for the current date range.\n// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\nfunction buildTitleFormat(dateProfile) {\n    let { currentRangeUnit } = dateProfile;\n    if (currentRangeUnit === \"year\") {\n        return {\n            year: \"numeric\"\n        };\n    }\n    if (currentRangeUnit === \"month\") {\n        return {\n            year: \"numeric\",\n            month: \"long\"\n        }; // like \"September 2014\"\n    }\n    let days = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.y)(dateProfile.currentRange.start, dateProfile.currentRange.end);\n    if (days !== null && days > 1) {\n        // multi-day range. shorter, like \"Sep 9 - 10 2014\"\n        return {\n            year: \"numeric\",\n            month: \"short\",\n            day: \"numeric\"\n        };\n    }\n    // one day. longer, like \"September 9 2014\"\n    return {\n        year: \"numeric\",\n        month: \"long\",\n        day: \"numeric\"\n    };\n}\n// in future refactor, do the redux-style function(state=initial) for initial-state\n// also, whatever is happening in constructor, have it happen in action queue too\nclass CalendarDataManager {\n    constructor(props){\n        this.computeCurrentViewData = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(this._computeCurrentViewData);\n        this.organizeRawLocales = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(organizeRawLocales);\n        this.buildLocale = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildLocale);\n        this.buildPluginHooks = buildBuildPluginHooks();\n        this.buildDateEnv = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildDateEnv$1);\n        this.buildTheme = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildTheme);\n        this.parseToolbars = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(parseToolbars);\n        this.buildViewSpecs = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildViewSpecs);\n        this.buildDateProfileGenerator = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.A)(buildDateProfileGenerator);\n        this.buildViewApi = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildViewApi);\n        this.buildViewUiProps = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.A)(buildViewUiProps);\n        this.buildEventUiBySource = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildEventUiBySource, _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.E);\n        this.buildEventUiBases = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildEventUiBases);\n        this.parseContextBusinessHours = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.A)(parseContextBusinessHours);\n        this.buildTitle = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildTitle);\n        this.emitter = new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.F();\n        this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));\n        this.currentCalendarOptionsInput = {};\n        this.currentCalendarOptionsRefined = {};\n        this.currentViewOptionsInput = {};\n        this.currentViewOptionsRefined = {};\n        this.currentCalendarOptionsRefiners = {};\n        this.optionsForRefining = [];\n        this.optionsForHandling = [];\n        this.getCurrentData = ()=>this.data;\n        this.dispatch = (action)=>{\n            this.actionRunner.request(action); // protects against recursive calls to _handleAction\n        };\n        this.props = props;\n        this.actionRunner.pause();\n        let dynamicOptionOverrides = {};\n        let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n        let currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;\n        let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);\n        // wire things up\n        // TODO: not DRY\n        props.calendarApi.currentDataManager = this;\n        this.emitter.setThisContext(props.calendarApi);\n        this.emitter.setOptions(currentViewData.options);\n        let currentDate = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.G)(optionsData.calendarOptions, optionsData.dateEnv);\n        let dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n        if (!(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.H)(dateProfile.activeRange, currentDate)) {\n            currentDate = dateProfile.currentRange.start;\n        }\n        let calendarContext = {\n            dateEnv: optionsData.dateEnv,\n            options: optionsData.calendarOptions,\n            pluginHooks: optionsData.pluginHooks,\n            calendarApi: props.calendarApi,\n            dispatch: this.dispatch,\n            emitter: this.emitter,\n            getCurrentData: this.getCurrentData\n        };\n        // needs to be after setThisContext\n        for (let callback of optionsData.pluginHooks.contextInit){\n            callback(calendarContext);\n        }\n        // NOT DRY\n        let eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);\n        let initialState = {\n            dynamicOptionOverrides,\n            currentViewType,\n            currentDate,\n            dateProfile,\n            businessHours: this.parseContextBusinessHours(calendarContext),\n            eventSources,\n            eventUiBases: {},\n            eventStore: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.I)(),\n            renderableEventStore: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.I)(),\n            dateSelection: null,\n            eventSelection: \"\",\n            eventDrag: null,\n            eventResize: null,\n            selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig\n        };\n        let contextAndState = Object.assign(Object.assign({}, calendarContext), initialState);\n        for (let reducer of optionsData.pluginHooks.reducers){\n            Object.assign(initialState, reducer(null, null, contextAndState));\n        }\n        if (computeIsLoading(initialState, calendarContext)) {\n            this.emitter.trigger(\"loading\", true); // NOT DRY\n        }\n        this.state = initialState;\n        this.updateData();\n        this.actionRunner.resume();\n    }\n    resetOptions(optionOverrides, changedOptionNames) {\n        let { props } = this;\n        if (changedOptionNames === undefined) {\n            props.optionOverrides = optionOverrides;\n        } else {\n            props.optionOverrides = Object.assign(Object.assign({}, props.optionOverrides || {}), optionOverrides);\n            this.optionsForRefining.push(...changedOptionNames);\n        }\n        if (changedOptionNames === undefined || changedOptionNames.length) {\n            this.actionRunner.request({\n                type: \"NOTHING\"\n            });\n        }\n    }\n    _handleAction(action) {\n        let { props, state, emitter } = this;\n        let dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);\n        let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n        let currentViewType = reduceViewType(state.currentViewType, action);\n        let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);\n        // wire things up\n        // TODO: not DRY\n        props.calendarApi.currentDataManager = this;\n        emitter.setThisContext(props.calendarApi);\n        emitter.setOptions(currentViewData.options);\n        let calendarContext = {\n            dateEnv: optionsData.dateEnv,\n            options: optionsData.calendarOptions,\n            pluginHooks: optionsData.pluginHooks,\n            calendarApi: props.calendarApi,\n            dispatch: this.dispatch,\n            emitter,\n            getCurrentData: this.getCurrentData\n        };\n        let { currentDate, dateProfile } = state;\n        if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {\n            dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n        }\n        currentDate = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.J)(currentDate, action);\n        dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);\n        if (action.type === \"PREV\" || // TODO: move this logic into DateProfileGenerator\n        action.type === \"NEXT\" || // \"\n        !(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.H)(dateProfile.currentRange, currentDate)) {\n            currentDate = dateProfile.currentRange.start;\n        }\n        let eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);\n        let eventStore = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.K)(state.eventStore, action, eventSources, dateProfile, calendarContext);\n        let isEventsLoading = computeEventSourcesLoading(eventSources); // BAD. also called in this func in computeIsLoading\n        let renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : eventStore;\n        let { eventUiSingleBase, selectionConfig } = this.buildViewUiProps(calendarContext); // will memoize obj\n        let eventUiBySource = this.buildEventUiBySource(eventSources);\n        let eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);\n        let newState = {\n            dynamicOptionOverrides,\n            currentViewType,\n            currentDate,\n            dateProfile,\n            eventSources,\n            eventStore,\n            renderableEventStore,\n            selectionConfig,\n            eventUiBases,\n            businessHours: this.parseContextBusinessHours(calendarContext),\n            dateSelection: reduceDateSelection(state.dateSelection, action),\n            eventSelection: reduceSelectedEvent(state.eventSelection, action),\n            eventDrag: reduceEventDrag(state.eventDrag, action),\n            eventResize: reduceEventResize(state.eventResize, action)\n        };\n        let contextAndState = Object.assign(Object.assign({}, calendarContext), newState);\n        for (let reducer of optionsData.pluginHooks.reducers){\n            Object.assign(newState, reducer(state, action, contextAndState)); // give the OLD state, for old value\n        }\n        let wasLoading = computeIsLoading(state, calendarContext);\n        let isLoading = computeIsLoading(newState, calendarContext);\n        // TODO: use propSetHandlers in plugin system\n        if (!wasLoading && isLoading) {\n            emitter.trigger(\"loading\", true);\n        } else if (wasLoading && !isLoading) {\n            emitter.trigger(\"loading\", false);\n        }\n        this.state = newState;\n        if (props.onAction) {\n            props.onAction(action);\n        }\n    }\n    updateData() {\n        let { props, state } = this;\n        let oldData = this.data;\n        let optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);\n        let currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);\n        let data = this.data = Object.assign(Object.assign(Object.assign({\n            viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv),\n            calendarApi: props.calendarApi,\n            dispatch: this.dispatch,\n            emitter: this.emitter,\n            getCurrentData: this.getCurrentData\n        }, optionsData), currentViewData), state);\n        let changeHandlers = optionsData.pluginHooks.optionChangeHandlers;\n        let oldCalendarOptions = oldData && oldData.calendarOptions;\n        let newCalendarOptions = optionsData.calendarOptions;\n        if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {\n            if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {\n                // hack\n                state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);\n                state.eventStore = data.eventStore = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.L)(data.eventStore, oldData.dateEnv, data.dateEnv);\n                state.renderableEventStore = data.renderableEventStore = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.L)(data.renderableEventStore, oldData.dateEnv, data.dateEnv);\n            }\n            for(let optionName in changeHandlers){\n                if (this.optionsForHandling.indexOf(optionName) !== -1 || oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {\n                    changeHandlers[optionName](newCalendarOptions[optionName], data);\n                }\n            }\n        }\n        this.optionsForHandling = [];\n        if (props.onData) {\n            props.onData(data);\n        }\n    }\n    computeOptionsData(optionOverrides, dynamicOptionOverrides, calendarApi) {\n        // TODO: blacklist options that are handled by optionChangeHandlers\n        if (!this.optionsForRefining.length && optionOverrides === this.stableOptionOverrides && dynamicOptionOverrides === this.stableDynamicOptionOverrides) {\n            return this.stableCalendarOptionsData;\n        }\n        let { refinedOptions, pluginHooks, localeDefaults, availableLocaleData, extra } = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides);\n        warnUnknownOptions(extra);\n        let dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);\n        let viewSpecs = this.buildViewSpecs(pluginHooks.views, this.stableOptionOverrides, this.stableDynamicOptionOverrides, localeDefaults);\n        let theme = this.buildTheme(refinedOptions, pluginHooks);\n        let toolbarConfig = this.parseToolbars(refinedOptions, this.stableOptionOverrides, theme, viewSpecs, calendarApi);\n        return this.stableCalendarOptionsData = {\n            calendarOptions: refinedOptions,\n            pluginHooks,\n            dateEnv,\n            viewSpecs,\n            theme,\n            toolbarConfig,\n            localeDefaults,\n            availableRawLocales: availableLocaleData.map\n        };\n    }\n    // always called from behind a memoizer\n    processRawCalendarOptions(optionOverrides, dynamicOptionOverrides) {\n        let { locales, locale } = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.M)([\n            _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e,\n            optionOverrides,\n            dynamicOptionOverrides\n        ]);\n        let availableLocaleData = this.organizeRawLocales(locales);\n        let availableRawLocales = availableLocaleData.map;\n        let localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;\n        let pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);\n        let refiners = this.currentCalendarOptionsRefiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.N), _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.O), _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.P), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n        let extra = {};\n        let raw = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.M)([\n            _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e,\n            localeDefaults,\n            optionOverrides,\n            dynamicOptionOverrides\n        ]);\n        let refined = {};\n        let currentRaw = this.currentCalendarOptionsInput;\n        let currentRefined = this.currentCalendarOptionsRefined;\n        let anyChanges = false;\n        for(let optionName in raw){\n            if (this.optionsForRefining.indexOf(optionName) === -1 && (raw[optionName] === currentRaw[optionName] || _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Q[optionName] && optionName in currentRaw && _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Q[optionName](currentRaw[optionName], raw[optionName]))) {\n                refined[optionName] = currentRefined[optionName];\n            } else if (refiners[optionName]) {\n                refined[optionName] = refiners[optionName](raw[optionName]);\n                anyChanges = true;\n            } else {\n                extra[optionName] = currentRaw[optionName];\n            }\n        }\n        if (anyChanges) {\n            this.currentCalendarOptionsInput = raw;\n            this.currentCalendarOptionsRefined = refined;\n            this.stableOptionOverrides = optionOverrides;\n            this.stableDynamicOptionOverrides = dynamicOptionOverrides;\n        }\n        this.optionsForHandling.push(...this.optionsForRefining);\n        this.optionsForRefining = [];\n        return {\n            rawOptions: this.currentCalendarOptionsInput,\n            refinedOptions: this.currentCalendarOptionsRefined,\n            pluginHooks,\n            availableLocaleData,\n            localeDefaults,\n            extra\n        };\n    }\n    _computeCurrentViewData(viewType, optionsData, optionOverrides, dynamicOptionOverrides) {\n        let viewSpec = optionsData.viewSpecs[viewType];\n        if (!viewSpec) {\n            throw new Error(`viewType \"${viewType}\" is not available. Please make sure you've loaded all neccessary plugins`);\n        }\n        let { refinedOptions, extra } = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides);\n        warnUnknownOptions(extra);\n        let dateProfileGenerator = this.buildDateProfileGenerator({\n            dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,\n            duration: viewSpec.duration,\n            durationUnit: viewSpec.durationUnit,\n            usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,\n            dateEnv: optionsData.dateEnv,\n            calendarApi: this.props.calendarApi,\n            slotMinTime: refinedOptions.slotMinTime,\n            slotMaxTime: refinedOptions.slotMaxTime,\n            showNonCurrentDates: refinedOptions.showNonCurrentDates,\n            dayCount: refinedOptions.dayCount,\n            dateAlignment: refinedOptions.dateAlignment,\n            dateIncrement: refinedOptions.dateIncrement,\n            hiddenDays: refinedOptions.hiddenDays,\n            weekends: refinedOptions.weekends,\n            nowInput: refinedOptions.now,\n            validRangeInput: refinedOptions.validRange,\n            visibleRangeInput: refinedOptions.visibleRange,\n            fixedWeekCount: refinedOptions.fixedWeekCount\n        });\n        let viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);\n        return {\n            viewSpec,\n            options: refinedOptions,\n            dateProfileGenerator,\n            viewApi\n        };\n    }\n    processRawViewOptions(viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {\n        let raw = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.M)([\n            _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e,\n            viewSpec.optionDefaults,\n            localeDefaults,\n            optionOverrides,\n            viewSpec.optionOverrides,\n            dynamicOptionOverrides\n        ]);\n        let refiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.N), _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.O), _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.P), _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.R), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n        let refined = {};\n        let currentRaw = this.currentViewOptionsInput;\n        let currentRefined = this.currentViewOptionsRefined;\n        let anyChanges = false;\n        let extra = {};\n        for(let optionName in raw){\n            if (raw[optionName] === currentRaw[optionName] || _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Q[optionName] && _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Q[optionName](raw[optionName], currentRaw[optionName])) {\n                refined[optionName] = currentRefined[optionName];\n            } else {\n                if (raw[optionName] === this.currentCalendarOptionsInput[optionName] || _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Q[optionName] && _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Q[optionName](raw[optionName], this.currentCalendarOptionsInput[optionName])) {\n                    if (optionName in this.currentCalendarOptionsRefined) {\n                        refined[optionName] = this.currentCalendarOptionsRefined[optionName];\n                    }\n                } else if (refiners[optionName]) {\n                    refined[optionName] = refiners[optionName](raw[optionName]);\n                } else {\n                    extra[optionName] = raw[optionName];\n                }\n                anyChanges = true;\n            }\n        }\n        if (anyChanges) {\n            this.currentViewOptionsInput = raw;\n            this.currentViewOptionsRefined = refined;\n        }\n        return {\n            rawOptions: this.currentViewOptionsInput,\n            refinedOptions: this.currentViewOptionsRefined,\n            extra\n        };\n    }\n}\nfunction buildDateEnv$1(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {\n    let locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);\n    return new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.S({\n        calendarSystem: \"gregory\",\n        timeZone,\n        namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,\n        locale,\n        weekNumberCalculation,\n        firstDay,\n        weekText,\n        cmdFormatter: pluginHooks.cmdFormatter,\n        defaultSeparator\n    });\n}\nfunction buildTheme(options, pluginHooks) {\n    let ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;\n    return new ThemeClass(options);\n}\nfunction buildDateProfileGenerator(props) {\n    let DateProfileGeneratorClass = props.dateProfileGeneratorClass || _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.U;\n    return new DateProfileGeneratorClass(props);\n}\nfunction buildViewApi(type, getCurrentData, dateEnv) {\n    return new ViewImpl(type, getCurrentData, dateEnv);\n}\nfunction buildEventUiBySource(eventSources) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a)(eventSources, (eventSource)=>eventSource.ui);\n}\nfunction buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {\n    let eventUiBases = {\n        \"\": eventUiSingleBase\n    };\n    for(let defId in eventDefs){\n        let def = eventDefs[defId];\n        if (def.sourceId && eventUiBySource[def.sourceId]) {\n            eventUiBases[defId] = eventUiBySource[def.sourceId];\n        }\n    }\n    return eventUiBases;\n}\nfunction buildViewUiProps(calendarContext) {\n    let { options } = calendarContext;\n    return {\n        eventUiSingleBase: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.W)({\n            display: options.eventDisplay,\n            editable: options.editable,\n            startEditable: options.eventStartEditable,\n            durationEditable: options.eventDurationEditable,\n            constraint: options.eventConstraint,\n            overlap: typeof options.eventOverlap === \"boolean\" ? options.eventOverlap : undefined,\n            allow: options.eventAllow,\n            backgroundColor: options.eventBackgroundColor,\n            borderColor: options.eventBorderColor,\n            textColor: options.eventTextColor,\n            color: options.eventColor\n        }, calendarContext),\n        selectionConfig: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.W)({\n            constraint: options.selectConstraint,\n            overlap: typeof options.selectOverlap === \"boolean\" ? options.selectOverlap : undefined,\n            allow: options.selectAllow\n        }, calendarContext)\n    };\n}\nfunction computeIsLoading(state, context) {\n    for (let isLoadingFunc of context.pluginHooks.isLoadingFuncs){\n        if (isLoadingFunc(state)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction parseContextBusinessHours(calendarContext) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.X)(calendarContext.options.businessHours, calendarContext);\n}\nfunction warnUnknownOptions(options, viewName) {\n    for(let optionName in options){\n        console.warn(`Unknown option '${optionName}'` + (viewName ? ` for view '${viewName}'` : \"\"));\n    }\n}\nclass ToolbarSection extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        let children = this.props.widgetGroups.map((widgetGroup)=>this.renderWidgetGroup(widgetGroup));\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: \"fc-toolbar-chunk\"\n        }, ...children);\n    }\n    renderWidgetGroup(widgetGroup) {\n        let { props } = this;\n        let { theme } = this.context;\n        let children = [];\n        let isOnlyButtons = true;\n        for (let widget of widgetGroup){\n            let { buttonName, buttonClick, buttonText, buttonIcon, buttonHint } = widget;\n            if (buttonName === \"title\") {\n                isOnlyButtons = false;\n                children.push((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"h2\", {\n                    className: \"fc-toolbar-title\",\n                    id: props.titleId\n                }, props.title));\n            } else {\n                let isPressed = buttonName === props.activeButton;\n                let isDisabled = !props.isTodayEnabled && buttonName === \"today\" || !props.isPrevEnabled && buttonName === \"prev\" || !props.isNextEnabled && buttonName === \"next\";\n                let buttonClasses = [\n                    `fc-${buttonName}-button`,\n                    theme.getClass(\"button\")\n                ];\n                if (isPressed) {\n                    buttonClasses.push(theme.getClass(\"buttonActive\"));\n                }\n                children.push((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"button\", {\n                    type: \"button\",\n                    title: typeof buttonHint === \"function\" ? buttonHint(props.navUnit) : buttonHint,\n                    disabled: isDisabled,\n                    \"aria-pressed\": isPressed,\n                    className: buttonClasses.join(\" \"),\n                    onClick: buttonClick\n                }, buttonText || (buttonIcon ? (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"span\", {\n                    className: buttonIcon,\n                    role: \"img\"\n                }) : \"\")));\n            }\n        }\n        if (children.length > 1) {\n            let groupClassName = isOnlyButtons && theme.getClass(\"buttonGroup\") || \"\";\n            return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: groupClassName\n            }, ...children);\n        }\n        return children[0];\n    }\n}\nclass Toolbar extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        let { model, extraClassName } = this.props;\n        let forceLtr = false;\n        let startContent;\n        let endContent;\n        let sectionWidgets = model.sectionWidgets;\n        let centerContent = sectionWidgets.center;\n        if (sectionWidgets.left) {\n            forceLtr = true;\n            startContent = sectionWidgets.left;\n        } else {\n            startContent = sectionWidgets.start;\n        }\n        if (sectionWidgets.right) {\n            forceLtr = true;\n            endContent = sectionWidgets.right;\n        } else {\n            endContent = sectionWidgets.end;\n        }\n        let classNames = [\n            extraClassName || \"\",\n            \"fc-toolbar\",\n            forceLtr ? \"fc-toolbar-ltr\" : \"\"\n        ];\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: classNames.join(\" \")\n        }, this.renderSection(\"start\", startContent || []), this.renderSection(\"center\", centerContent || []), this.renderSection(\"end\", endContent || []));\n    }\n    renderSection(key, widgetGroups) {\n        let { props } = this;\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(ToolbarSection, {\n            key: key,\n            widgetGroups: widgetGroups,\n            title: props.title,\n            navUnit: props.navUnit,\n            activeButton: props.activeButton,\n            isTodayEnabled: props.isTodayEnabled,\n            isPrevEnabled: props.isPrevEnabled,\n            isNextEnabled: props.isNextEnabled,\n            titleId: props.titleId\n        });\n    }\n}\nclass ViewHarness extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    constructor(){\n        super(...arguments);\n        this.state = {\n            availableWidth: null\n        };\n        this.handleEl = (el)=>{\n            this.el = el;\n            (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Y)(this.props.elRef, el);\n            this.updateAvailableWidth();\n        };\n        this.handleResize = ()=>{\n            this.updateAvailableWidth();\n        };\n    }\n    render() {\n        let { props, state } = this;\n        let { aspectRatio } = props;\n        let classNames = [\n            \"fc-view-harness\",\n            aspectRatio || props.liquid || props.height ? \"fc-view-harness-active\" // harness controls the height\n             : \"fc-view-harness-passive\"\n        ];\n        let height = \"\";\n        let paddingBottom = \"\";\n        if (aspectRatio) {\n            if (state.availableWidth !== null) {\n                height = state.availableWidth / aspectRatio;\n            } else {\n                // while waiting to know availableWidth, we can't set height to *zero*\n                // because will cause lots of unnecessary scrollbars within scrollgrid.\n                // BETTER: don't start rendering ANYTHING yet until we know container width\n                // NOTE: why not always use paddingBottom? Causes height oscillation (issue 5606)\n                paddingBottom = `${1 / aspectRatio * 100}%`;\n            }\n        } else {\n            height = props.height || \"\";\n        }\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            \"aria-labelledby\": props.labeledById,\n            ref: this.handleEl,\n            className: classNames.join(\" \"),\n            style: {\n                height,\n                paddingBottom\n            }\n        }, props.children);\n    }\n    componentDidMount() {\n        this.context.addResizeHandler(this.handleResize);\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleResize);\n    }\n    updateAvailableWidth() {\n        if (this.el && // needed. but why?\n        this.props.aspectRatio // aspectRatio is the only height setting that needs availableWidth\n        ) {\n            this.setState({\n                availableWidth: this.el.offsetWidth\n            });\n        }\n    }\n}\n/*\nDetects when the user clicks on an event within a DateComponent\n*/ class EventClicking extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Z {\n    constructor(settings){\n        super(settings);\n        this.handleSegClick = (ev, segEl)=>{\n            let { component } = this;\n            let { context } = component;\n            let seg = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__._)(segEl);\n            if (seg && // might be the <div> surrounding the more link\n            component.isValidSegDownEl(ev.target)) {\n                // our way to simulate a link click for elements that can't be <a> tags\n                // grab before trigger fired in case trigger trashes DOM thru rerendering\n                let hasUrlContainer = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.$)(ev.target, \".fc-event-forced-url\");\n                let url = hasUrlContainer ? hasUrlContainer.querySelector(\"a[href]\").href : \"\";\n                context.emitter.trigger(\"eventClick\", {\n                    el: segEl,\n                    event: new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a0(component.context, seg.eventRange.def, seg.eventRange.instance),\n                    jsEvent: ev,\n                    view: context.viewApi\n                });\n                if (url && !ev.defaultPrevented) {\n                    window.location.href = url;\n                }\n            }\n        };\n        this.destroy = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a1)(settings.el, \"click\", \".fc-event\", this.handleSegClick);\n    }\n}\n/*\nTriggers events and adds/removes core classNames when the user's pointer\nenters/leaves event-elements of a component.\n*/ class EventHovering extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Z {\n    constructor(settings){\n        super(settings);\n        // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it\n        this.handleEventElRemove = (el)=>{\n            if (el === this.currentSegEl) {\n                this.handleSegLeave(null, this.currentSegEl);\n            }\n        };\n        this.handleSegEnter = (ev, segEl)=>{\n            if ((0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__._)(segEl)) {\n                this.currentSegEl = segEl;\n                this.triggerEvent(\"eventMouseEnter\", ev, segEl);\n            }\n        };\n        this.handleSegLeave = (ev, segEl)=>{\n            if (this.currentSegEl) {\n                this.currentSegEl = null;\n                this.triggerEvent(\"eventMouseLeave\", ev, segEl);\n            }\n        };\n        this.removeHoverListeners = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a2)(settings.el, \".fc-event\", this.handleSegEnter, this.handleSegLeave);\n    }\n    destroy() {\n        this.removeHoverListeners();\n    }\n    triggerEvent(publicEvName, ev, segEl) {\n        let { component } = this;\n        let { context } = component;\n        let seg = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__._)(segEl);\n        if (!ev || component.isValidSegDownEl(ev.target)) {\n            context.emitter.trigger(publicEvName, {\n                el: segEl,\n                event: new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a0(context, seg.eventRange.def, seg.eventRange.instance),\n                jsEvent: ev,\n                view: context.viewApi\n            });\n        }\n    }\n}\nclass CalendarContent extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a3 {\n    constructor(){\n        super(...arguments);\n        this.buildViewContext = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a4);\n        this.buildViewPropTransformers = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildViewPropTransformers);\n        this.buildToolbarProps = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildToolbarProps);\n        this.headerRef = (0,preact__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.footerRef = (0,preact__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.interactionsStore = {};\n        // eslint-disable-next-line\n        this.state = {\n            viewLabelId: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a5)()\n        };\n        // Component Registration\n        // -----------------------------------------------------------------------------------------------------------------\n        this.registerInteractiveComponent = (component, settingsInput)=>{\n            let settings = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a6)(component, settingsInput);\n            let DEFAULT_INTERACTIONS = [\n                EventClicking,\n                EventHovering\n            ];\n            let interactionClasses = DEFAULT_INTERACTIONS.concat(this.props.pluginHooks.componentInteractions);\n            let interactions = interactionClasses.map((TheInteractionClass)=>new TheInteractionClass(settings));\n            this.interactionsStore[component.uid] = interactions;\n            _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a7[component.uid] = settings;\n        };\n        this.unregisterInteractiveComponent = (component)=>{\n            let listeners = this.interactionsStore[component.uid];\n            if (listeners) {\n                for (let listener of listeners){\n                    listener.destroy();\n                }\n                delete this.interactionsStore[component.uid];\n            }\n            delete _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a7[component.uid];\n        };\n        // Resizing\n        // -----------------------------------------------------------------------------------------------------------------\n        this.resizeRunner = new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.D(()=>{\n            this.props.emitter.trigger(\"_resize\", true); // should window resizes be considered \"forced\" ?\n            this.props.emitter.trigger(\"windowResize\", {\n                view: this.props.viewApi\n            });\n        });\n        this.handleWindowResize = (ev)=>{\n            let { options } = this.props;\n            if (options.handleWindowResize && ev.target === window // avoid jqui events\n            ) {\n                this.resizeRunner.request(options.windowResizeDelay);\n            }\n        };\n    }\n    /*\n    renders INSIDE of an outer div\n    */ render() {\n        let { props } = this;\n        let { toolbarConfig, options } = props;\n        let toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a8)(props.options.now, props.dateEnv), props.viewTitle);\n        let viewVGrow = false;\n        let viewHeight = \"\";\n        let viewAspectRatio;\n        if (props.isHeightAuto || props.forPrint) {\n            viewHeight = \"\";\n        } else if (options.height != null) {\n            viewVGrow = true;\n        } else if (options.contentHeight != null) {\n            viewHeight = options.contentHeight;\n        } else {\n            viewAspectRatio = Math.max(options.aspectRatio, 0.5); // prevent from getting too tall\n        }\n        let viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);\n        let viewLabelId = toolbarConfig.header && toolbarConfig.header.hasTitle ? this.state.viewLabelId : \"\";\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.V.Provider, {\n            value: viewContext\n        }, toolbarConfig.header && (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(Toolbar, Object.assign({\n            ref: this.headerRef,\n            extraClassName: \"fc-header-toolbar\",\n            model: toolbarConfig.header,\n            titleId: viewLabelId\n        }, toolbarProps)), (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewHarness, {\n            liquid: viewVGrow,\n            height: viewHeight,\n            aspectRatio: viewAspectRatio,\n            labeledById: viewLabelId\n        }, this.renderView(props), this.buildAppendContent()), toolbarConfig.footer && (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(Toolbar, Object.assign({\n            ref: this.footerRef,\n            extraClassName: \"fc-footer-toolbar\",\n            model: toolbarConfig.footer,\n            titleId: \"\"\n        }, toolbarProps)));\n    }\n    componentDidMount() {\n        let { props } = this;\n        this.calendarInteractions = props.pluginHooks.calendarInteractions.map((CalendarInteractionClass)=>new CalendarInteractionClass(props));\n        window.addEventListener(\"resize\", this.handleWindowResize);\n        let { propSetHandlers } = props.pluginHooks;\n        for(let propName in propSetHandlers){\n            propSetHandlers[propName](props[propName], props);\n        }\n    }\n    componentDidUpdate(prevProps) {\n        let { props } = this;\n        let { propSetHandlers } = props.pluginHooks;\n        for(let propName in propSetHandlers){\n            if (props[propName] !== prevProps[propName]) {\n                propSetHandlers[propName](props[propName], props);\n            }\n        }\n    }\n    componentWillUnmount() {\n        window.removeEventListener(\"resize\", this.handleWindowResize);\n        this.resizeRunner.clear();\n        for (let interaction of this.calendarInteractions){\n            interaction.destroy();\n        }\n        this.props.emitter.trigger(\"_unmount\");\n    }\n    buildAppendContent() {\n        let { props } = this;\n        let children = props.pluginHooks.viewContainerAppends.map((buildAppendContent)=>buildAppendContent(props));\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(preact__WEBPACK_IMPORTED_MODULE_1__.Fragment, {}, ...children);\n    }\n    renderView(props) {\n        let { pluginHooks } = props;\n        let { viewSpec } = props;\n        let viewProps = {\n            dateProfile: props.dateProfile,\n            businessHours: props.businessHours,\n            eventStore: props.renderableEventStore,\n            eventUiBases: props.eventUiBases,\n            dateSelection: props.dateSelection,\n            eventSelection: props.eventSelection,\n            eventDrag: props.eventDrag,\n            eventResize: props.eventResize,\n            isHeightAuto: props.isHeightAuto,\n            forPrint: props.forPrint\n        };\n        let transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);\n        for (let transformer of transformers){\n            Object.assign(viewProps, transformer.transform(viewProps, props));\n        }\n        let ViewComponent = viewSpec.component;\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewComponent, Object.assign({}, viewProps));\n    }\n}\nfunction buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {\n    // don't force any date-profiles to valid date profiles (the `false`) so that we can tell if it's invalid\n    let todayInfo = dateProfileGenerator.build(now, undefined, false); // TODO: need `undefined` or else INFINITE LOOP for some reason\n    let prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);\n    let nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);\n    return {\n        title,\n        activeButton: viewSpec.type,\n        navUnit: viewSpec.singleUnit,\n        isTodayEnabled: todayInfo.isValid && !(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.H)(dateProfile.currentRange, now),\n        isPrevEnabled: prevInfo.isValid,\n        isNextEnabled: nextInfo.isValid\n    };\n}\n// Plugin\n// -----------------------------------------------------------------------------------------------------------------\nfunction buildViewPropTransformers(theClasses) {\n    return theClasses.map((TheClass)=>new TheClass());\n}\nclass Calendar extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a9 {\n    constructor(el, optionOverrides = {}){\n        super();\n        this.isRendering = false;\n        this.isRendered = false;\n        this.currentClassNames = [];\n        this.customContentRenderId = 0;\n        this.handleAction = (action)=>{\n            // actions we know we want to render immediately\n            switch(action.type){\n                case \"SET_EVENT_DRAG\":\n                case \"SET_EVENT_RESIZE\":\n                    this.renderRunner.tryDrain();\n            }\n        };\n        this.handleData = (data)=>{\n            this.currentData = data;\n            this.renderRunner.request(data.calendarOptions.rerenderDelay);\n        };\n        this.handleRenderRequest = ()=>{\n            if (this.isRendering) {\n                this.isRendered = true;\n                let { currentData } = this;\n                (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.aa)(()=>{\n                    (0,preact__WEBPACK_IMPORTED_MODULE_1__.render)((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.ab, {\n                        options: currentData.calendarOptions,\n                        theme: currentData.theme,\n                        emitter: currentData.emitter\n                    }, (classNames, height, isHeightAuto, forPrint)=>{\n                        this.setClassNames(classNames);\n                        this.setHeight(height);\n                        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.ac.Provider, {\n                            value: this.customContentRenderId\n                        }, (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(CalendarContent, Object.assign({\n                            isHeightAuto: isHeightAuto,\n                            forPrint: forPrint\n                        }, currentData)));\n                    }), this.el);\n                });\n            } else if (this.isRendered) {\n                this.isRendered = false;\n                (0,preact__WEBPACK_IMPORTED_MODULE_1__.render)(null, this.el);\n                this.setClassNames([]);\n                this.setHeight(\"\");\n            }\n        };\n        (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.ad)(el);\n        this.el = el;\n        this.renderRunner = new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.D(this.handleRenderRequest);\n        new CalendarDataManager({\n            optionOverrides,\n            calendarApi: this,\n            onAction: this.handleAction,\n            onData: this.handleData\n        });\n    }\n    render() {\n        let wasRendering = this.isRendering;\n        if (!wasRendering) {\n            this.isRendering = true;\n        } else {\n            this.customContentRenderId += 1;\n        }\n        this.renderRunner.request();\n        if (wasRendering) {\n            this.updateSize();\n        }\n    }\n    destroy() {\n        if (this.isRendering) {\n            this.isRendering = false;\n            this.renderRunner.request();\n        }\n    }\n    updateSize() {\n        (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.aa)(()=>{\n            super.updateSize();\n        });\n    }\n    batchRendering(func) {\n        this.renderRunner.pause(\"batchRendering\");\n        func();\n        this.renderRunner.resume(\"batchRendering\");\n    }\n    pauseRendering() {\n        this.renderRunner.pause(\"pauseRendering\");\n    }\n    resumeRendering() {\n        this.renderRunner.resume(\"pauseRendering\", true);\n    }\n    resetOptions(optionOverrides, changedOptionNames) {\n        this.currentDataManager.resetOptions(optionOverrides, changedOptionNames);\n    }\n    setClassNames(classNames) {\n        if (!(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.i)(classNames, this.currentClassNames)) {\n            let { classList } = this.el;\n            for (let className of this.currentClassNames){\n                classList.remove(className);\n            }\n            for (let className of classNames){\n                classList.add(className);\n            }\n            this.currentClassNames = classNames;\n        }\n    }\n    setHeight(height) {\n        (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.ae)(this.el, \"height\", height);\n    }\n}\nfunction formatDate(dateInput, options = {}) {\n    let dateEnv = buildDateEnv(options);\n    let formatter = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.x)(options);\n    let dateMeta = dateEnv.createMarkerMeta(dateInput);\n    if (!dateMeta) {\n        return \"\";\n    }\n    return dateEnv.format(dateMeta.marker, formatter, {\n        forcedTzo: dateMeta.forcedTzo\n    });\n}\nfunction formatRange(startInput, endInput, options) {\n    let dateEnv = buildDateEnv(typeof options === \"object\" && options ? options : {}); // pass in if non-null object\n    let formatter = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.x)(options);\n    let startMeta = dateEnv.createMarkerMeta(startInput);\n    let endMeta = dateEnv.createMarkerMeta(endInput);\n    if (!startMeta || !endMeta) {\n        return \"\";\n    }\n    return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {\n        forcedStartTzo: startMeta.forcedTzo,\n        forcedEndTzo: endMeta.forcedTzo,\n        isEndExclusive: options.isEndExclusive,\n        defaultSeparator: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e.defaultRangeSeparator\n    });\n}\n// TODO: more DRY and optimized\nfunction buildDateEnv(settings) {\n    let locale = buildLocale(settings.locale || \"en\", organizeRawLocales([]).map); // TODO: don't hardcode 'en' everywhere\n    return new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.S(Object.assign(Object.assign({\n        timeZone: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e.timeZone,\n        calendarSystem: \"gregory\"\n    }, settings), {\n        locale\n    }));\n}\n// HELPERS\n/*\nif nextDayThreshold is specified, slicing is done in an all-day fashion.\nyou can get nextDayThreshold from context.nextDayThreshold\n*/ function sliceEvents(props, allDay) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.af)(props.eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? props.nextDayThreshold : null).fg;\n}\nconst version = \"6.1.10\";\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFpaUQ7QUFDbitDO0FBQ007QUFDN0M7QUFFdkIsTUFBTWtKLGdCQUFnQixFQUFFO0FBRXhCLE1BQU1DLHdCQUF3QjtJQUMxQkMsTUFBTTtJQUNOQyxNQUFNO1FBQ0ZDLEtBQUs7UUFDTEMsS0FBSztJQUNUO0lBQ0FDLFdBQVc7SUFDWEMsWUFBWTtRQUNSQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsVUFBVTtRQUNWQyxVQUFVO1FBQ1ZDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxPQUFPO1FBQ1BYLE1BQU07UUFDTlksS0FBSztRQUNMQyxNQUFNO0lBQ1Y7SUFDQUMsVUFBVTtJQUNWQyxjQUFjO0lBQ2RDLFdBQVc7SUFDWEMsVUFBVTtJQUNWQyxXQUFXO0lBQ1hDLFlBQVk7SUFDWkMsY0FBYztJQUNkQyxjQUFjO0FBQ2xCO0FBQ0EsTUFBTUMsZ0JBQWdCQyxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUcxQix3QkFBd0I7SUFDMUUsMERBQTBEO0lBQzFELHNEQUFzRDtJQUN0RDJCLGFBQWE7UUFDVHBCLE1BQU07UUFDTkMsTUFBTTtRQUNOSSxPQUFNTixVQUFVLEVBQUVzQixJQUFJO1lBQ2xCLE9BQU8sU0FBVSxRQUNYLFVBQ0EsQ0FBQyxLQUFLLEVBQUV0QixXQUFXLENBQUM7UUFDOUI7SUFDSjtJQUFHdUIsVUFBVTtJQUFXQyxhQUFhO0lBQVlDLGNBQWFDLFFBQVE7UUFDbEUsT0FBTyxDQUFDLEtBQUssRUFBRUEsU0FBUyxXQUFXLEVBQUVBLGFBQWEsSUFBSSxLQUFLLElBQUksQ0FBQztJQUNwRTtBQUFFO0FBQ04sU0FBU0MsbUJBQW1CQyxrQkFBa0I7SUFDMUMsSUFBSUMsY0FBY0QsbUJBQW1CRSxNQUFNLEdBQUcsSUFBSUYsa0JBQWtCLENBQUMsRUFBRSxDQUFDakMsSUFBSSxHQUFHO0lBQy9F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WUFBWXJaLFFBQVFnWixnQkFBZ0IsQ0FBQ0c7SUFDekMsSUFBSUcsVUFBVXRaLFFBQVFnWixnQkFBZ0IsQ0FBQ0k7SUFDdkMsSUFBSSxDQUFDQyxhQUFhLENBQUNDLFNBQVM7UUFDeEIsT0FBTztJQUNYO0lBQ0EsT0FBT3RaLFFBQVEyRyxXQUFXLENBQUMwUyxVQUFVSixNQUFNLEVBQUVLLFFBQVFMLE1BQU0sRUFBRUgsV0FBVztRQUNwRVMsZ0JBQWdCRixVQUFVSCxTQUFTO1FBQ25DTSxjQUFjRixRQUFRSixTQUFTO1FBQy9CcFMsZ0JBQWdCaFosUUFBUWdaLGNBQWM7UUFDdENFLGtCQUFrQjlrQixrREFBb0JBLENBQUN5cEIscUJBQXFCO0lBQ2hFO0FBQ0o7QUFDQSwrQkFBK0I7QUFDL0IsU0FBU3BFLGFBQWF3TCxRQUFRO0lBQzFCLElBQUl2SCxTQUFTL2UsWUFBWXNtQixTQUFTdkgsTUFBTSxJQUFJLE1BQU16ZixtQkFBbUIsRUFBRSxFQUFFUyxHQUFHLEdBQUcsdUNBQXVDO0lBQ3RILE9BQU8sSUFBSWhHLGtEQUFPQSxDQUFDK0UsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUM7UUFBRWlYLFVBQVV2Z0Isa0RBQW9CQSxDQUFDdWdCLFFBQVE7UUFBRTZLLGdCQUFnQjtJQUFVLEdBQUd5RixXQUFXO1FBQUV2SDtJQUFPO0FBQy9JO0FBRUEsVUFBVTtBQUNWOzs7QUFHQSxHQUNBLFNBQVNpTyxZQUFZclMsS0FBSyxFQUFFc1MsTUFBTTtJQUM5QixPQUFPcHdCLHVEQUFlQSxDQUFDOGQsTUFBTWpDLFVBQVUsRUFBRWlDLE1BQU1rQyxZQUFZLEVBQUVsQyxNQUFNNU8sV0FBVyxDQUFDQyxXQUFXLEVBQUVpaEIsU0FBU3RTLE1BQU1wUyxnQkFBZ0IsR0FBRyxNQUFNMmtCLEVBQUU7QUFDMUk7QUFFQSxNQUFNQyxVQUFVO0FBRStGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL2luZGV4LmpzP2E2NmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbSBhcyBtZXJnZVByb3BzLCBnIGFzIGd1aWQsIGkgYXMgaXNBcnJheXNFcXVhbCwgVCBhcyBUaGVtZSwgYSBhcyBtYXBIYXNoLCBCIGFzIEJhc2VDb21wb25lbnQsIFYgYXMgVmlld0NvbnRleHRUeXBlLCBDIGFzIENvbnRlbnRDb250YWluZXIsIGIgYXMgYnVpbGRWaWV3Q2xhc3NOYW1lcywgYyBhcyBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IsIGQgYXMgY3JlYXRlRHVyYXRpb24sIGUgYXMgQkFTRV9PUFRJT05fREVGQVVMVFMsIGYgYXMgYXJyYXlUb0hhc2gsIGggYXMgZmlsdGVySGFzaCwgaiBhcyBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMsIHAgYXMgcGFyc2VFdmVudFNvdXJjZSwgayBhcyBmb3JtYXRXaXRoT3JkaW5hbHMsIHUgYXMgdW5wcm9taXNpZnksIGwgYXMgYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZSwgbiBhcyBpZGVudGl0eSwgciBhcyByZXF1ZXN0SnNvbiwgcyBhcyBzdWJ0cmFjdER1cmF0aW9ucywgbyBhcyBpbnRlcnNlY3RSYW5nZXMsIHEgYXMgc3RhcnRPZkRheSwgdCBhcyBhZGREYXlzLCB2IGFzIGhhc2hWYWx1ZXNUb0FycmF5LCB3IGFzIGJ1aWxkRXZlbnRBcGlzLCBEIGFzIERlbGF5ZWRSdW5uZXIsIHggYXMgY3JlYXRlRm9ybWF0dGVyLCB5IGFzIGRpZmZXaG9sZURheXMsIHogYXMgbWVtb2l6ZSwgQSBhcyBtZW1vaXplT2JqQXJnLCBFIGFzIGlzUHJvcHNFcXVhbCwgRiBhcyBFbWl0dGVyLCBHIGFzIGdldEluaXRpYWxEYXRlLCBIIGFzIHJhbmdlQ29udGFpbnNNYXJrZXIsIEkgYXMgY3JlYXRlRW1wdHlFdmVudFN0b3JlLCBKIGFzIHJlZHVjZUN1cnJlbnREYXRlLCBLIGFzIHJlZHVjZUV2ZW50U3RvcmUsIEwgYXMgcmV6b25lRXZlbnRTdG9yZURhdGVzLCBNIGFzIG1lcmdlUmF3T3B0aW9ucywgTiBhcyBCQVNFX09QVElPTl9SRUZJTkVSUywgTyBhcyBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUywgUCBhcyBDQUxFTkRBUl9PUFRJT05fUkVGSU5FUlMsIFEgYXMgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlMsIFIgYXMgVklFV19PUFRJT05fUkVGSU5FUlMsIFMgYXMgRGF0ZUVudiwgVSBhcyBEYXRlUHJvZmlsZUdlbmVyYXRvciwgVyBhcyBjcmVhdGVFdmVudFVpLCBYIGFzIHBhcnNlQnVzaW5lc3NIb3VycywgWSBhcyBzZXRSZWYsIFogYXMgSW50ZXJhY3Rpb24sIF8gYXMgZ2V0RWxTZWcsICQgYXMgZWxlbWVudENsb3Nlc3QsIGEwIGFzIEV2ZW50SW1wbCwgYTEgYXMgbGlzdGVuQnlTZWxlY3RvciwgYTIgYXMgbGlzdGVuVG9Ib3ZlckJ5U2VsZWN0b3IsIGEzIGFzIFB1cmVDb21wb25lbnQsIGE0IGFzIGJ1aWxkVmlld0NvbnRleHQsIGE1IGFzIGdldFVuaXF1ZURvbUlkLCBhNiBhcyBwYXJzZUludGVyYWN0aW9uU2V0dGluZ3MsIGE3IGFzIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSwgYTggYXMgZ2V0Tm93LCBhOSBhcyBDYWxlbmRhckltcGwsIGFhIGFzIGZsdXNoU3luYywgYWIgYXMgQ2FsZW5kYXJSb290LCBhYyBhcyBSZW5kZXJJZCwgYWQgYXMgZW5zdXJlRWxIYXNTdHlsZXMsIGFlIGFzIGFwcGx5U3R5bGVQcm9wLCBhZiBhcyBzbGljZUV2ZW50U3RvcmUgfSBmcm9tICcuL2ludGVybmFsLWNvbW1vbi5qcyc7XG5leHBvcnQgeyBhZyBhcyBKc29uUmVxdWVzdEVycm9yIH0gZnJvbSAnLi9pbnRlcm5hbC1jb21tb24uanMnO1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgY3JlYXRlUmVmLCBGcmFnbWVudCwgcmVuZGVyIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCAncHJlYWN0L2NvbXBhdCc7XG5cbmNvbnN0IGdsb2JhbExvY2FsZXMgPSBbXTtcblxuY29uc3QgTUlOSU1BTF9SQVdfRU5fTE9DQUxFID0ge1xuICAgIGNvZGU6ICdlbicsXG4gICAgd2Vlazoge1xuICAgICAgICBkb3c6IDAsXG4gICAgICAgIGRveTogNCwgLy8gNCBkYXlzIG5lZWQgdG8gYmUgd2l0aGluIHRoZSB5ZWFyIHRvIGJlIGNvbnNpZGVyZWQgdGhlIGZpcnN0IHdlZWtcbiAgICB9LFxuICAgIGRpcmVjdGlvbjogJ2x0cicsXG4gICAgYnV0dG9uVGV4dDoge1xuICAgICAgICBwcmV2OiAncHJldicsXG4gICAgICAgIG5leHQ6ICduZXh0JyxcbiAgICAgICAgcHJldlllYXI6ICdwcmV2IHllYXInLFxuICAgICAgICBuZXh0WWVhcjogJ25leHQgeWVhcicsXG4gICAgICAgIHllYXI6ICd5ZWFyJyxcbiAgICAgICAgdG9kYXk6ICd0b2RheScsXG4gICAgICAgIG1vbnRoOiAnbW9udGgnLFxuICAgICAgICB3ZWVrOiAnd2VlaycsXG4gICAgICAgIGRheTogJ2RheScsXG4gICAgICAgIGxpc3Q6ICdsaXN0JyxcbiAgICB9LFxuICAgIHdlZWtUZXh0OiAnVycsXG4gICAgd2Vla1RleHRMb25nOiAnV2VlaycsXG4gICAgY2xvc2VIaW50OiAnQ2xvc2UnLFxuICAgIHRpbWVIaW50OiAnVGltZScsXG4gICAgZXZlbnRIaW50OiAnRXZlbnQnLFxuICAgIGFsbERheVRleHQ6ICdhbGwtZGF5JyxcbiAgICBtb3JlTGlua1RleHQ6ICdtb3JlJyxcbiAgICBub0V2ZW50c1RleHQ6ICdObyBldmVudHMgdG8gZGlzcGxheScsXG59O1xuY29uc3QgUkFXX0VOX0xPQ0FMRSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgTUlOSU1BTF9SQVdfRU5fTE9DQUxFKSwgeyBcbiAgICAvLyBJbmNsdWRlcyB0aGluZ3Mgd2UgZG9uJ3Qgd2FudCBvdGhlciBsb2NhbGVzIHRvIGluaGVyaXQsXG4gICAgLy8gdGhpbmdzIHRoYXQgZGVyaXZlIGZyb20gb3RoZXIgdHJhbnNsYXRhYmxlIHN0cmluZ3MuXG4gICAgYnV0dG9uSGludHM6IHtcbiAgICAgICAgcHJldjogJ1ByZXZpb3VzICQwJyxcbiAgICAgICAgbmV4dDogJ05leHQgJDAnLFxuICAgICAgICB0b2RheShidXR0b25UZXh0LCB1bml0KSB7XG4gICAgICAgICAgICByZXR1cm4gKHVuaXQgPT09ICdkYXknKVxuICAgICAgICAgICAgICAgID8gJ1RvZGF5J1xuICAgICAgICAgICAgICAgIDogYFRoaXMgJHtidXR0b25UZXh0fWA7XG4gICAgICAgIH0sXG4gICAgfSwgdmlld0hpbnQ6ICckMCB2aWV3JywgbmF2TGlua0hpbnQ6ICdHbyB0byAkMCcsIG1vcmVMaW5rSGludChldmVudENudCkge1xuICAgICAgICByZXR1cm4gYFNob3cgJHtldmVudENudH0gbW9yZSBldmVudCR7ZXZlbnRDbnQgPT09IDEgPyAnJyA6ICdzJ31gO1xuICAgIH0gfSk7XG5mdW5jdGlvbiBvcmdhbml6ZVJhd0xvY2FsZXMoZXhwbGljaXRSYXdMb2NhbGVzKSB7XG4gICAgbGV0IGRlZmF1bHRDb2RlID0gZXhwbGljaXRSYXdMb2NhbGVzLmxlbmd0aCA+IDAgPyBleHBsaWNpdFJhd0xvY2FsZXNbMF0uY29kZSA6ICdlbic7XG4gICAgbGV0IGFsbFJhd0xvY2FsZXMgPSBnbG9iYWxMb2NhbGVzLmNvbmNhdChleHBsaWNpdFJhd0xvY2FsZXMpO1xuICAgIGxldCByYXdMb2NhbGVNYXAgPSB7XG4gICAgICAgIGVuOiBSQVdfRU5fTE9DQUxFLFxuICAgIH07XG4gICAgZm9yIChsZXQgcmF3TG9jYWxlIG9mIGFsbFJhd0xvY2FsZXMpIHtcbiAgICAgICAgcmF3TG9jYWxlTWFwW3Jhd0xvY2FsZS5jb2RlXSA9IHJhd0xvY2FsZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFwOiByYXdMb2NhbGVNYXAsXG4gICAgICAgIGRlZmF1bHRDb2RlLFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZExvY2FsZShpbnB1dFNpbmd1bGFyLCBhdmFpbGFibGUpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0U2luZ3VsYXIgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGlucHV0U2luZ3VsYXIpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUxvY2FsZShpbnB1dFNpbmd1bGFyLmNvZGUsIFtpbnB1dFNpbmd1bGFyLmNvZGVdLCBpbnB1dFNpbmd1bGFyKTtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5TG9jYWxlKGlucHV0U2luZ3VsYXIsIGF2YWlsYWJsZSk7XG59XG5mdW5jdGlvbiBxdWVyeUxvY2FsZShjb2RlQXJnLCBhdmFpbGFibGUpIHtcbiAgICBsZXQgY29kZXMgPSBbXS5jb25jYXQoY29kZUFyZyB8fCBbXSk7IC8vIHdpbGwgY29udmVydCB0byBhcnJheVxuICAgIGxldCByYXcgPSBxdWVyeVJhd0xvY2FsZShjb2RlcywgYXZhaWxhYmxlKSB8fCBSQVdfRU5fTE9DQUxFO1xuICAgIHJldHVybiBwYXJzZUxvY2FsZShjb2RlQXJnLCBjb2RlcywgcmF3KTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5UmF3TG9jYWxlKGNvZGVzLCBhdmFpbGFibGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IGNvZGVzW2ldLnRvTG9jYWxlTG93ZXJDYXNlKCkuc3BsaXQoJy0nKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IHBhcnRzLmxlbmd0aDsgaiA+IDA7IGogLT0gMSkge1xuICAgICAgICAgICAgbGV0IHNpbXBsZUlkID0gcGFydHMuc2xpY2UoMCwgaikuam9pbignLScpO1xuICAgICAgICAgICAgaWYgKGF2YWlsYWJsZVtzaW1wbGVJZF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXZhaWxhYmxlW3NpbXBsZUlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcnNlTG9jYWxlKGNvZGVBcmcsIGNvZGVzLCByYXcpIHtcbiAgICBsZXQgbWVyZ2VkID0gbWVyZ2VQcm9wcyhbTUlOSU1BTF9SQVdfRU5fTE9DQUxFLCByYXddLCBbJ2J1dHRvblRleHQnXSk7XG4gICAgZGVsZXRlIG1lcmdlZC5jb2RlOyAvLyBkb24ndCB3YW50IHRoaXMgcGFydCBvZiB0aGUgb3B0aW9uc1xuICAgIGxldCB7IHdlZWsgfSA9IG1lcmdlZDtcbiAgICBkZWxldGUgbWVyZ2VkLndlZWs7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZUFyZyxcbiAgICAgICAgY29kZXMsXG4gICAgICAgIHdlZWssXG4gICAgICAgIHNpbXBsZU51bWJlckZvcm1hdDogbmV3IEludGwuTnVtYmVyRm9ybWF0KGNvZGVBcmcpLFxuICAgICAgICBvcHRpb25zOiBtZXJnZWQsXG4gICAgfTtcbn1cblxuLy8gVE9ETzogZWFzaWVyIHdheSB0byBhZGQgbmV3IGhvb2tzPyBuZWVkIHRvIHVwZGF0ZSBhIG1pbGxpb24gdGhpbmdzXG5mdW5jdGlvbiBjcmVhdGVQbHVnaW4oaW5wdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogZ3VpZCgpLFxuICAgICAgICBuYW1lOiBpbnB1dC5uYW1lLFxuICAgICAgICBwcmVtaXVtUmVsZWFzZURhdGU6IGlucHV0LnByZW1pdW1SZWxlYXNlRGF0ZSA/IG5ldyBEYXRlKGlucHV0LnByZW1pdW1SZWxlYXNlRGF0ZSkgOiB1bmRlZmluZWQsXG4gICAgICAgIGRlcHM6IGlucHV0LmRlcHMgfHwgW10sXG4gICAgICAgIHJlZHVjZXJzOiBpbnB1dC5yZWR1Y2VycyB8fCBbXSxcbiAgICAgICAgaXNMb2FkaW5nRnVuY3M6IGlucHV0LmlzTG9hZGluZ0Z1bmNzIHx8IFtdLFxuICAgICAgICBjb250ZXh0SW5pdDogW10uY29uY2F0KGlucHV0LmNvbnRleHRJbml0IHx8IFtdKSxcbiAgICAgICAgZXZlbnRSZWZpbmVyczogaW5wdXQuZXZlbnRSZWZpbmVycyB8fCB7fSxcbiAgICAgICAgZXZlbnREZWZNZW1iZXJBZGRlcnM6IGlucHV0LmV2ZW50RGVmTWVtYmVyQWRkZXJzIHx8IFtdLFxuICAgICAgICBldmVudFNvdXJjZVJlZmluZXJzOiBpbnB1dC5ldmVudFNvdXJjZVJlZmluZXJzIHx8IHt9LFxuICAgICAgICBpc0RyYWdnYWJsZVRyYW5zZm9ybWVyczogaW5wdXQuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnMgfHwgW10sXG4gICAgICAgIGV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzOiBpbnB1dC5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VycyB8fCBbXSxcbiAgICAgICAgZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzOiBpbnB1dC5ldmVudERlZk11dGF0aW9uQXBwbGllcnMgfHwgW10sXG4gICAgICAgIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnM6IGlucHV0LmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMgfHwgW10sXG4gICAgICAgIGRhdGVQb2ludFRyYW5zZm9ybXM6IGlucHV0LmRhdGVQb2ludFRyYW5zZm9ybXMgfHwgW10sXG4gICAgICAgIGRhdGVTcGFuVHJhbnNmb3JtczogaW5wdXQuZGF0ZVNwYW5UcmFuc2Zvcm1zIHx8IFtdLFxuICAgICAgICB2aWV3czogaW5wdXQudmlld3MgfHwge30sXG4gICAgICAgIHZpZXdQcm9wc1RyYW5zZm9ybWVyczogaW5wdXQudmlld1Byb3BzVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgICAgICBpc1Byb3BzVmFsaWQ6IGlucHV0LmlzUHJvcHNWYWxpZCB8fCBudWxsLFxuICAgICAgICBleHRlcm5hbERlZlRyYW5zZm9ybXM6IGlucHV0LmV4dGVybmFsRGVmVHJhbnNmb3JtcyB8fCBbXSxcbiAgICAgICAgdmlld0NvbnRhaW5lckFwcGVuZHM6IGlucHV0LnZpZXdDb250YWluZXJBcHBlbmRzIHx8IFtdLFxuICAgICAgICBldmVudERyb3BUcmFuc2Zvcm1lcnM6IGlucHV0LmV2ZW50RHJvcFRyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAgICAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBpbnB1dC5jb21wb25lbnRJbnRlcmFjdGlvbnMgfHwgW10sXG4gICAgICAgIGNhbGVuZGFySW50ZXJhY3Rpb25zOiBpbnB1dC5jYWxlbmRhckludGVyYWN0aW9ucyB8fCBbXSxcbiAgICAgICAgdGhlbWVDbGFzc2VzOiBpbnB1dC50aGVtZUNsYXNzZXMgfHwge30sXG4gICAgICAgIGV2ZW50U291cmNlRGVmczogaW5wdXQuZXZlbnRTb3VyY2VEZWZzIHx8IFtdLFxuICAgICAgICBjbWRGb3JtYXR0ZXI6IGlucHV0LmNtZEZvcm1hdHRlcixcbiAgICAgICAgcmVjdXJyaW5nVHlwZXM6IGlucHV0LnJlY3VycmluZ1R5cGVzIHx8IFtdLFxuICAgICAgICBuYW1lZFRpbWVab25lZEltcGw6IGlucHV0Lm5hbWVkVGltZVpvbmVkSW1wbCxcbiAgICAgICAgaW5pdGlhbFZpZXc6IGlucHV0LmluaXRpYWxWaWV3IHx8ICcnLFxuICAgICAgICBlbGVtZW50RHJhZ2dpbmdJbXBsOiBpbnB1dC5lbGVtZW50RHJhZ2dpbmdJbXBsLFxuICAgICAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczogaW5wdXQub3B0aW9uQ2hhbmdlSGFuZGxlcnMgfHwge30sXG4gICAgICAgIHNjcm9sbEdyaWRJbXBsOiBpbnB1dC5zY3JvbGxHcmlkSW1wbCB8fCBudWxsLFxuICAgICAgICBsaXN0ZW5lclJlZmluZXJzOiBpbnB1dC5saXN0ZW5lclJlZmluZXJzIHx8IHt9LFxuICAgICAgICBvcHRpb25SZWZpbmVyczogaW5wdXQub3B0aW9uUmVmaW5lcnMgfHwge30sXG4gICAgICAgIHByb3BTZXRIYW5kbGVyczogaW5wdXQucHJvcFNldEhhbmRsZXJzIHx8IHt9LFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZFBsdWdpbkhvb2tzKHBsdWdpbkRlZnMsIGdsb2JhbERlZnMpIHtcbiAgICBsZXQgY3VycmVudFBsdWdpbklkcyA9IHt9O1xuICAgIGxldCBob29rcyA9IHtcbiAgICAgICAgcHJlbWl1bVJlbGVhc2VEYXRlOiB1bmRlZmluZWQsXG4gICAgICAgIHJlZHVjZXJzOiBbXSxcbiAgICAgICAgaXNMb2FkaW5nRnVuY3M6IFtdLFxuICAgICAgICBjb250ZXh0SW5pdDogW10sXG4gICAgICAgIGV2ZW50UmVmaW5lcnM6IHt9LFxuICAgICAgICBldmVudERlZk1lbWJlckFkZGVyczogW10sXG4gICAgICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IHt9LFxuICAgICAgICBpc0RyYWdnYWJsZVRyYW5zZm9ybWVyczogW10sXG4gICAgICAgIGV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzOiBbXSxcbiAgICAgICAgZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzOiBbXSxcbiAgICAgICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogW10sXG4gICAgICAgIGRhdGVQb2ludFRyYW5zZm9ybXM6IFtdLFxuICAgICAgICBkYXRlU3BhblRyYW5zZm9ybXM6IFtdLFxuICAgICAgICB2aWV3czoge30sXG4gICAgICAgIHZpZXdQcm9wc1RyYW5zZm9ybWVyczogW10sXG4gICAgICAgIGlzUHJvcHNWYWxpZDogbnVsbCxcbiAgICAgICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBbXSxcbiAgICAgICAgdmlld0NvbnRhaW5lckFwcGVuZHM6IFtdLFxuICAgICAgICBldmVudERyb3BUcmFuc2Zvcm1lcnM6IFtdLFxuICAgICAgICBjb21wb25lbnRJbnRlcmFjdGlvbnM6IFtdLFxuICAgICAgICBjYWxlbmRhckludGVyYWN0aW9uczogW10sXG4gICAgICAgIHRoZW1lQ2xhc3Nlczoge30sXG4gICAgICAgIGV2ZW50U291cmNlRGVmczogW10sXG4gICAgICAgIGNtZEZvcm1hdHRlcjogbnVsbCxcbiAgICAgICAgcmVjdXJyaW5nVHlwZXM6IFtdLFxuICAgICAgICBuYW1lZFRpbWVab25lZEltcGw6IG51bGwsXG4gICAgICAgIGluaXRpYWxWaWV3OiAnJyxcbiAgICAgICAgZWxlbWVudERyYWdnaW5nSW1wbDogbnVsbCxcbiAgICAgICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IHt9LFxuICAgICAgICBzY3JvbGxHcmlkSW1wbDogbnVsbCxcbiAgICAgICAgbGlzdGVuZXJSZWZpbmVyczoge30sXG4gICAgICAgIG9wdGlvblJlZmluZXJzOiB7fSxcbiAgICAgICAgcHJvcFNldEhhbmRsZXJzOiB7fSxcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGFkZERlZnMoZGVmcykge1xuICAgICAgICBmb3IgKGxldCBkZWYgb2YgZGVmcykge1xuICAgICAgICAgICAgY29uc3QgcGx1Z2luTmFtZSA9IGRlZi5uYW1lO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudElkID0gY3VycmVudFBsdWdpbklkc1twbHVnaW5OYW1lXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQbHVnaW5JZHNbcGx1Z2luTmFtZV0gPSBkZWYuaWQ7XG4gICAgICAgICAgICAgICAgYWRkRGVmcyhkZWYuZGVwcyk7XG4gICAgICAgICAgICAgICAgaG9va3MgPSBjb21iaW5lSG9va3MoaG9va3MsIGRlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50SWQgIT09IGRlZi5pZCkge1xuICAgICAgICAgICAgICAgIC8vIGRpZmZlcmVudCBJRCB0aGFuIHRoZSBvbmUgYWxyZWFkeSBhZGRlZFxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRHVwbGljYXRlIHBsdWdpbiAnJHtwbHVnaW5OYW1lfSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGx1Z2luRGVmcykge1xuICAgICAgICBhZGREZWZzKHBsdWdpbkRlZnMpO1xuICAgIH1cbiAgICBhZGREZWZzKGdsb2JhbERlZnMpO1xuICAgIHJldHVybiBob29rcztcbn1cbmZ1bmN0aW9uIGJ1aWxkQnVpbGRQbHVnaW5Ib29rcygpIHtcbiAgICBsZXQgY3VycmVudE92ZXJyaWRlRGVmcyA9IFtdO1xuICAgIGxldCBjdXJyZW50R2xvYmFsRGVmcyA9IFtdO1xuICAgIGxldCBjdXJyZW50SG9va3M7XG4gICAgcmV0dXJuIChvdmVycmlkZURlZnMsIGdsb2JhbERlZnMpID0+IHtcbiAgICAgICAgaWYgKCFjdXJyZW50SG9va3MgfHwgIWlzQXJyYXlzRXF1YWwob3ZlcnJpZGVEZWZzLCBjdXJyZW50T3ZlcnJpZGVEZWZzKSB8fCAhaXNBcnJheXNFcXVhbChnbG9iYWxEZWZzLCBjdXJyZW50R2xvYmFsRGVmcykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRIb29rcyA9IGJ1aWxkUGx1Z2luSG9va3Mob3ZlcnJpZGVEZWZzLCBnbG9iYWxEZWZzKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50T3ZlcnJpZGVEZWZzID0gb3ZlcnJpZGVEZWZzO1xuICAgICAgICBjdXJyZW50R2xvYmFsRGVmcyA9IGdsb2JhbERlZnM7XG4gICAgICAgIHJldHVybiBjdXJyZW50SG9va3M7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbWJpbmVIb29rcyhob29rczAsIGhvb2tzMSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHByZW1pdW1SZWxlYXNlRGF0ZTogY29tcGFyZU9wdGlvbmFsRGF0ZXMoaG9va3MwLnByZW1pdW1SZWxlYXNlRGF0ZSwgaG9va3MxLnByZW1pdW1SZWxlYXNlRGF0ZSksXG4gICAgICAgIHJlZHVjZXJzOiBob29rczAucmVkdWNlcnMuY29uY2F0KGhvb2tzMS5yZWR1Y2VycyksXG4gICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBob29rczAuaXNMb2FkaW5nRnVuY3MuY29uY2F0KGhvb2tzMS5pc0xvYWRpbmdGdW5jcyksXG4gICAgICAgIGNvbnRleHRJbml0OiBob29rczAuY29udGV4dEluaXQuY29uY2F0KGhvb2tzMS5jb250ZXh0SW5pdCksXG4gICAgICAgIGV2ZW50UmVmaW5lcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLmV2ZW50UmVmaW5lcnMpLCBob29rczEuZXZlbnRSZWZpbmVycyksXG4gICAgICAgIGV2ZW50RGVmTWVtYmVyQWRkZXJzOiBob29rczAuZXZlbnREZWZNZW1iZXJBZGRlcnMuY29uY2F0KGhvb2tzMS5ldmVudERlZk1lbWJlckFkZGVycyksXG4gICAgICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLmV2ZW50U291cmNlUmVmaW5lcnMpLCBob29rczEuZXZlbnRTb3VyY2VSZWZpbmVycyksXG4gICAgICAgIGlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzOiBob29rczAuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycyksXG4gICAgICAgIGV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzOiBob29rczAuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMuY29uY2F0KGhvb2tzMS5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VycyksXG4gICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogaG9va3MwLmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycy5jb25jYXQoaG9va3MxLmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycyksXG4gICAgICAgIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnM6IGhvb2tzMC5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyksXG4gICAgICAgIGRhdGVQb2ludFRyYW5zZm9ybXM6IGhvb2tzMC5kYXRlUG9pbnRUcmFuc2Zvcm1zLmNvbmNhdChob29rczEuZGF0ZVBvaW50VHJhbnNmb3JtcyksXG4gICAgICAgIGRhdGVTcGFuVHJhbnNmb3JtczogaG9va3MwLmRhdGVTcGFuVHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmRhdGVTcGFuVHJhbnNmb3JtcyksXG4gICAgICAgIHZpZXdzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC52aWV3cyksIGhvb2tzMS52aWV3cyksXG4gICAgICAgIHZpZXdQcm9wc1RyYW5zZm9ybWVyczogaG9va3MwLnZpZXdQcm9wc1RyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLnZpZXdQcm9wc1RyYW5zZm9ybWVycyksXG4gICAgICAgIGlzUHJvcHNWYWxpZDogaG9va3MxLmlzUHJvcHNWYWxpZCB8fCBob29rczAuaXNQcm9wc1ZhbGlkLFxuICAgICAgICBleHRlcm5hbERlZlRyYW5zZm9ybXM6IGhvb2tzMC5leHRlcm5hbERlZlRyYW5zZm9ybXMuY29uY2F0KGhvb2tzMS5leHRlcm5hbERlZlRyYW5zZm9ybXMpLFxuICAgICAgICB2aWV3Q29udGFpbmVyQXBwZW5kczogaG9va3MwLnZpZXdDb250YWluZXJBcHBlbmRzLmNvbmNhdChob29rczEudmlld0NvbnRhaW5lckFwcGVuZHMpLFxuICAgICAgICBldmVudERyb3BUcmFuc2Zvcm1lcnM6IGhvb2tzMC5ldmVudERyb3BUcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS5ldmVudERyb3BUcmFuc2Zvcm1lcnMpLFxuICAgICAgICBjYWxlbmRhckludGVyYWN0aW9uczogaG9va3MwLmNhbGVuZGFySW50ZXJhY3Rpb25zLmNvbmNhdChob29rczEuY2FsZW5kYXJJbnRlcmFjdGlvbnMpLFxuICAgICAgICBjb21wb25lbnRJbnRlcmFjdGlvbnM6IGhvb2tzMC5jb21wb25lbnRJbnRlcmFjdGlvbnMuY29uY2F0KGhvb2tzMS5jb21wb25lbnRJbnRlcmFjdGlvbnMpLFxuICAgICAgICB0aGVtZUNsYXNzZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLnRoZW1lQ2xhc3NlcyksIGhvb2tzMS50aGVtZUNsYXNzZXMpLFxuICAgICAgICBldmVudFNvdXJjZURlZnM6IGhvb2tzMC5ldmVudFNvdXJjZURlZnMuY29uY2F0KGhvb2tzMS5ldmVudFNvdXJjZURlZnMpLFxuICAgICAgICBjbWRGb3JtYXR0ZXI6IGhvb2tzMS5jbWRGb3JtYXR0ZXIgfHwgaG9va3MwLmNtZEZvcm1hdHRlcixcbiAgICAgICAgcmVjdXJyaW5nVHlwZXM6IGhvb2tzMC5yZWN1cnJpbmdUeXBlcy5jb25jYXQoaG9va3MxLnJlY3VycmluZ1R5cGVzKSxcbiAgICAgICAgbmFtZWRUaW1lWm9uZWRJbXBsOiBob29rczEubmFtZWRUaW1lWm9uZWRJbXBsIHx8IGhvb2tzMC5uYW1lZFRpbWVab25lZEltcGwsXG4gICAgICAgIGluaXRpYWxWaWV3OiBob29rczAuaW5pdGlhbFZpZXcgfHwgaG9va3MxLmluaXRpYWxWaWV3LFxuICAgICAgICBlbGVtZW50RHJhZ2dpbmdJbXBsOiBob29rczAuZWxlbWVudERyYWdnaW5nSW1wbCB8fCBob29rczEuZWxlbWVudERyYWdnaW5nSW1wbCxcbiAgICAgICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLm9wdGlvbkNoYW5nZUhhbmRsZXJzKSwgaG9va3MxLm9wdGlvbkNoYW5nZUhhbmRsZXJzKSxcbiAgICAgICAgc2Nyb2xsR3JpZEltcGw6IGhvb2tzMS5zY3JvbGxHcmlkSW1wbCB8fCBob29rczAuc2Nyb2xsR3JpZEltcGwsXG4gICAgICAgIGxpc3RlbmVyUmVmaW5lcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLmxpc3RlbmVyUmVmaW5lcnMpLCBob29rczEubGlzdGVuZXJSZWZpbmVycyksXG4gICAgICAgIG9wdGlvblJlZmluZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5vcHRpb25SZWZpbmVycyksIGhvb2tzMS5vcHRpb25SZWZpbmVycyksXG4gICAgICAgIHByb3BTZXRIYW5kbGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAucHJvcFNldEhhbmRsZXJzKSwgaG9va3MxLnByb3BTZXRIYW5kbGVycyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVPcHRpb25hbERhdGVzKGRhdGUwLCBkYXRlMSkge1xuICAgIGlmIChkYXRlMCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBkYXRlMTtcbiAgICB9XG4gICAgaWYgKGRhdGUxID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUwO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoTWF0aC5tYXgoZGF0ZTAudmFsdWVPZigpLCBkYXRlMS52YWx1ZU9mKCkpKTtcbn1cblxuY2xhc3MgU3RhbmRhcmRUaGVtZSBleHRlbmRzIFRoZW1lIHtcbn1cblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7XG4gICAgcm9vdDogJ2ZjLXRoZW1lLXN0YW5kYXJkJyxcbiAgICB0YWJsZUNlbGxTaGFkZWQ6ICdmYy1jZWxsLXNoYWRlZCcsXG4gICAgYnV0dG9uR3JvdXA6ICdmYy1idXR0b24tZ3JvdXAnLFxuICAgIGJ1dHRvbjogJ2ZjLWJ1dHRvbiBmYy1idXR0b24tcHJpbWFyeScsXG4gICAgYnV0dG9uQWN0aXZlOiAnZmMtYnV0dG9uLWFjdGl2ZScsXG59O1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICdmYy1pY29uJztcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge1xuICAgIGNsb3NlOiAnZmMtaWNvbi14JyxcbiAgICBwcmV2OiAnZmMtaWNvbi1jaGV2cm9uLWxlZnQnLFxuICAgIG5leHQ6ICdmYy1pY29uLWNoZXZyb24tcmlnaHQnLFxuICAgIHByZXZZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1sZWZ0JyxcbiAgICBuZXh0WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtcmlnaHQnLFxufTtcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLnJ0bEljb25DbGFzc2VzID0ge1xuICAgIHByZXY6ICdmYy1pY29uLWNoZXZyb24tcmlnaHQnLFxuICAgIG5leHQ6ICdmYy1pY29uLWNoZXZyb24tbGVmdCcsXG4gICAgcHJldlllYXI6ICdmYy1pY29uLWNoZXZyb25zLXJpZ2h0JyxcbiAgICBuZXh0WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtbGVmdCcsXG59O1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlT3B0aW9uID0gJ2J1dHRvbkljb25zJzsgLy8gVE9ETzogbWFrZSBUUy1mcmllbmRseVxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uID0gJ2ljb24nO1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJ2ZjLWljb24tJztcblxuZnVuY3Rpb24gY29tcGlsZVZpZXdEZWZzKGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpIHtcbiAgICBsZXQgaGFzaCA9IHt9O1xuICAgIGxldCB2aWV3VHlwZTtcbiAgICBmb3IgKHZpZXdUeXBlIGluIGRlZmF1bHRDb25maWdzKSB7XG4gICAgICAgIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgIH1cbiAgICBmb3IgKHZpZXdUeXBlIGluIG92ZXJyaWRlQ29uZmlncykge1xuICAgICAgICBlbnN1cmVWaWV3RGVmKHZpZXdUeXBlLCBoYXNoLCBkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2g7XG59XG5mdW5jdGlvbiBlbnN1cmVWaWV3RGVmKHZpZXdUeXBlLCBoYXNoLCBkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKSB7XG4gICAgaWYgKGhhc2hbdmlld1R5cGVdKSB7XG4gICAgICAgIHJldHVybiBoYXNoW3ZpZXdUeXBlXTtcbiAgICB9XG4gICAgbGV0IHZpZXdEZWYgPSBidWlsZFZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgIGlmICh2aWV3RGVmKSB7XG4gICAgICAgIGhhc2hbdmlld1R5cGVdID0gdmlld0RlZjtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXdEZWY7XG59XG5mdW5jdGlvbiBidWlsZFZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpIHtcbiAgICBsZXQgZGVmYXVsdENvbmZpZyA9IGRlZmF1bHRDb25maWdzW3ZpZXdUeXBlXTtcbiAgICBsZXQgb3ZlcnJpZGVDb25maWcgPSBvdmVycmlkZUNvbmZpZ3Nbdmlld1R5cGVdO1xuICAgIGxldCBxdWVyeVByb3AgPSAobmFtZSkgPT4gKChkZWZhdWx0Q29uZmlnICYmIGRlZmF1bHRDb25maWdbbmFtZV0gIT09IG51bGwpID8gZGVmYXVsdENvbmZpZ1tuYW1lXSA6XG4gICAgICAgICgob3ZlcnJpZGVDb25maWcgJiYgb3ZlcnJpZGVDb25maWdbbmFtZV0gIT09IG51bGwpID8gb3ZlcnJpZGVDb25maWdbbmFtZV0gOiBudWxsKSk7XG4gICAgbGV0IHRoZUNvbXBvbmVudCA9IHF1ZXJ5UHJvcCgnY29tcG9uZW50Jyk7XG4gICAgbGV0IHN1cGVyVHlwZSA9IHF1ZXJ5UHJvcCgnc3VwZXJUeXBlJyk7XG4gICAgbGV0IHN1cGVyRGVmID0gbnVsbDtcbiAgICBpZiAoc3VwZXJUeXBlKSB7XG4gICAgICAgIGlmIChzdXBlclR5cGUgPT09IHZpZXdUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgaGF2ZSBhIGN1c3RvbSB2aWV3IHR5cGUgdGhhdCByZWZlcmVuY2VzIGl0c2VsZicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyRGVmID0gZW5zdXJlVmlld0RlZihzdXBlclR5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgIH1cbiAgICBpZiAoIXRoZUNvbXBvbmVudCAmJiBzdXBlckRlZikge1xuICAgICAgICB0aGVDb21wb25lbnQgPSBzdXBlckRlZi5jb21wb25lbnQ7XG4gICAgfVxuICAgIGlmICghdGhlQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsOyAvLyBkb24ndCB0aHJvdyBhIHdhcm5pbmcsIG1pZ2h0IGJlIHNldHRpbmdzIGZvciBhIHNpbmdsZS11bml0IHZpZXdcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdmlld1R5cGUsXG4gICAgICAgIGNvbXBvbmVudDogdGhlQ29tcG9uZW50LFxuICAgICAgICBkZWZhdWx0czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoc3VwZXJEZWYgPyBzdXBlckRlZi5kZWZhdWx0cyA6IHt9KSksIChkZWZhdWx0Q29uZmlnID8gZGVmYXVsdENvbmZpZy5yYXdPcHRpb25zIDoge30pKSxcbiAgICAgICAgb3ZlcnJpZGVzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChzdXBlckRlZiA/IHN1cGVyRGVmLm92ZXJyaWRlcyA6IHt9KSksIChvdmVycmlkZUNvbmZpZyA/IG92ZXJyaWRlQ29uZmlnLnJhd09wdGlvbnMgOiB7fSkpLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVmlld0NvbmZpZ3MoaW5wdXRzKSB7XG4gICAgcmV0dXJuIG1hcEhhc2goaW5wdXRzLCBwYXJzZVZpZXdDb25maWcpO1xufVxuZnVuY3Rpb24gcGFyc2VWaWV3Q29uZmlnKGlucHV0KSB7XG4gICAgbGV0IHJhd09wdGlvbnMgPSB0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICB7IGNvbXBvbmVudDogaW5wdXQgfSA6XG4gICAgICAgIGlucHV0O1xuICAgIGxldCB7IGNvbXBvbmVudCB9ID0gcmF3T3B0aW9ucztcbiAgICBpZiAocmF3T3B0aW9ucy5jb250ZW50KSB7XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSBjb250ZW50L2NsYXNzTmFtZXMvZGlkTW91bnQvZXRjIGZyb20gb3B0aW9ucz9cbiAgICAgICAgY29tcG9uZW50ID0gY3JlYXRlVmlld0hvb2tDb21wb25lbnQocmF3T3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbXBvbmVudCAmJiAhKGNvbXBvbmVudC5wcm90b3R5cGUgaW5zdGFuY2VvZiBCYXNlQ29tcG9uZW50KSkge1xuICAgICAgICAvLyBXSFk/OiBwZW9wbGUgd2VyZSB1c2luZyBgY29tcG9uZW50YCBwcm9wZXJ0eSBmb3IgYGNvbnRlbnRgXG4gICAgICAgIC8vIFRPRE86IGNvbnZlcmdlIG9uIG9uZSBzZXR0aW5nIG5hbWVcbiAgICAgICAgY29tcG9uZW50ID0gY3JlYXRlVmlld0hvb2tDb21wb25lbnQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByYXdPcHRpb25zKSwgeyBjb250ZW50OiBjb21wb25lbnQgfSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdXBlclR5cGU6IHJhd09wdGlvbnMudHlwZSxcbiAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gICAgICAgIHJhd09wdGlvbnMsIC8vIGluY2x1ZGVzIHR5cGUgYW5kIGNvbXBvbmVudCB0b28gOihcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVmlld0hvb2tDb21wb25lbnQob3B0aW9ucykge1xuICAgIHJldHVybiAodmlld1Byb3BzKSA9PiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXIsIG51bGwsIChjb250ZXh0KSA9PiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IGJ1aWxkVmlld0NsYXNzTmFtZXMoY29udGV4dC52aWV3U3BlYyksIHJlbmRlclByb3BzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZpZXdQcm9wcyksIHsgbmV4dERheVRocmVzaG9sZDogY29udGV4dC5vcHRpb25zLm5leHREYXlUaHJlc2hvbGQgfSksIGdlbmVyYXRvck5hbWU6IHVuZGVmaW5lZCwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmNvbnRlbnQsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5jbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5kaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMud2lsbFVubW91bnQgfSkpKSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVmlld1NwZWNzKGRlZmF1bHRJbnB1dHMsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgbG9jYWxlRGVmYXVsdHMpIHtcbiAgICBsZXQgZGVmYXVsdENvbmZpZ3MgPSBwYXJzZVZpZXdDb25maWdzKGRlZmF1bHRJbnB1dHMpO1xuICAgIGxldCBvdmVycmlkZUNvbmZpZ3MgPSBwYXJzZVZpZXdDb25maWdzKG9wdGlvbk92ZXJyaWRlcy52aWV3cyk7XG4gICAgbGV0IHZpZXdEZWZzID0gY29tcGlsZVZpZXdEZWZzKGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgIHJldHVybiBtYXBIYXNoKHZpZXdEZWZzLCAodmlld0RlZikgPT4gYnVpbGRWaWV3U3BlYyh2aWV3RGVmLCBvdmVycmlkZUNvbmZpZ3MsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgbG9jYWxlRGVmYXVsdHMpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld1NwZWModmlld0RlZiwgb3ZlcnJpZGVDb25maWdzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKSB7XG4gICAgbGV0IGR1cmF0aW9uSW5wdXQgPSB2aWV3RGVmLm92ZXJyaWRlcy5kdXJhdGlvbiB8fFxuICAgICAgICB2aWV3RGVmLmRlZmF1bHRzLmR1cmF0aW9uIHx8XG4gICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMuZHVyYXRpb24gfHxcbiAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLmR1cmF0aW9uO1xuICAgIGxldCBkdXJhdGlvbiA9IG51bGw7XG4gICAgbGV0IGR1cmF0aW9uVW5pdCA9ICcnO1xuICAgIGxldCBzaW5nbGVVbml0ID0gJyc7XG4gICAgbGV0IHNpbmdsZVVuaXRPdmVycmlkZXMgPSB7fTtcbiAgICBpZiAoZHVyYXRpb25JbnB1dCkge1xuICAgICAgICBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uQ2FjaGVkKGR1cmF0aW9uSW5wdXQpO1xuICAgICAgICBpZiAoZHVyYXRpb24pIHsgLy8gdmFsaWQ/XG4gICAgICAgICAgICBsZXQgZGVub20gPSBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IoZHVyYXRpb24pO1xuICAgICAgICAgICAgZHVyYXRpb25Vbml0ID0gZGVub20udW5pdDtcbiAgICAgICAgICAgIGlmIChkZW5vbS52YWx1ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHNpbmdsZVVuaXQgPSBkdXJhdGlvblVuaXQ7XG4gICAgICAgICAgICAgICAgc2luZ2xlVW5pdE92ZXJyaWRlcyA9IG92ZXJyaWRlQ29uZmlnc1tkdXJhdGlvblVuaXRdID8gb3ZlcnJpZGVDb25maWdzW2R1cmF0aW9uVW5pdF0ucmF3T3B0aW9ucyA6IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBxdWVyeUJ1dHRvblRleHQgPSAob3B0aW9uc1N1YnNldCkgPT4ge1xuICAgICAgICBsZXQgYnV0dG9uVGV4dE1hcCA9IG9wdGlvbnNTdWJzZXQuYnV0dG9uVGV4dCB8fCB7fTtcbiAgICAgICAgbGV0IGJ1dHRvblRleHRLZXkgPSB2aWV3RGVmLmRlZmF1bHRzLmJ1dHRvblRleHRLZXk7XG4gICAgICAgIGlmIChidXR0b25UZXh0S2V5ICE9IG51bGwgJiYgYnV0dG9uVGV4dE1hcFtidXR0b25UZXh0S2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uVGV4dE1hcFtidXR0b25UZXh0S2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9uVGV4dE1hcFt2aWV3RGVmLnR5cGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25UZXh0TWFwW3ZpZXdEZWYudHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvblRleHRNYXBbc2luZ2xlVW5pdF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvblRleHRNYXBbc2luZ2xlVW5pdF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBsZXQgcXVlcnlCdXR0b25UaXRsZSA9IChvcHRpb25zU3Vic2V0KSA9PiB7XG4gICAgICAgIGxldCBidXR0b25IaW50cyA9IG9wdGlvbnNTdWJzZXQuYnV0dG9uSGludHMgfHwge307XG4gICAgICAgIGxldCBidXR0b25LZXkgPSB2aWV3RGVmLmRlZmF1bHRzLmJ1dHRvblRleHRLZXk7IC8vIHVzZSBzYW1lIGtleSBhcyB0ZXh0XG4gICAgICAgIGlmIChidXR0b25LZXkgIT0gbnVsbCAmJiBidXR0b25IaW50c1tidXR0b25LZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25IaW50c1tidXR0b25LZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidXR0b25IaW50c1t2aWV3RGVmLnR5cGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25IaW50c1t2aWV3RGVmLnR5cGVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidXR0b25IaW50c1tzaW5nbGVVbml0XSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uSGludHNbc2luZ2xlVW5pdF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB2aWV3RGVmLnR5cGUsXG4gICAgICAgIGNvbXBvbmVudDogdmlld0RlZi5jb21wb25lbnQsXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBkdXJhdGlvblVuaXQsXG4gICAgICAgIHNpbmdsZVVuaXQsXG4gICAgICAgIG9wdGlvbkRlZmF1bHRzOiB2aWV3RGVmLmRlZmF1bHRzLFxuICAgICAgICBvcHRpb25PdmVycmlkZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2luZ2xlVW5pdE92ZXJyaWRlcyksIHZpZXdEZWYub3ZlcnJpZGVzKSxcbiAgICAgICAgYnV0dG9uVGV4dE92ZXJyaWRlOiBxdWVyeUJ1dHRvblRleHQoZHluYW1pY09wdGlvbk92ZXJyaWRlcykgfHxcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25PdmVycmlkZXMpIHx8IC8vIGNvbnN0cnVjdG9yLXNwZWNpZmllZCBidXR0b25UZXh0IGxvb2t1cCBoYXNoIHRha2VzIHByZWNlZGVuY2VcbiAgICAgICAgICAgIHZpZXdEZWYub3ZlcnJpZGVzLmJ1dHRvblRleHQsXG4gICAgICAgIGJ1dHRvblRleHREZWZhdWx0OiBxdWVyeUJ1dHRvblRleHQobG9jYWxlRGVmYXVsdHMpIHx8XG4gICAgICAgICAgICB2aWV3RGVmLmRlZmF1bHRzLmJ1dHRvblRleHQgfHxcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChCQVNFX09QVElPTl9ERUZBVUxUUykgfHxcbiAgICAgICAgICAgIHZpZXdEZWYudHlwZSxcbiAgICAgICAgLy8gbm90IERSWVxuICAgICAgICBidXR0b25UaXRsZU92ZXJyaWRlOiBxdWVyeUJ1dHRvblRpdGxlKGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHx8XG4gICAgICAgICAgICBxdWVyeUJ1dHRvblRpdGxlKG9wdGlvbk92ZXJyaWRlcykgfHxcbiAgICAgICAgICAgIHZpZXdEZWYub3ZlcnJpZGVzLmJ1dHRvbkhpbnQsXG4gICAgICAgIGJ1dHRvblRpdGxlRGVmYXVsdDogcXVlcnlCdXR0b25UaXRsZShsb2NhbGVEZWZhdWx0cykgfHxcbiAgICAgICAgICAgIHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uSGludCB8fFxuICAgICAgICAgICAgcXVlcnlCdXR0b25UaXRsZShCQVNFX09QVElPTl9ERUZBVUxUUyksXG4gICAgICAgIC8vIHdpbGwgZXZlbnR1YWxseSBmYWxsIGJhY2sgdG8gYnV0dG9uVGV4dFxuICAgIH07XG59XG4vLyBoYWNrIHRvIGdldCBtZW1vaXphdGlvbiB3b3JraW5nXG5sZXQgZHVyYXRpb25JbnB1dE1hcCA9IHt9O1xuZnVuY3Rpb24gY3JlYXRlRHVyYXRpb25DYWNoZWQoZHVyYXRpb25JbnB1dCkge1xuICAgIGxldCBqc29uID0gSlNPTi5zdHJpbmdpZnkoZHVyYXRpb25JbnB1dCk7XG4gICAgbGV0IHJlcyA9IGR1cmF0aW9uSW5wdXRNYXBbanNvbl07XG4gICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcyA9IGNyZWF0ZUR1cmF0aW9uKGR1cmF0aW9uSW5wdXQpO1xuICAgICAgICBkdXJhdGlvbklucHV0TWFwW2pzb25dID0gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VWaWV3VHlwZSh2aWV3VHlwZSwgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdDSEFOR0VfVklFV19UWVBFJzpcbiAgICAgICAgICAgIHZpZXdUeXBlID0gYWN0aW9uLnZpZXdUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gdmlld1R5cGU7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZUR5bmFtaWNPcHRpb25PdmVycmlkZXMoZHluYW1pY09wdGlvbk92ZXJyaWRlcywgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdTRVRfT1BUSU9OJzpcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpLCB7IFthY3Rpb24ub3B0aW9uTmFtZV06IGFjdGlvbi5yYXdPcHRpb25WYWx1ZSB9KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlRGF0ZVByb2ZpbGUoY3VycmVudERhdGVQcm9maWxlLCBhY3Rpb24sIGN1cnJlbnREYXRlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcikge1xuICAgIGxldCBkcDtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgcmV0dXJuIGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGFjdGlvbi5kYXRlTWFya2VyIHx8IGN1cnJlbnREYXRlKTtcbiAgICAgICAgY2FzZSAnQ0hBTkdFX0RBVEUnOlxuICAgICAgICAgICAgcmV0dXJuIGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGFjdGlvbi5kYXRlTWFya2VyKTtcbiAgICAgICAgY2FzZSAnUFJFVic6XG4gICAgICAgICAgICBkcCA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkUHJldihjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlKTtcbiAgICAgICAgICAgIGlmIChkcC5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ05FWFQnOlxuICAgICAgICAgICAgZHAgPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZE5leHQoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSk7XG4gICAgICAgICAgICBpZiAoZHAuaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudERhdGVQcm9maWxlO1xufVxuXG5mdW5jdGlvbiBpbml0RXZlbnRTb3VyY2VzKGNhbGVuZGFyT3B0aW9ucywgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBsZXQgYWN0aXZlUmFuZ2UgPSBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbDtcbiAgICByZXR1cm4gYWRkU291cmNlcyh7fSwgcGFyc2VJbml0aWFsU291cmNlcyhjYWxlbmRhck9wdGlvbnMsIGNvbnRleHQpLCBhY3RpdmVSYW5nZSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiByZWR1Y2VFdmVudFNvdXJjZXMoZXZlbnRTb3VyY2VzLCBhY3Rpb24sIGRhdGVQcm9maWxlLCBjb250ZXh0KSB7XG4gICAgbGV0IGFjdGl2ZVJhbmdlID0gZGF0ZVByb2ZpbGUgPyBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSA6IG51bGw7IC8vIG5lZWQgdGhpcyBjaGVjaz9cbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0FERF9FVkVOVF9TT1VSQ0VTJzogLy8gYWxyZWFkeSBwYXJzZWRcbiAgICAgICAgICAgIHJldHVybiBhZGRTb3VyY2VzKGV2ZW50U291cmNlcywgYWN0aW9uLnNvdXJjZXMsIGFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0VWRU5UX1NPVVJDRSc6XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlU291cmNlKGV2ZW50U291cmNlcywgYWN0aW9uLnNvdXJjZUlkKTtcbiAgICAgICAgY2FzZSAnUFJFVic6IC8vIFRPRE86IGhvdyBkbyB3ZSB0cmFjayBhbGwgYWN0aW9ucyB0aGF0IGFmZmVjdCBkYXRlUHJvZmlsZSA6KFxuICAgICAgICBjYXNlICdORVhUJzpcbiAgICAgICAgY2FzZSAnQ0hBTkdFX0RBVEUnOlxuICAgICAgICBjYXNlICdDSEFOR0VfVklFV19UWVBFJzpcbiAgICAgICAgICAgIGlmIChkYXRlUHJvZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaERpcnR5U291cmNlcyhldmVudFNvdXJjZXMsIGFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBldmVudFNvdXJjZXM7XG4gICAgICAgIGNhc2UgJ0ZFVENIX0VWRU5UX1NPVVJDRVMnOlxuICAgICAgICAgICAgcmV0dXJuIGZldGNoU291cmNlc0J5SWRzKGV2ZW50U291cmNlcywgYWN0aW9uLnNvdXJjZUlkcyA/IC8vIHdoeSBubyB0eXBlP1xuICAgICAgICAgICAgICAgIGFycmF5VG9IYXNoKGFjdGlvbi5zb3VyY2VJZHMpIDpcbiAgICAgICAgICAgICAgICBleGNsdWRlU3RhdGljU291cmNlcyhldmVudFNvdXJjZXMsIGNvbnRleHQpLCBhY3RpdmVSYW5nZSwgYWN0aW9uLmlzUmVmZXRjaCB8fCBmYWxzZSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ1JFQ0VJVkVfRVZFTlRTJzpcbiAgICAgICAgY2FzZSAnUkVDRUlWRV9FVkVOVF9FUlJPUic6XG4gICAgICAgICAgICByZXR1cm4gcmVjZWl2ZVJlc3BvbnNlKGV2ZW50U291cmNlcywgYWN0aW9uLnNvdXJjZUlkLCBhY3Rpb24uZmV0Y2hJZCwgYWN0aW9uLmZldGNoUmFuZ2UpO1xuICAgICAgICBjYXNlICdSRU1PVkVfQUxMX0VWRU5UX1NPVVJDRVMnOlxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50U291cmNlcztcbiAgICB9XG59XG5mdW5jdGlvbiByZWR1Y2VFdmVudFNvdXJjZXNOZXdUaW1lWm9uZShldmVudFNvdXJjZXMsIGRhdGVQcm9maWxlLCBjb250ZXh0KSB7XG4gICAgbGV0IGFjdGl2ZVJhbmdlID0gZGF0ZVByb2ZpbGUgPyBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSA6IG51bGw7IC8vIG5lZWQgdGhpcyBjaGVjaz9cbiAgICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoZXZlbnRTb3VyY2VzLCBleGNsdWRlU3RhdGljU291cmNlcyhldmVudFNvdXJjZXMsIGNvbnRleHQpLCBhY3RpdmVSYW5nZSwgdHJ1ZSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiBjb21wdXRlRXZlbnRTb3VyY2VzTG9hZGluZyhldmVudFNvdXJjZXMpIHtcbiAgICBmb3IgKGxldCBzb3VyY2VJZCBpbiBldmVudFNvdXJjZXMpIHtcbiAgICAgICAgaWYgKGV2ZW50U291cmNlc1tzb3VyY2VJZF0uaXNGZXRjaGluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYWRkU291cmNlcyhldmVudFNvdXJjZUhhc2gsIHNvdXJjZXMsIGZldGNoUmFuZ2UsIGNvbnRleHQpIHtcbiAgICBsZXQgaGFzaCA9IHt9O1xuICAgIGZvciAobGV0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgICAgIGhhc2hbc291cmNlLnNvdXJjZUlkXSA9IHNvdXJjZTtcbiAgICB9XG4gICAgaWYgKGZldGNoUmFuZ2UpIHtcbiAgICAgICAgaGFzaCA9IGZldGNoRGlydHlTb3VyY2VzKGhhc2gsIGZldGNoUmFuZ2UsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudFNvdXJjZUhhc2gpLCBoYXNoKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVNvdXJjZShldmVudFNvdXJjZUhhc2gsIHNvdXJjZUlkKSB7XG4gICAgcmV0dXJuIGZpbHRlckhhc2goZXZlbnRTb3VyY2VIYXNoLCAoZXZlbnRTb3VyY2UpID0+IGV2ZW50U291cmNlLnNvdXJjZUlkICE9PSBzb3VyY2VJZCk7XG59XG5mdW5jdGlvbiBmZXRjaERpcnR5U291cmNlcyhzb3VyY2VIYXNoLCBmZXRjaFJhbmdlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZldGNoU291cmNlc0J5SWRzKHNvdXJjZUhhc2gsIGZpbHRlckhhc2goc291cmNlSGFzaCwgKGV2ZW50U291cmNlKSA9PiBpc1NvdXJjZURpcnR5KGV2ZW50U291cmNlLCBmZXRjaFJhbmdlLCBjb250ZXh0KSksIGZldGNoUmFuZ2UsIGZhbHNlLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGlzU291cmNlRGlydHkoZXZlbnRTb3VyY2UsIGZldGNoUmFuZ2UsIGNvbnRleHQpIHtcbiAgICBpZiAoIWRvZXNTb3VyY2VOZWVkUmFuZ2UoZXZlbnRTb3VyY2UsIGNvbnRleHQpKSB7XG4gICAgICAgIHJldHVybiAhZXZlbnRTb3VyY2UubGF0ZXN0RmV0Y2hJZDtcbiAgICB9XG4gICAgcmV0dXJuICFjb250ZXh0Lm9wdGlvbnMubGF6eUZldGNoaW5nIHx8XG4gICAgICAgICFldmVudFNvdXJjZS5mZXRjaFJhbmdlIHx8XG4gICAgICAgIGV2ZW50U291cmNlLmlzRmV0Y2hpbmcgfHwgLy8gYWx3YXlzIGNhbmNlbCBvdXRkYXRlZCBpbi1wcm9ncmVzcyBmZXRjaGVzXG4gICAgICAgIGZldGNoUmFuZ2Uuc3RhcnQgPCBldmVudFNvdXJjZS5mZXRjaFJhbmdlLnN0YXJ0IHx8XG4gICAgICAgIGZldGNoUmFuZ2UuZW5kID4gZXZlbnRTb3VyY2UuZmV0Y2hSYW5nZS5lbmQ7XG59XG5mdW5jdGlvbiBmZXRjaFNvdXJjZXNCeUlkcyhwcmV2U291cmNlcywgc291cmNlSWRIYXNoLCBmZXRjaFJhbmdlLCBpc1JlZmV0Y2gsIGNvbnRleHQpIHtcbiAgICBsZXQgbmV4dFNvdXJjZXMgPSB7fTtcbiAgICBmb3IgKGxldCBzb3VyY2VJZCBpbiBwcmV2U291cmNlcykge1xuICAgICAgICBsZXQgc291cmNlID0gcHJldlNvdXJjZXNbc291cmNlSWRdO1xuICAgICAgICBpZiAoc291cmNlSWRIYXNoW3NvdXJjZUlkXSkge1xuICAgICAgICAgICAgbmV4dFNvdXJjZXNbc291cmNlSWRdID0gZmV0Y2hTb3VyY2Uoc291cmNlLCBmZXRjaFJhbmdlLCBpc1JlZmV0Y2gsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV4dFNvdXJjZXNbc291cmNlSWRdID0gc291cmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXh0U291cmNlcztcbn1cbmZ1bmN0aW9uIGZldGNoU291cmNlKGV2ZW50U291cmNlLCBmZXRjaFJhbmdlLCBpc1JlZmV0Y2gsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBvcHRpb25zLCBjYWxlbmRhckFwaSB9ID0gY29udGV4dDtcbiAgICBsZXQgc291cmNlRGVmID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZURlZnNbZXZlbnRTb3VyY2Uuc291cmNlRGVmSWRdO1xuICAgIGxldCBmZXRjaElkID0gZ3VpZCgpO1xuICAgIHNvdXJjZURlZi5mZXRjaCh7XG4gICAgICAgIGV2ZW50U291cmNlLFxuICAgICAgICByYW5nZTogZmV0Y2hSYW5nZSxcbiAgICAgICAgaXNSZWZldGNoLFxuICAgICAgICBjb250ZXh0LFxuICAgIH0sIChyZXMpID0+IHtcbiAgICAgICAgbGV0IHsgcmF3RXZlbnRzIH0gPSByZXM7XG4gICAgICAgIGlmIChvcHRpb25zLmV2ZW50U291cmNlU3VjY2Vzcykge1xuICAgICAgICAgICAgcmF3RXZlbnRzID0gb3B0aW9ucy5ldmVudFNvdXJjZVN1Y2Nlc3MuY2FsbChjYWxlbmRhckFwaSwgcmF3RXZlbnRzLCByZXMucmVzcG9uc2UpIHx8IHJhd0V2ZW50cztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRTb3VyY2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgcmF3RXZlbnRzID0gZXZlbnRTb3VyY2Uuc3VjY2Vzcy5jYWxsKGNhbGVuZGFyQXBpLCByYXdFdmVudHMsIHJlcy5yZXNwb25zZSkgfHwgcmF3RXZlbnRzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1JFQ0VJVkVfRVZFTlRTJyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiBldmVudFNvdXJjZS5zb3VyY2VJZCxcbiAgICAgICAgICAgIGZldGNoSWQsXG4gICAgICAgICAgICBmZXRjaFJhbmdlLFxuICAgICAgICAgICAgcmF3RXZlbnRzLFxuICAgICAgICB9KTtcbiAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgbGV0IGVycm9ySGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICBpZiAob3B0aW9ucy5ldmVudFNvdXJjZUZhaWx1cmUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZXZlbnRTb3VyY2VGYWlsdXJlLmNhbGwoY2FsZW5kYXJBcGksIGVycm9yKTtcbiAgICAgICAgICAgIGVycm9ySGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50U291cmNlLmZhaWx1cmUpIHtcbiAgICAgICAgICAgIGV2ZW50U291cmNlLmZhaWx1cmUoZXJyb3IpO1xuICAgICAgICAgICAgZXJyb3JIYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVycm9ySGFuZGxlZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGVycm9yLm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRUNFSVZFX0VWRU5UX0VSUk9SJyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiBldmVudFNvdXJjZS5zb3VyY2VJZCxcbiAgICAgICAgICAgIGZldGNoSWQsXG4gICAgICAgICAgICBmZXRjaFJhbmdlLFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50U291cmNlKSwgeyBpc0ZldGNoaW5nOiB0cnVlLCBsYXRlc3RGZXRjaElkOiBmZXRjaElkIH0pO1xufVxuZnVuY3Rpb24gcmVjZWl2ZVJlc3BvbnNlKHNvdXJjZUhhc2gsIHNvdXJjZUlkLCBmZXRjaElkLCBmZXRjaFJhbmdlKSB7XG4gICAgbGV0IGV2ZW50U291cmNlID0gc291cmNlSGFzaFtzb3VyY2VJZF07XG4gICAgaWYgKGV2ZW50U291cmNlICYmIC8vIG5vdCBhbHJlYWR5IHJlbW92ZWRcbiAgICAgICAgZmV0Y2hJZCA9PT0gZXZlbnRTb3VyY2UubGF0ZXN0RmV0Y2hJZCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzb3VyY2VIYXNoKSwgeyBbc291cmNlSWRdOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50U291cmNlKSwgeyBpc0ZldGNoaW5nOiBmYWxzZSwgZmV0Y2hSYW5nZSB9KSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZUhhc2g7XG59XG5mdW5jdGlvbiBleGNsdWRlU3RhdGljU291cmNlcyhldmVudFNvdXJjZXMsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZmlsdGVySGFzaChldmVudFNvdXJjZXMsIChldmVudFNvdXJjZSkgPT4gZG9lc1NvdXJjZU5lZWRSYW5nZShldmVudFNvdXJjZSwgY29udGV4dCkpO1xufVxuZnVuY3Rpb24gcGFyc2VJbml0aWFsU291cmNlcyhyYXdPcHRpb25zLCBjb250ZXh0KSB7XG4gICAgbGV0IHJlZmluZXJzID0gYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzKGNvbnRleHQpO1xuICAgIGxldCByYXdTb3VyY2VzID0gW10uY29uY2F0KHJhd09wdGlvbnMuZXZlbnRTb3VyY2VzIHx8IFtdKTtcbiAgICBsZXQgc291cmNlcyA9IFtdOyAvLyBwYXJzZWRcbiAgICBpZiAocmF3T3B0aW9ucy5pbml0aWFsRXZlbnRzKSB7XG4gICAgICAgIHJhd1NvdXJjZXMudW5zaGlmdChyYXdPcHRpb25zLmluaXRpYWxFdmVudHMpO1xuICAgIH1cbiAgICBpZiAocmF3T3B0aW9ucy5ldmVudHMpIHtcbiAgICAgICAgcmF3U291cmNlcy51bnNoaWZ0KHJhd09wdGlvbnMuZXZlbnRzKTtcbiAgICB9XG4gICAgZm9yIChsZXQgcmF3U291cmNlIG9mIHJhd1NvdXJjZXMpIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IHBhcnNlRXZlbnRTb3VyY2UocmF3U291cmNlLCBjb250ZXh0LCByZWZpbmVycyk7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VzO1xufVxuZnVuY3Rpb24gZG9lc1NvdXJjZU5lZWRSYW5nZShldmVudFNvdXJjZSwgY29udGV4dCkge1xuICAgIGxldCBkZWZzID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZURlZnM7XG4gICAgcmV0dXJuICFkZWZzW2V2ZW50U291cmNlLnNvdXJjZURlZklkXS5pZ25vcmVSYW5nZTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlRGF0ZVNlbGVjdGlvbihjdXJyZW50U2VsZWN0aW9uLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1VOU0VMRUNUX0RBVEVTJzpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlICdTRUxFQ1RfREFURVMnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5zZWxlY3Rpb247XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFNlbGVjdGlvbjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZVNlbGVjdGVkRXZlbnQoY3VycmVudEluc3RhbmNlSWQsIGFjdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnVU5TRUxFQ1RfRVZFTlQnOlxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICBjYXNlICdTRUxFQ1RfRVZFTlQnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5ldmVudEluc3RhbmNlSWQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEluc3RhbmNlSWQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2VFdmVudERyYWcoY3VycmVudERyYWcsIGFjdGlvbikge1xuICAgIGxldCBuZXdEcmFnO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnVU5TRVRfRVZFTlRfRFJBRyc6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAnU0VUX0VWRU5UX0RSQUcnOlxuICAgICAgICAgICAgbmV3RHJhZyA9IGFjdGlvbi5zdGF0ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IG5ld0RyYWcuYWZmZWN0ZWRFdmVudHMsXG4gICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogbmV3RHJhZy5tdXRhdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IG5ld0RyYWcuaXNFdmVudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudERyYWc7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2VFdmVudFJlc2l6ZShjdXJyZW50UmVzaXplLCBhY3Rpb24pIHtcbiAgICBsZXQgbmV3UmVzaXplO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnVU5TRVRfRVZFTlRfUkVTSVpFJzpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlICdTRVRfRVZFTlRfUkVTSVpFJzpcbiAgICAgICAgICAgIG5ld1Jlc2l6ZSA9IGFjdGlvbi5zdGF0ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IG5ld1Jlc2l6ZS5hZmZlY3RlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBuZXdSZXNpemUubXV0YXRlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiBuZXdSZXNpemUuaXNFdmVudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFJlc2l6ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlVG9vbGJhcnMoY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIHtcbiAgICBsZXQgaGVhZGVyID0gY2FsZW5kYXJPcHRpb25zLmhlYWRlclRvb2xiYXIgPyBwYXJzZVRvb2xiYXIoY2FsZW5kYXJPcHRpb25zLmhlYWRlclRvb2xiYXIsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSA6IG51bGw7XG4gICAgbGV0IGZvb3RlciA9IGNhbGVuZGFyT3B0aW9ucy5mb290ZXJUb29sYmFyID8gcGFyc2VUb29sYmFyKGNhbGVuZGFyT3B0aW9ucy5mb290ZXJUb29sYmFyLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkgOiBudWxsO1xuICAgIHJldHVybiB7IGhlYWRlciwgZm9vdGVyIH07XG59XG5mdW5jdGlvbiBwYXJzZVRvb2xiYXIoc2VjdGlvblN0ckhhc2gsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSB7XG4gICAgbGV0IHNlY3Rpb25XaWRnZXRzID0ge307XG4gICAgbGV0IHZpZXdzV2l0aEJ1dHRvbnMgPSBbXTtcbiAgICBsZXQgaGFzVGl0bGUgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBzZWN0aW9uTmFtZSBpbiBzZWN0aW9uU3RySGFzaCkge1xuICAgICAgICBsZXQgc2VjdGlvblN0ciA9IHNlY3Rpb25TdHJIYXNoW3NlY3Rpb25OYW1lXTtcbiAgICAgICAgbGV0IHNlY3Rpb25SZXMgPSBwYXJzZVNlY3Rpb24oc2VjdGlvblN0ciwgY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpO1xuICAgICAgICBzZWN0aW9uV2lkZ2V0c1tzZWN0aW9uTmFtZV0gPSBzZWN0aW9uUmVzLndpZGdldHM7XG4gICAgICAgIHZpZXdzV2l0aEJ1dHRvbnMucHVzaCguLi5zZWN0aW9uUmVzLnZpZXdzV2l0aEJ1dHRvbnMpO1xuICAgICAgICBoYXNUaXRsZSA9IGhhc1RpdGxlIHx8IHNlY3Rpb25SZXMuaGFzVGl0bGU7XG4gICAgfVxuICAgIHJldHVybiB7IHNlY3Rpb25XaWRnZXRzLCB2aWV3c1dpdGhCdXR0b25zLCBoYXNUaXRsZSB9O1xufVxuLypcbkJBRDogcXVlcnlpbmcgaWNvbnMgYW5kIHRleHQgaGVyZS4gc2hvdWxkIGJlIGRvbmUgYXQgcmVuZGVyIHRpbWVcbiovXG5mdW5jdGlvbiBwYXJzZVNlY3Rpb24oc2VjdGlvblN0ciwgY2FsZW5kYXJPcHRpb25zLCAvLyBkZWZhdWx0cytvdmVycmlkZXMsIHRoZW4gcmVmaW5lZFxuY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIC8vIG92ZXJyaWRlcyBvbmx5ISwgdW5yZWZpbmVkIDooXG50aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkge1xuICAgIGxldCBpc1J0bCA9IGNhbGVuZGFyT3B0aW9ucy5kaXJlY3Rpb24gPT09ICdydGwnO1xuICAgIGxldCBjYWxlbmRhckN1c3RvbUJ1dHRvbnMgPSBjYWxlbmRhck9wdGlvbnMuY3VzdG9tQnV0dG9ucyB8fCB7fTtcbiAgICBsZXQgY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzID0gY2FsZW5kYXJPcHRpb25PdmVycmlkZXMuYnV0dG9uVGV4dCB8fCB7fTtcbiAgICBsZXQgY2FsZW5kYXJCdXR0b25UZXh0ID0gY2FsZW5kYXJPcHRpb25zLmJ1dHRvblRleHQgfHwge307XG4gICAgbGV0IGNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlcyA9IGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLmJ1dHRvbkhpbnRzIHx8IHt9O1xuICAgIGxldCBjYWxlbmRhckJ1dHRvbkhpbnRzID0gY2FsZW5kYXJPcHRpb25zLmJ1dHRvbkhpbnRzIHx8IHt9O1xuICAgIGxldCBzZWN0aW9uU3Vic3RycyA9IHNlY3Rpb25TdHIgPyBzZWN0aW9uU3RyLnNwbGl0KCcgJykgOiBbXTtcbiAgICBsZXQgdmlld3NXaXRoQnV0dG9ucyA9IFtdO1xuICAgIGxldCBoYXNUaXRsZSA9IGZhbHNlO1xuICAgIGxldCB3aWRnZXRzID0gc2VjdGlvblN1YnN0cnMubWFwKChidXR0b25Hcm91cFN0cikgPT4gKGJ1dHRvbkdyb3VwU3RyLnNwbGl0KCcsJykubWFwKChidXR0b25OYW1lKSA9PiB7XG4gICAgICAgIGlmIChidXR0b25OYW1lID09PSAndGl0bGUnKSB7XG4gICAgICAgICAgICBoYXNUaXRsZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4geyBidXR0b25OYW1lIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1c3RvbUJ1dHRvblByb3BzO1xuICAgICAgICBsZXQgdmlld1NwZWM7XG4gICAgICAgIGxldCBidXR0b25DbGljaztcbiAgICAgICAgbGV0IGJ1dHRvbkljb247IC8vIG9ubHkgb25lIG9mIHRoZXNlIHdpbGwgYmUgc2V0XG4gICAgICAgIGxldCBidXR0b25UZXh0OyAvLyBcIlxuICAgICAgICBsZXQgYnV0dG9uSGludDtcbiAgICAgICAgLy8gXiBmb3IgdGhlIHRpdGxlPVwiXCIgYXR0cmlidXRlLCBmb3IgYWNjZXNzaWJpbGl0eVxuICAgICAgICBpZiAoKGN1c3RvbUJ1dHRvblByb3BzID0gY2FsZW5kYXJDdXN0b21CdXR0b25zW2J1dHRvbk5hbWVdKSkge1xuICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSAoZXYpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tQnV0dG9uUHJvcHMuY2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tQnV0dG9uUHJvcHMuY2xpY2suY2FsbChldi50YXJnZXQsIGV2LCBldi50YXJnZXQpOyAvLyBUT0RPOiB1c2UgQ2FsZW5kYXIgdGhpcyBjb250ZXh0P1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEN1c3RvbUJ1dHRvbkljb25DbGFzcyhjdXN0b21CdXR0b25Qcm9wcykpIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gY3VzdG9tQnV0dG9uUHJvcHMudGV4dCk7XG4gICAgICAgICAgICBidXR0b25IaW50ID0gY3VzdG9tQnV0dG9uUHJvcHMuaGludCB8fCBjdXN0b21CdXR0b25Qcm9wcy50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh2aWV3U3BlYyA9IHZpZXdTcGVjc1tidXR0b25OYW1lXSkpIHtcbiAgICAgICAgICAgIHZpZXdzV2l0aEJ1dHRvbnMucHVzaChidXR0b25OYW1lKTtcbiAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyQXBpLmNoYW5nZVZpZXcoYnV0dG9uTmFtZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgKGJ1dHRvblRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0T3ZlcnJpZGUpIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gdmlld1NwZWMuYnV0dG9uVGV4dERlZmF1bHQpO1xuICAgICAgICAgICAgbGV0IHRleHRGYWxsYmFjayA9IHZpZXdTcGVjLmJ1dHRvblRleHRPdmVycmlkZSB8fFxuICAgICAgICAgICAgICAgIHZpZXdTcGVjLmJ1dHRvblRleHREZWZhdWx0O1xuICAgICAgICAgICAgYnV0dG9uSGludCA9IGZvcm1hdFdpdGhPcmRpbmFscyh2aWV3U3BlYy5idXR0b25UaXRsZU92ZXJyaWRlIHx8XG4gICAgICAgICAgICAgICAgdmlld1NwZWMuYnV0dG9uVGl0bGVEZWZhdWx0IHx8XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJPcHRpb25zLnZpZXdIaW50LCBbdGV4dEZhbGxiYWNrLCBidXR0b25OYW1lXSwgLy8gdmlldy1uYW1lID0gYnV0dG9uTmFtZVxuICAgICAgICAgICAgdGV4dEZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYWxlbmRhckFwaVtidXR0b25OYW1lXSkgeyAvLyBhIGNhbGVuZGFyQXBpIG1ldGhvZFxuICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJBcGlbYnV0dG9uTmFtZV0oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlc1tidXR0b25OYW1lXSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkpIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjYWxlbmRhckJ1dHRvblRleHRbYnV0dG9uTmFtZV0pOyAvLyBldmVyeXRoaW5nIGVsc2UgaXMgY29uc2lkZXJlZCBkZWZhdWx0XG4gICAgICAgICAgICBpZiAoYnV0dG9uTmFtZSA9PT0gJ3ByZXZZZWFyJyB8fCBidXR0b25OYW1lID09PSAnbmV4dFllYXInKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZXZPck5leHQgPSBidXR0b25OYW1lID09PSAncHJldlllYXInID8gJ3ByZXYnIDogJ25leHQnO1xuICAgICAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSBmb3JtYXRXaXRoT3JkaW5hbHMoY2FsZW5kYXJCdXR0b25IaW50T3ZlcnJpZGVzW3ByZXZPck5leHRdIHx8XG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uSGludHNbcHJldk9yTmV4dF0sIFtcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJCdXR0b25UZXh0LnllYXIgfHwgJ3llYXInLFxuICAgICAgICAgICAgICAgICAgICAneWVhcicsXG4gICAgICAgICAgICAgICAgXSwgY2FsZW5kYXJCdXR0b25UZXh0W2J1dHRvbk5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSAobmF2VW5pdCkgPT4gZm9ybWF0V2l0aE9yZGluYWxzKGNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlc1tidXR0b25OYW1lXSB8fFxuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhckJ1dHRvbkhpbnRzW2J1dHRvbk5hbWVdLCBbXG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uVGV4dFtuYXZVbml0XSB8fCBuYXZVbml0LFxuICAgICAgICAgICAgICAgICAgICBuYXZVbml0LFxuICAgICAgICAgICAgICAgIF0sIGNhbGVuZGFyQnV0dG9uVGV4dFtidXR0b25OYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgYnV0dG9uTmFtZSwgYnV0dG9uQ2xpY2ssIGJ1dHRvbkljb24sIGJ1dHRvblRleHQsIGJ1dHRvbkhpbnQgfTtcbiAgICB9KSkpO1xuICAgIHJldHVybiB7IHdpZGdldHMsIHZpZXdzV2l0aEJ1dHRvbnMsIGhhc1RpdGxlIH07XG59XG5cbi8vIGFsd2F5cyByZXByZXNlbnRzIHRoZSBjdXJyZW50IHZpZXcuIG90aGVyd2lzZSwgaXQnZCBuZWVkIHRvIGNoYW5nZSB2YWx1ZSBldmVyeSB0aW1lIGRhdGUgY2hhbmdlc1xuY2xhc3MgVmlld0ltcGwge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGdldEN1cnJlbnREYXRhLCBkYXRlRW52KSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudERhdGEgPSBnZXRDdXJyZW50RGF0YTtcbiAgICAgICAgdGhpcy5kYXRlRW52ID0gZGF0ZUVudjtcbiAgICB9XG4gICAgZ2V0IGNhbGVuZGFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLmNhbGVuZGFyQXBpO1xuICAgIH1cbiAgICBnZXQgdGl0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnREYXRhKCkudmlld1RpdGxlO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlU3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZS5zdGFydCk7XG4gICAgfVxuICAgIGdldCBhY3RpdmVFbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZS5lbmQpO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLmdldEN1cnJlbnREYXRhKCkuZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0KTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRFbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UuZW5kKTtcbiAgICB9XG4gICAgZ2V0T3B0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS5vcHRpb25zW25hbWVdOyAvLyBhcmUgdGhlIHZpZXctc3BlY2lmaWMgb3B0aW9uc1xuICAgIH1cbn1cblxubGV0IGV2ZW50U291cmNlRGVmJDIgPSB7XG4gICAgaWdub3JlUmFuZ2U6IHRydWUsXG4gICAgcGFyc2VNZXRhKHJlZmluZWQpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVmaW5lZC5ldmVudHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmaW5lZC5ldmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBmZXRjaChhcmcsIHN1Y2Nlc3NDYWxsYmFjaykge1xuICAgICAgICBzdWNjZXNzQ2FsbGJhY2soe1xuICAgICAgICAgICAgcmF3RXZlbnRzOiBhcmcuZXZlbnRTb3VyY2UubWV0YSxcbiAgICAgICAgfSk7XG4gICAgfSxcbn07XG5jb25zdCBhcnJheUV2ZW50U291cmNlUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnYXJyYXktZXZlbnQtc291cmNlJyxcbiAgICBldmVudFNvdXJjZURlZnM6IFtldmVudFNvdXJjZURlZiQyXSxcbn0pO1xuXG5sZXQgZXZlbnRTb3VyY2VEZWYkMSA9IHtcbiAgICBwYXJzZU1ldGEocmVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHJlZmluZWQuZXZlbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmaW5lZC5ldmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBmZXRjaChhcmcsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICBjb25zdCB7IGRhdGVFbnYgfSA9IGFyZy5jb250ZXh0O1xuICAgICAgICBjb25zdCBmdW5jID0gYXJnLmV2ZW50U291cmNlLm1ldGE7XG4gICAgICAgIHVucHJvbWlzaWZ5KGZ1bmMuYmluZChudWxsLCBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lKGFyZy5yYW5nZSwgZGF0ZUVudikpLCAocmF3RXZlbnRzKSA9PiBzdWNjZXNzQ2FsbGJhY2soeyByYXdFdmVudHMgfSksIGVycm9yQ2FsbGJhY2spO1xuICAgIH0sXG59O1xuY29uc3QgZnVuY0V2ZW50U291cmNlUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnZnVuYy1ldmVudC1zb3VyY2UnLFxuICAgIGV2ZW50U291cmNlRGVmczogW2V2ZW50U291cmNlRGVmJDFdLFxufSk7XG5cbmNvbnN0IEpTT05fRkVFRF9FVkVOVF9TT1VSQ0VfUkVGSU5FUlMgPSB7XG4gICAgbWV0aG9kOiBTdHJpbmcsXG4gICAgZXh0cmFQYXJhbXM6IGlkZW50aXR5LFxuICAgIHN0YXJ0UGFyYW06IFN0cmluZyxcbiAgICBlbmRQYXJhbTogU3RyaW5nLFxuICAgIHRpbWVab25lUGFyYW06IFN0cmluZyxcbn07XG5cbmxldCBldmVudFNvdXJjZURlZiA9IHtcbiAgICBwYXJzZU1ldGEocmVmaW5lZCkge1xuICAgICAgICBpZiAocmVmaW5lZC51cmwgJiYgKHJlZmluZWQuZm9ybWF0ID09PSAnanNvbicgfHwgIXJlZmluZWQuZm9ybWF0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6IHJlZmluZWQudXJsLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2pzb24nLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogKHJlZmluZWQubWV0aG9kIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgICAgIGV4dHJhUGFyYW1zOiByZWZpbmVkLmV4dHJhUGFyYW1zLFxuICAgICAgICAgICAgICAgIHN0YXJ0UGFyYW06IHJlZmluZWQuc3RhcnRQYXJhbSxcbiAgICAgICAgICAgICAgICBlbmRQYXJhbTogcmVmaW5lZC5lbmRQYXJhbSxcbiAgICAgICAgICAgICAgICB0aW1lWm9uZVBhcmFtOiByZWZpbmVkLnRpbWVab25lUGFyYW0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZmV0Y2goYXJnLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgeyBtZXRhIH0gPSBhcmcuZXZlbnRTb3VyY2U7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RQYXJhbXMgPSBidWlsZFJlcXVlc3RQYXJhbXMobWV0YSwgYXJnLnJhbmdlLCBhcmcuY29udGV4dCk7XG4gICAgICAgIHJlcXVlc3RKc29uKG1ldGEubWV0aG9kLCBtZXRhLnVybCwgcmVxdWVzdFBhcmFtcykudGhlbigoW3Jhd0V2ZW50cywgcmVzcG9uc2VdKSA9PiB7XG4gICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2soeyByYXdFdmVudHMsIHJlc3BvbnNlIH0pO1xuICAgICAgICB9LCBlcnJvckNhbGxiYWNrKTtcbiAgICB9LFxufTtcbmNvbnN0IGpzb25GZWVkRXZlbnRTb3VyY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdqc29uLWV2ZW50LXNvdXJjZScsXG4gICAgZXZlbnRTb3VyY2VSZWZpbmVyczogSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyxcbiAgICBldmVudFNvdXJjZURlZnM6IFtldmVudFNvdXJjZURlZl0sXG59KTtcbmZ1bmN0aW9uIGJ1aWxkUmVxdWVzdFBhcmFtcyhtZXRhLCByYW5nZSwgY29udGV4dCkge1xuICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHN0YXJ0UGFyYW07XG4gICAgbGV0IGVuZFBhcmFtO1xuICAgIGxldCB0aW1lWm9uZVBhcmFtO1xuICAgIGxldCBjdXN0b21SZXF1ZXN0UGFyYW1zO1xuICAgIGxldCBwYXJhbXMgPSB7fTtcbiAgICBzdGFydFBhcmFtID0gbWV0YS5zdGFydFBhcmFtO1xuICAgIGlmIChzdGFydFBhcmFtID09IG51bGwpIHtcbiAgICAgICAgc3RhcnRQYXJhbSA9IG9wdGlvbnMuc3RhcnRQYXJhbTtcbiAgICB9XG4gICAgZW5kUGFyYW0gPSBtZXRhLmVuZFBhcmFtO1xuICAgIGlmIChlbmRQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgIGVuZFBhcmFtID0gb3B0aW9ucy5lbmRQYXJhbTtcbiAgICB9XG4gICAgdGltZVpvbmVQYXJhbSA9IG1ldGEudGltZVpvbmVQYXJhbTtcbiAgICBpZiAodGltZVpvbmVQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgIHRpbWVab25lUGFyYW0gPSBvcHRpb25zLnRpbWVab25lUGFyYW07XG4gICAgfVxuICAgIC8vIHJldHJpZXZlIGFueSBvdXRib3VuZCBHRVQvUE9TVCBkYXRhIGZyb20gdGhlIG9wdGlvbnNcbiAgICBpZiAodHlwZW9mIG1ldGEuZXh0cmFQYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gc3VwcGxpZWQgYXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBrZXkvdmFsdWUgb2JqZWN0XG4gICAgICAgIGN1c3RvbVJlcXVlc3RQYXJhbXMgPSBtZXRhLmV4dHJhUGFyYW1zKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBwcm9iYWJseSBzdXBwbGllZCBhcyBhIHN0cmFpZ2h0IGtleS92YWx1ZSBvYmplY3RcbiAgICAgICAgY3VzdG9tUmVxdWVzdFBhcmFtcyA9IG1ldGEuZXh0cmFQYXJhbXMgfHwge307XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24ocGFyYW1zLCBjdXN0b21SZXF1ZXN0UGFyYW1zKTtcbiAgICBwYXJhbXNbc3RhcnRQYXJhbV0gPSBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5zdGFydCk7XG4gICAgcGFyYW1zW2VuZFBhcmFtXSA9IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLmVuZCk7XG4gICAgaWYgKGRhdGVFbnYudGltZVpvbmUgIT09ICdsb2NhbCcpIHtcbiAgICAgICAgcGFyYW1zW3RpbWVab25lUGFyYW1dID0gZGF0ZUVudi50aW1lWm9uZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbn1cblxuY29uc3QgU0lNUExFX1JFQ1VSUklOR19SRUZJTkVSUyA9IHtcbiAgICBkYXlzT2ZXZWVrOiBpZGVudGl0eSxcbiAgICBzdGFydFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGVuZFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzdGFydFJlY3VyOiBpZGVudGl0eSxcbiAgICBlbmRSZWN1cjogaWRlbnRpdHksXG59O1xuXG5sZXQgcmVjdXJyaW5nID0ge1xuICAgIHBhcnNlKHJlZmluZWQsIGRhdGVFbnYpIHtcbiAgICAgICAgaWYgKHJlZmluZWQuZGF5c09mV2VlayB8fCByZWZpbmVkLnN0YXJ0VGltZSB8fCByZWZpbmVkLmVuZFRpbWUgfHwgcmVmaW5lZC5zdGFydFJlY3VyIHx8IHJlZmluZWQuZW5kUmVjdXIpIHtcbiAgICAgICAgICAgIGxldCByZWN1cnJpbmdEYXRhID0ge1xuICAgICAgICAgICAgICAgIGRheXNPZldlZWs6IHJlZmluZWQuZGF5c09mV2VlayB8fCBudWxsLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogcmVmaW5lZC5zdGFydFRpbWUgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBlbmRUaW1lOiByZWZpbmVkLmVuZFRpbWUgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBzdGFydFJlY3VyOiByZWZpbmVkLnN0YXJ0UmVjdXIgPyBkYXRlRW52LmNyZWF0ZU1hcmtlcihyZWZpbmVkLnN0YXJ0UmVjdXIpIDogbnVsbCxcbiAgICAgICAgICAgICAgICBlbmRSZWN1cjogcmVmaW5lZC5lbmRSZWN1ciA/IGRhdGVFbnYuY3JlYXRlTWFya2VyKHJlZmluZWQuZW5kUmVjdXIpIDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgZHVyYXRpb247XG4gICAgICAgICAgICBpZiAocmVmaW5lZC5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gcmVmaW5lZC5kdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZHVyYXRpb24gJiYgcmVmaW5lZC5zdGFydFRpbWUgJiYgcmVmaW5lZC5lbmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSBzdWJ0cmFjdER1cmF0aW9ucyhyZWZpbmVkLmVuZFRpbWUsIHJlZmluZWQuc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWxsRGF5R3Vlc3M6IEJvb2xlYW4oIXJlZmluZWQuc3RhcnRUaW1lICYmICFyZWZpbmVkLmVuZFRpbWUpLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHR5cGVEYXRhOiByZWN1cnJpbmdEYXRhLCAvLyBkb2Vzbid0IG5lZWQgZW5kVGltZSBhbnltb3JlIGJ1dCBvaCB3ZWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZXhwYW5kKHR5cGVEYXRhLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYpIHtcbiAgICAgICAgbGV0IGNsaXBwZWRGcmFtaW5nUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoZnJhbWluZ1JhbmdlLCB7IHN0YXJ0OiB0eXBlRGF0YS5zdGFydFJlY3VyLCBlbmQ6IHR5cGVEYXRhLmVuZFJlY3VyIH0pO1xuICAgICAgICBpZiAoY2xpcHBlZEZyYW1pbmdSYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGFuZFJhbmdlcyh0eXBlRGF0YS5kYXlzT2ZXZWVrLCB0eXBlRGF0YS5zdGFydFRpbWUsIGNsaXBwZWRGcmFtaW5nUmFuZ2UsIGRhdGVFbnYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxufTtcbmNvbnN0IHNpbXBsZVJlY3VycmluZ0V2ZW50c1BsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ3NpbXBsZS1yZWN1cnJpbmctZXZlbnQnLFxuICAgIHJlY3VycmluZ1R5cGVzOiBbcmVjdXJyaW5nXSxcbiAgICBldmVudFJlZmluZXJzOiBTSU1QTEVfUkVDVVJSSU5HX1JFRklORVJTLFxufSk7XG5mdW5jdGlvbiBleHBhbmRSYW5nZXMoZGF5c09mV2Vlaywgc3RhcnRUaW1lLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYpIHtcbiAgICBsZXQgZG93SGFzaCA9IGRheXNPZldlZWsgPyBhcnJheVRvSGFzaChkYXlzT2ZXZWVrKSA6IG51bGw7XG4gICAgbGV0IGRheU1hcmtlciA9IHN0YXJ0T2ZEYXkoZnJhbWluZ1JhbmdlLnN0YXJ0KTtcbiAgICBsZXQgZW5kTWFya2VyID0gZnJhbWluZ1JhbmdlLmVuZDtcbiAgICBsZXQgaW5zdGFuY2VTdGFydHMgPSBbXTtcbiAgICB3aGlsZSAoZGF5TWFya2VyIDwgZW5kTWFya2VyKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZVN0YXJ0O1xuICAgICAgICAvLyBpZiBldmVyeWRheSwgb3IgdGhpcyBwYXJ0aWN1bGFyIGRheS1vZi13ZWVrXG4gICAgICAgIGlmICghZG93SGFzaCB8fCBkb3dIYXNoW2RheU1hcmtlci5nZXRVVENEYXkoKV0pIHtcbiAgICAgICAgICAgIGlmIChzdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVN0YXJ0ID0gZGF0ZUVudi5hZGQoZGF5TWFya2VyLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VTdGFydCA9IGRheU1hcmtlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RhbmNlU3RhcnRzLnB1c2goaW5zdGFuY2VTdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF5TWFya2VyID0gYWRkRGF5cyhkYXlNYXJrZXIsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2VTdGFydHM7XG59XG5cbmNvbnN0IGNoYW5nZUhhbmRsZXJQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdjaGFuZ2UtaGFuZGxlcicsXG4gICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IHtcbiAgICAgICAgZXZlbnRzKGV2ZW50cywgY29udGV4dCkge1xuICAgICAgICAgICAgaGFuZGxlRXZlbnRTb3VyY2VzKFtldmVudHNdLCBjb250ZXh0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZXZlbnRTb3VyY2VzOiBoYW5kbGVFdmVudFNvdXJjZXMsXG4gICAgfSxcbn0pO1xuLypcbkJVRzogaWYgYGV2ZW50YCB3YXMgc3VwcGxpZWQsIGFsbCBwcmV2aW91c2x5LWdpdmVuIGBldmVudFNvdXJjZXNgIHdpbGwgYmUgd2lwZWQgb3V0XG4qL1xuZnVuY3Rpb24gaGFuZGxlRXZlbnRTb3VyY2VzKGlucHV0cywgY29udGV4dCkge1xuICAgIGxldCB1bmZvdW5kU291cmNlcyA9IGhhc2hWYWx1ZXNUb0FycmF5KGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5ldmVudFNvdXJjZXMpO1xuICAgIGlmICh1bmZvdW5kU291cmNlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgaW5wdXRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KHVuZm91bmRTb3VyY2VzWzBdLl9yYXcpICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkoaW5wdXRzWzBdKSkge1xuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRVNFVF9SQVdfRVZFTlRTJyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiB1bmZvdW5kU291cmNlc1swXS5zb3VyY2VJZCxcbiAgICAgICAgICAgIHJhd0V2ZW50czogaW5wdXRzWzBdLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbmV3SW5wdXRzID0gW107XG4gICAgZm9yIChsZXQgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgICAgIGxldCBpbnB1dEZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5mb3VuZFNvdXJjZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICh1bmZvdW5kU291cmNlc1tpXS5fcmF3ID09PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIHVuZm91bmRTb3VyY2VzLnNwbGljZShpLCAxKTsgLy8gZGVsZXRlXG4gICAgICAgICAgICAgICAgaW5wdXRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbnB1dEZvdW5kKSB7XG4gICAgICAgICAgICBuZXdJbnB1dHMucHVzaChpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgdW5mb3VuZFNvdXJjZSBvZiB1bmZvdW5kU291cmNlcykge1xuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRfU09VUkNFJyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiB1bmZvdW5kU291cmNlLnNvdXJjZUlkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChsZXQgbmV3SW5wdXQgb2YgbmV3SW5wdXRzKSB7XG4gICAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkuYWRkRXZlbnRTb3VyY2UobmV3SW5wdXQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRGF0ZVByb2ZpbGUoZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZGF0ZXNTZXQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGNvbnRleHQuZGF0ZUVudikpLCB7IHZpZXc6IGNvbnRleHQudmlld0FwaSB9KSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgY29udGV4dCkge1xuICAgIGxldCB7IGVtaXR0ZXIgfSA9IGNvbnRleHQ7XG4gICAgaWYgKGVtaXR0ZXIuaGFzSGFuZGxlcnMoJ2V2ZW50c1NldCcpKSB7XG4gICAgICAgIGVtaXR0ZXIudHJpZ2dlcignZXZlbnRzU2V0JywgYnVpbGRFdmVudEFwaXMoZXZlbnRTdG9yZSwgY29udGV4dCkpO1xuICAgIH1cbn1cblxuLypcbnRoaXMgYXJyYXkgaXMgZXhwb3NlZCBvbiB0aGUgcm9vdCBuYW1lc3BhY2Ugc28gdGhhdCBVTUQgcGx1Z2lucyBjYW4gYWRkIHRvIGl0Llxuc2VlIHRoZSByb2xsdXAtYnVuZGxlcyBzY3JpcHQuXG4qL1xuY29uc3QgZ2xvYmFsUGx1Z2lucyA9IFtcbiAgICBhcnJheUV2ZW50U291cmNlUGx1Z2luLFxuICAgIGZ1bmNFdmVudFNvdXJjZVBsdWdpbixcbiAgICBqc29uRmVlZEV2ZW50U291cmNlUGx1Z2luLFxuICAgIHNpbXBsZVJlY3VycmluZ0V2ZW50c1BsdWdpbixcbiAgICBjaGFuZ2VIYW5kbGVyUGx1Z2luLFxuICAgIGNyZWF0ZVBsdWdpbih7XG4gICAgICAgIG5hbWU6ICdtaXNjJyxcbiAgICAgICAgaXNMb2FkaW5nRnVuY3M6IFtcbiAgICAgICAgICAgIChzdGF0ZSkgPT4gY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmcoc3RhdGUuZXZlbnRTb3VyY2VzKSxcbiAgICAgICAgXSxcbiAgICAgICAgcHJvcFNldEhhbmRsZXJzOiB7XG4gICAgICAgICAgICBkYXRlUHJvZmlsZTogaGFuZGxlRGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICBldmVudFN0b3JlOiBoYW5kbGVFdmVudFN0b3JlLFxuICAgICAgICB9LFxuICAgIH0pLFxuXTtcblxuY2xhc3MgVGFza1J1bm5lciB7XG4gICAgY29uc3RydWN0b3IocnVuVGFza09wdGlvbiwgZHJhaW5lZE9wdGlvbikge1xuICAgICAgICB0aGlzLnJ1blRhc2tPcHRpb24gPSBydW5UYXNrT3B0aW9uO1xuICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24gPSBkcmFpbmVkT3B0aW9uO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuZGVsYXllZFJ1bm5lciA9IG5ldyBEZWxheWVkUnVubmVyKHRoaXMuZHJhaW4uYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIHJlcXVlc3QodGFzaywgZGVsYXkpIHtcbiAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHRhc2spO1xuICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucmVxdWVzdChkZWxheSk7XG4gICAgfVxuICAgIHBhdXNlKHNjb3BlKSB7XG4gICAgICAgIHRoaXMuZGVsYXllZFJ1bm5lci5wYXVzZShzY29wZSk7XG4gICAgfVxuICAgIHJlc3VtZShzY29wZSwgZm9yY2UpIHtcbiAgICAgICAgdGhpcy5kZWxheWVkUnVubmVyLnJlc3VtZShzY29wZSwgZm9yY2UpO1xuICAgIH1cbiAgICBkcmFpbigpIHtcbiAgICAgICAgbGV0IHsgcXVldWUgfSA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjb21wbGV0ZWRUYXNrcyA9IFtdO1xuICAgICAgICAgICAgbGV0IHRhc2s7XG4gICAgICAgICAgICB3aGlsZSAoKHRhc2sgPSBxdWV1ZS5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucnVuVGFzayh0YXNrKTtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWRUYXNrcy5wdXNoKHRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kcmFpbmVkKGNvbXBsZXRlZFRhc2tzKTtcbiAgICAgICAgfSAvLyBrZWVwIGdvaW5nLCBpbiBjYXNlIG5ldyB0YXNrcyB3ZXJlIGFkZGVkIGluIHRoZSBkcmFpbmVkIGhhbmRsZXJcbiAgICB9XG4gICAgcnVuVGFzayh0YXNrKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1blRhc2tPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucnVuVGFza09wdGlvbih0YXNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmFpbmVkKGNvbXBsZXRlZFRhc2tzKSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWluZWRPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZHJhaW5lZE9wdGlvbihjb21wbGV0ZWRUYXNrcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIENvbXB1dGVzIHdoYXQgdGhlIHRpdGxlIGF0IHRoZSB0b3Agb2YgdGhlIGNhbGVuZGFyQXBpIHNob3VsZCBiZSBmb3IgdGhpcyB2aWV3XG5mdW5jdGlvbiBidWlsZFRpdGxlKGRhdGVQcm9maWxlLCB2aWV3T3B0aW9ucywgZGF0ZUVudikge1xuICAgIGxldCByYW5nZTtcbiAgICAvLyBmb3Igdmlld3MgdGhhdCBzcGFuIGEgbGFyZ2UgdW5pdCBvZiB0aW1lLCBzaG93IHRoZSBwcm9wZXIgaW50ZXJ2YWwsIGlnbm9yaW5nIHN0cmF5IGRheXMgYmVmb3JlIGFuZCBhZnRlclxuICAgIGlmICgvXih5ZWFyfG1vbnRoKSQvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCkpIHtcbiAgICAgICAgcmFuZ2UgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2U7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBmb3IgZGF5IHVuaXRzIG9yIHNtYWxsZXIsIHVzZSB0aGUgYWN0dWFsIGRheSByYW5nZVxuICAgICAgICByYW5nZSA9IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShyYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBjcmVhdGVGb3JtYXR0ZXIodmlld09wdGlvbnMudGl0bGVGb3JtYXQgfHwgYnVpbGRUaXRsZUZvcm1hdChkYXRlUHJvZmlsZSkpLCB7XG4gICAgICAgIGlzRW5kRXhjbHVzaXZlOiBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5LFxuICAgICAgICBkZWZhdWx0U2VwYXJhdG9yOiB2aWV3T3B0aW9ucy50aXRsZVJhbmdlU2VwYXJhdG9yLFxuICAgIH0pO1xufVxuLy8gR2VuZXJhdGVzIHRoZSBmb3JtYXQgc3RyaW5nIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpdGxlIGZvciB0aGUgY3VycmVudCBkYXRlIHJhbmdlLlxuLy8gQXR0ZW1wdHMgdG8gY29tcHV0ZSB0aGUgbW9zdCBhcHByb3ByaWF0ZSBmb3JtYXQgaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIHdpdGggYHRpdGxlRm9ybWF0YC5cbmZ1bmN0aW9uIGJ1aWxkVGl0bGVGb3JtYXQoZGF0ZVByb2ZpbGUpIHtcbiAgICBsZXQgeyBjdXJyZW50UmFuZ2VVbml0IH0gPSBkYXRlUHJvZmlsZTtcbiAgICBpZiAoY3VycmVudFJhbmdlVW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJyB9O1xuICAgIH1cbiAgICBpZiAoY3VycmVudFJhbmdlVW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycgfTsgLy8gbGlrZSBcIlNlcHRlbWJlciAyMDE0XCJcbiAgICB9XG4gICAgbGV0IGRheXMgPSBkaWZmV2hvbGVEYXlzKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydCwgZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLmVuZCk7XG4gICAgaWYgKGRheXMgIT09IG51bGwgJiYgZGF5cyA+IDEpIHtcbiAgICAgICAgLy8gbXVsdGktZGF5IHJhbmdlLiBzaG9ydGVyLCBsaWtlIFwiU2VwIDkgLSAxMCAyMDE0XCJcbiAgICAgICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ3Nob3J0JywgZGF5OiAnbnVtZXJpYycgfTtcbiAgICB9XG4gICAgLy8gb25lIGRheS4gbG9uZ2VyLCBsaWtlIFwiU2VwdGVtYmVyIDkgMjAxNFwiXG4gICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJyB9O1xufVxuXG4vLyBpbiBmdXR1cmUgcmVmYWN0b3IsIGRvIHRoZSByZWR1eC1zdHlsZSBmdW5jdGlvbihzdGF0ZT1pbml0aWFsKSBmb3IgaW5pdGlhbC1zdGF0ZVxuLy8gYWxzbywgd2hhdGV2ZXIgaXMgaGFwcGVuaW5nIGluIGNvbnN0cnVjdG9yLCBoYXZlIGl0IGhhcHBlbiBpbiBhY3Rpb24gcXVldWUgdG9vXG5jbGFzcyBDYWxlbmRhckRhdGFNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEgPSBtZW1vaXplKHRoaXMuX2NvbXB1dGVDdXJyZW50Vmlld0RhdGEpO1xuICAgICAgICB0aGlzLm9yZ2FuaXplUmF3TG9jYWxlcyA9IG1lbW9pemUob3JnYW5pemVSYXdMb2NhbGVzKTtcbiAgICAgICAgdGhpcy5idWlsZExvY2FsZSA9IG1lbW9pemUoYnVpbGRMb2NhbGUpO1xuICAgICAgICB0aGlzLmJ1aWxkUGx1Z2luSG9va3MgPSBidWlsZEJ1aWxkUGx1Z2luSG9va3MoKTtcbiAgICAgICAgdGhpcy5idWlsZERhdGVFbnYgPSBtZW1vaXplKGJ1aWxkRGF0ZUVudiQxKTtcbiAgICAgICAgdGhpcy5idWlsZFRoZW1lID0gbWVtb2l6ZShidWlsZFRoZW1lKTtcbiAgICAgICAgdGhpcy5wYXJzZVRvb2xiYXJzID0gbWVtb2l6ZShwYXJzZVRvb2xiYXJzKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXdTcGVjcyA9IG1lbW9pemUoYnVpbGRWaWV3U3BlY3MpO1xuICAgICAgICB0aGlzLmJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSBtZW1vaXplT2JqQXJnKGJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlld0FwaSA9IG1lbW9pemUoYnVpbGRWaWV3QXBpKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXdVaVByb3BzID0gbWVtb2l6ZU9iakFyZyhidWlsZFZpZXdVaVByb3BzKTtcbiAgICAgICAgdGhpcy5idWlsZEV2ZW50VWlCeVNvdXJjZSA9IG1lbW9pemUoYnVpbGRFdmVudFVpQnlTb3VyY2UsIGlzUHJvcHNFcXVhbCk7XG4gICAgICAgIHRoaXMuYnVpbGRFdmVudFVpQmFzZXMgPSBtZW1vaXplKGJ1aWxkRXZlbnRVaUJhc2VzKTtcbiAgICAgICAgdGhpcy5wYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzID0gbWVtb2l6ZU9iakFyZyhwYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKTtcbiAgICAgICAgdGhpcy5idWlsZFRpdGxlID0gbWVtb2l6ZShidWlsZFRpdGxlKTtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIgPSBuZXcgVGFza1J1bm5lcih0aGlzLl9oYW5kbGVBY3Rpb24uYmluZCh0aGlzKSwgdGhpcy51cGRhdGVEYXRhLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkID0ge307XG4gICAgICAgIHRoaXMuY3VycmVudFZpZXdPcHRpb25zSW5wdXQgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkID0ge307XG4gICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzID0ge307XG4gICAgICAgIHRoaXMub3B0aW9uc0ZvclJlZmluaW5nID0gW107XG4gICAgICAgIHRoaXMub3B0aW9uc0ZvckhhbmRsaW5nID0gW107XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudERhdGEgPSAoKSA9PiB0aGlzLmRhdGE7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSAoYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblJ1bm5lci5yZXF1ZXN0KGFjdGlvbik7IC8vIHByb3RlY3RzIGFnYWluc3QgcmVjdXJzaXZlIGNhbGxzIHRvIF9oYW5kbGVBY3Rpb25cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLmFjdGlvblJ1bm5lci5wYXVzZSgpO1xuICAgICAgICBsZXQgZHluYW1pY09wdGlvbk92ZXJyaWRlcyA9IHt9O1xuICAgICAgICBsZXQgb3B0aW9uc0RhdGEgPSB0aGlzLmNvbXB1dGVPcHRpb25zRGF0YShwcm9wcy5vcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIHByb3BzLmNhbGVuZGFyQXBpKTtcbiAgICAgICAgbGV0IGN1cnJlbnRWaWV3VHlwZSA9IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucy5pbml0aWFsVmlldyB8fCBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5pbml0aWFsVmlldztcbiAgICAgICAgbGV0IGN1cnJlbnRWaWV3RGF0YSA9IHRoaXMuY29tcHV0ZUN1cnJlbnRWaWV3RGF0YShjdXJyZW50Vmlld1R5cGUsIG9wdGlvbnNEYXRhLCBwcm9wcy5vcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpO1xuICAgICAgICAvLyB3aXJlIHRoaW5ncyB1cFxuICAgICAgICAvLyBUT0RPOiBub3QgRFJZXG4gICAgICAgIHByb3BzLmNhbGVuZGFyQXBpLmN1cnJlbnREYXRhTWFuYWdlciA9IHRoaXM7XG4gICAgICAgIHRoaXMuZW1pdHRlci5zZXRUaGlzQ29udGV4dChwcm9wcy5jYWxlbmRhckFwaSk7XG4gICAgICAgIHRoaXMuZW1pdHRlci5zZXRPcHRpb25zKGN1cnJlbnRWaWV3RGF0YS5vcHRpb25zKTtcbiAgICAgICAgbGV0IGN1cnJlbnREYXRlID0gZ2V0SW5pdGlhbERhdGUob3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLCBvcHRpb25zRGF0YS5kYXRlRW52KTtcbiAgICAgICAgbGV0IGRhdGVQcm9maWxlID0gY3VycmVudFZpZXdEYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGN1cnJlbnREYXRlKTtcbiAgICAgICAgaWYgKCFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjdXJyZW50RGF0ZSkpIHtcbiAgICAgICAgICAgIGN1cnJlbnREYXRlID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBjYWxlbmRhckNvbnRleHQgPSB7XG4gICAgICAgICAgICBkYXRlRW52OiBvcHRpb25zRGF0YS5kYXRlRW52LFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLFxuICAgICAgICAgICAgcGx1Z2luSG9va3M6IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLFxuICAgICAgICAgICAgY2FsZW5kYXJBcGk6IHByb3BzLmNhbGVuZGFyQXBpLFxuICAgICAgICAgICAgZGlzcGF0Y2g6IHRoaXMuZGlzcGF0Y2gsXG4gICAgICAgICAgICBlbWl0dGVyOiB0aGlzLmVtaXR0ZXIsXG4gICAgICAgICAgICBnZXRDdXJyZW50RGF0YTogdGhpcy5nZXRDdXJyZW50RGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gbmVlZHMgdG8gYmUgYWZ0ZXIgc2V0VGhpc0NvbnRleHRcbiAgICAgICAgZm9yIChsZXQgY2FsbGJhY2sgb2Ygb3B0aW9uc0RhdGEucGx1Z2luSG9va3MuY29udGV4dEluaXQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9UIERSWVxuICAgICAgICBsZXQgZXZlbnRTb3VyY2VzID0gaW5pdEV2ZW50U291cmNlcyhvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsIGRhdGVQcm9maWxlLCBjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICBsZXQgaW5pdGlhbFN0YXRlID0ge1xuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIGN1cnJlbnRWaWV3VHlwZSxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlLFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICBidXNpbmVzc0hvdXJzOiB0aGlzLnBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0KSxcbiAgICAgICAgICAgIGV2ZW50U291cmNlcyxcbiAgICAgICAgICAgIGV2ZW50VWlCYXNlczoge30sXG4gICAgICAgICAgICBldmVudFN0b3JlOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgIHJlbmRlcmFibGVFdmVudFN0b3JlOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IG51bGwsXG4gICAgICAgICAgICBldmVudFNlbGVjdGlvbjogJycsXG4gICAgICAgICAgICBldmVudERyYWc6IG51bGwsXG4gICAgICAgICAgICBldmVudFJlc2l6ZTogbnVsbCxcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbmZpZzogdGhpcy5idWlsZFZpZXdVaVByb3BzKGNhbGVuZGFyQ29udGV4dCkuc2VsZWN0aW9uQ29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY29udGV4dEFuZFN0YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjYWxlbmRhckNvbnRleHQpLCBpbml0aWFsU3RhdGUpO1xuICAgICAgICBmb3IgKGxldCByZWR1Y2VyIG9mIG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLnJlZHVjZXJzKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGluaXRpYWxTdGF0ZSwgcmVkdWNlcihudWxsLCBudWxsLCBjb250ZXh0QW5kU3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHV0ZUlzTG9hZGluZyhpbml0aWFsU3RhdGUsIGNhbGVuZGFyQ29udGV4dCkpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdsb2FkaW5nJywgdHJ1ZSk7IC8vIE5PVCBEUllcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgICB0aGlzLnVwZGF0ZURhdGEoKTtcbiAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucmVzdW1lKCk7XG4gICAgfVxuICAgIHJlc2V0T3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGNoYW5nZWRPcHRpb25OYW1lcykge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKGNoYW5nZWRPcHRpb25OYW1lcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwcm9wcy5vcHRpb25PdmVycmlkZXMgPSBvcHRpb25PdmVycmlkZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcm9wcy5vcHRpb25PdmVycmlkZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChwcm9wcy5vcHRpb25PdmVycmlkZXMgfHwge30pKSwgb3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc0ZvclJlZmluaW5nLnB1c2goLi4uY2hhbmdlZE9wdGlvbk5hbWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlZE9wdGlvbk5hbWVzID09PSB1bmRlZmluZWQgfHwgY2hhbmdlZE9wdGlvbk5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ05PVEhJTkcnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2hhbmRsZUFjdGlvbihhY3Rpb24pIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlLCBlbWl0dGVyIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZHluYW1pY09wdGlvbk92ZXJyaWRlcyA9IHJlZHVjZUR5bmFtaWNPcHRpb25PdmVycmlkZXMoc3RhdGUuZHluYW1pY09wdGlvbk92ZXJyaWRlcywgYWN0aW9uKTtcbiAgICAgICAgbGV0IG9wdGlvbnNEYXRhID0gdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEocHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBwcm9wcy5jYWxlbmRhckFwaSk7XG4gICAgICAgIGxldCBjdXJyZW50Vmlld1R5cGUgPSByZWR1Y2VWaWV3VHlwZShzdGF0ZS5jdXJyZW50Vmlld1R5cGUsIGFjdGlvbik7XG4gICAgICAgIGxldCBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoY3VycmVudFZpZXdUeXBlLCBvcHRpb25zRGF0YSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgLy8gd2lyZSB0aGluZ3MgdXBcbiAgICAgICAgLy8gVE9ETzogbm90IERSWVxuICAgICAgICBwcm9wcy5jYWxlbmRhckFwaS5jdXJyZW50RGF0YU1hbmFnZXIgPSB0aGlzO1xuICAgICAgICBlbWl0dGVyLnNldFRoaXNDb250ZXh0KHByb3BzLmNhbGVuZGFyQXBpKTtcbiAgICAgICAgZW1pdHRlci5zZXRPcHRpb25zKGN1cnJlbnRWaWV3RGF0YS5vcHRpb25zKTtcbiAgICAgICAgbGV0IGNhbGVuZGFyQ29udGV4dCA9IHtcbiAgICAgICAgICAgIGRhdGVFbnY6IG9wdGlvbnNEYXRhLmRhdGVFbnYsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsXG4gICAgICAgICAgICBwbHVnaW5Ib29rczogb3B0aW9uc0RhdGEucGx1Z2luSG9va3MsXG4gICAgICAgICAgICBjYWxlbmRhckFwaTogcHJvcHMuY2FsZW5kYXJBcGksXG4gICAgICAgICAgICBkaXNwYXRjaDogdGhpcy5kaXNwYXRjaCxcbiAgICAgICAgICAgIGVtaXR0ZXIsXG4gICAgICAgICAgICBnZXRDdXJyZW50RGF0YTogdGhpcy5nZXRDdXJyZW50RGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHsgY3VycmVudERhdGUsIGRhdGVQcm9maWxlIH0gPSBzdGF0ZTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IgIT09IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvcikgeyAvLyBoYWNrXG4gICAgICAgICAgICBkYXRlUHJvZmlsZSA9IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChjdXJyZW50RGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudERhdGUgPSByZWR1Y2VDdXJyZW50RGF0ZShjdXJyZW50RGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgZGF0ZVByb2ZpbGUgPSByZWR1Y2VEYXRlUHJvZmlsZShkYXRlUHJvZmlsZSwgYWN0aW9uLCBjdXJyZW50RGF0ZSwgY3VycmVudFZpZXdEYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnUFJFVicgfHwgLy8gVE9ETzogbW92ZSB0aGlzIGxvZ2ljIGludG8gRGF0ZVByb2ZpbGVHZW5lcmF0b3JcbiAgICAgICAgICAgIGFjdGlvbi50eXBlID09PSAnTkVYVCcgfHwgLy8gXCJcbiAgICAgICAgICAgICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgY3VycmVudERhdGUpKSB7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXZlbnRTb3VyY2VzID0gcmVkdWNlRXZlbnRTb3VyY2VzKHN0YXRlLmV2ZW50U291cmNlcywgYWN0aW9uLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgbGV0IGV2ZW50U3RvcmUgPSByZWR1Y2VFdmVudFN0b3JlKHN0YXRlLmV2ZW50U3RvcmUsIGFjdGlvbiwgZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgbGV0IGlzRXZlbnRzTG9hZGluZyA9IGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nKGV2ZW50U291cmNlcyk7IC8vIEJBRC4gYWxzbyBjYWxsZWQgaW4gdGhpcyBmdW5jIGluIGNvbXB1dGVJc0xvYWRpbmdcbiAgICAgICAgbGV0IHJlbmRlcmFibGVFdmVudFN0b3JlID0gKGlzRXZlbnRzTG9hZGluZyAmJiAhY3VycmVudFZpZXdEYXRhLm9wdGlvbnMucHJvZ3Jlc3NpdmVFdmVudFJlbmRlcmluZykgP1xuICAgICAgICAgICAgKHN0YXRlLnJlbmRlcmFibGVFdmVudFN0b3JlIHx8IGV2ZW50U3RvcmUpIDogLy8gdHJ5IGZyb20gcHJldmlvdXMgc3RhdGVcbiAgICAgICAgICAgIGV2ZW50U3RvcmU7XG4gICAgICAgIGxldCB7IGV2ZW50VWlTaW5nbGVCYXNlLCBzZWxlY3Rpb25Db25maWcgfSA9IHRoaXMuYnVpbGRWaWV3VWlQcm9wcyhjYWxlbmRhckNvbnRleHQpOyAvLyB3aWxsIG1lbW9pemUgb2JqXG4gICAgICAgIGxldCBldmVudFVpQnlTb3VyY2UgPSB0aGlzLmJ1aWxkRXZlbnRVaUJ5U291cmNlKGV2ZW50U291cmNlcyk7XG4gICAgICAgIGxldCBldmVudFVpQmFzZXMgPSB0aGlzLmJ1aWxkRXZlbnRVaUJhc2VzKHJlbmRlcmFibGVFdmVudFN0b3JlLmRlZnMsIGV2ZW50VWlTaW5nbGVCYXNlLCBldmVudFVpQnlTb3VyY2UpO1xuICAgICAgICBsZXQgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgY3VycmVudFZpZXdUeXBlLFxuICAgICAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgICAgICBkYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIGV2ZW50U291cmNlcyxcbiAgICAgICAgICAgIGV2ZW50U3RvcmUsXG4gICAgICAgICAgICByZW5kZXJhYmxlRXZlbnRTdG9yZSxcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbmZpZyxcbiAgICAgICAgICAgIGV2ZW50VWlCYXNlcyxcbiAgICAgICAgICAgIGJ1c2luZXNzSG91cnM6IHRoaXMucGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyhjYWxlbmRhckNvbnRleHQpLFxuICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogcmVkdWNlRGF0ZVNlbGVjdGlvbihzdGF0ZS5kYXRlU2VsZWN0aW9uLCBhY3Rpb24pLFxuICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246IHJlZHVjZVNlbGVjdGVkRXZlbnQoc3RhdGUuZXZlbnRTZWxlY3Rpb24sIGFjdGlvbiksXG4gICAgICAgICAgICBldmVudERyYWc6IHJlZHVjZUV2ZW50RHJhZyhzdGF0ZS5ldmVudERyYWcsIGFjdGlvbiksXG4gICAgICAgICAgICBldmVudFJlc2l6ZTogcmVkdWNlRXZlbnRSZXNpemUoc3RhdGUuZXZlbnRSZXNpemUsIGFjdGlvbiksXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjb250ZXh0QW5kU3RhdGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNhbGVuZGFyQ29udGV4dCksIG5ld1N0YXRlKTtcbiAgICAgICAgZm9yIChsZXQgcmVkdWNlciBvZiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5yZWR1Y2Vycykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdTdGF0ZSwgcmVkdWNlcihzdGF0ZSwgYWN0aW9uLCBjb250ZXh0QW5kU3RhdGUpKTsgLy8gZ2l2ZSB0aGUgT0xEIHN0YXRlLCBmb3Igb2xkIHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdhc0xvYWRpbmcgPSBjb21wdXRlSXNMb2FkaW5nKHN0YXRlLCBjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICBsZXQgaXNMb2FkaW5nID0gY29tcHV0ZUlzTG9hZGluZyhuZXdTdGF0ZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgLy8gVE9ETzogdXNlIHByb3BTZXRIYW5kbGVycyBpbiBwbHVnaW4gc3lzdGVtXG4gICAgICAgIGlmICghd2FzTG9hZGluZyAmJiBpc0xvYWRpbmcpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIudHJpZ2dlcignbG9hZGluZycsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdhc0xvYWRpbmcgJiYgIWlzTG9hZGluZykge1xuICAgICAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdsb2FkaW5nJywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgaWYgKHByb3BzLm9uQWN0aW9uKSB7XG4gICAgICAgICAgICBwcm9wcy5vbkFjdGlvbihhY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZURhdGEoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IG9sZERhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGxldCBvcHRpb25zRGF0YSA9IHRoaXMuY29tcHV0ZU9wdGlvbnNEYXRhKHByb3BzLm9wdGlvbk92ZXJyaWRlcywgc3RhdGUuZHluYW1pY09wdGlvbk92ZXJyaWRlcywgcHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICBsZXQgY3VycmVudFZpZXdEYXRhID0gdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhKHN0YXRlLmN1cnJlbnRWaWV3VHlwZSwgb3B0aW9uc0RhdGEsIHByb3BzLm9wdGlvbk92ZXJyaWRlcywgc3RhdGUuZHluYW1pY09wdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5kYXRhID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB2aWV3VGl0bGU6IHRoaXMuYnVpbGRUaXRsZShzdGF0ZS5kYXRlUHJvZmlsZSwgY3VycmVudFZpZXdEYXRhLm9wdGlvbnMsIG9wdGlvbnNEYXRhLmRhdGVFbnYpLCBjYWxlbmRhckFwaTogcHJvcHMuY2FsZW5kYXJBcGksIGRpc3BhdGNoOiB0aGlzLmRpc3BhdGNoLCBlbWl0dGVyOiB0aGlzLmVtaXR0ZXIsIGdldEN1cnJlbnREYXRhOiB0aGlzLmdldEN1cnJlbnREYXRhIH0sIG9wdGlvbnNEYXRhKSwgY3VycmVudFZpZXdEYXRhKSwgc3RhdGUpO1xuICAgICAgICBsZXQgY2hhbmdlSGFuZGxlcnMgPSBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5vcHRpb25DaGFuZ2VIYW5kbGVycztcbiAgICAgICAgbGV0IG9sZENhbGVuZGFyT3B0aW9ucyA9IG9sZERhdGEgJiYgb2xkRGF0YS5jYWxlbmRhck9wdGlvbnM7XG4gICAgICAgIGxldCBuZXdDYWxlbmRhck9wdGlvbnMgPSBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnM7XG4gICAgICAgIGlmIChvbGRDYWxlbmRhck9wdGlvbnMgJiYgb2xkQ2FsZW5kYXJPcHRpb25zICE9PSBuZXdDYWxlbmRhck9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvbGRDYWxlbmRhck9wdGlvbnMudGltZVpvbmUgIT09IG5ld0NhbGVuZGFyT3B0aW9ucy50aW1lWm9uZSkge1xuICAgICAgICAgICAgICAgIC8vIGhhY2tcbiAgICAgICAgICAgICAgICBzdGF0ZS5ldmVudFNvdXJjZXMgPSBkYXRhLmV2ZW50U291cmNlcyA9IHJlZHVjZUV2ZW50U291cmNlc05ld1RpbWVab25lKGRhdGEuZXZlbnRTb3VyY2VzLCBzdGF0ZS5kYXRlUHJvZmlsZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgc3RhdGUuZXZlbnRTdG9yZSA9IGRhdGEuZXZlbnRTdG9yZSA9IHJlem9uZUV2ZW50U3RvcmVEYXRlcyhkYXRhLmV2ZW50U3RvcmUsIG9sZERhdGEuZGF0ZUVudiwgZGF0YS5kYXRlRW52KTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5yZW5kZXJhYmxlRXZlbnRTdG9yZSA9IGRhdGEucmVuZGVyYWJsZUV2ZW50U3RvcmUgPSByZXpvbmVFdmVudFN0b3JlRGF0ZXMoZGF0YS5yZW5kZXJhYmxlRXZlbnRTdG9yZSwgb2xkRGF0YS5kYXRlRW52LCBkYXRhLmRhdGVFbnYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiBjaGFuZ2VIYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNGb3JIYW5kbGluZy5pbmRleE9mKG9wdGlvbk5hbWUpICE9PSAtMSB8fFxuICAgICAgICAgICAgICAgICAgICBvbGRDYWxlbmRhck9wdGlvbnNbb3B0aW9uTmFtZV0gIT09IG5ld0NhbGVuZGFyT3B0aW9uc1tvcHRpb25OYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VIYW5kbGVyc1tvcHRpb25OYW1lXShuZXdDYWxlbmRhck9wdGlvbnNbb3B0aW9uTmFtZV0sIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNGb3JIYW5kbGluZyA9IFtdO1xuICAgICAgICBpZiAocHJvcHMub25EYXRhKSB7XG4gICAgICAgICAgICBwcm9wcy5vbkRhdGEoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZU9wdGlvbnNEYXRhKG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgY2FsZW5kYXJBcGkpIHtcbiAgICAgICAgLy8gVE9ETzogYmxhY2tsaXN0IG9wdGlvbnMgdGhhdCBhcmUgaGFuZGxlZCBieSBvcHRpb25DaGFuZ2VIYW5kbGVyc1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9uc0ZvclJlZmluaW5nLmxlbmd0aCAmJlxuICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzID09PSB0aGlzLnN0YWJsZU9wdGlvbk92ZXJyaWRlcyAmJlxuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyA9PT0gdGhpcy5zdGFibGVEeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFibGVDYWxlbmRhck9wdGlvbnNEYXRhO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHJlZmluZWRPcHRpb25zLCBwbHVnaW5Ib29rcywgbG9jYWxlRGVmYXVsdHMsIGF2YWlsYWJsZUxvY2FsZURhdGEsIGV4dHJhLCB9ID0gdGhpcy5wcm9jZXNzUmF3Q2FsZW5kYXJPcHRpb25zKG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgIHdhcm5Vbmtub3duT3B0aW9ucyhleHRyYSk7XG4gICAgICAgIGxldCBkYXRlRW52ID0gdGhpcy5idWlsZERhdGVFbnYocmVmaW5lZE9wdGlvbnMudGltZVpvbmUsIHJlZmluZWRPcHRpb25zLmxvY2FsZSwgcmVmaW5lZE9wdGlvbnMud2Vla051bWJlckNhbGN1bGF0aW9uLCByZWZpbmVkT3B0aW9ucy5maXJzdERheSwgcmVmaW5lZE9wdGlvbnMud2Vla1RleHQsIHBsdWdpbkhvb2tzLCBhdmFpbGFibGVMb2NhbGVEYXRhLCByZWZpbmVkT3B0aW9ucy5kZWZhdWx0UmFuZ2VTZXBhcmF0b3IpO1xuICAgICAgICBsZXQgdmlld1NwZWNzID0gdGhpcy5idWlsZFZpZXdTcGVjcyhwbHVnaW5Ib29rcy52aWV3cywgdGhpcy5zdGFibGVPcHRpb25PdmVycmlkZXMsIHRoaXMuc3RhYmxlRHluYW1pY09wdGlvbk92ZXJyaWRlcywgbG9jYWxlRGVmYXVsdHMpO1xuICAgICAgICBsZXQgdGhlbWUgPSB0aGlzLmJ1aWxkVGhlbWUocmVmaW5lZE9wdGlvbnMsIHBsdWdpbkhvb2tzKTtcbiAgICAgICAgbGV0IHRvb2xiYXJDb25maWcgPSB0aGlzLnBhcnNlVG9vbGJhcnMocmVmaW5lZE9wdGlvbnMsIHRoaXMuc3RhYmxlT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWJsZUNhbGVuZGFyT3B0aW9uc0RhdGEgPSB7XG4gICAgICAgICAgICBjYWxlbmRhck9wdGlvbnM6IHJlZmluZWRPcHRpb25zLFxuICAgICAgICAgICAgcGx1Z2luSG9va3MsXG4gICAgICAgICAgICBkYXRlRW52LFxuICAgICAgICAgICAgdmlld1NwZWNzLFxuICAgICAgICAgICAgdGhlbWUsXG4gICAgICAgICAgICB0b29sYmFyQ29uZmlnLFxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHMsXG4gICAgICAgICAgICBhdmFpbGFibGVSYXdMb2NhbGVzOiBhdmFpbGFibGVMb2NhbGVEYXRhLm1hcCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gYWx3YXlzIGNhbGxlZCBmcm9tIGJlaGluZCBhIG1lbW9pemVyXG4gICAgcHJvY2Vzc1Jhd0NhbGVuZGFyT3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHtcbiAgICAgICAgbGV0IHsgbG9jYWxlcywgbG9jYWxlIH0gPSBtZXJnZVJhd09wdGlvbnMoW1xuICAgICAgICAgICAgQkFTRV9PUFRJT05fREVGQVVMVFMsXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICBdKTtcbiAgICAgICAgbGV0IGF2YWlsYWJsZUxvY2FsZURhdGEgPSB0aGlzLm9yZ2FuaXplUmF3TG9jYWxlcyhsb2NhbGVzKTtcbiAgICAgICAgbGV0IGF2YWlsYWJsZVJhd0xvY2FsZXMgPSBhdmFpbGFibGVMb2NhbGVEYXRhLm1hcDtcbiAgICAgICAgbGV0IGxvY2FsZURlZmF1bHRzID0gdGhpcy5idWlsZExvY2FsZShsb2NhbGUgfHwgYXZhaWxhYmxlTG9jYWxlRGF0YS5kZWZhdWx0Q29kZSwgYXZhaWxhYmxlUmF3TG9jYWxlcykub3B0aW9ucztcbiAgICAgICAgbGV0IHBsdWdpbkhvb2tzID0gdGhpcy5idWlsZFBsdWdpbkhvb2tzKG9wdGlvbk92ZXJyaWRlcy5wbHVnaW5zIHx8IFtdLCBnbG9iYWxQbHVnaW5zKTtcbiAgICAgICAgbGV0IHJlZmluZXJzID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEJBU0VfT1BUSU9OX1JFRklORVJTKSwgQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlMpLCBDQUxFTkRBUl9PUFRJT05fUkVGSU5FUlMpLCBwbHVnaW5Ib29rcy5saXN0ZW5lclJlZmluZXJzKSwgcGx1Z2luSG9va3Mub3B0aW9uUmVmaW5lcnMpO1xuICAgICAgICBsZXQgZXh0cmEgPSB7fTtcbiAgICAgICAgbGV0IHJhdyA9IG1lcmdlUmF3T3B0aW9ucyhbXG4gICAgICAgICAgICBCQVNFX09QVElPTl9ERUZBVUxUUyxcbiAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzLFxuICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgXSk7XG4gICAgICAgIGxldCByZWZpbmVkID0ge307XG4gICAgICAgIGxldCBjdXJyZW50UmF3ID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQ7XG4gICAgICAgIGxldCBjdXJyZW50UmVmaW5lZCA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQ7XG4gICAgICAgIGxldCBhbnlDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IG9wdGlvbk5hbWUgaW4gcmF3KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zRm9yUmVmaW5pbmcuaW5kZXhPZihvcHRpb25OYW1lKSA9PT0gLTEgJiYgKHJhd1tvcHRpb25OYW1lXSA9PT0gY3VycmVudFJhd1tvcHRpb25OYW1lXSB8fCAoQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0gJiZcbiAgICAgICAgICAgICAgICAob3B0aW9uTmFtZSBpbiBjdXJyZW50UmF3KSAmJlxuICAgICAgICAgICAgICAgIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdKGN1cnJlbnRSYXdbb3B0aW9uTmFtZV0sIHJhd1tvcHRpb25OYW1lXSkpKSkge1xuICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSBjdXJyZW50UmVmaW5lZFtvcHRpb25OYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlZmluZXJzW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IHJlZmluZXJzW29wdGlvbk5hbWVdKHJhd1tvcHRpb25OYW1lXSk7XG4gICAgICAgICAgICAgICAgYW55Q2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHRyYVtvcHRpb25OYW1lXSA9IGN1cnJlbnRSYXdbb3B0aW9uTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFueUNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0ID0gcmF3O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCA9IHJlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnN0YWJsZU9wdGlvbk92ZXJyaWRlcyA9IG9wdGlvbk92ZXJyaWRlcztcbiAgICAgICAgICAgIHRoaXMuc3RhYmxlRHluYW1pY09wdGlvbk92ZXJyaWRlcyA9IGR5bmFtaWNPcHRpb25PdmVycmlkZXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zRm9ySGFuZGxpbmcucHVzaCguLi50aGlzLm9wdGlvbnNGb3JSZWZpbmluZyk7XG4gICAgICAgIHRoaXMub3B0aW9uc0ZvclJlZmluaW5nID0gW107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXdPcHRpb25zOiB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCxcbiAgICAgICAgICAgIHJlZmluZWRPcHRpb25zOiB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkLFxuICAgICAgICAgICAgcGx1Z2luSG9va3MsXG4gICAgICAgICAgICBhdmFpbGFibGVMb2NhbGVEYXRhLFxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHMsXG4gICAgICAgICAgICBleHRyYSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2NvbXB1dGVDdXJyZW50Vmlld0RhdGEodmlld1R5cGUsIG9wdGlvbnNEYXRhLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHtcbiAgICAgICAgbGV0IHZpZXdTcGVjID0gb3B0aW9uc0RhdGEudmlld1NwZWNzW3ZpZXdUeXBlXTtcbiAgICAgICAgaWYgKCF2aWV3U3BlYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2aWV3VHlwZSBcIiR7dmlld1R5cGV9XCIgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIG1ha2Ugc3VyZSB5b3UndmUgbG9hZGVkIGFsbCBuZWNjZXNzYXJ5IHBsdWdpbnNgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyByZWZpbmVkT3B0aW9ucywgZXh0cmEgfSA9IHRoaXMucHJvY2Vzc1Jhd1ZpZXdPcHRpb25zKHZpZXdTcGVjLCBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcywgb3B0aW9uc0RhdGEubG9jYWxlRGVmYXVsdHMsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgIHdhcm5Vbmtub3duT3B0aW9ucyhleHRyYSk7XG4gICAgICAgIGxldCBkYXRlUHJvZmlsZUdlbmVyYXRvciA9IHRoaXMuYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvcih7XG4gICAgICAgICAgICBkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzOiB2aWV3U3BlYy5vcHRpb25EZWZhdWx0cy5kYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzLFxuICAgICAgICAgICAgZHVyYXRpb246IHZpZXdTcGVjLmR1cmF0aW9uLFxuICAgICAgICAgICAgZHVyYXRpb25Vbml0OiB2aWV3U3BlYy5kdXJhdGlvblVuaXQsXG4gICAgICAgICAgICB1c2VzTWluTWF4VGltZTogdmlld1NwZWMub3B0aW9uRGVmYXVsdHMudXNlc01pbk1heFRpbWUsXG4gICAgICAgICAgICBkYXRlRW52OiBvcHRpb25zRGF0YS5kYXRlRW52LFxuICAgICAgICAgICAgY2FsZW5kYXJBcGk6IHRoaXMucHJvcHMuY2FsZW5kYXJBcGksXG4gICAgICAgICAgICBzbG90TWluVGltZTogcmVmaW5lZE9wdGlvbnMuc2xvdE1pblRpbWUsXG4gICAgICAgICAgICBzbG90TWF4VGltZTogcmVmaW5lZE9wdGlvbnMuc2xvdE1heFRpbWUsXG4gICAgICAgICAgICBzaG93Tm9uQ3VycmVudERhdGVzOiByZWZpbmVkT3B0aW9ucy5zaG93Tm9uQ3VycmVudERhdGVzLFxuICAgICAgICAgICAgZGF5Q291bnQ6IHJlZmluZWRPcHRpb25zLmRheUNvdW50LFxuICAgICAgICAgICAgZGF0ZUFsaWdubWVudDogcmVmaW5lZE9wdGlvbnMuZGF0ZUFsaWdubWVudCxcbiAgICAgICAgICAgIGRhdGVJbmNyZW1lbnQ6IHJlZmluZWRPcHRpb25zLmRhdGVJbmNyZW1lbnQsXG4gICAgICAgICAgICBoaWRkZW5EYXlzOiByZWZpbmVkT3B0aW9ucy5oaWRkZW5EYXlzLFxuICAgICAgICAgICAgd2Vla2VuZHM6IHJlZmluZWRPcHRpb25zLndlZWtlbmRzLFxuICAgICAgICAgICAgbm93SW5wdXQ6IHJlZmluZWRPcHRpb25zLm5vdyxcbiAgICAgICAgICAgIHZhbGlkUmFuZ2VJbnB1dDogcmVmaW5lZE9wdGlvbnMudmFsaWRSYW5nZSxcbiAgICAgICAgICAgIHZpc2libGVSYW5nZUlucHV0OiByZWZpbmVkT3B0aW9ucy52aXNpYmxlUmFuZ2UsXG4gICAgICAgICAgICBmaXhlZFdlZWtDb3VudDogcmVmaW5lZE9wdGlvbnMuZml4ZWRXZWVrQ291bnQsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdmlld0FwaSA9IHRoaXMuYnVpbGRWaWV3QXBpKHZpZXdUeXBlLCB0aGlzLmdldEN1cnJlbnREYXRhLCBvcHRpb25zRGF0YS5kYXRlRW52KTtcbiAgICAgICAgcmV0dXJuIHsgdmlld1NwZWMsIG9wdGlvbnM6IHJlZmluZWRPcHRpb25zLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgdmlld0FwaSB9O1xuICAgIH1cbiAgICBwcm9jZXNzUmF3Vmlld09wdGlvbnModmlld1NwZWMsIHBsdWdpbkhvb2tzLCBsb2NhbGVEZWZhdWx0cywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB7XG4gICAgICAgIGxldCByYXcgPSBtZXJnZVJhd09wdGlvbnMoW1xuICAgICAgICAgICAgQkFTRV9PUFRJT05fREVGQVVMVFMsXG4gICAgICAgICAgICB2aWV3U3BlYy5vcHRpb25EZWZhdWx0cyxcbiAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzLFxuICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgdmlld1NwZWMub3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgXSk7XG4gICAgICAgIGxldCByZWZpbmVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBCQVNFX09QVElPTl9SRUZJTkVSUyksIENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTKSwgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTKSwgVklFV19PUFRJT05fUkVGSU5FUlMpLCBwbHVnaW5Ib29rcy5saXN0ZW5lclJlZmluZXJzKSwgcGx1Z2luSG9va3Mub3B0aW9uUmVmaW5lcnMpO1xuICAgICAgICBsZXQgcmVmaW5lZCA9IHt9O1xuICAgICAgICBsZXQgY3VycmVudFJhdyA9IHRoaXMuY3VycmVudFZpZXdPcHRpb25zSW5wdXQ7XG4gICAgICAgIGxldCBjdXJyZW50UmVmaW5lZCA9IHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZDtcbiAgICAgICAgbGV0IGFueUNoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgbGV0IGV4dHJhID0ge307XG4gICAgICAgIGZvciAobGV0IG9wdGlvbk5hbWUgaW4gcmF3KSB7XG4gICAgICAgICAgICBpZiAocmF3W29wdGlvbk5hbWVdID09PSBjdXJyZW50UmF3W29wdGlvbk5hbWVdIHx8XG4gICAgICAgICAgICAgICAgKENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdICYmXG4gICAgICAgICAgICAgICAgICAgIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdKHJhd1tvcHRpb25OYW1lXSwgY3VycmVudFJhd1tvcHRpb25OYW1lXSkpKSB7XG4gICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IGN1cnJlbnRSZWZpbmVkW29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhd1tvcHRpb25OYW1lXSA9PT0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXRbb3B0aW9uTmFtZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgKENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0sIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0W29wdGlvbk5hbWVdKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbk5hbWUgaW4gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCkgeyAvLyBtaWdodCBiZSBhbiBcImV4dHJhXCIgcHJvcFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWRbb3B0aW9uTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmaW5lcnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IHJlZmluZXJzW29wdGlvbk5hbWVdKHJhd1tvcHRpb25OYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleHRyYVtvcHRpb25OYW1lXSA9IHJhd1tvcHRpb25OYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYW55Q2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFueUNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXdPcHRpb25zSW5wdXQgPSByYXc7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQgPSByZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXdPcHRpb25zOiB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0LFxuICAgICAgICAgICAgcmVmaW5lZE9wdGlvbnM6IHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZCxcbiAgICAgICAgICAgIGV4dHJhLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRGF0ZUVudiQxKHRpbWVab25lLCBleHBsaWNpdExvY2FsZSwgd2Vla051bWJlckNhbGN1bGF0aW9uLCBmaXJzdERheSwgd2Vla1RleHQsIHBsdWdpbkhvb2tzLCBhdmFpbGFibGVMb2NhbGVEYXRhLCBkZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgbGV0IGxvY2FsZSA9IGJ1aWxkTG9jYWxlKGV4cGxpY2l0TG9jYWxlIHx8IGF2YWlsYWJsZUxvY2FsZURhdGEuZGVmYXVsdENvZGUsIGF2YWlsYWJsZUxvY2FsZURhdGEubWFwKTtcbiAgICByZXR1cm4gbmV3IERhdGVFbnYoe1xuICAgICAgICBjYWxlbmRhclN5c3RlbTogJ2dyZWdvcnknLFxuICAgICAgICB0aW1lWm9uZSxcbiAgICAgICAgbmFtZWRUaW1lWm9uZUltcGw6IHBsdWdpbkhvb2tzLm5hbWVkVGltZVpvbmVkSW1wbCxcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24sXG4gICAgICAgIGZpcnN0RGF5LFxuICAgICAgICB3ZWVrVGV4dCxcbiAgICAgICAgY21kRm9ybWF0dGVyOiBwbHVnaW5Ib29rcy5jbWRGb3JtYXR0ZXIsXG4gICAgICAgIGRlZmF1bHRTZXBhcmF0b3IsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBidWlsZFRoZW1lKG9wdGlvbnMsIHBsdWdpbkhvb2tzKSB7XG4gICAgbGV0IFRoZW1lQ2xhc3MgPSBwbHVnaW5Ib29rcy50aGVtZUNsYXNzZXNbb3B0aW9ucy50aGVtZVN5c3RlbV0gfHwgU3RhbmRhcmRUaGVtZTtcbiAgICByZXR1cm4gbmV3IFRoZW1lQ2xhc3Mob3B0aW9ucyk7XG59XG5mdW5jdGlvbiBidWlsZERhdGVQcm9maWxlR2VuZXJhdG9yKHByb3BzKSB7XG4gICAgbGV0IERhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgPSBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzIHx8IERhdGVQcm9maWxlR2VuZXJhdG9yO1xuICAgIHJldHVybiBuZXcgRGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyhwcm9wcyk7XG59XG5mdW5jdGlvbiBidWlsZFZpZXdBcGkodHlwZSwgZ2V0Q3VycmVudERhdGEsIGRhdGVFbnYpIHtcbiAgICByZXR1cm4gbmV3IFZpZXdJbXBsKHR5cGUsIGdldEN1cnJlbnREYXRhLCBkYXRlRW52KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUJ5U291cmNlKGV2ZW50U291cmNlcykge1xuICAgIHJldHVybiBtYXBIYXNoKGV2ZW50U291cmNlcywgKGV2ZW50U291cmNlKSA9PiBldmVudFNvdXJjZS51aSk7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50VWlCYXNlcyhldmVudERlZnMsIGV2ZW50VWlTaW5nbGVCYXNlLCBldmVudFVpQnlTb3VyY2UpIHtcbiAgICBsZXQgZXZlbnRVaUJhc2VzID0geyAnJzogZXZlbnRVaVNpbmdsZUJhc2UgfTtcbiAgICBmb3IgKGxldCBkZWZJZCBpbiBldmVudERlZnMpIHtcbiAgICAgICAgbGV0IGRlZiA9IGV2ZW50RGVmc1tkZWZJZF07XG4gICAgICAgIGlmIChkZWYuc291cmNlSWQgJiYgZXZlbnRVaUJ5U291cmNlW2RlZi5zb3VyY2VJZF0pIHtcbiAgICAgICAgICAgIGV2ZW50VWlCYXNlc1tkZWZJZF0gPSBldmVudFVpQnlTb3VyY2VbZGVmLnNvdXJjZUlkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRVaUJhc2VzO1xufVxuZnVuY3Rpb24gYnVpbGRWaWV3VWlQcm9wcyhjYWxlbmRhckNvbnRleHQpIHtcbiAgICBsZXQgeyBvcHRpb25zIH0gPSBjYWxlbmRhckNvbnRleHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXZlbnRVaVNpbmdsZUJhc2U6IGNyZWF0ZUV2ZW50VWkoe1xuICAgICAgICAgICAgZGlzcGxheTogb3B0aW9ucy5ldmVudERpc3BsYXksXG4gICAgICAgICAgICBlZGl0YWJsZTogb3B0aW9ucy5lZGl0YWJsZSxcbiAgICAgICAgICAgIHN0YXJ0RWRpdGFibGU6IG9wdGlvbnMuZXZlbnRTdGFydEVkaXRhYmxlLFxuICAgICAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogb3B0aW9ucy5ldmVudER1cmF0aW9uRWRpdGFibGUsXG4gICAgICAgICAgICBjb25zdHJhaW50OiBvcHRpb25zLmV2ZW50Q29uc3RyYWludCxcbiAgICAgICAgICAgIG92ZXJsYXA6IHR5cGVvZiBvcHRpb25zLmV2ZW50T3ZlcmxhcCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5ldmVudE92ZXJsYXAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhbGxvdzogb3B0aW9ucy5ldmVudEFsbG93LFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmV2ZW50QmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IG9wdGlvbnMuZXZlbnRCb3JkZXJDb2xvcixcbiAgICAgICAgICAgIHRleHRDb2xvcjogb3B0aW9ucy5ldmVudFRleHRDb2xvcixcbiAgICAgICAgICAgIGNvbG9yOiBvcHRpb25zLmV2ZW50Q29sb3IsXG4gICAgICAgICAgICAvLyBjbGFzc05hbWVzOiBvcHRpb25zLmV2ZW50Q2xhc3NOYW1lcyAvLyByZW5kZXIgaG9vayB3aWxsIGhhbmRsZSB0aGlzXG4gICAgICAgIH0sIGNhbGVuZGFyQ29udGV4dCksXG4gICAgICAgIHNlbGVjdGlvbkNvbmZpZzogY3JlYXRlRXZlbnRVaSh7XG4gICAgICAgICAgICBjb25zdHJhaW50OiBvcHRpb25zLnNlbGVjdENvbnN0cmFpbnQsXG4gICAgICAgICAgICBvdmVybGFwOiB0eXBlb2Ygb3B0aW9ucy5zZWxlY3RPdmVybGFwID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnNlbGVjdE92ZXJsYXAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhbGxvdzogb3B0aW9ucy5zZWxlY3RBbGxvdyxcbiAgICAgICAgfSwgY2FsZW5kYXJDb250ZXh0KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUlzTG9hZGluZyhzdGF0ZSwgY29udGV4dCkge1xuICAgIGZvciAobGV0IGlzTG9hZGluZ0Z1bmMgb2YgY29udGV4dC5wbHVnaW5Ib29rcy5pc0xvYWRpbmdGdW5jcykge1xuICAgICAgICBpZiAoaXNMb2FkaW5nRnVuYyhzdGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0KSB7XG4gICAgcmV0dXJuIHBhcnNlQnVzaW5lc3NIb3VycyhjYWxlbmRhckNvbnRleHQub3B0aW9ucy5idXNpbmVzc0hvdXJzLCBjYWxlbmRhckNvbnRleHQpO1xufVxuZnVuY3Rpb24gd2FyblVua25vd25PcHRpb25zKG9wdGlvbnMsIHZpZXdOYW1lKSB7XG4gICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgVW5rbm93biBvcHRpb24gJyR7b3B0aW9uTmFtZX0nYCArXG4gICAgICAgICAgICAodmlld05hbWUgPyBgIGZvciB2aWV3ICcke3ZpZXdOYW1lfSdgIDogJycpKTtcbiAgICB9XG59XG5cbmNsYXNzIFRvb2xiYXJTZWN0aW9uIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLnByb3BzLndpZGdldEdyb3Vwcy5tYXAoKHdpZGdldEdyb3VwKSA9PiB0aGlzLnJlbmRlcldpZGdldEdyb3VwKHdpZGdldEdyb3VwKSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdkaXYnLCB7IGNsYXNzTmFtZTogJ2ZjLXRvb2xiYXItY2h1bmsnIH0sIC4uLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmVuZGVyV2lkZ2V0R3JvdXAod2lkZ2V0R3JvdXApIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHRoZW1lIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICBsZXQgaXNPbmx5QnV0dG9ucyA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IHdpZGdldCBvZiB3aWRnZXRHcm91cCkge1xuICAgICAgICAgICAgbGV0IHsgYnV0dG9uTmFtZSwgYnV0dG9uQ2xpY2ssIGJ1dHRvblRleHQsIGJ1dHRvbkljb24sIGJ1dHRvbkhpbnQgfSA9IHdpZGdldDtcbiAgICAgICAgICAgIGlmIChidXR0b25OYW1lID09PSAndGl0bGUnKSB7XG4gICAgICAgICAgICAgICAgaXNPbmx5QnV0dG9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY3JlYXRlRWxlbWVudChcImgyXCIsIHsgY2xhc3NOYW1lOiBcImZjLXRvb2xiYXItdGl0bGVcIiwgaWQ6IHByb3BzLnRpdGxlSWQgfSwgcHJvcHMudGl0bGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBpc1ByZXNzZWQgPSBidXR0b25OYW1lID09PSBwcm9wcy5hY3RpdmVCdXR0b247XG4gICAgICAgICAgICAgICAgbGV0IGlzRGlzYWJsZWQgPSAoIXByb3BzLmlzVG9kYXlFbmFibGVkICYmIGJ1dHRvbk5hbWUgPT09ICd0b2RheScpIHx8XG4gICAgICAgICAgICAgICAgICAgICghcHJvcHMuaXNQcmV2RW5hYmxlZCAmJiBidXR0b25OYW1lID09PSAncHJldicpIHx8XG4gICAgICAgICAgICAgICAgICAgICghcHJvcHMuaXNOZXh0RW5hYmxlZCAmJiBidXR0b25OYW1lID09PSAnbmV4dCcpO1xuICAgICAgICAgICAgICAgIGxldCBidXR0b25DbGFzc2VzID0gW2BmYy0ke2J1dHRvbk5hbWV9LWJ1dHRvbmAsIHRoZW1lLmdldENsYXNzKCdidXR0b24nKV07XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBidXR0b25DbGFzc2VzLnB1c2godGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbkFjdGl2ZScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgdHlwZTogXCJidXR0b25cIiwgdGl0bGU6IHR5cGVvZiBidXR0b25IaW50ID09PSAnZnVuY3Rpb24nID8gYnV0dG9uSGludChwcm9wcy5uYXZVbml0KSA6IGJ1dHRvbkhpbnQsIGRpc2FibGVkOiBpc0Rpc2FibGVkLCBcImFyaWEtcHJlc3NlZFwiOiBpc1ByZXNzZWQsIGNsYXNzTmFtZTogYnV0dG9uQ2xhc3Nlcy5qb2luKCcgJyksIG9uQ2xpY2s6IGJ1dHRvbkNsaWNrIH0sIGJ1dHRvblRleHQgfHwgKGJ1dHRvbkljb24gPyBjcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogYnV0dG9uSWNvbiwgcm9sZTogXCJpbWdcIiB9KSA6ICcnKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBDbGFzc05hbWUgPSAoaXNPbmx5QnV0dG9ucyAmJiB0aGVtZS5nZXRDbGFzcygnYnV0dG9uR3JvdXAnKSkgfHwgJyc7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6IGdyb3VwQ2xhc3NOYW1lIH0sIC4uLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGRyZW5bMF07XG4gICAgfVxufVxuXG5jbGFzcyBUb29sYmFyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBtb2RlbCwgZXh0cmFDbGFzc05hbWUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBmb3JjZUx0ciA9IGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnRDb250ZW50O1xuICAgICAgICBsZXQgZW5kQ29udGVudDtcbiAgICAgICAgbGV0IHNlY3Rpb25XaWRnZXRzID0gbW9kZWwuc2VjdGlvbldpZGdldHM7XG4gICAgICAgIGxldCBjZW50ZXJDb250ZW50ID0gc2VjdGlvbldpZGdldHMuY2VudGVyO1xuICAgICAgICBpZiAoc2VjdGlvbldpZGdldHMubGVmdCkge1xuICAgICAgICAgICAgZm9yY2VMdHIgPSB0cnVlO1xuICAgICAgICAgICAgc3RhcnRDb250ZW50ID0gc2VjdGlvbldpZGdldHMubGVmdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0Q29udGVudCA9IHNlY3Rpb25XaWRnZXRzLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWN0aW9uV2lkZ2V0cy5yaWdodCkge1xuICAgICAgICAgICAgZm9yY2VMdHIgPSB0cnVlO1xuICAgICAgICAgICAgZW5kQ29udGVudCA9IHNlY3Rpb25XaWRnZXRzLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kQ29udGVudCA9IHNlY3Rpb25XaWRnZXRzLmVuZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgIGV4dHJhQ2xhc3NOYW1lIHx8ICcnLFxuICAgICAgICAgICAgJ2ZjLXRvb2xiYXInLFxuICAgICAgICAgICAgZm9yY2VMdHIgPyAnZmMtdG9vbGJhci1sdHInIDogJycsXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJykgfSxcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2VjdGlvbignc3RhcnQnLCBzdGFydENvbnRlbnQgfHwgW10pLFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdjZW50ZXInLCBjZW50ZXJDb250ZW50IHx8IFtdKSxcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2VjdGlvbignZW5kJywgZW5kQ29udGVudCB8fCBbXSkpKTtcbiAgICB9XG4gICAgcmVuZGVyU2VjdGlvbihrZXksIHdpZGdldEdyb3Vwcykge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFRvb2xiYXJTZWN0aW9uLCB7IGtleToga2V5LCB3aWRnZXRHcm91cHM6IHdpZGdldEdyb3VwcywgdGl0bGU6IHByb3BzLnRpdGxlLCBuYXZVbml0OiBwcm9wcy5uYXZVbml0LCBhY3RpdmVCdXR0b246IHByb3BzLmFjdGl2ZUJ1dHRvbiwgaXNUb2RheUVuYWJsZWQ6IHByb3BzLmlzVG9kYXlFbmFibGVkLCBpc1ByZXZFbmFibGVkOiBwcm9wcy5pc1ByZXZFbmFibGVkLCBpc05leHRFbmFibGVkOiBwcm9wcy5pc05leHRFbmFibGVkLCB0aXRsZUlkOiBwcm9wcy50aXRsZUlkIH0pKTtcbiAgICB9XG59XG5cbmNsYXNzIFZpZXdIYXJuZXNzIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBhdmFpbGFibGVXaWR0aDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVFbCA9IChlbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXZhaWxhYmxlV2lkdGgoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUF2YWlsYWJsZVdpZHRoKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBhc3BlY3RSYXRpbyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgJ2ZjLXZpZXctaGFybmVzcycsXG4gICAgICAgICAgICAoYXNwZWN0UmF0aW8gfHwgcHJvcHMubGlxdWlkIHx8IHByb3BzLmhlaWdodClcbiAgICAgICAgICAgICAgICA/ICdmYy12aWV3LWhhcm5lc3MtYWN0aXZlJyAvLyBoYXJuZXNzIGNvbnRyb2xzIHRoZSBoZWlnaHRcbiAgICAgICAgICAgICAgICA6ICdmYy12aWV3LWhhcm5lc3MtcGFzc2l2ZScsIC8vIGxldCB0aGUgdmlldyBkbyB0aGUgaGVpZ2h0XG4gICAgICAgIF07XG4gICAgICAgIGxldCBoZWlnaHQgPSAnJztcbiAgICAgICAgbGV0IHBhZGRpbmdCb3R0b20gPSAnJztcbiAgICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuYXZhaWxhYmxlV2lkdGggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBzdGF0ZS5hdmFpbGFibGVXaWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2hpbGUgd2FpdGluZyB0byBrbm93IGF2YWlsYWJsZVdpZHRoLCB3ZSBjYW4ndCBzZXQgaGVpZ2h0IHRvICp6ZXJvKlxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2lsbCBjYXVzZSBsb3RzIG9mIHVubmVjZXNzYXJ5IHNjcm9sbGJhcnMgd2l0aGluIHNjcm9sbGdyaWQuXG4gICAgICAgICAgICAgICAgLy8gQkVUVEVSOiBkb24ndCBzdGFydCByZW5kZXJpbmcgQU5ZVEhJTkcgeWV0IHVudGlsIHdlIGtub3cgY29udGFpbmVyIHdpZHRoXG4gICAgICAgICAgICAgICAgLy8gTk9URTogd2h5IG5vdCBhbHdheXMgdXNlIHBhZGRpbmdCb3R0b20/IENhdXNlcyBoZWlnaHQgb3NjaWxsYXRpb24gKGlzc3VlIDU2MDYpXG4gICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbSA9IGAkeygxIC8gYXNwZWN0UmF0aW8pICogMTAwfSVgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0IHx8ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHByb3BzLmxhYmVsZWRCeUlkLCByZWY6IHRoaXMuaGFuZGxlRWwsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIHN0eWxlOiB7IGhlaWdodCwgcGFkZGluZ0JvdHRvbSB9IH0sIHByb3BzLmNoaWxkcmVuKSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLmNvbnRleHQuYWRkUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLmNvbnRleHQucmVtb3ZlUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgfVxuICAgIHVwZGF0ZUF2YWlsYWJsZVdpZHRoKCkge1xuICAgICAgICBpZiAodGhpcy5lbCAmJiAvLyBuZWVkZWQuIGJ1dCB3aHk/XG4gICAgICAgICAgICB0aGlzLnByb3BzLmFzcGVjdFJhdGlvIC8vIGFzcGVjdFJhdGlvIGlzIHRoZSBvbmx5IGhlaWdodCBzZXR0aW5nIHRoYXQgbmVlZHMgYXZhaWxhYmxlV2lkdGhcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgYXZhaWxhYmxlV2lkdGg6IHRoaXMuZWwub2Zmc2V0V2lkdGggfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qXG5EZXRlY3RzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIGFuIGV2ZW50IHdpdGhpbiBhIERhdGVDb21wb25lbnRcbiovXG5jbGFzcyBFdmVudENsaWNraW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVTZWdDbGljayA9IChldiwgc2VnRWwpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudCB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCB7IGNvbnRleHQgfSA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgIGxldCBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XG4gICAgICAgICAgICBpZiAoc2VnICYmIC8vIG1pZ2h0IGJlIHRoZSA8ZGl2PiBzdXJyb3VuZGluZyB0aGUgbW9yZSBsaW5rXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwoZXYudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIC8vIG91ciB3YXkgdG8gc2ltdWxhdGUgYSBsaW5rIGNsaWNrIGZvciBlbGVtZW50cyB0aGF0IGNhbid0IGJlIDxhPiB0YWdzXG4gICAgICAgICAgICAgICAgLy8gZ3JhYiBiZWZvcmUgdHJpZ2dlciBmaXJlZCBpbiBjYXNlIHRyaWdnZXIgdHJhc2hlcyBET00gdGhydSByZXJlbmRlcmluZ1xuICAgICAgICAgICAgICAgIGxldCBoYXNVcmxDb250YWluZXIgPSBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQsICcuZmMtZXZlbnQtZm9yY2VkLXVybCcpO1xuICAgICAgICAgICAgICAgIGxldCB1cmwgPSBoYXNVcmxDb250YWluZXIgPyBoYXNVcmxDb250YWluZXIucXVlcnlTZWxlY3RvcignYVtocmVmXScpLmhyZWYgOiAnJztcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDbGljaycsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHNlZ0VsLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb21wb25lbnQuY29udGV4dCwgc2VnLmV2ZW50UmFuZ2UuZGVmLCBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHVybCAmJiAhZXYuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVzdHJveSA9IGxpc3RlbkJ5U2VsZWN0b3Ioc2V0dGluZ3MuZWwsICdjbGljaycsICcuZmMtZXZlbnQnLCAvLyBvbiBib3RoIGZnIGFuZCBiZyBldmVudHNcbiAgICAgICAgdGhpcy5oYW5kbGVTZWdDbGljayk7XG4gICAgfVxufVxuXG4vKlxuVHJpZ2dlcnMgZXZlbnRzIGFuZCBhZGRzL3JlbW92ZXMgY29yZSBjbGFzc05hbWVzIHdoZW4gdGhlIHVzZXIncyBwb2ludGVyXG5lbnRlcnMvbGVhdmVzIGV2ZW50LWVsZW1lbnRzIG9mIGEgY29tcG9uZW50LlxuKi9cbmNsYXNzIEV2ZW50SG92ZXJpbmcgZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgICAgICAvLyBmb3Igc2ltdWxhdGluZyBhbiBldmVudE1vdXNlTGVhdmUgd2hlbiB0aGUgZXZlbnQgZWwgaXMgZGVzdHJveWVkIHdoaWxlIG1vdXNlIGlzIG92ZXIgaXRcbiAgICAgICAgdGhpcy5oYW5kbGVFdmVudEVsUmVtb3ZlID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWwgPT09IHRoaXMuY3VycmVudFNlZ0VsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTZWdMZWF2ZShudWxsLCB0aGlzLmN1cnJlbnRTZWdFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2VnRW50ZXIgPSAoZXYsIHNlZ0VsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZ2V0RWxTZWcoc2VnRWwpKSB7IC8vIFRPRE86IGJldHRlciB3YXkgdG8gbWFrZSBzdXJlIG5vdCBob3ZlcmluZyBvdmVyIG1vcmUrIGxpbmsgb3IgaXRzIHdyYXBwZXJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWdFbCA9IHNlZ0VsO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KCdldmVudE1vdXNlRW50ZXInLCBldiwgc2VnRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVNlZ0xlYXZlID0gKGV2LCBzZWdFbCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFNlZ0VsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VnRWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KCdldmVudE1vdXNlTGVhdmUnLCBldiwgc2VnRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlbW92ZUhvdmVyTGlzdGVuZXJzID0gbGlzdGVuVG9Ib3ZlckJ5U2VsZWN0b3Ioc2V0dGluZ3MuZWwsICcuZmMtZXZlbnQnLCAvLyBvbiBib3RoIGZnIGFuZCBiZyBldmVudHNcbiAgICAgICAgdGhpcy5oYW5kbGVTZWdFbnRlciwgdGhpcy5oYW5kbGVTZWdMZWF2ZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlSG92ZXJMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgdHJpZ2dlckV2ZW50KHB1YmxpY0V2TmFtZSwgZXYsIHNlZ0VsKSB7XG4gICAgICAgIGxldCB7IGNvbXBvbmVudCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gY29tcG9uZW50O1xuICAgICAgICBsZXQgc2VnID0gZ2V0RWxTZWcoc2VnRWwpO1xuICAgICAgICBpZiAoIWV2IHx8IGNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKGV2LnRhcmdldCkpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKHB1YmxpY0V2TmFtZSwge1xuICAgICAgICAgICAgICAgIGVsOiBzZWdFbCxcbiAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb250ZXh0LCBzZWcuZXZlbnRSYW5nZS5kZWYsIHNlZy5ldmVudFJhbmdlLmluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICBqc0V2ZW50OiBldixcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQ2FsZW5kYXJDb250ZW50IGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYnVpbGRWaWV3Q29udGV4dCA9IG1lbW9pemUoYnVpbGRWaWV3Q29udGV4dCk7XG4gICAgICAgIHRoaXMuYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyA9IG1lbW9pemUoYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyk7XG4gICAgICAgIHRoaXMuYnVpbGRUb29sYmFyUHJvcHMgPSBtZW1vaXplKGJ1aWxkVG9vbGJhclByb3BzKTtcbiAgICAgICAgdGhpcy5oZWFkZXJSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5mb290ZXJSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbnNTdG9yZSA9IHt9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHZpZXdMYWJlbElkOiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICB9O1xuICAgICAgICAvLyBDb21wb25lbnQgUmVnaXN0cmF0aW9uXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHRoaXMucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCA9IChjb21wb25lbnQsIHNldHRpbmdzSW5wdXQpID0+IHtcbiAgICAgICAgICAgIGxldCBzZXR0aW5ncyA9IHBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyhjb21wb25lbnQsIHNldHRpbmdzSW5wdXQpO1xuICAgICAgICAgICAgbGV0IERFRkFVTFRfSU5URVJBQ1RJT05TID0gW1xuICAgICAgICAgICAgICAgIEV2ZW50Q2xpY2tpbmcsXG4gICAgICAgICAgICAgICAgRXZlbnRIb3ZlcmluZyxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb25DbGFzc2VzID0gREVGQVVMVF9JTlRFUkFDVElPTlMuY29uY2F0KHRoaXMucHJvcHMucGx1Z2luSG9va3MuY29tcG9uZW50SW50ZXJhY3Rpb25zKTtcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbnMgPSBpbnRlcmFjdGlvbkNsYXNzZXMubWFwKChUaGVJbnRlcmFjdGlvbkNsYXNzKSA9PiBuZXcgVGhlSW50ZXJhY3Rpb25DbGFzcyhzZXR0aW5ncykpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbnNTdG9yZVtjb21wb25lbnQudWlkXSA9IGludGVyYWN0aW9ucztcbiAgICAgICAgICAgIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZVtjb21wb25lbnQudWlkXSA9IHNldHRpbmdzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCA9IChjb21wb25lbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBsaXN0ZW5lcnMgPSB0aGlzLmludGVyYWN0aW9uc1N0b3JlW2NvbXBvbmVudC51aWRdO1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmludGVyYWN0aW9uc1N0b3JlW2NvbXBvbmVudC51aWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZVtjb21wb25lbnQudWlkXTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVzaXppbmdcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgdGhpcy5yZXNpemVSdW5uZXIgPSBuZXcgRGVsYXllZFJ1bm5lcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLmVtaXR0ZXIudHJpZ2dlcignX3Jlc2l6ZScsIHRydWUpOyAvLyBzaG91bGQgd2luZG93IHJlc2l6ZXMgYmUgY29uc2lkZXJlZCBcImZvcmNlZFwiID9cbiAgICAgICAgICAgIHRoaXMucHJvcHMuZW1pdHRlci50cmlnZ2VyKCd3aW5kb3dSZXNpemUnLCB7IHZpZXc6IHRoaXMucHJvcHMudmlld0FwaSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFuZGxlV2luZG93UmVzaXplID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFuZGxlV2luZG93UmVzaXplICYmXG4gICAgICAgICAgICAgICAgZXYudGFyZ2V0ID09PSB3aW5kb3cgLy8gYXZvaWQganF1aSBldmVudHNcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplUnVubmVyLnJlcXVlc3Qob3B0aW9ucy53aW5kb3dSZXNpemVEZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qXG4gICAgcmVuZGVycyBJTlNJREUgb2YgYW4gb3V0ZXIgZGl2XG4gICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyB0b29sYmFyQ29uZmlnLCBvcHRpb25zIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IHRvb2xiYXJQcm9wcyA9IHRoaXMuYnVpbGRUb29sYmFyUHJvcHMocHJvcHMudmlld1NwZWMsIHByb3BzLmRhdGVQcm9maWxlLCBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvciwgcHJvcHMuY3VycmVudERhdGUsIGdldE5vdyhwcm9wcy5vcHRpb25zLm5vdywgcHJvcHMuZGF0ZUVudiksIC8vIFRPRE86IHVzZSBOb3dUaW1lcj8/Pz9cbiAgICAgICAgcHJvcHMudmlld1RpdGxlKTtcbiAgICAgICAgbGV0IHZpZXdWR3JvdyA9IGZhbHNlO1xuICAgICAgICBsZXQgdmlld0hlaWdodCA9ICcnO1xuICAgICAgICBsZXQgdmlld0FzcGVjdFJhdGlvO1xuICAgICAgICBpZiAocHJvcHMuaXNIZWlnaHRBdXRvIHx8IHByb3BzLmZvclByaW50KSB7XG4gICAgICAgICAgICB2aWV3SGVpZ2h0ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5oZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmlld1ZHcm93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmNvbnRlbnRIZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmlld0hlaWdodCA9IG9wdGlvbnMuY29udGVudEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZpZXdBc3BlY3RSYXRpbyA9IE1hdGgubWF4KG9wdGlvbnMuYXNwZWN0UmF0aW8sIDAuNSk7IC8vIHByZXZlbnQgZnJvbSBnZXR0aW5nIHRvbyB0YWxsXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZpZXdDb250ZXh0ID0gdGhpcy5idWlsZFZpZXdDb250ZXh0KHByb3BzLnZpZXdTcGVjLCBwcm9wcy52aWV3QXBpLCBwcm9wcy5vcHRpb25zLCBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvciwgcHJvcHMuZGF0ZUVudiwgcHJvcHMudGhlbWUsIHByb3BzLnBsdWdpbkhvb2tzLCBwcm9wcy5kaXNwYXRjaCwgcHJvcHMuZ2V0Q3VycmVudERhdGEsIHByb3BzLmVtaXR0ZXIsIHByb3BzLmNhbGVuZGFyQXBpLCB0aGlzLnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsIHRoaXMudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KTtcbiAgICAgICAgbGV0IHZpZXdMYWJlbElkID0gKHRvb2xiYXJDb25maWcuaGVhZGVyICYmIHRvb2xiYXJDb25maWcuaGVhZGVyLmhhc1RpdGxlKVxuICAgICAgICAgICAgPyB0aGlzLnN0YXRlLnZpZXdMYWJlbElkXG4gICAgICAgICAgICA6ICcnO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLlByb3ZpZGVyLCB7IHZhbHVlOiB2aWV3Q29udGV4dCB9LFxuICAgICAgICAgICAgdG9vbGJhckNvbmZpZy5oZWFkZXIgJiYgKGNyZWF0ZUVsZW1lbnQoVG9vbGJhciwgT2JqZWN0LmFzc2lnbih7IHJlZjogdGhpcy5oZWFkZXJSZWYsIGV4dHJhQ2xhc3NOYW1lOiBcImZjLWhlYWRlci10b29sYmFyXCIsIG1vZGVsOiB0b29sYmFyQ29uZmlnLmhlYWRlciwgdGl0bGVJZDogdmlld0xhYmVsSWQgfSwgdG9vbGJhclByb3BzKSkpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChWaWV3SGFybmVzcywgeyBsaXF1aWQ6IHZpZXdWR3JvdywgaGVpZ2h0OiB2aWV3SGVpZ2h0LCBhc3BlY3RSYXRpbzogdmlld0FzcGVjdFJhdGlvLCBsYWJlbGVkQnlJZDogdmlld0xhYmVsSWQgfSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclZpZXcocHJvcHMpLFxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRBcHBlbmRDb250ZW50KCkpLFxuICAgICAgICAgICAgdG9vbGJhckNvbmZpZy5mb290ZXIgJiYgKGNyZWF0ZUVsZW1lbnQoVG9vbGJhciwgT2JqZWN0LmFzc2lnbih7IHJlZjogdGhpcy5mb290ZXJSZWYsIGV4dHJhQ2xhc3NOYW1lOiBcImZjLWZvb3Rlci10b29sYmFyXCIsIG1vZGVsOiB0b29sYmFyQ29uZmlnLmZvb3RlciwgdGl0bGVJZDogXCJcIiB9LCB0b29sYmFyUHJvcHMpKSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmNhbGVuZGFySW50ZXJhY3Rpb25zID0gcHJvcHMucGx1Z2luSG9va3MuY2FsZW5kYXJJbnRlcmFjdGlvbnNcbiAgICAgICAgICAgIC5tYXAoKENhbGVuZGFySW50ZXJhY3Rpb25DbGFzcykgPT4gbmV3IENhbGVuZGFySW50ZXJhY3Rpb25DbGFzcyhwcm9wcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUpO1xuICAgICAgICBsZXQgeyBwcm9wU2V0SGFuZGxlcnMgfSA9IHByb3BzLnBsdWdpbkhvb2tzO1xuICAgICAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wU2V0SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHByb3BTZXRIYW5kbGVyc1twcm9wTmFtZV0ocHJvcHNbcHJvcE5hbWVdLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcHJvcFNldEhhbmRsZXJzIH0gPSBwcm9wcy5wbHVnaW5Ib29rcztcbiAgICAgICAgZm9yIChsZXQgcHJvcE5hbWUgaW4gcHJvcFNldEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdICE9PSBwcmV2UHJvcHNbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcHJvcFNldEhhbmRsZXJzW3Byb3BOYW1lXShwcm9wc1twcm9wTmFtZV0sIHByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlV2luZG93UmVzaXplKTtcbiAgICAgICAgdGhpcy5yZXNpemVSdW5uZXIuY2xlYXIoKTtcbiAgICAgICAgZm9yIChsZXQgaW50ZXJhY3Rpb24gb2YgdGhpcy5jYWxlbmRhckludGVyYWN0aW9ucykge1xuICAgICAgICAgICAgaW50ZXJhY3Rpb24uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvcHMuZW1pdHRlci50cmlnZ2VyKCdfdW5tb3VudCcpO1xuICAgIH1cbiAgICBidWlsZEFwcGVuZENvbnRlbnQoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBwcm9wcy5wbHVnaW5Ib29rcy52aWV3Q29udGFpbmVyQXBwZW5kcy5tYXAoKGJ1aWxkQXBwZW5kQ29udGVudCkgPT4gYnVpbGRBcHBlbmRDb250ZW50KHByb3BzKSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7fSwgLi4uY2hpbGRyZW4pO1xuICAgIH1cbiAgICByZW5kZXJWaWV3KHByb3BzKSB7XG4gICAgICAgIGxldCB7IHBsdWdpbkhvb2tzIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IHsgdmlld1NwZWMgfSA9IHByb3BzO1xuICAgICAgICBsZXQgdmlld1Byb3BzID0ge1xuICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICAgICAgYnVzaW5lc3NIb3VyczogcHJvcHMuYnVzaW5lc3NIb3VycyxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IHByb3BzLnJlbmRlcmFibGVFdmVudFN0b3JlLFxuICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiBwcm9wcy5ldmVudFVpQmFzZXMsXG4gICAgICAgICAgICBkYXRlU2VsZWN0aW9uOiBwcm9wcy5kYXRlU2VsZWN0aW9uLFxuICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLFxuICAgICAgICAgICAgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsXG4gICAgICAgICAgICBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsXG4gICAgICAgICAgICBpc0hlaWdodEF1dG86IHByb3BzLmlzSGVpZ2h0QXV0byxcbiAgICAgICAgICAgIGZvclByaW50OiBwcm9wcy5mb3JQcmludCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVycyA9IHRoaXMuYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyhwbHVnaW5Ib29rcy52aWV3UHJvcHNUcmFuc2Zvcm1lcnMpO1xuICAgICAgICBmb3IgKGxldCB0cmFuc2Zvcm1lciBvZiB0cmFuc2Zvcm1lcnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odmlld1Byb3BzLCB0cmFuc2Zvcm1lci50cmFuc2Zvcm0odmlld1Byb3BzLCBwcm9wcykpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBWaWV3Q29tcG9uZW50ID0gdmlld1NwZWMuY29tcG9uZW50O1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbXBvbmVudCwgT2JqZWN0LmFzc2lnbih7fSwgdmlld1Byb3BzKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkVG9vbGJhclByb3BzKHZpZXdTcGVjLCBkYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIGN1cnJlbnREYXRlLCBub3csIHRpdGxlKSB7XG4gICAgLy8gZG9uJ3QgZm9yY2UgYW55IGRhdGUtcHJvZmlsZXMgdG8gdmFsaWQgZGF0ZSBwcm9maWxlcyAodGhlIGBmYWxzZWApIHNvIHRoYXQgd2UgY2FuIHRlbGwgaWYgaXQncyBpbnZhbGlkXG4gICAgbGV0IHRvZGF5SW5mbyA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKG5vdywgdW5kZWZpbmVkLCBmYWxzZSk7IC8vIFRPRE86IG5lZWQgYHVuZGVmaW5lZGAgb3IgZWxzZSBJTkZJTklURSBMT09QIGZvciBzb21lIHJlYXNvblxuICAgIGxldCBwcmV2SW5mbyA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkUHJldihkYXRlUHJvZmlsZSwgY3VycmVudERhdGUsIGZhbHNlKTtcbiAgICBsZXQgbmV4dEluZm8gPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZE5leHQoZGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGFjdGl2ZUJ1dHRvbjogdmlld1NwZWMudHlwZSxcbiAgICAgICAgbmF2VW5pdDogdmlld1NwZWMuc2luZ2xlVW5pdCxcbiAgICAgICAgaXNUb2RheUVuYWJsZWQ6IHRvZGF5SW5mby5pc1ZhbGlkICYmICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgbm93KSxcbiAgICAgICAgaXNQcmV2RW5hYmxlZDogcHJldkluZm8uaXNWYWxpZCxcbiAgICAgICAgaXNOZXh0RW5hYmxlZDogbmV4dEluZm8uaXNWYWxpZCxcbiAgICB9O1xufVxuLy8gUGx1Z2luXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyh0aGVDbGFzc2VzKSB7XG4gICAgcmV0dXJuIHRoZUNsYXNzZXMubWFwKChUaGVDbGFzcykgPT4gbmV3IFRoZUNsYXNzKCkpO1xufVxuXG5jbGFzcyBDYWxlbmRhciBleHRlbmRzIENhbGVuZGFySW1wbCB7XG4gICAgY29uc3RydWN0b3IoZWwsIG9wdGlvbk92ZXJyaWRlcyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1JlbmRlcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3VycmVudENsYXNzTmFtZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jdXN0b21Db250ZW50UmVuZGVySWQgPSAwO1xuICAgICAgICB0aGlzLmhhbmRsZUFjdGlvbiA9IChhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIC8vIGFjdGlvbnMgd2Uga25vdyB3ZSB3YW50IHRvIHJlbmRlciBpbW1lZGlhdGVseVxuICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ1NFVF9FVkVOVF9EUkFHJzpcbiAgICAgICAgICAgICAgICBjYXNlICdTRVRfRVZFTlRfUkVTSVpFJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIudHJ5RHJhaW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEYXRhID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGEgPSBkYXRhO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucmVxdWVzdChkYXRhLmNhbGVuZGFyT3B0aW9ucy5yZXJlbmRlckRlbGF5KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZW5kZXJSZXF1ZXN0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzUmVuZGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCB7IGN1cnJlbnREYXRhIH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcihjcmVhdGVFbGVtZW50KENhbGVuZGFyUm9vdCwgeyBvcHRpb25zOiBjdXJyZW50RGF0YS5jYWxlbmRhck9wdGlvbnMsIHRoZW1lOiBjdXJyZW50RGF0YS50aGVtZSwgZW1pdHRlcjogY3VycmVudERhdGEuZW1pdHRlciB9LCAoY2xhc3NOYW1lcywgaGVpZ2h0LCBpc0hlaWdodEF1dG8sIGZvclByaW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldENsYXNzTmFtZXMoY2xhc3NOYW1lcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEhlaWdodChoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFJlbmRlcklkLlByb3ZpZGVyLCB7IHZhbHVlOiB0aGlzLmN1c3RvbUNvbnRlbnRSZW5kZXJJZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoQ2FsZW5kYXJDb250ZW50LCBPYmplY3QuYXNzaWduKHsgaXNIZWlnaHRBdXRvOiBpc0hlaWdodEF1dG8sIGZvclByaW50OiBmb3JQcmludCB9LCBjdXJyZW50RGF0YSkpKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLCB0aGlzLmVsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNSZW5kZXJlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlbmRlcihudWxsLCB0aGlzLmVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENsYXNzTmFtZXMoW10pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZW5zdXJlRWxIYXNTdHlsZXMoZWwpO1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMucmVuZGVyUnVubmVyID0gbmV3IERlbGF5ZWRSdW5uZXIodGhpcy5oYW5kbGVSZW5kZXJSZXF1ZXN0KTtcbiAgICAgICAgbmV3IENhbGVuZGFyRGF0YU1hbmFnZXIoe1xuICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgY2FsZW5kYXJBcGk6IHRoaXMsXG4gICAgICAgICAgICBvbkFjdGlvbjogdGhpcy5oYW5kbGVBY3Rpb24sXG4gICAgICAgICAgICBvbkRhdGE6IHRoaXMuaGFuZGxlRGF0YSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHdhc1JlbmRlcmluZyA9IHRoaXMuaXNSZW5kZXJpbmc7XG4gICAgICAgIGlmICghd2FzUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmlzUmVuZGVyaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tQ29udGVudFJlbmRlcklkICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucmVxdWVzdCgpO1xuICAgICAgICBpZiAod2FzUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5pc1JlbmRlcmluZykge1xuICAgICAgICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucmVxdWVzdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVNpemUoKSB7XG4gICAgICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgICBzdXBlci51cGRhdGVTaXplKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBiYXRjaFJlbmRlcmluZyhmdW5jKSB7XG4gICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnBhdXNlKCdiYXRjaFJlbmRlcmluZycpO1xuICAgICAgICBmdW5jKCk7XG4gICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnJlc3VtZSgnYmF0Y2hSZW5kZXJpbmcnKTtcbiAgICB9XG4gICAgcGF1c2VSZW5kZXJpbmcoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnBhdXNlKCdwYXVzZVJlbmRlcmluZycpO1xuICAgIH1cbiAgICByZXN1bWVSZW5kZXJpbmcoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnJlc3VtZSgncGF1c2VSZW5kZXJpbmcnLCB0cnVlKTtcbiAgICB9XG4gICAgcmVzZXRPcHRpb25zKG9wdGlvbk92ZXJyaWRlcywgY2hhbmdlZE9wdGlvbk5hbWVzKSB7XG4gICAgICAgIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLnJlc2V0T3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGNoYW5nZWRPcHRpb25OYW1lcyk7XG4gICAgfVxuICAgIHNldENsYXNzTmFtZXMoY2xhc3NOYW1lcykge1xuICAgICAgICBpZiAoIWlzQXJyYXlzRXF1YWwoY2xhc3NOYW1lcywgdGhpcy5jdXJyZW50Q2xhc3NOYW1lcykpIHtcbiAgICAgICAgICAgIGxldCB7IGNsYXNzTGlzdCB9ID0gdGhpcy5lbDtcbiAgICAgICAgICAgIGZvciAobGV0IGNsYXNzTmFtZSBvZiB0aGlzLmN1cnJlbnRDbGFzc05hbWVzKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgY2xhc3NOYW1lIG9mIGNsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBjbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDbGFzc05hbWVzID0gY2xhc3NOYW1lcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIGFwcGx5U3R5bGVQcm9wKHRoaXMuZWwsICdoZWlnaHQnLCBoZWlnaHQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlSW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBkYXRlRW52ID0gYnVpbGREYXRlRW52KG9wdGlvbnMpO1xuICAgIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucyk7XG4gICAgbGV0IGRhdGVNZXRhID0gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKGRhdGVJbnB1dCk7XG4gICAgaWYgKCFkYXRlTWV0YSkgeyAvLyBUT0RPOiB3YXJuaW5nP1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChkYXRlTWV0YS5tYXJrZXIsIGZvcm1hdHRlciwge1xuICAgICAgICBmb3JjZWRUem86IGRhdGVNZXRhLmZvcmNlZFR6byxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFJhbmdlKHN0YXJ0SW5wdXQsIGVuZElucHV0LCBvcHRpb25zKSB7XG4gICAgbGV0IGRhdGVFbnYgPSBidWlsZERhdGVFbnYodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgPyBvcHRpb25zIDoge30pOyAvLyBwYXNzIGluIGlmIG5vbi1udWxsIG9iamVjdFxuICAgIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucyk7XG4gICAgbGV0IHN0YXJ0TWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFydElucHV0KTtcbiAgICBsZXQgZW5kTWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShlbmRJbnB1dCk7XG4gICAgaWYgKCFzdGFydE1ldGEgfHwgIWVuZE1ldGEpIHsgLy8gVE9ETzogd2FybmluZz9cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShzdGFydE1ldGEubWFya2VyLCBlbmRNZXRhLm1hcmtlciwgZm9ybWF0dGVyLCB7XG4gICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBzdGFydE1ldGEuZm9yY2VkVHpvLFxuICAgICAgICBmb3JjZWRFbmRUem86IGVuZE1ldGEuZm9yY2VkVHpvLFxuICAgICAgICBpc0VuZEV4Y2x1c2l2ZTogb3B0aW9ucy5pc0VuZEV4Y2x1c2l2ZSxcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcjogQkFTRV9PUFRJT05fREVGQVVMVFMuZGVmYXVsdFJhbmdlU2VwYXJhdG9yLFxuICAgIH0pO1xufVxuLy8gVE9ETzogbW9yZSBEUlkgYW5kIG9wdGltaXplZFxuZnVuY3Rpb24gYnVpbGREYXRlRW52KHNldHRpbmdzKSB7XG4gICAgbGV0IGxvY2FsZSA9IGJ1aWxkTG9jYWxlKHNldHRpbmdzLmxvY2FsZSB8fCAnZW4nLCBvcmdhbml6ZVJhd0xvY2FsZXMoW10pLm1hcCk7IC8vIFRPRE86IGRvbid0IGhhcmRjb2RlICdlbicgZXZlcnl3aGVyZVxuICAgIHJldHVybiBuZXcgRGF0ZUVudihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB0aW1lWm9uZTogQkFTRV9PUFRJT05fREVGQVVMVFMudGltZVpvbmUsIGNhbGVuZGFyU3lzdGVtOiAnZ3JlZ29yeScgfSwgc2V0dGluZ3MpLCB7IGxvY2FsZSB9KSk7XG59XG5cbi8vIEhFTFBFUlNcbi8qXG5pZiBuZXh0RGF5VGhyZXNob2xkIGlzIHNwZWNpZmllZCwgc2xpY2luZyBpcyBkb25lIGluIGFuIGFsbC1kYXkgZmFzaGlvbi5cbnlvdSBjYW4gZ2V0IG5leHREYXlUaHJlc2hvbGQgZnJvbSBjb250ZXh0Lm5leHREYXlUaHJlc2hvbGRcbiovXG5mdW5jdGlvbiBzbGljZUV2ZW50cyhwcm9wcywgYWxsRGF5KSB7XG4gICAgcmV0dXJuIHNsaWNlRXZlbnRTdG9yZShwcm9wcy5ldmVudFN0b3JlLCBwcm9wcy5ldmVudFVpQmFzZXMsIHByb3BzLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBhbGxEYXkgPyBwcm9wcy5uZXh0RGF5VGhyZXNob2xkIDogbnVsbCkuZmc7XG59XG5cbmNvbnN0IHZlcnNpb24gPSAnNi4xLjEwJztcblxuZXhwb3J0IHsgQ2FsZW5kYXIsIGNyZWF0ZVBsdWdpbiwgZm9ybWF0RGF0ZSwgZm9ybWF0UmFuZ2UsIGdsb2JhbExvY2FsZXMsIGdsb2JhbFBsdWdpbnMsIHNsaWNlRXZlbnRzLCB2ZXJzaW9uIH07XG4iXSwibmFtZXMiOlsibSIsIm1lcmdlUHJvcHMiLCJnIiwiZ3VpZCIsImkiLCJpc0FycmF5c0VxdWFsIiwiVCIsIlRoZW1lIiwiYSIsIm1hcEhhc2giLCJCIiwiQmFzZUNvbXBvbmVudCIsIlYiLCJWaWV3Q29udGV4dFR5cGUiLCJDIiwiQ29udGVudENvbnRhaW5lciIsImIiLCJidWlsZFZpZXdDbGFzc05hbWVzIiwiYyIsImdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvciIsImQiLCJjcmVhdGVEdXJhdGlvbiIsImUiLCJCQVNFX09QVElPTl9ERUZBVUxUUyIsImYiLCJhcnJheVRvSGFzaCIsImgiLCJmaWx0ZXJIYXNoIiwiaiIsImJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyIsInAiLCJwYXJzZUV2ZW50U291cmNlIiwiayIsImZvcm1hdFdpdGhPcmRpbmFscyIsInUiLCJ1bnByb21pc2lmeSIsImwiLCJidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lIiwibiIsImlkZW50aXR5IiwiciIsInJlcXVlc3RKc29uIiwicyIsInN1YnRyYWN0RHVyYXRpb25zIiwibyIsImludGVyc2VjdFJhbmdlcyIsInEiLCJzdGFydE9mRGF5IiwidCIsImFkZERheXMiLCJ2IiwiaGFzaFZhbHVlc1RvQXJyYXkiLCJ3IiwiYnVpbGRFdmVudEFwaXMiLCJEIiwiRGVsYXllZFJ1bm5lciIsIngiLCJjcmVhdGVGb3JtYXR0ZXIiLCJ5IiwiZGlmZldob2xlRGF5cyIsInoiLCJtZW1vaXplIiwiQSIsIm1lbW9pemVPYmpBcmciLCJFIiwiaXNQcm9wc0VxdWFsIiwiRiIsIkVtaXR0ZXIiLCJHIiwiZ2V0SW5pdGlhbERhdGUiLCJIIiwicmFuZ2VDb250YWluc01hcmtlciIsIkkiLCJjcmVhdGVFbXB0eUV2ZW50U3RvcmUiLCJKIiwicmVkdWNlQ3VycmVudERhdGUiLCJLIiwicmVkdWNlRXZlbnRTdG9yZSIsIkwiLCJyZXpvbmVFdmVudFN0b3JlRGF0ZXMiLCJNIiwibWVyZ2VSYXdPcHRpb25zIiwiTiIsIkJBU0VfT1BUSU9OX1JFRklORVJTIiwiTyIsIkNBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTIiwiUCIsIkNBTEVOREFSX09QVElPTl9SRUZJTkVSUyIsIlEiLCJDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUyIsIlIiLCJWSUVXX09QVElPTl9SRUZJTkVSUyIsIlMiLCJEYXRlRW52IiwiVSIsIkRhdGVQcm9maWxlR2VuZXJhdG9yIiwiVyIsImNyZWF0ZUV2ZW50VWkiLCJYIiwicGFyc2VCdXNpbmVzc0hvdXJzIiwiWSIsInNldFJlZiIsIloiLCJJbnRlcmFjdGlvbiIsIl8iLCJnZXRFbFNlZyIsIiQiLCJlbGVtZW50Q2xvc2VzdCIsImEwIiwiRXZlbnRJbXBsIiwiYTEiLCJsaXN0ZW5CeVNlbGVjdG9yIiwiYTIiLCJsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvciIsImEzIiwiUHVyZUNvbXBvbmVudCIsImE0IiwiYnVpbGRWaWV3Q29udGV4dCIsImE1IiwiZ2V0VW5pcXVlRG9tSWQiLCJhNiIsInBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyIsImE3IiwiaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlIiwiYTgiLCJnZXROb3ciLCJhOSIsIkNhbGVuZGFySW1wbCIsImFhIiwiZmx1c2hTeW5jIiwiYWIiLCJDYWxlbmRhclJvb3QiLCJhYyIsIlJlbmRlcklkIiwiYWQiLCJlbnN1cmVFbEhhc1N0eWxlcyIsImFlIiwiYXBwbHlTdHlsZVByb3AiLCJhZiIsInNsaWNlRXZlbnRTdG9yZSIsImFnIiwiSnNvblJlcXVlc3RFcnJvciIsImNyZWF0ZUVsZW1lbnQiLCJjcmVhdGVSZWYiLCJGcmFnbWVudCIsInJlbmRlciIsImdsb2JhbExvY2FsZXMiLCJNSU5JTUFMX1JBV19FTl9MT0NBTEUiLCJjb2RlIiwid2VlayIsImRvdyIsImRveSIsImRpcmVjdGlvbiIsImJ1dHRvblRleHQiLCJwcmV2IiwibmV4dCIsInByZXZZZWFyIiwibmV4dFllYXIiLCJ5ZWFyIiwidG9kYXkiLCJtb250aCIsImRheSIsImxpc3QiLCJ3ZWVrVGV4dCIsIndlZWtUZXh0TG9uZyIsImNsb3NlSGludCIsInRpbWVIaW50IiwiZXZlbnRIaW50IiwiYWxsRGF5VGV4dCIsIm1vcmVMaW5rVGV4dCIsIm5vRXZlbnRzVGV4dCIsIlJBV19FTl9MT0NBTEUiLCJPYmplY3QiLCJhc3NpZ24iLCJidXR0b25IaW50cyIsInVuaXQiLCJ2aWV3SGludCIsIm5hdkxpbmtIaW50IiwibW9yZUxpbmtIaW50IiwiZXZlbnRDbnQiLCJvcmdhbml6ZVJhd0xvY2FsZXMiLCJleHBsaWNpdFJhd0xvY2FsZXMiLCJkZWZhdWx0Q29kZSIsImxlbmd0aCIsImFsbFJhd0xvY2FsZXMiLCJjb25jYXQiLCJyYXdMb2NhbGVNYXAiLCJlbiIsInJhd0xvY2FsZSIsIm1hcCIsImJ1aWxkTG9jYWxlIiwiaW5wdXRTaW5ndWxhciIsImF2YWlsYWJsZSIsIkFycmF5IiwiaXNBcnJheSIsInBhcnNlTG9jYWxlIiwicXVlcnlMb2NhbGUiLCJjb2RlQXJnIiwiY29kZXMiLCJyYXciLCJxdWVyeVJhd0xvY2FsZSIsInBhcnRzIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJzcGxpdCIsInNpbXBsZUlkIiwic2xpY2UiLCJqb2luIiwibWVyZ2VkIiwic2ltcGxlTnVtYmVyRm9ybWF0IiwiSW50bCIsIk51bWJlckZvcm1hdCIsIm9wdGlvbnMiLCJjcmVhdGVQbHVnaW4iLCJpbnB1dCIsImlkIiwibmFtZSIsInByZW1pdW1SZWxlYXNlRGF0ZSIsIkRhdGUiLCJ1bmRlZmluZWQiLCJkZXBzIiwicmVkdWNlcnMiLCJpc0xvYWRpbmdGdW5jcyIsImNvbnRleHRJbml0IiwiZXZlbnRSZWZpbmVycyIsImV2ZW50RGVmTWVtYmVyQWRkZXJzIiwiZXZlbnRTb3VyY2VSZWZpbmVycyIsImlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzIiwiZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMiLCJldmVudERlZk11dGF0aW9uQXBwbGllcnMiLCJkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzIiwiZGF0ZVBvaW50VHJhbnNmb3JtcyIsImRhdGVTcGFuVHJhbnNmb3JtcyIsInZpZXdzIiwidmlld1Byb3BzVHJhbnNmb3JtZXJzIiwiaXNQcm9wc1ZhbGlkIiwiZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zIiwidmlld0NvbnRhaW5lckFwcGVuZHMiLCJldmVudERyb3BUcmFuc2Zvcm1lcnMiLCJjb21wb25lbnRJbnRlcmFjdGlvbnMiLCJjYWxlbmRhckludGVyYWN0aW9ucyIsInRoZW1lQ2xhc3NlcyIsImV2ZW50U291cmNlRGVmcyIsImNtZEZvcm1hdHRlciIsInJlY3VycmluZ1R5cGVzIiwibmFtZWRUaW1lWm9uZWRJbXBsIiwiaW5pdGlhbFZpZXciLCJlbGVtZW50RHJhZ2dpbmdJbXBsIiwib3B0aW9uQ2hhbmdlSGFuZGxlcnMiLCJzY3JvbGxHcmlkSW1wbCIsImxpc3RlbmVyUmVmaW5lcnMiLCJvcHRpb25SZWZpbmVycyIsInByb3BTZXRIYW5kbGVycyIsImJ1aWxkUGx1Z2luSG9va3MiLCJwbHVnaW5EZWZzIiwiZ2xvYmFsRGVmcyIsImN1cnJlbnRQbHVnaW5JZHMiLCJob29rcyIsImFkZERlZnMiLCJkZWZzIiwiZGVmIiwicGx1Z2luTmFtZSIsImN1cnJlbnRJZCIsImNvbWJpbmVIb29rcyIsImNvbnNvbGUiLCJ3YXJuIiwiYnVpbGRCdWlsZFBsdWdpbkhvb2tzIiwiY3VycmVudE92ZXJyaWRlRGVmcyIsImN1cnJlbnRHbG9iYWxEZWZzIiwiY3VycmVudEhvb2tzIiwib3ZlcnJpZGVEZWZzIiwiaG9va3MwIiwiaG9va3MxIiwiY29tcGFyZU9wdGlvbmFsRGF0ZXMiLCJkYXRlMCIsImRhdGUxIiwiTWF0aCIsIm1heCIsInZhbHVlT2YiLCJTdGFuZGFyZFRoZW1lIiwicHJvdG90eXBlIiwiY2xhc3NlcyIsInJvb3QiLCJ0YWJsZUNlbGxTaGFkZWQiLCJidXR0b25Hcm91cCIsImJ1dHRvbiIsImJ1dHRvbkFjdGl2ZSIsImJhc2VJY29uQ2xhc3MiLCJpY29uQ2xhc3NlcyIsImNsb3NlIiwicnRsSWNvbkNsYXNzZXMiLCJpY29uT3ZlcnJpZGVPcHRpb24iLCJpY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24iLCJpY29uT3ZlcnJpZGVQcmVmaXgiLCJjb21waWxlVmlld0RlZnMiLCJkZWZhdWx0Q29uZmlncyIsIm92ZXJyaWRlQ29uZmlncyIsImhhc2giLCJ2aWV3VHlwZSIsImVuc3VyZVZpZXdEZWYiLCJ2aWV3RGVmIiwiYnVpbGRWaWV3RGVmIiwiZGVmYXVsdENvbmZpZyIsIm92ZXJyaWRlQ29uZmlnIiwicXVlcnlQcm9wIiwidGhlQ29tcG9uZW50Iiwic3VwZXJUeXBlIiwic3VwZXJEZWYiLCJFcnJvciIsImNvbXBvbmVudCIsInR5cGUiLCJkZWZhdWx0cyIsInJhd09wdGlvbnMiLCJvdmVycmlkZXMiLCJwYXJzZVZpZXdDb25maWdzIiwiaW5wdXRzIiwicGFyc2VWaWV3Q29uZmlnIiwiY29udGVudCIsImNyZWF0ZVZpZXdIb29rQ29tcG9uZW50Iiwidmlld1Byb3BzIiwiQ29uc3VtZXIiLCJjb250ZXh0IiwiZWxUYWciLCJlbENsYXNzZXMiLCJ2aWV3U3BlYyIsInJlbmRlclByb3BzIiwibmV4dERheVRocmVzaG9sZCIsImdlbmVyYXRvck5hbWUiLCJjdXN0b21HZW5lcmF0b3IiLCJjbGFzc05hbWVHZW5lcmF0b3IiLCJjbGFzc05hbWVzIiwiZGlkTW91bnQiLCJ3aWxsVW5tb3VudCIsImJ1aWxkVmlld1NwZWNzIiwiZGVmYXVsdElucHV0cyIsIm9wdGlvbk92ZXJyaWRlcyIsImR5bmFtaWNPcHRpb25PdmVycmlkZXMiLCJsb2NhbGVEZWZhdWx0cyIsInZpZXdEZWZzIiwiYnVpbGRWaWV3U3BlYyIsImR1cmF0aW9uSW5wdXQiLCJkdXJhdGlvbiIsImR1cmF0aW9uVW5pdCIsInNpbmdsZVVuaXQiLCJzaW5nbGVVbml0T3ZlcnJpZGVzIiwiY3JlYXRlRHVyYXRpb25DYWNoZWQiLCJkZW5vbSIsInZhbHVlIiwicXVlcnlCdXR0b25UZXh0Iiwib3B0aW9uc1N1YnNldCIsImJ1dHRvblRleHRNYXAiLCJidXR0b25UZXh0S2V5IiwicXVlcnlCdXR0b25UaXRsZSIsImJ1dHRvbktleSIsIm9wdGlvbkRlZmF1bHRzIiwiYnV0dG9uVGV4dE92ZXJyaWRlIiwiYnV0dG9uVGV4dERlZmF1bHQiLCJidXR0b25UaXRsZU92ZXJyaWRlIiwiYnV0dG9uSGludCIsImJ1dHRvblRpdGxlRGVmYXVsdCIsImR1cmF0aW9uSW5wdXRNYXAiLCJqc29uIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlcyIsInJlZHVjZVZpZXdUeXBlIiwiYWN0aW9uIiwicmVkdWNlRHluYW1pY09wdGlvbk92ZXJyaWRlcyIsIm9wdGlvbk5hbWUiLCJyYXdPcHRpb25WYWx1ZSIsInJlZHVjZURhdGVQcm9maWxlIiwiY3VycmVudERhdGVQcm9maWxlIiwiY3VycmVudERhdGUiLCJkYXRlUHJvZmlsZUdlbmVyYXRvciIsImRwIiwiYnVpbGQiLCJkYXRlTWFya2VyIiwiYnVpbGRQcmV2IiwiaXNWYWxpZCIsImJ1aWxkTmV4dCIsImluaXRFdmVudFNvdXJjZXMiLCJjYWxlbmRhck9wdGlvbnMiLCJkYXRlUHJvZmlsZSIsImFjdGl2ZVJhbmdlIiwiYWRkU291cmNlcyIsInBhcnNlSW5pdGlhbFNvdXJjZXMiLCJyZWR1Y2VFdmVudFNvdXJjZXMiLCJldmVudFNvdXJjZXMiLCJzb3VyY2VzIiwicmVtb3ZlU291cmNlIiwic291cmNlSWQiLCJmZXRjaERpcnR5U291cmNlcyIsImZldGNoU291cmNlc0J5SWRzIiwic291cmNlSWRzIiwiZXhjbHVkZVN0YXRpY1NvdXJjZXMiLCJpc1JlZmV0Y2giLCJyZWNlaXZlUmVzcG9uc2UiLCJmZXRjaElkIiwiZmV0Y2hSYW5nZSIsInJlZHVjZUV2ZW50U291cmNlc05ld1RpbWVab25lIiwiY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmciLCJpc0ZldGNoaW5nIiwiZXZlbnRTb3VyY2VIYXNoIiwic291cmNlIiwiZXZlbnRTb3VyY2UiLCJzb3VyY2VIYXNoIiwiaXNTb3VyY2VEaXJ0eSIsImRvZXNTb3VyY2VOZWVkUmFuZ2UiLCJsYXRlc3RGZXRjaElkIiwibGF6eUZldGNoaW5nIiwic3RhcnQiLCJlbmQiLCJwcmV2U291cmNlcyIsInNvdXJjZUlkSGFzaCIsIm5leHRTb3VyY2VzIiwiZmV0Y2hTb3VyY2UiLCJjYWxlbmRhckFwaSIsInNvdXJjZURlZiIsInBsdWdpbkhvb2tzIiwic291cmNlRGVmSWQiLCJmZXRjaCIsInJhbmdlIiwicmF3RXZlbnRzIiwiZXZlbnRTb3VyY2VTdWNjZXNzIiwiY2FsbCIsInJlc3BvbnNlIiwic3VjY2VzcyIsImRpc3BhdGNoIiwiZXJyb3IiLCJlcnJvckhhbmRsZWQiLCJldmVudFNvdXJjZUZhaWx1cmUiLCJmYWlsdXJlIiwibWVzc2FnZSIsInJlZmluZXJzIiwicmF3U291cmNlcyIsImluaXRpYWxFdmVudHMiLCJ1bnNoaWZ0IiwiZXZlbnRzIiwicmF3U291cmNlIiwicHVzaCIsImlnbm9yZVJhbmdlIiwicmVkdWNlRGF0ZVNlbGVjdGlvbiIsImN1cnJlbnRTZWxlY3Rpb24iLCJzZWxlY3Rpb24iLCJyZWR1Y2VTZWxlY3RlZEV2ZW50IiwiY3VycmVudEluc3RhbmNlSWQiLCJldmVudEluc3RhbmNlSWQiLCJyZWR1Y2VFdmVudERyYWciLCJjdXJyZW50RHJhZyIsIm5ld0RyYWciLCJzdGF0ZSIsImFmZmVjdGVkRXZlbnRzIiwibXV0YXRlZEV2ZW50cyIsImlzRXZlbnQiLCJyZWR1Y2VFdmVudFJlc2l6ZSIsImN1cnJlbnRSZXNpemUiLCJuZXdSZXNpemUiLCJwYXJzZVRvb2xiYXJzIiwiY2FsZW5kYXJPcHRpb25PdmVycmlkZXMiLCJ0aGVtZSIsInZpZXdTcGVjcyIsImhlYWRlciIsImhlYWRlclRvb2xiYXIiLCJwYXJzZVRvb2xiYXIiLCJmb290ZXIiLCJmb290ZXJUb29sYmFyIiwic2VjdGlvblN0ckhhc2giLCJzZWN0aW9uV2lkZ2V0cyIsInZpZXdzV2l0aEJ1dHRvbnMiLCJoYXNUaXRsZSIsInNlY3Rpb25OYW1lIiwic2VjdGlvblN0ciIsInNlY3Rpb25SZXMiLCJwYXJzZVNlY3Rpb24iLCJ3aWRnZXRzIiwiaXNSdGwiLCJjYWxlbmRhckN1c3RvbUJ1dHRvbnMiLCJjdXN0b21CdXR0b25zIiwiY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzIiwiY2FsZW5kYXJCdXR0b25UZXh0IiwiY2FsZW5kYXJCdXR0b25IaW50T3ZlcnJpZGVzIiwiY2FsZW5kYXJCdXR0b25IaW50cyIsInNlY3Rpb25TdWJzdHJzIiwiYnV0dG9uR3JvdXBTdHIiLCJidXR0b25OYW1lIiwiY3VzdG9tQnV0dG9uUHJvcHMiLCJidXR0b25DbGljayIsImJ1dHRvbkljb24iLCJldiIsImNsaWNrIiwidGFyZ2V0IiwiZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzIiwiZ2V0SWNvbkNsYXNzIiwidGV4dCIsImhpbnQiLCJjaGFuZ2VWaWV3IiwidGV4dEZhbGxiYWNrIiwicHJldk9yTmV4dCIsIm5hdlVuaXQiLCJWaWV3SW1wbCIsImNvbnN0cnVjdG9yIiwiZ2V0Q3VycmVudERhdGEiLCJkYXRlRW52IiwiY2FsZW5kYXIiLCJ0aXRsZSIsInZpZXdUaXRsZSIsImFjdGl2ZVN0YXJ0IiwidG9EYXRlIiwiYWN0aXZlRW5kIiwiY3VycmVudFN0YXJ0IiwiY3VycmVudFJhbmdlIiwiY3VycmVudEVuZCIsImdldE9wdGlvbiIsImV2ZW50U291cmNlRGVmJDIiLCJwYXJzZU1ldGEiLCJyZWZpbmVkIiwiYXJnIiwic3VjY2Vzc0NhbGxiYWNrIiwibWV0YSIsImFycmF5RXZlbnRTb3VyY2VQbHVnaW4iLCJldmVudFNvdXJjZURlZiQxIiwiZXJyb3JDYWxsYmFjayIsImZ1bmMiLCJiaW5kIiwiZnVuY0V2ZW50U291cmNlUGx1Z2luIiwiSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyIsIm1ldGhvZCIsIlN0cmluZyIsImV4dHJhUGFyYW1zIiwic3RhcnRQYXJhbSIsImVuZFBhcmFtIiwidGltZVpvbmVQYXJhbSIsImV2ZW50U291cmNlRGVmIiwidXJsIiwiZm9ybWF0IiwidG9VcHBlckNhc2UiLCJyZXF1ZXN0UGFyYW1zIiwiYnVpbGRSZXF1ZXN0UGFyYW1zIiwidGhlbiIsImpzb25GZWVkRXZlbnRTb3VyY2VQbHVnaW4iLCJjdXN0b21SZXF1ZXN0UGFyYW1zIiwicGFyYW1zIiwiZm9ybWF0SXNvIiwidGltZVpvbmUiLCJTSU1QTEVfUkVDVVJSSU5HX1JFRklORVJTIiwiZGF5c09mV2VlayIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJzdGFydFJlY3VyIiwiZW5kUmVjdXIiLCJyZWN1cnJpbmciLCJwYXJzZSIsInJlY3VycmluZ0RhdGEiLCJjcmVhdGVNYXJrZXIiLCJhbGxEYXlHdWVzcyIsIkJvb2xlYW4iLCJ0eXBlRGF0YSIsImV4cGFuZCIsImZyYW1pbmdSYW5nZSIsImNsaXBwZWRGcmFtaW5nUmFuZ2UiLCJleHBhbmRSYW5nZXMiLCJzaW1wbGVSZWN1cnJpbmdFdmVudHNQbHVnaW4iLCJkb3dIYXNoIiwiZGF5TWFya2VyIiwiZW5kTWFya2VyIiwiaW5zdGFuY2VTdGFydHMiLCJpbnN0YW5jZVN0YXJ0IiwiZ2V0VVRDRGF5IiwiYWRkIiwiY2hhbmdlSGFuZGxlclBsdWdpbiIsImhhbmRsZUV2ZW50U291cmNlcyIsInVuZm91bmRTb3VyY2VzIiwiX3JhdyIsIm5ld0lucHV0cyIsImlucHV0Rm91bmQiLCJzcGxpY2UiLCJ1bmZvdW5kU291cmNlIiwibmV3SW5wdXQiLCJhZGRFdmVudFNvdXJjZSIsImhhbmRsZURhdGVQcm9maWxlIiwiZW1pdHRlciIsInRyaWdnZXIiLCJ2aWV3Iiwidmlld0FwaSIsImhhbmRsZUV2ZW50U3RvcmUiLCJldmVudFN0b3JlIiwiaGFzSGFuZGxlcnMiLCJnbG9iYWxQbHVnaW5zIiwiVGFza1J1bm5lciIsInJ1blRhc2tPcHRpb24iLCJkcmFpbmVkT3B0aW9uIiwicXVldWUiLCJkZWxheWVkUnVubmVyIiwiZHJhaW4iLCJyZXF1ZXN0IiwidGFzayIsImRlbGF5IiwicGF1c2UiLCJzY29wZSIsInJlc3VtZSIsImZvcmNlIiwiY29tcGxldGVkVGFza3MiLCJzaGlmdCIsInJ1blRhc2siLCJkcmFpbmVkIiwiYnVpbGRUaXRsZSIsInZpZXdPcHRpb25zIiwidGVzdCIsImN1cnJlbnRSYW5nZVVuaXQiLCJmb3JtYXRSYW5nZSIsInRpdGxlRm9ybWF0IiwiYnVpbGRUaXRsZUZvcm1hdCIsImlzRW5kRXhjbHVzaXZlIiwiaXNSYW5nZUFsbERheSIsImRlZmF1bHRTZXBhcmF0b3IiLCJ0aXRsZVJhbmdlU2VwYXJhdG9yIiwiZGF5cyIsIkNhbGVuZGFyRGF0YU1hbmFnZXIiLCJwcm9wcyIsImNvbXB1dGVDdXJyZW50Vmlld0RhdGEiLCJfY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSIsImJ1aWxkRGF0ZUVudiIsImJ1aWxkRGF0ZUVudiQxIiwiYnVpbGRUaGVtZSIsImJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IiLCJidWlsZFZpZXdBcGkiLCJidWlsZFZpZXdVaVByb3BzIiwiYnVpbGRFdmVudFVpQnlTb3VyY2UiLCJidWlsZEV2ZW50VWlCYXNlcyIsInBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMiLCJhY3Rpb25SdW5uZXIiLCJfaGFuZGxlQWN0aW9uIiwidXBkYXRlRGF0YSIsImN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCIsImN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkIiwiY3VycmVudFZpZXdPcHRpb25zSW5wdXQiLCJjdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkIiwiY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzIiwib3B0aW9uc0ZvclJlZmluaW5nIiwib3B0aW9uc0ZvckhhbmRsaW5nIiwiZGF0YSIsIm9wdGlvbnNEYXRhIiwiY29tcHV0ZU9wdGlvbnNEYXRhIiwiY3VycmVudFZpZXdUeXBlIiwiY3VycmVudFZpZXdEYXRhIiwiY3VycmVudERhdGFNYW5hZ2VyIiwic2V0VGhpc0NvbnRleHQiLCJzZXRPcHRpb25zIiwiY2FsZW5kYXJDb250ZXh0IiwiY2FsbGJhY2siLCJpbml0aWFsU3RhdGUiLCJidXNpbmVzc0hvdXJzIiwiZXZlbnRVaUJhc2VzIiwicmVuZGVyYWJsZUV2ZW50U3RvcmUiLCJkYXRlU2VsZWN0aW9uIiwiZXZlbnRTZWxlY3Rpb24iLCJldmVudERyYWciLCJldmVudFJlc2l6ZSIsInNlbGVjdGlvbkNvbmZpZyIsImNvbnRleHRBbmRTdGF0ZSIsInJlZHVjZXIiLCJjb21wdXRlSXNMb2FkaW5nIiwicmVzZXRPcHRpb25zIiwiY2hhbmdlZE9wdGlvbk5hbWVzIiwiaXNFdmVudHNMb2FkaW5nIiwicHJvZ3Jlc3NpdmVFdmVudFJlbmRlcmluZyIsImV2ZW50VWlTaW5nbGVCYXNlIiwiZXZlbnRVaUJ5U291cmNlIiwibmV3U3RhdGUiLCJ3YXNMb2FkaW5nIiwiaXNMb2FkaW5nIiwib25BY3Rpb24iLCJvbGREYXRhIiwiY2hhbmdlSGFuZGxlcnMiLCJvbGRDYWxlbmRhck9wdGlvbnMiLCJuZXdDYWxlbmRhck9wdGlvbnMiLCJpbmRleE9mIiwib25EYXRhIiwic3RhYmxlT3B0aW9uT3ZlcnJpZGVzIiwic3RhYmxlRHluYW1pY09wdGlvbk92ZXJyaWRlcyIsInN0YWJsZUNhbGVuZGFyT3B0aW9uc0RhdGEiLCJyZWZpbmVkT3B0aW9ucyIsImF2YWlsYWJsZUxvY2FsZURhdGEiLCJleHRyYSIsInByb2Nlc3NSYXdDYWxlbmRhck9wdGlvbnMiLCJ3YXJuVW5rbm93bk9wdGlvbnMiLCJsb2NhbGUiLCJ3ZWVrTnVtYmVyQ2FsY3VsYXRpb24iLCJmaXJzdERheSIsImRlZmF1bHRSYW5nZVNlcGFyYXRvciIsInRvb2xiYXJDb25maWciLCJhdmFpbGFibGVSYXdMb2NhbGVzIiwibG9jYWxlcyIsInBsdWdpbnMiLCJjdXJyZW50UmF3IiwiY3VycmVudFJlZmluZWQiLCJhbnlDaGFuZ2VzIiwicHJvY2Vzc1Jhd1ZpZXdPcHRpb25zIiwiZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyIsInVzZXNNaW5NYXhUaW1lIiwic2xvdE1pblRpbWUiLCJzbG90TWF4VGltZSIsInNob3dOb25DdXJyZW50RGF0ZXMiLCJkYXlDb3VudCIsImRhdGVBbGlnbm1lbnQiLCJkYXRlSW5jcmVtZW50IiwiaGlkZGVuRGF5cyIsIndlZWtlbmRzIiwibm93SW5wdXQiLCJub3ciLCJ2YWxpZFJhbmdlSW5wdXQiLCJ2YWxpZFJhbmdlIiwidmlzaWJsZVJhbmdlSW5wdXQiLCJ2aXNpYmxlUmFuZ2UiLCJmaXhlZFdlZWtDb3VudCIsImV4cGxpY2l0TG9jYWxlIiwiY2FsZW5kYXJTeXN0ZW0iLCJuYW1lZFRpbWVab25lSW1wbCIsIlRoZW1lQ2xhc3MiLCJ0aGVtZVN5c3RlbSIsIkRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MiLCJ1aSIsImV2ZW50RGVmcyIsImRlZklkIiwiZGlzcGxheSIsImV2ZW50RGlzcGxheSIsImVkaXRhYmxlIiwic3RhcnRFZGl0YWJsZSIsImV2ZW50U3RhcnRFZGl0YWJsZSIsImR1cmF0aW9uRWRpdGFibGUiLCJldmVudER1cmF0aW9uRWRpdGFibGUiLCJjb25zdHJhaW50IiwiZXZlbnRDb25zdHJhaW50Iiwib3ZlcmxhcCIsImV2ZW50T3ZlcmxhcCIsImFsbG93IiwiZXZlbnRBbGxvdyIsImJhY2tncm91bmRDb2xvciIsImV2ZW50QmFja2dyb3VuZENvbG9yIiwiYm9yZGVyQ29sb3IiLCJldmVudEJvcmRlckNvbG9yIiwidGV4dENvbG9yIiwiZXZlbnRUZXh0Q29sb3IiLCJjb2xvciIsImV2ZW50Q29sb3IiLCJzZWxlY3RDb25zdHJhaW50Iiwic2VsZWN0T3ZlcmxhcCIsInNlbGVjdEFsbG93IiwiaXNMb2FkaW5nRnVuYyIsInZpZXdOYW1lIiwiVG9vbGJhclNlY3Rpb24iLCJjaGlsZHJlbiIsIndpZGdldEdyb3VwcyIsIndpZGdldEdyb3VwIiwicmVuZGVyV2lkZ2V0R3JvdXAiLCJjbGFzc05hbWUiLCJpc09ubHlCdXR0b25zIiwid2lkZ2V0IiwidGl0bGVJZCIsImlzUHJlc3NlZCIsImFjdGl2ZUJ1dHRvbiIsImlzRGlzYWJsZWQiLCJpc1RvZGF5RW5hYmxlZCIsImlzUHJldkVuYWJsZWQiLCJpc05leHRFbmFibGVkIiwiYnV0dG9uQ2xhc3NlcyIsImdldENsYXNzIiwiZGlzYWJsZWQiLCJvbkNsaWNrIiwicm9sZSIsImdyb3VwQ2xhc3NOYW1lIiwiVG9vbGJhciIsIm1vZGVsIiwiZXh0cmFDbGFzc05hbWUiLCJmb3JjZUx0ciIsInN0YXJ0Q29udGVudCIsImVuZENvbnRlbnQiLCJjZW50ZXJDb250ZW50IiwiY2VudGVyIiwibGVmdCIsInJpZ2h0IiwicmVuZGVyU2VjdGlvbiIsImtleSIsIlZpZXdIYXJuZXNzIiwiYXJndW1lbnRzIiwiYXZhaWxhYmxlV2lkdGgiLCJoYW5kbGVFbCIsImVsIiwiZWxSZWYiLCJ1cGRhdGVBdmFpbGFibGVXaWR0aCIsImhhbmRsZVJlc2l6ZSIsImFzcGVjdFJhdGlvIiwibGlxdWlkIiwiaGVpZ2h0IiwicGFkZGluZ0JvdHRvbSIsImxhYmVsZWRCeUlkIiwicmVmIiwic3R5bGUiLCJjb21wb25lbnREaWRNb3VudCIsImFkZFJlc2l6ZUhhbmRsZXIiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInJlbW92ZVJlc2l6ZUhhbmRsZXIiLCJzZXRTdGF0ZSIsIm9mZnNldFdpZHRoIiwiRXZlbnRDbGlja2luZyIsInNldHRpbmdzIiwiaGFuZGxlU2VnQ2xpY2siLCJzZWdFbCIsInNlZyIsImlzVmFsaWRTZWdEb3duRWwiLCJoYXNVcmxDb250YWluZXIiLCJxdWVyeVNlbGVjdG9yIiwiaHJlZiIsImV2ZW50IiwiZXZlbnRSYW5nZSIsImluc3RhbmNlIiwianNFdmVudCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImRlc3Ryb3kiLCJFdmVudEhvdmVyaW5nIiwiaGFuZGxlRXZlbnRFbFJlbW92ZSIsImN1cnJlbnRTZWdFbCIsImhhbmRsZVNlZ0xlYXZlIiwiaGFuZGxlU2VnRW50ZXIiLCJ0cmlnZ2VyRXZlbnQiLCJyZW1vdmVIb3Zlckxpc3RlbmVycyIsInB1YmxpY0V2TmFtZSIsIkNhbGVuZGFyQ29udGVudCIsImJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMiLCJidWlsZFRvb2xiYXJQcm9wcyIsImhlYWRlclJlZiIsImZvb3RlclJlZiIsImludGVyYWN0aW9uc1N0b3JlIiwidmlld0xhYmVsSWQiLCJyZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50Iiwic2V0dGluZ3NJbnB1dCIsIkRFRkFVTFRfSU5URVJBQ1RJT05TIiwiaW50ZXJhY3Rpb25DbGFzc2VzIiwiaW50ZXJhY3Rpb25zIiwiVGhlSW50ZXJhY3Rpb25DbGFzcyIsInVpZCIsInVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCIsImxpc3RlbmVycyIsImxpc3RlbmVyIiwicmVzaXplUnVubmVyIiwiaGFuZGxlV2luZG93UmVzaXplIiwid2luZG93UmVzaXplRGVsYXkiLCJ0b29sYmFyUHJvcHMiLCJ2aWV3Vkdyb3ciLCJ2aWV3SGVpZ2h0Iiwidmlld0FzcGVjdFJhdGlvIiwiaXNIZWlnaHRBdXRvIiwiZm9yUHJpbnQiLCJjb250ZW50SGVpZ2h0Iiwidmlld0NvbnRleHQiLCJQcm92aWRlciIsInJlbmRlclZpZXciLCJidWlsZEFwcGVuZENvbnRlbnQiLCJDYWxlbmRhckludGVyYWN0aW9uQ2xhc3MiLCJhZGRFdmVudExpc3RlbmVyIiwicHJvcE5hbWUiLCJjb21wb25lbnREaWRVcGRhdGUiLCJwcmV2UHJvcHMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xlYXIiLCJpbnRlcmFjdGlvbiIsInRyYW5zZm9ybWVycyIsInRyYW5zZm9ybWVyIiwidHJhbnNmb3JtIiwiVmlld0NvbXBvbmVudCIsInRvZGF5SW5mbyIsInByZXZJbmZvIiwibmV4dEluZm8iLCJ0aGVDbGFzc2VzIiwiVGhlQ2xhc3MiLCJDYWxlbmRhciIsImlzUmVuZGVyaW5nIiwiaXNSZW5kZXJlZCIsImN1cnJlbnRDbGFzc05hbWVzIiwiY3VzdG9tQ29udGVudFJlbmRlcklkIiwiaGFuZGxlQWN0aW9uIiwicmVuZGVyUnVubmVyIiwidHJ5RHJhaW4iLCJoYW5kbGVEYXRhIiwiY3VycmVudERhdGEiLCJyZXJlbmRlckRlbGF5IiwiaGFuZGxlUmVuZGVyUmVxdWVzdCIsInNldENsYXNzTmFtZXMiLCJzZXRIZWlnaHQiLCJ3YXNSZW5kZXJpbmciLCJ1cGRhdGVTaXplIiwiYmF0Y2hSZW5kZXJpbmciLCJwYXVzZVJlbmRlcmluZyIsInJlc3VtZVJlbmRlcmluZyIsImNsYXNzTGlzdCIsInJlbW92ZSIsImZvcm1hdERhdGUiLCJkYXRlSW5wdXQiLCJmb3JtYXR0ZXIiLCJkYXRlTWV0YSIsImNyZWF0ZU1hcmtlck1ldGEiLCJtYXJrZXIiLCJmb3JjZWRUem8iLCJzdGFydElucHV0IiwiZW5kSW5wdXQiLCJzdGFydE1ldGEiLCJlbmRNZXRhIiwiZm9yY2VkU3RhcnRUem8iLCJmb3JjZWRFbmRUem8iLCJzbGljZUV2ZW50cyIsImFsbERheSIsImZnIiwidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/core/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@fullcalendar/core/internal-common.js":
/*!************************************************************!*\
  !*** ./node_modules/@fullcalendar/core/internal-common.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ elementClosest),\n/* harmony export */   A: () => (/* binding */ memoizeObjArg),\n/* harmony export */   B: () => (/* binding */ BaseComponent),\n/* harmony export */   C: () => (/* binding */ ContentContainer),\n/* harmony export */   D: () => (/* binding */ DelayedRunner),\n/* harmony export */   E: () => (/* binding */ isPropsEqual),\n/* harmony export */   F: () => (/* binding */ Emitter),\n/* harmony export */   G: () => (/* binding */ getInitialDate),\n/* harmony export */   H: () => (/* binding */ rangeContainsMarker),\n/* harmony export */   I: () => (/* binding */ createEmptyEventStore),\n/* harmony export */   J: () => (/* binding */ reduceCurrentDate),\n/* harmony export */   K: () => (/* binding */ reduceEventStore),\n/* harmony export */   L: () => (/* binding */ rezoneEventStoreDates),\n/* harmony export */   M: () => (/* binding */ mergeRawOptions),\n/* harmony export */   N: () => (/* binding */ BASE_OPTION_REFINERS),\n/* harmony export */   O: () => (/* binding */ CALENDAR_LISTENER_REFINERS),\n/* harmony export */   P: () => (/* binding */ CALENDAR_OPTION_REFINERS),\n/* harmony export */   Q: () => (/* binding */ COMPLEX_OPTION_COMPARATORS),\n/* harmony export */   R: () => (/* binding */ VIEW_OPTION_REFINERS),\n/* harmony export */   S: () => (/* binding */ DateEnv),\n/* harmony export */   T: () => (/* binding */ Theme),\n/* harmony export */   U: () => (/* binding */ DateProfileGenerator),\n/* harmony export */   V: () => (/* binding */ ViewContextType),\n/* harmony export */   W: () => (/* binding */ createEventUi),\n/* harmony export */   X: () => (/* binding */ parseBusinessHours),\n/* harmony export */   Y: () => (/* binding */ setRef),\n/* harmony export */   Z: () => (/* binding */ Interaction),\n/* harmony export */   _: () => (/* binding */ getElSeg),\n/* harmony export */   a: () => (/* binding */ mapHash),\n/* harmony export */   a$: () => (/* binding */ getSlotClassNames),\n/* harmony export */   a0: () => (/* binding */ EventImpl),\n/* harmony export */   a1: () => (/* binding */ listenBySelector),\n/* harmony export */   a2: () => (/* binding */ listenToHoverBySelector),\n/* harmony export */   a3: () => (/* binding */ PureComponent),\n/* harmony export */   a4: () => (/* binding */ buildViewContext),\n/* harmony export */   a5: () => (/* binding */ getUniqueDomId),\n/* harmony export */   a6: () => (/* binding */ parseInteractionSettings),\n/* harmony export */   a7: () => (/* binding */ interactionSettingsStore),\n/* harmony export */   a8: () => (/* binding */ getNow),\n/* harmony export */   a9: () => (/* binding */ CalendarImpl),\n/* harmony export */   aA: () => (/* binding */ diffDates),\n/* harmony export */   aB: () => (/* binding */ removeExact),\n/* harmony export */   aC: () => (/* binding */ memoizeArraylike),\n/* harmony export */   aD: () => (/* binding */ memoizeHashlike),\n/* harmony export */   aE: () => (/* binding */ intersectRects),\n/* harmony export */   aF: () => (/* binding */ pointInsideRect),\n/* harmony export */   aG: () => (/* binding */ constrainPoint),\n/* harmony export */   aH: () => (/* binding */ getRectCenter),\n/* harmony export */   aI: () => (/* binding */ diffPoints),\n/* harmony export */   aJ: () => (/* binding */ translateRect),\n/* harmony export */   aK: () => (/* binding */ compareObjs),\n/* harmony export */   aL: () => (/* binding */ collectFromHash),\n/* harmony export */   aM: () => (/* binding */ findElements),\n/* harmony export */   aN: () => (/* binding */ findDirectChildren),\n/* harmony export */   aO: () => (/* binding */ removeElement),\n/* harmony export */   aP: () => (/* binding */ applyStyle),\n/* harmony export */   aQ: () => (/* binding */ elementMatches),\n/* harmony export */   aR: () => (/* binding */ getEventTargetViaRoot),\n/* harmony export */   aS: () => (/* binding */ parseClassNames),\n/* harmony export */   aT: () => (/* binding */ getCanVGrowWithinCell),\n/* harmony export */   aU: () => (/* binding */ mergeEventStores),\n/* harmony export */   aV: () => (/* binding */ getRelevantEvents),\n/* harmony export */   aW: () => (/* binding */ eventTupleToStore),\n/* harmony export */   aX: () => (/* binding */ combineEventUis),\n/* harmony export */   aY: () => (/* binding */ Splitter),\n/* harmony export */   aZ: () => (/* binding */ getDayClassNames),\n/* harmony export */   a_: () => (/* binding */ getDateMeta),\n/* harmony export */   aa: () => (/* binding */ flushSync),\n/* harmony export */   ab: () => (/* binding */ CalendarRoot),\n/* harmony export */   ac: () => (/* binding */ RenderId),\n/* harmony export */   ad: () => (/* binding */ ensureElHasStyles),\n/* harmony export */   ae: () => (/* binding */ applyStyleProp),\n/* harmony export */   af: () => (/* binding */ sliceEventStore),\n/* harmony export */   ag: () => (/* binding */ JsonRequestError),\n/* harmony export */   ah: () => (/* binding */ createContext),\n/* harmony export */   ai: () => (/* binding */ refineProps),\n/* harmony export */   aj: () => (/* binding */ createEventInstance),\n/* harmony export */   ak: () => (/* binding */ parseEventDef),\n/* harmony export */   al: () => (/* binding */ refineEventDef),\n/* harmony export */   am: () => (/* binding */ padStart),\n/* harmony export */   an: () => (/* binding */ isInt),\n/* harmony export */   ao: () => (/* binding */ parseFieldSpecs),\n/* harmony export */   ap: () => (/* binding */ compareByFieldSpecs),\n/* harmony export */   aq: () => (/* binding */ flexibleCompare),\n/* harmony export */   ar: () => (/* binding */ preventSelection),\n/* harmony export */   as: () => (/* binding */ allowSelection),\n/* harmony export */   at: () => (/* binding */ preventContextMenu),\n/* harmony export */   au: () => (/* binding */ allowContextMenu),\n/* harmony export */   av: () => (/* binding */ compareNumbers),\n/* harmony export */   aw: () => (/* binding */ enableCursor),\n/* harmony export */   ax: () => (/* binding */ disableCursor),\n/* harmony export */   ay: () => (/* binding */ computeVisibleDayRange),\n/* harmony export */   az: () => (/* binding */ isMultiDayRange),\n/* harmony export */   b: () => (/* binding */ buildViewClassNames),\n/* harmony export */   b$: () => (/* binding */ SimpleScrollGrid),\n/* harmony export */   b0: () => (/* binding */ buildNavLinkAttrs),\n/* harmony export */   b1: () => (/* binding */ preventDefault),\n/* harmony export */   b2: () => (/* binding */ whenTransitionDone),\n/* harmony export */   b3: () => (/* binding */ computeInnerRect),\n/* harmony export */   b4: () => (/* binding */ computeEdges),\n/* harmony export */   b5: () => (/* binding */ getClippingParents),\n/* harmony export */   b6: () => (/* binding */ computeRect),\n/* harmony export */   b7: () => (/* binding */ rangesEqual),\n/* harmony export */   b8: () => (/* binding */ rangesIntersect),\n/* harmony export */   b9: () => (/* binding */ rangeContainsRange),\n/* harmony export */   bA: () => (/* binding */ SegHierarchy),\n/* harmony export */   bB: () => (/* binding */ buildEntryKey),\n/* harmony export */   bC: () => (/* binding */ getEntrySpanEnd),\n/* harmony export */   bD: () => (/* binding */ binarySearch),\n/* harmony export */   bE: () => (/* binding */ groupIntersectingEntries),\n/* harmony export */   bF: () => (/* binding */ intersectSpans),\n/* harmony export */   bG: () => (/* binding */ interactionSettingsToStore),\n/* harmony export */   bH: () => (/* binding */ ElementDragging),\n/* harmony export */   bI: () => (/* binding */ config),\n/* harmony export */   bJ: () => (/* binding */ parseDragMeta),\n/* harmony export */   bK: () => (/* binding */ DayHeader),\n/* harmony export */   bL: () => (/* binding */ computeFallbackHeaderFormat),\n/* harmony export */   bM: () => (/* binding */ TableDateCell),\n/* harmony export */   bN: () => (/* binding */ TableDowCell),\n/* harmony export */   bO: () => (/* binding */ DaySeriesModel),\n/* harmony export */   bP: () => (/* binding */ hasBgRendering),\n/* harmony export */   bQ: () => (/* binding */ buildSegTimeText),\n/* harmony export */   bR: () => (/* binding */ sortEventSegs),\n/* harmony export */   bS: () => (/* binding */ getSegMeta),\n/* harmony export */   bT: () => (/* binding */ buildEventRangeKey),\n/* harmony export */   bU: () => (/* binding */ getSegAnchorAttrs),\n/* harmony export */   bV: () => (/* binding */ DayTableModel),\n/* harmony export */   bW: () => (/* binding */ Slicer),\n/* harmony export */   bX: () => (/* binding */ applyMutationToEventStore),\n/* harmony export */   bY: () => (/* binding */ isPropsValid),\n/* harmony export */   bZ: () => (/* binding */ isInteractionValid),\n/* harmony export */   b_: () => (/* binding */ isDateSelectionValid),\n/* harmony export */   ba: () => (/* binding */ PositionCache),\n/* harmony export */   bb: () => (/* binding */ ScrollController),\n/* harmony export */   bc: () => (/* binding */ ElementScrollController),\n/* harmony export */   bd: () => (/* binding */ WindowScrollController),\n/* harmony export */   be: () => (/* binding */ DateComponent),\n/* harmony export */   bf: () => (/* binding */ isDateSpansEqual),\n/* harmony export */   bg: () => (/* binding */ addMs),\n/* harmony export */   bh: () => (/* binding */ addWeeks),\n/* harmony export */   bi: () => (/* binding */ diffWeeks),\n/* harmony export */   bj: () => (/* binding */ diffWholeWeeks),\n/* harmony export */   bk: () => (/* binding */ diffDayAndTime),\n/* harmony export */   bl: () => (/* binding */ diffDays),\n/* harmony export */   bm: () => (/* binding */ isValidDate),\n/* harmony export */   bn: () => (/* binding */ asCleanDays),\n/* harmony export */   bo: () => (/* binding */ multiplyDuration),\n/* harmony export */   bp: () => (/* binding */ addDurations),\n/* harmony export */   bq: () => (/* binding */ asRoughMinutes),\n/* harmony export */   br: () => (/* binding */ asRoughSeconds),\n/* harmony export */   bs: () => (/* binding */ asRoughMs),\n/* harmony export */   bt: () => (/* binding */ wholeDivideDurations),\n/* harmony export */   bu: () => (/* binding */ formatIsoTimeString),\n/* harmony export */   bv: () => (/* binding */ formatDayString),\n/* harmony export */   bw: () => (/* binding */ buildIsoString),\n/* harmony export */   bx: () => (/* binding */ formatIsoMonthStr),\n/* harmony export */   by: () => (/* binding */ NamedTimeZoneImpl),\n/* harmony export */   bz: () => (/* binding */ parse),\n/* harmony export */   c: () => (/* binding */ greatestDurationDenominator),\n/* harmony export */   c0: () => (/* binding */ hasShrinkWidth),\n/* harmony export */   c1: () => (/* binding */ renderMicroColGroup),\n/* harmony export */   c2: () => (/* binding */ getScrollGridClassNames),\n/* harmony export */   c3: () => (/* binding */ getSectionClassNames),\n/* harmony export */   c4: () => (/* binding */ getSectionHasLiquidHeight),\n/* harmony export */   c5: () => (/* binding */ getAllowYScrolling),\n/* harmony export */   c6: () => (/* binding */ renderChunkContent),\n/* harmony export */   c7: () => (/* binding */ computeShrinkWidth),\n/* harmony export */   c8: () => (/* binding */ sanitizeShrinkWidth),\n/* harmony export */   c9: () => (/* binding */ isColPropsEqual),\n/* harmony export */   ca: () => (/* binding */ renderScrollShim),\n/* harmony export */   cb: () => (/* binding */ getStickyFooterScrollbar),\n/* harmony export */   cc: () => (/* binding */ getStickyHeaderDates),\n/* harmony export */   cd: () => (/* binding */ Scroller),\n/* harmony export */   ce: () => (/* binding */ getScrollbarWidths),\n/* harmony export */   cf: () => (/* binding */ RefMap),\n/* harmony export */   cg: () => (/* binding */ getIsRtlScrollbarOnLeft),\n/* harmony export */   ch: () => (/* binding */ NowTimer),\n/* harmony export */   ci: () => (/* binding */ ScrollResponder),\n/* harmony export */   cj: () => (/* binding */ StandardEvent),\n/* harmony export */   ck: () => (/* binding */ NowIndicatorContainer),\n/* harmony export */   cl: () => (/* binding */ DayCellContainer),\n/* harmony export */   cm: () => (/* binding */ hasCustomDayCellContent),\n/* harmony export */   cn: () => (/* binding */ EventContainer),\n/* harmony export */   co: () => (/* binding */ renderFill),\n/* harmony export */   cp: () => (/* binding */ BgEvent),\n/* harmony export */   cq: () => (/* binding */ WeekNumberContainer),\n/* harmony export */   cr: () => (/* binding */ MoreLinkContainer),\n/* harmony export */   cs: () => (/* binding */ computeEarliestSegStart),\n/* harmony export */   ct: () => (/* binding */ ViewContainer),\n/* harmony export */   cu: () => (/* binding */ triggerDateSelect),\n/* harmony export */   cv: () => (/* binding */ getDefaultEventEnd),\n/* harmony export */   cw: () => (/* binding */ injectStyles),\n/* harmony export */   cx: () => (/* binding */ buildElAttrs),\n/* harmony export */   cy: () => (/* binding */ CustomRenderingStore),\n/* harmony export */   d: () => (/* binding */ createDuration),\n/* harmony export */   e: () => (/* binding */ BASE_OPTION_DEFAULTS),\n/* harmony export */   f: () => (/* binding */ arrayToHash),\n/* harmony export */   g: () => (/* binding */ guid),\n/* harmony export */   h: () => (/* binding */ filterHash),\n/* harmony export */   i: () => (/* binding */ isArraysEqual),\n/* harmony export */   j: () => (/* binding */ buildEventSourceRefiners),\n/* harmony export */   k: () => (/* binding */ formatWithOrdinals),\n/* harmony export */   l: () => (/* binding */ buildRangeApiWithTimeZone),\n/* harmony export */   m: () => (/* binding */ mergeProps),\n/* harmony export */   n: () => (/* binding */ identity),\n/* harmony export */   o: () => (/* binding */ intersectRanges),\n/* harmony export */   p: () => (/* binding */ parseEventSource),\n/* harmony export */   q: () => (/* binding */ startOfDay),\n/* harmony export */   r: () => (/* binding */ requestJson),\n/* harmony export */   s: () => (/* binding */ subtractDurations),\n/* harmony export */   t: () => (/* binding */ addDays),\n/* harmony export */   u: () => (/* binding */ unpromisify),\n/* harmony export */   v: () => (/* binding */ hashValuesToArray),\n/* harmony export */   w: () => (/* binding */ buildEventApis),\n/* harmony export */   x: () => (/* binding */ createFormatter),\n/* harmony export */   y: () => (/* binding */ diffWholeDays),\n/* harmony export */   z: () => (/* binding */ memoize)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"(ssr)/./node_modules/@fullcalendar/core/node_modules/preact/dist/preact.mjs\");\n/* harmony import */ var preact_compat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact/compat */ \"(ssr)/./node_modules/@fullcalendar/core/node_modules/preact/compat/dist/compat.mjs\");\n\n\n\nconst styleTexts = [];\nconst styleEls = new Map();\nfunction injectStyles(styleText) {\n    styleTexts.push(styleText);\n    styleEls.forEach((styleEl)=>{\n        appendStylesTo(styleEl, styleText);\n    });\n}\nfunction ensureElHasStyles(el) {\n    if (el.isConnected) {\n        registerStylesRoot(el.getRootNode());\n    }\n}\nfunction registerStylesRoot(rootNode) {\n    let styleEl = styleEls.get(rootNode);\n    if (!styleEl || !styleEl.isConnected) {\n        styleEl = rootNode.querySelector(\"style[data-fullcalendar]\");\n        if (!styleEl) {\n            styleEl = document.createElement(\"style\");\n            styleEl.setAttribute(\"data-fullcalendar\", \"\");\n            const nonce = getNonceValue();\n            if (nonce) {\n                styleEl.nonce = nonce;\n            }\n            const parentEl = rootNode === document ? document.head : rootNode;\n            const insertBefore = rootNode === document ? parentEl.querySelector(\"script,link[rel=stylesheet],link[as=style],style\") : parentEl.firstChild;\n            parentEl.insertBefore(styleEl, insertBefore);\n        }\n        styleEls.set(rootNode, styleEl);\n        hydrateStylesRoot(styleEl);\n    }\n}\nfunction hydrateStylesRoot(styleEl) {\n    for (const styleText of styleTexts){\n        appendStylesTo(styleEl, styleText);\n    }\n}\nfunction appendStylesTo(styleEl, styleText) {\n    const { sheet } = styleEl;\n    const ruleCnt = sheet.cssRules.length;\n    styleText.split(\"}\").forEach((styleStr, i)=>{\n        styleStr = styleStr.trim();\n        if (styleStr) {\n            sheet.insertRule(styleStr + \"}\", ruleCnt + i);\n        }\n    });\n}\n// nonce\n// -------------------------------------------------------------------------------------------------\nlet queriedNonceValue;\nfunction getNonceValue() {\n    if (queriedNonceValue === undefined) {\n        queriedNonceValue = queryNonceValue();\n    }\n    return queriedNonceValue;\n}\n/*\nTODO: discourage meta tag and instead put nonce attribute on placeholder <style> tag\n*/ function queryNonceValue() {\n    const metaWithNonce = document.querySelector('meta[name=\"csp-nonce\"]');\n    if (metaWithNonce && metaWithNonce.hasAttribute(\"content\")) {\n        return metaWithNonce.getAttribute(\"content\");\n    }\n    const elWithNonce = document.querySelector(\"script[nonce]\");\n    if (elWithNonce) {\n        return elWithNonce.nonce || \"\";\n    }\n    return \"\";\n}\n// main\n// -------------------------------------------------------------------------------------------------\nif (typeof document !== \"undefined\") {\n    registerStylesRoot(document);\n}\nvar css_248z = ':root{--fc-small-font-size:.85em;--fc-page-bg-color:#fff;--fc-neutral-bg-color:hsla(0,0%,82%,.3);--fc-neutral-text-color:grey;--fc-border-color:#ddd;--fc-button-text-color:#fff;--fc-button-bg-color:#2c3e50;--fc-button-border-color:#2c3e50;--fc-button-hover-bg-color:#1e2b37;--fc-button-hover-border-color:#1a252f;--fc-button-active-bg-color:#1a252f;--fc-button-active-border-color:#151e27;--fc-event-bg-color:#3788d8;--fc-event-border-color:#3788d8;--fc-event-text-color:#fff;--fc-event-selected-overlay-color:rgba(0,0,0,.25);--fc-more-link-bg-color:#d0d0d0;--fc-more-link-text-color:inherit;--fc-event-resizer-thickness:8px;--fc-event-resizer-dot-total-width:8px;--fc-event-resizer-dot-border-width:1px;--fc-non-business-color:hsla(0,0%,84%,.3);--fc-bg-event-color:#8fdf82;--fc-bg-event-opacity:0.3;--fc-highlight-color:rgba(188,232,241,.3);--fc-today-bg-color:rgba(255,220,40,.15);--fc-now-indicator-color:red}.fc-not-allowed,.fc-not-allowed .fc-event{cursor:not-allowed}.fc{display:flex;flex-direction:column;font-size:1em}.fc,.fc *,.fc :after,.fc :before{box-sizing:border-box}.fc table{border-collapse:collapse;border-spacing:0;font-size:1em}.fc th{text-align:center}.fc td,.fc th{padding:0;vertical-align:top}.fc a[data-navlink]{cursor:pointer}.fc a[data-navlink]:hover{text-decoration:underline}.fc-direction-ltr{direction:ltr;text-align:left}.fc-direction-rtl{direction:rtl;text-align:right}.fc-theme-standard td,.fc-theme-standard th{border:1px solid var(--fc-border-color)}.fc-liquid-hack td,.fc-liquid-hack th{position:relative}@font-face{font-family:fcicons;font-style:normal;font-weight:400;src:url(\"data:application/x-font-ttf;charset=utf-8;base64,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\") format(\"truetype\")}.fc-icon{speak:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;display:inline-block;font-family:fcicons!important;font-style:normal;font-variant:normal;font-weight:400;height:1em;line-height:1;text-align:center;text-transform:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:1em}.fc-icon-chevron-left:before{content:\"\\\\e900\"}.fc-icon-chevron-right:before{content:\"\\\\e901\"}.fc-icon-chevrons-left:before{content:\"\\\\e902\"}.fc-icon-chevrons-right:before{content:\"\\\\e903\"}.fc-icon-minus-square:before{content:\"\\\\e904\"}.fc-icon-plus-square:before{content:\"\\\\e905\"}.fc-icon-x:before{content:\"\\\\e906\"}.fc .fc-button{border-radius:0;font-family:inherit;font-size:inherit;line-height:inherit;margin:0;overflow:visible;text-transform:none}.fc .fc-button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}.fc .fc-button{-webkit-appearance:button}.fc .fc-button:not(:disabled){cursor:pointer}.fc .fc-button{background-color:transparent;border:1px solid transparent;border-radius:.25em;display:inline-block;font-size:1em;font-weight:400;line-height:1.5;padding:.4em .65em;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle}.fc .fc-button:hover{text-decoration:none}.fc .fc-button:focus{box-shadow:0 0 0 .2rem rgba(44,62,80,.25);outline:0}.fc .fc-button:disabled{opacity:.65}.fc .fc-button-primary{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:hover{background-color:var(--fc-button-hover-bg-color);border-color:var(--fc-button-hover-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:disabled{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button-primary:not(:disabled).fc-button-active,.fc .fc-button-primary:not(:disabled):active{background-color:var(--fc-button-active-bg-color);border-color:var(--fc-button-active-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:not(:disabled).fc-button-active:focus,.fc .fc-button-primary:not(:disabled):active:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button .fc-icon{font-size:1.5em;vertical-align:middle}.fc .fc-button-group{display:inline-flex;position:relative;vertical-align:middle}.fc .fc-button-group>.fc-button{flex:1 1 auto;position:relative}.fc .fc-button-group>.fc-button.fc-button-active,.fc .fc-button-group>.fc-button:active,.fc .fc-button-group>.fc-button:focus,.fc .fc-button-group>.fc-button:hover{z-index:1}.fc-direction-ltr .fc-button-group>.fc-button:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-1px}.fc-direction-ltr .fc-button-group>.fc-button:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.fc-direction-rtl .fc-button-group>.fc-button:not(:first-child){border-bottom-right-radius:0;border-top-right-radius:0;margin-right:-1px}.fc-direction-rtl .fc-button-group>.fc-button:not(:last-child){border-bottom-left-radius:0;border-top-left-radius:0}.fc .fc-toolbar{align-items:center;display:flex;justify-content:space-between}.fc .fc-toolbar.fc-header-toolbar{margin-bottom:1.5em}.fc .fc-toolbar.fc-footer-toolbar{margin-top:1.5em}.fc .fc-toolbar-title{font-size:1.75em;margin:0}.fc-direction-ltr .fc-toolbar>*>:not(:first-child){margin-left:.75em}.fc-direction-rtl .fc-toolbar>*>:not(:first-child){margin-right:.75em}.fc-direction-rtl .fc-toolbar-ltr{flex-direction:row-reverse}.fc .fc-scroller{-webkit-overflow-scrolling:touch;position:relative}.fc .fc-scroller-liquid{height:100%}.fc .fc-scroller-liquid-absolute{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-scroller-harness{direction:ltr;overflow:hidden;position:relative}.fc .fc-scroller-harness-liquid{height:100%}.fc-direction-rtl .fc-scroller-harness>.fc-scroller{direction:rtl}.fc-theme-standard .fc-scrollgrid{border:1px solid var(--fc-border-color)}.fc .fc-scrollgrid,.fc .fc-scrollgrid table{table-layout:fixed;width:100%}.fc .fc-scrollgrid table{border-left-style:hidden;border-right-style:hidden;border-top-style:hidden}.fc .fc-scrollgrid{border-bottom-width:0;border-collapse:separate;border-right-width:0}.fc .fc-scrollgrid-liquid{height:100%}.fc .fc-scrollgrid-section,.fc .fc-scrollgrid-section table,.fc .fc-scrollgrid-section>td{height:1px}.fc .fc-scrollgrid-section-liquid>td{height:100%}.fc .fc-scrollgrid-section>*{border-left-width:0;border-top-width:0}.fc .fc-scrollgrid-section-footer>*,.fc .fc-scrollgrid-section-header>*{border-bottom-width:0}.fc .fc-scrollgrid-section-body table,.fc .fc-scrollgrid-section-footer table{border-bottom-style:hidden}.fc .fc-scrollgrid-section-sticky>*{background:var(--fc-page-bg-color);position:sticky;z-index:3}.fc .fc-scrollgrid-section-header.fc-scrollgrid-section-sticky>*{top:0}.fc .fc-scrollgrid-section-footer.fc-scrollgrid-section-sticky>*{bottom:0}.fc .fc-scrollgrid-sticky-shim{height:1px;margin-bottom:-1px}.fc-sticky{position:sticky}.fc .fc-view-harness{flex-grow:1;position:relative}.fc .fc-view-harness-active>.fc-view{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-col-header-cell-cushion{display:inline-block;padding:2px 4px}.fc .fc-bg-event,.fc .fc-highlight,.fc .fc-non-business{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-non-business{background:var(--fc-non-business-color)}.fc .fc-bg-event{background:var(--fc-bg-event-color);opacity:var(--fc-bg-event-opacity)}.fc .fc-bg-event .fc-event-title{font-size:var(--fc-small-font-size);font-style:italic;margin:.5em}.fc .fc-highlight{background:var(--fc-highlight-color)}.fc .fc-cell-shaded,.fc .fc-day-disabled{background:var(--fc-neutral-bg-color)}a.fc-event,a.fc-event:hover{text-decoration:none}.fc-event.fc-event-draggable,.fc-event[href]{cursor:pointer}.fc-event .fc-event-main{position:relative;z-index:2}.fc-event-dragging:not(.fc-event-selected){opacity:.75}.fc-event-dragging.fc-event-selected{box-shadow:0 2px 7px rgba(0,0,0,.3)}.fc-event .fc-event-resizer{display:none;position:absolute;z-index:4}.fc-event-selected .fc-event-resizer,.fc-event:hover .fc-event-resizer{display:block}.fc-event-selected .fc-event-resizer{background:var(--fc-page-bg-color);border-color:inherit;border-radius:calc(var(--fc-event-resizer-dot-total-width)/2);border-style:solid;border-width:var(--fc-event-resizer-dot-border-width);height:var(--fc-event-resizer-dot-total-width);width:var(--fc-event-resizer-dot-total-width)}.fc-event-selected .fc-event-resizer:before{bottom:-20px;content:\"\";left:-20px;position:absolute;right:-20px;top:-20px}.fc-event-selected,.fc-event:focus{box-shadow:0 2px 5px rgba(0,0,0,.2)}.fc-event-selected:before,.fc-event:focus:before{bottom:0;content:\"\";left:0;position:absolute;right:0;top:0;z-index:3}.fc-event-selected:after,.fc-event:focus:after{background:var(--fc-event-selected-overlay-color);bottom:-1px;content:\"\";left:-1px;position:absolute;right:-1px;top:-1px;z-index:1}.fc-h-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-h-event .fc-event-main{color:var(--fc-event-text-color)}.fc-h-event .fc-event-main-frame{display:flex}.fc-h-event .fc-event-time{max-width:100%;overflow:hidden}.fc-h-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-width:0}.fc-h-event .fc-event-title{display:inline-block;left:0;max-width:100%;overflow:hidden;right:0;vertical-align:top}.fc-h-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end){border-bottom-left-radius:0;border-left-width:0;border-top-left-radius:0}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start){border-bottom-right-radius:0;border-right-width:0;border-top-right-radius:0}.fc-h-event:not(.fc-event-selected) .fc-event-resizer{bottom:0;top:0;width:var(--fc-event-resizer-thickness)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end{cursor:w-resize;left:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start{cursor:e-resize;right:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-h-event.fc-event-selected .fc-event-resizer{margin-top:calc(var(--fc-event-resizer-dot-total-width)*-.5);top:50%}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end{left:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start{right:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc .fc-popover{box-shadow:0 2px 6px rgba(0,0,0,.15);position:absolute;z-index:9999}.fc .fc-popover-header{align-items:center;display:flex;flex-direction:row;justify-content:space-between;padding:3px 4px}.fc .fc-popover-title{margin:0 2px}.fc .fc-popover-close{cursor:pointer;font-size:1.1em;opacity:.65}.fc-theme-standard .fc-popover{background:var(--fc-page-bg-color);border:1px solid var(--fc-border-color)}.fc-theme-standard .fc-popover-header{background:var(--fc-neutral-bg-color)}';\ninjectStyles(css_248z);\nclass DelayedRunner {\n    constructor(drainedOption){\n        this.drainedOption = drainedOption;\n        this.isRunning = false;\n        this.isDirty = false;\n        this.pauseDepths = {};\n        this.timeoutId = 0;\n    }\n    request(delay) {\n        this.isDirty = true;\n        if (!this.isPaused()) {\n            this.clearTimeout();\n            if (delay == null) {\n                this.tryDrain();\n            } else {\n                this.timeoutId = setTimeout(this.tryDrain.bind(this), delay);\n            }\n        }\n    }\n    pause(scope = \"\") {\n        let { pauseDepths } = this;\n        pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;\n        this.clearTimeout();\n    }\n    resume(scope = \"\", force) {\n        let { pauseDepths } = this;\n        if (scope in pauseDepths) {\n            if (force) {\n                delete pauseDepths[scope];\n            } else {\n                pauseDepths[scope] -= 1;\n                let depth = pauseDepths[scope];\n                if (depth <= 0) {\n                    delete pauseDepths[scope];\n                }\n            }\n            this.tryDrain();\n        }\n    }\n    isPaused() {\n        return Object.keys(this.pauseDepths).length;\n    }\n    tryDrain() {\n        if (!this.isRunning && !this.isPaused()) {\n            this.isRunning = true;\n            while(this.isDirty){\n                this.isDirty = false;\n                this.drained(); // might set isDirty to true again\n            }\n            this.isRunning = false;\n        }\n    }\n    clear() {\n        this.clearTimeout();\n        this.isDirty = false;\n        this.pauseDepths = {};\n    }\n    clearTimeout() {\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n            this.timeoutId = 0;\n        }\n    }\n    drained() {\n        if (this.drainedOption) {\n            this.drainedOption();\n        }\n    }\n}\nfunction removeElement(el) {\n    if (el.parentNode) {\n        el.parentNode.removeChild(el);\n    }\n}\n// Querying\n// ----------------------------------------------------------------------------------------------------------------\nfunction elementClosest(el, selector) {\n    if (el.closest) {\n        return el.closest(selector);\n    // really bad fallback for IE\n    // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n    }\n    if (!document.documentElement.contains(el)) {\n        return null;\n    }\n    do {\n        if (elementMatches(el, selector)) {\n            return el;\n        }\n        el = el.parentElement || el.parentNode;\n    }while (el !== null && el.nodeType === 1);\n    return null;\n}\nfunction elementMatches(el, selector) {\n    let method = el.matches || el.matchesSelector || el.msMatchesSelector;\n    return method.call(el, selector);\n}\n// accepts multiple subject els\n// returns a real array. good for methods like forEach\n// TODO: accept the document\nfunction findElements(container, selector) {\n    let containers = container instanceof HTMLElement ? [\n        container\n    ] : container;\n    let allMatches = [];\n    for(let i = 0; i < containers.length; i += 1){\n        let matches = containers[i].querySelectorAll(selector);\n        for(let j = 0; j < matches.length; j += 1){\n            allMatches.push(matches[j]);\n        }\n    }\n    return allMatches;\n}\n// accepts multiple subject els\n// only queries direct child elements // TODO: rename to findDirectChildren!\nfunction findDirectChildren(parent, selector) {\n    let parents = parent instanceof HTMLElement ? [\n        parent\n    ] : parent;\n    let allMatches = [];\n    for(let i = 0; i < parents.length; i += 1){\n        let childNodes = parents[i].children; // only ever elements\n        for(let j = 0; j < childNodes.length; j += 1){\n            let childNode = childNodes[j];\n            if (!selector || elementMatches(childNode, selector)) {\n                allMatches.push(childNode);\n            }\n        }\n    }\n    return allMatches;\n}\n// Style\n// ----------------------------------------------------------------------------------------------------------------\nconst PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;\nfunction applyStyle(el, props) {\n    for(let propName in props){\n        applyStyleProp(el, propName, props[propName]);\n    }\n}\nfunction applyStyleProp(el, name, val) {\n    if (val == null) {\n        el.style[name] = \"\";\n    } else if (typeof val === \"number\" && PIXEL_PROP_RE.test(name)) {\n        el.style[name] = `${val}px`;\n    } else {\n        el.style[name] = val;\n    }\n}\n// Event Handling\n// ----------------------------------------------------------------------------------------------------------------\n// if intercepting bubbled events at the document/window/body level,\n// and want to see originating element (the 'target'), use this util instead\n// of `ev.target` because it goes within web-component boundaries.\nfunction getEventTargetViaRoot(ev) {\n    var _a, _b;\n    return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;\n}\n// Unique ID for DOM attribute\nlet guid$1 = 0;\nfunction getUniqueDomId() {\n    guid$1 += 1;\n    return \"fc-dom-\" + guid$1;\n}\n// Stops a mouse/touch event from doing it's native browser action\nfunction preventDefault(ev) {\n    ev.preventDefault();\n}\n// Event Delegation\n// ----------------------------------------------------------------------------------------------------------------\nfunction buildDelegationHandler(selector, handler) {\n    return (ev)=>{\n        let matchedChild = elementClosest(ev.target, selector);\n        if (matchedChild) {\n            handler.call(matchedChild, ev, matchedChild);\n        }\n    };\n}\nfunction listenBySelector(container, eventType, selector, handler) {\n    let attachedHandler = buildDelegationHandler(selector, handler);\n    container.addEventListener(eventType, attachedHandler);\n    return ()=>{\n        container.removeEventListener(eventType, attachedHandler);\n    };\n}\nfunction listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {\n    let currentMatchedChild;\n    return listenBySelector(container, \"mouseover\", selector, (mouseOverEv, matchedChild)=>{\n        if (matchedChild !== currentMatchedChild) {\n            currentMatchedChild = matchedChild;\n            onMouseEnter(mouseOverEv, matchedChild);\n            let realOnMouseLeave = (mouseLeaveEv)=>{\n                currentMatchedChild = null;\n                onMouseLeave(mouseLeaveEv, matchedChild);\n                matchedChild.removeEventListener(\"mouseleave\", realOnMouseLeave);\n            };\n            // listen to the next mouseleave, and then unattach\n            matchedChild.addEventListener(\"mouseleave\", realOnMouseLeave);\n        }\n    });\n}\n// Animation\n// ----------------------------------------------------------------------------------------------------------------\nconst transitionEventNames = [\n    \"webkitTransitionEnd\",\n    \"otransitionend\",\n    \"oTransitionEnd\",\n    \"msTransitionEnd\",\n    \"transitionend\"\n];\n// triggered only when the next single subsequent transition finishes\nfunction whenTransitionDone(el, callback) {\n    let realCallback = (ev)=>{\n        callback(ev);\n        transitionEventNames.forEach((eventName)=>{\n            el.removeEventListener(eventName, realCallback);\n        });\n    };\n    transitionEventNames.forEach((eventName)=>{\n        el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes\n    });\n}\n// ARIA workarounds\n// ----------------------------------------------------------------------------------------------------------------\nfunction createAriaClickAttrs(handler) {\n    return Object.assign({\n        onClick: handler\n    }, createAriaKeyboardAttrs(handler));\n}\nfunction createAriaKeyboardAttrs(handler) {\n    return {\n        tabIndex: 0,\n        onKeyDown (ev) {\n            if (ev.key === \"Enter\" || ev.key === \" \") {\n                handler(ev);\n                ev.preventDefault(); // if space, don't scroll down page\n            }\n        }\n    };\n}\nlet guidNumber = 0;\nfunction guid() {\n    guidNumber += 1;\n    return String(guidNumber);\n}\n/* FullCalendar-specific DOM Utilities\n----------------------------------------------------------------------------------------------------------------------*/ // Make the mouse cursor express that an event is not allowed in the current area\nfunction disableCursor() {\n    document.body.classList.add(\"fc-not-allowed\");\n}\n// Returns the mouse cursor to its original look\nfunction enableCursor() {\n    document.body.classList.remove(\"fc-not-allowed\");\n}\n/* Selection\n----------------------------------------------------------------------------------------------------------------------*/ function preventSelection(el) {\n    el.style.userSelect = \"none\";\n    el.style.webkitUserSelect = \"none\";\n    el.addEventListener(\"selectstart\", preventDefault);\n}\nfunction allowSelection(el) {\n    el.style.userSelect = \"\";\n    el.style.webkitUserSelect = \"\";\n    el.removeEventListener(\"selectstart\", preventDefault);\n}\n/* Context Menu\n----------------------------------------------------------------------------------------------------------------------*/ function preventContextMenu(el) {\n    el.addEventListener(\"contextmenu\", preventDefault);\n}\nfunction allowContextMenu(el) {\n    el.removeEventListener(\"contextmenu\", preventDefault);\n}\nfunction parseFieldSpecs(input) {\n    let specs = [];\n    let tokens = [];\n    let i;\n    let token;\n    if (typeof input === \"string\") {\n        tokens = input.split(/\\s*,\\s*/);\n    } else if (typeof input === \"function\") {\n        tokens = [\n            input\n        ];\n    } else if (Array.isArray(input)) {\n        tokens = input;\n    }\n    for(i = 0; i < tokens.length; i += 1){\n        token = tokens[i];\n        if (typeof token === \"string\") {\n            specs.push(token.charAt(0) === \"-\" ? {\n                field: token.substring(1),\n                order: -1\n            } : {\n                field: token,\n                order: 1\n            });\n        } else if (typeof token === \"function\") {\n            specs.push({\n                func: token\n            });\n        }\n    }\n    return specs;\n}\nfunction compareByFieldSpecs(obj0, obj1, fieldSpecs) {\n    let i;\n    let cmp;\n    for(i = 0; i < fieldSpecs.length; i += 1){\n        cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);\n        if (cmp) {\n            return cmp;\n        }\n    }\n    return 0;\n}\nfunction compareByFieldSpec(obj0, obj1, fieldSpec) {\n    if (fieldSpec.func) {\n        return fieldSpec.func(obj0, obj1);\n    }\n    return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);\n}\nfunction flexibleCompare(a, b) {\n    if (!a && !b) {\n        return 0;\n    }\n    if (b == null) {\n        return -1;\n    }\n    if (a == null) {\n        return 1;\n    }\n    if (typeof a === \"string\" || typeof b === \"string\") {\n        return String(a).localeCompare(String(b));\n    }\n    return a - b;\n}\n/* String Utilities\n----------------------------------------------------------------------------------------------------------------------*/ function padStart(val, len) {\n    let s = String(val);\n    return \"000\".substr(0, len - s.length) + s;\n}\nfunction formatWithOrdinals(formatter, args, fallbackText) {\n    if (typeof formatter === \"function\") {\n        return formatter(...args);\n    }\n    if (typeof formatter === \"string\") {\n        return args.reduce((str, arg, index)=>str.replace(\"$\" + index, arg || \"\"), formatter);\n    }\n    return fallbackText;\n}\n/* Number Utilities\n----------------------------------------------------------------------------------------------------------------------*/ function compareNumbers(a, b) {\n    return a - b;\n}\nfunction isInt(n) {\n    return n % 1 === 0;\n}\n/* FC-specific DOM dimension stuff\n----------------------------------------------------------------------------------------------------------------------*/ function computeSmallestCellWidth(cellEl) {\n    let allWidthEl = cellEl.querySelector(\".fc-scrollgrid-shrink-frame\");\n    let contentWidthEl = cellEl.querySelector(\".fc-scrollgrid-shrink-cushion\");\n    if (!allWidthEl) {\n        throw new Error(\"needs fc-scrollgrid-shrink-frame className\"); // TODO: use const\n    }\n    if (!contentWidthEl) {\n        throw new Error(\"needs fc-scrollgrid-shrink-cushion className\");\n    }\n    return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border\n    contentWidthEl.getBoundingClientRect().width;\n}\nconst INTERNAL_UNITS = [\n    \"years\",\n    \"months\",\n    \"days\",\n    \"milliseconds\"\n];\nconst PARSE_RE = /^(-?)(?:(\\d+)\\.)?(\\d+):(\\d\\d)(?::(\\d\\d)(?:\\.(\\d\\d\\d))?)?/;\n// Parsing and Creation\nfunction createDuration(input, unit) {\n    if (typeof input === \"string\") {\n        return parseString(input);\n    }\n    if (typeof input === \"object\" && input) {\n        return parseObject(input);\n    }\n    if (typeof input === \"number\") {\n        return parseObject({\n            [unit || \"milliseconds\"]: input\n        });\n    }\n    return null;\n}\nfunction parseString(s) {\n    let m = PARSE_RE.exec(s);\n    if (m) {\n        let sign = m[1] ? -1 : 1;\n        return {\n            years: 0,\n            months: 0,\n            days: sign * (m[2] ? parseInt(m[2], 10) : 0),\n            milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours\n            (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes\n            (m[5] ? parseInt(m[5], 10) : 0) * 1000 + // seconds\n            (m[6] ? parseInt(m[6], 10) : 0 // ms\n            ))\n        };\n    }\n    return null;\n}\nfunction parseObject(obj) {\n    let duration = {\n        years: obj.years || obj.year || 0,\n        months: obj.months || obj.month || 0,\n        days: obj.days || obj.day || 0,\n        milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours\n        (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes\n        (obj.seconds || obj.second || 0) * 1000 + // seconds\n        (obj.milliseconds || obj.millisecond || obj.ms || 0)\n    };\n    let weeks = obj.weeks || obj.week;\n    if (weeks) {\n        duration.days += weeks * 7;\n        duration.specifiedWeeks = true;\n    }\n    return duration;\n}\n// Equality\nfunction durationsEqual(d0, d1) {\n    return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;\n}\nfunction asCleanDays(dur) {\n    if (!dur.years && !dur.months && !dur.milliseconds) {\n        return dur.days;\n    }\n    return 0;\n}\n// Simple Math\nfunction addDurations(d0, d1) {\n    return {\n        years: d0.years + d1.years,\n        months: d0.months + d1.months,\n        days: d0.days + d1.days,\n        milliseconds: d0.milliseconds + d1.milliseconds\n    };\n}\nfunction subtractDurations(d1, d0) {\n    return {\n        years: d1.years - d0.years,\n        months: d1.months - d0.months,\n        days: d1.days - d0.days,\n        milliseconds: d1.milliseconds - d0.milliseconds\n    };\n}\nfunction multiplyDuration(d, n) {\n    return {\n        years: d.years * n,\n        months: d.months * n,\n        days: d.days * n,\n        milliseconds: d.milliseconds * n\n    };\n}\n// Conversions\n// \"Rough\" because they are based on average-case Gregorian months/years\nfunction asRoughYears(dur) {\n    return asRoughDays(dur) / 365;\n}\nfunction asRoughMonths(dur) {\n    return asRoughDays(dur) / 30;\n}\nfunction asRoughDays(dur) {\n    return asRoughMs(dur) / 864e5;\n}\nfunction asRoughMinutes(dur) {\n    return asRoughMs(dur) / (1000 * 60);\n}\nfunction asRoughSeconds(dur) {\n    return asRoughMs(dur) / 1000;\n}\nfunction asRoughMs(dur) {\n    return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;\n}\n// Advanced Math\nfunction wholeDivideDurations(numerator, denominator) {\n    let res = null;\n    for(let i = 0; i < INTERNAL_UNITS.length; i += 1){\n        let unit = INTERNAL_UNITS[i];\n        if (denominator[unit]) {\n            let localRes = numerator[unit] / denominator[unit];\n            if (!isInt(localRes) || res !== null && res !== localRes) {\n                return null;\n            }\n            res = localRes;\n        } else if (numerator[unit]) {\n            // needs to divide by something but can't!\n            return null;\n        }\n    }\n    return res;\n}\nfunction greatestDurationDenominator(dur) {\n    let ms = dur.milliseconds;\n    if (ms) {\n        if (ms % 1000 !== 0) {\n            return {\n                unit: \"millisecond\",\n                value: ms\n            };\n        }\n        if (ms % (1000 * 60) !== 0) {\n            return {\n                unit: \"second\",\n                value: ms / 1000\n            };\n        }\n        if (ms % (1000 * 60 * 60) !== 0) {\n            return {\n                unit: \"minute\",\n                value: ms / (1000 * 60)\n            };\n        }\n        if (ms) {\n            return {\n                unit: \"hour\",\n                value: ms / (1000 * 60 * 60)\n            };\n        }\n    }\n    if (dur.days) {\n        if (dur.specifiedWeeks && dur.days % 7 === 0) {\n            return {\n                unit: \"week\",\n                value: dur.days / 7\n            };\n        }\n        return {\n            unit: \"day\",\n            value: dur.days\n        };\n    }\n    if (dur.months) {\n        return {\n            unit: \"month\",\n            value: dur.months\n        };\n    }\n    if (dur.years) {\n        return {\n            unit: \"year\",\n            value: dur.years\n        };\n    }\n    return {\n        unit: \"millisecond\",\n        value: 0\n    };\n}\n// TODO: new util arrayify?\nfunction removeExact(array, exactVal) {\n    let removeCnt = 0;\n    let i = 0;\n    while(i < array.length){\n        if (array[i] === exactVal) {\n            array.splice(i, 1);\n            removeCnt += 1;\n        } else {\n            i += 1;\n        }\n    }\n    return removeCnt;\n}\nfunction isArraysEqual(a0, a1, equalityFunc) {\n    if (a0 === a1) {\n        return true;\n    }\n    let len = a0.length;\n    let i;\n    if (len !== a1.length) {\n        return false;\n    }\n    for(i = 0; i < len; i += 1){\n        if (!(equalityFunc ? equalityFunc(a0[i], a1[i]) : a0[i] === a1[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nconst DAY_IDS = [\n    \"sun\",\n    \"mon\",\n    \"tue\",\n    \"wed\",\n    \"thu\",\n    \"fri\",\n    \"sat\"\n];\n// Adding\nfunction addWeeks(m, n) {\n    let a = dateToUtcArray(m);\n    a[2] += n * 7;\n    return arrayToUtcDate(a);\n}\nfunction addDays(m, n) {\n    let a = dateToUtcArray(m);\n    a[2] += n;\n    return arrayToUtcDate(a);\n}\nfunction addMs(m, n) {\n    let a = dateToUtcArray(m);\n    a[6] += n;\n    return arrayToUtcDate(a);\n}\n// Diffing (all return floats)\n// TODO: why not use ranges?\nfunction diffWeeks(m0, m1) {\n    return diffDays(m0, m1) / 7;\n}\nfunction diffDays(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);\n}\nfunction diffHours(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);\n}\nfunction diffMinutes(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / (1000 * 60);\n}\nfunction diffSeconds(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / 1000;\n}\nfunction diffDayAndTime(m0, m1) {\n    let m0day = startOfDay(m0);\n    let m1day = startOfDay(m1);\n    return {\n        years: 0,\n        months: 0,\n        days: Math.round(diffDays(m0day, m1day)),\n        milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())\n    };\n}\n// Diffing Whole Units\nfunction diffWholeWeeks(m0, m1) {\n    let d = diffWholeDays(m0, m1);\n    if (d !== null && d % 7 === 0) {\n        return d / 7;\n    }\n    return null;\n}\nfunction diffWholeDays(m0, m1) {\n    if (timeAsMs(m0) === timeAsMs(m1)) {\n        return Math.round(diffDays(m0, m1));\n    }\n    return null;\n}\n// Start-Of\nfunction startOfDay(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate()\n    ]);\n}\nfunction startOfHour(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n        m.getUTCHours()\n    ]);\n}\nfunction startOfMinute(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n        m.getUTCHours(),\n        m.getUTCMinutes()\n    ]);\n}\nfunction startOfSecond(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n        m.getUTCHours(),\n        m.getUTCMinutes(),\n        m.getUTCSeconds()\n    ]);\n}\n// Week Computation\nfunction weekOfYear(marker, dow, doy) {\n    let y = marker.getUTCFullYear();\n    let w = weekOfGivenYear(marker, y, dow, doy);\n    if (w < 1) {\n        return weekOfGivenYear(marker, y - 1, dow, doy);\n    }\n    let nextW = weekOfGivenYear(marker, y + 1, dow, doy);\n    if (nextW >= 1) {\n        return Math.min(w, nextW);\n    }\n    return w;\n}\nfunction weekOfGivenYear(marker, year, dow, doy) {\n    let firstWeekStart = arrayToUtcDate([\n        year,\n        0,\n        1 + firstWeekOffset(year, dow, doy)\n    ]);\n    let dayStart = startOfDay(marker);\n    let days = Math.round(diffDays(firstWeekStart, dayStart));\n    return Math.floor(days / 7) + 1; // zero-indexed\n}\n// start-of-first-week - start-of-year\nfunction firstWeekOffset(year, dow, doy) {\n    // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n    let fwd = 7 + dow - doy;\n    // first-week day local weekday -- which local weekday is fwd\n    let fwdlw = (7 + arrayToUtcDate([\n        year,\n        0,\n        fwd\n    ]).getUTCDay() - dow) % 7;\n    return -fwdlw + fwd - 1;\n}\n// Array Conversion\nfunction dateToLocalArray(date) {\n    return [\n        date.getFullYear(),\n        date.getMonth(),\n        date.getDate(),\n        date.getHours(),\n        date.getMinutes(),\n        date.getSeconds(),\n        date.getMilliseconds()\n    ];\n}\nfunction arrayToLocalDate(a) {\n    return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], a[3] || 0, a[4] || 0, a[5] || 0);\n}\nfunction dateToUtcArray(date) {\n    return [\n        date.getUTCFullYear(),\n        date.getUTCMonth(),\n        date.getUTCDate(),\n        date.getUTCHours(),\n        date.getUTCMinutes(),\n        date.getUTCSeconds(),\n        date.getUTCMilliseconds()\n    ];\n}\nfunction arrayToUtcDate(a) {\n    // according to web standards (and Safari), a month index is required.\n    // massage if only given a year.\n    if (a.length === 1) {\n        a = a.concat([\n            0\n        ]);\n    }\n    return new Date(Date.UTC(...a));\n}\n// Other Utils\nfunction isValidDate(m) {\n    return !isNaN(m.valueOf());\n}\nfunction timeAsMs(m) {\n    return m.getUTCHours() * 1000 * 60 * 60 + m.getUTCMinutes() * 1000 * 60 + m.getUTCSeconds() * 1000 + m.getUTCMilliseconds();\n}\n// timeZoneOffset is in minutes\nfunction buildIsoString(marker, timeZoneOffset, stripZeroTime = false) {\n    let s = marker.toISOString();\n    s = s.replace(\".000\", \"\");\n    if (stripZeroTime) {\n        s = s.replace(\"T00:00:00Z\", \"\");\n    }\n    if (s.length > 10) {\n        if (timeZoneOffset == null) {\n            s = s.replace(\"Z\", \"\");\n        } else if (timeZoneOffset !== 0) {\n            s = s.replace(\"Z\", formatTimeZoneOffset(timeZoneOffset, true));\n        }\n    // otherwise, its UTC-0 and we want to keep the Z\n    }\n    return s;\n}\n// formats the date, but with no time part\n// TODO: somehow merge with buildIsoString and stripZeroTime\n// TODO: rename. omit \"string\"\nfunction formatDayString(marker) {\n    return marker.toISOString().replace(/T.*$/, \"\");\n}\nfunction formatIsoMonthStr(marker) {\n    return marker.toISOString().match(/^\\d{4}-\\d{2}/)[0];\n}\n// TODO: use Date::toISOString and use everything after the T?\nfunction formatIsoTimeString(marker) {\n    return padStart(marker.getUTCHours(), 2) + \":\" + padStart(marker.getUTCMinutes(), 2) + \":\" + padStart(marker.getUTCSeconds(), 2);\n}\nfunction formatTimeZoneOffset(minutes, doIso = false) {\n    let sign = minutes < 0 ? \"-\" : \"+\";\n    let abs = Math.abs(minutes);\n    let hours = Math.floor(abs / 60);\n    let mins = Math.round(abs % 60);\n    if (doIso) {\n        return `${sign + padStart(hours, 2)}:${padStart(mins, 2)}`;\n    }\n    return `GMT${sign}${hours}${mins ? `:${padStart(mins, 2)}` : \"\"}`;\n}\nfunction memoize(workerFunc, resEquality, teardownFunc) {\n    let currentArgs;\n    let currentRes;\n    return function(...newArgs) {\n        if (!currentArgs) {\n            currentRes = workerFunc.apply(this, newArgs);\n        } else if (!isArraysEqual(currentArgs, newArgs)) {\n            if (teardownFunc) {\n                teardownFunc(currentRes);\n            }\n            let res = workerFunc.apply(this, newArgs);\n            if (!resEquality || !resEquality(res, currentRes)) {\n                currentRes = res;\n            }\n        }\n        currentArgs = newArgs;\n        return currentRes;\n    };\n}\nfunction memoizeObjArg(workerFunc, resEquality, teardownFunc) {\n    let currentArg;\n    let currentRes;\n    return (newArg)=>{\n        if (!currentArg) {\n            currentRes = workerFunc.call(this, newArg);\n        } else if (!isPropsEqual(currentArg, newArg)) {\n            if (teardownFunc) {\n                teardownFunc(currentRes);\n            }\n            let res = workerFunc.call(this, newArg);\n            if (!resEquality || !resEquality(res, currentRes)) {\n                currentRes = res;\n            }\n        }\n        currentArg = newArg;\n        return currentRes;\n    };\n}\nfunction memoizeArraylike(workerFunc, resEquality, teardownFunc) {\n    let currentArgSets = [];\n    let currentResults = [];\n    return (newArgSets)=>{\n        let currentLen = currentArgSets.length;\n        let newLen = newArgSets.length;\n        let i = 0;\n        for(; i < currentLen; i += 1){\n            if (!newArgSets[i]) {\n                if (teardownFunc) {\n                    teardownFunc(currentResults[i]);\n                }\n            } else if (!isArraysEqual(currentArgSets[i], newArgSets[i])) {\n                if (teardownFunc) {\n                    teardownFunc(currentResults[i]);\n                }\n                let res = workerFunc.apply(this, newArgSets[i]);\n                if (!resEquality || !resEquality(res, currentResults[i])) {\n                    currentResults[i] = res;\n                }\n            }\n        }\n        for(; i < newLen; i += 1){\n            currentResults[i] = workerFunc.apply(this, newArgSets[i]);\n        }\n        currentArgSets = newArgSets;\n        currentResults.splice(newLen); // remove excess\n        return currentResults;\n    };\n}\nfunction memoizeHashlike(workerFunc, resEquality, teardownFunc) {\n    let currentArgHash = {};\n    let currentResHash = {};\n    return (newArgHash)=>{\n        let newResHash = {};\n        for(let key in newArgHash){\n            if (!currentResHash[key]) {\n                newResHash[key] = workerFunc.apply(this, newArgHash[key]);\n            } else if (!isArraysEqual(currentArgHash[key], newArgHash[key])) {\n                if (teardownFunc) {\n                    teardownFunc(currentResHash[key]);\n                }\n                let res = workerFunc.apply(this, newArgHash[key]);\n                newResHash[key] = resEquality && resEquality(res, currentResHash[key]) ? currentResHash[key] : res;\n            } else {\n                newResHash[key] = currentResHash[key];\n            }\n        }\n        currentArgHash = newArgHash;\n        currentResHash = newResHash;\n        return newResHash;\n    };\n}\nconst EXTENDED_SETTINGS_AND_SEVERITIES = {\n    week: 3,\n    separator: 0,\n    omitZeroMinute: 0,\n    meridiem: 0,\n    omitCommas: 0\n};\nconst STANDARD_DATE_PROP_SEVERITIES = {\n    timeZoneName: 7,\n    era: 6,\n    year: 5,\n    month: 4,\n    day: 2,\n    weekday: 2,\n    hour: 1,\n    minute: 1,\n    second: 1\n};\nconst MERIDIEM_RE = /\\s*([ap])\\.?m\\.?/i; // eats up leading spaces too\nconst COMMA_RE = /,/g; // we need re for globalness\nconst MULTI_SPACE_RE = /\\s+/g;\nconst LTR_RE = /\\u200e/g; // control character\nconst UTC_RE = /UTC|GMT/;\nclass NativeFormatter {\n    constructor(formatSettings){\n        let standardDateProps = {};\n        let extendedSettings = {};\n        let severity = 0;\n        for(let name in formatSettings){\n            if (name in EXTENDED_SETTINGS_AND_SEVERITIES) {\n                extendedSettings[name] = formatSettings[name];\n                severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name], severity);\n            } else {\n                standardDateProps[name] = formatSettings[name];\n                if (name in STANDARD_DATE_PROP_SEVERITIES) {\n                    severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name], severity);\n                }\n            }\n        }\n        this.standardDateProps = standardDateProps;\n        this.extendedSettings = extendedSettings;\n        this.severity = severity;\n        this.buildFormattingFunc = memoize(buildFormattingFunc);\n    }\n    format(date, context) {\n        return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);\n    }\n    formatRange(start, end, context, betterDefaultSeparator) {\n        let { standardDateProps, extendedSettings } = this;\n        let diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);\n        if (!diffSeverity) {\n            return this.format(start, context);\n        }\n        let biggestUnitForPartial = diffSeverity;\n        if (biggestUnitForPartial > 1 && // the two dates are different in a way that's larger scale than time\n        (standardDateProps.year === \"numeric\" || standardDateProps.year === \"2-digit\") && (standardDateProps.month === \"numeric\" || standardDateProps.month === \"2-digit\") && (standardDateProps.day === \"numeric\" || standardDateProps.day === \"2-digit\")) {\n            biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time\n        }\n        let full0 = this.format(start, context);\n        let full1 = this.format(end, context);\n        if (full0 === full1) {\n            return full0;\n        }\n        let partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);\n        let partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);\n        let partial0 = partialFormattingFunc(start);\n        let partial1 = partialFormattingFunc(end);\n        let insertion = findCommonInsertion(full0, partial0, full1, partial1);\n        let separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || \"\";\n        if (insertion) {\n            return insertion.before + partial0 + separator + partial1 + insertion.after;\n        }\n        return full0 + separator + full1;\n    }\n    getLargestUnit() {\n        switch(this.severity){\n            case 7:\n            case 6:\n            case 5:\n                return \"year\";\n            case 4:\n                return \"month\";\n            case 3:\n                return \"week\";\n            case 2:\n                return \"day\";\n            default:\n                return \"time\"; // really?\n        }\n    }\n}\nfunction buildFormattingFunc(standardDateProps, extendedSettings, context) {\n    let standardDatePropCnt = Object.keys(standardDateProps).length;\n    if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === \"short\") {\n        return (date)=>formatTimeZoneOffset(date.timeZoneOffset);\n    }\n    if (standardDatePropCnt === 0 && extendedSettings.week) {\n        return (date)=>formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week);\n    }\n    return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);\n}\nfunction buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {\n    standardDateProps = Object.assign({}, standardDateProps); // copy\n    extendedSettings = Object.assign({}, extendedSettings); // copy\n    sanitizeSettings(standardDateProps, extendedSettings);\n    standardDateProps.timeZone = \"UTC\"; // we leverage the only guaranteed timeZone for our UTC markers\n    let normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);\n    let zeroFormat; // needed?\n    if (extendedSettings.omitZeroMinute) {\n        let zeroProps = Object.assign({}, standardDateProps);\n        delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings\n        zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);\n    }\n    return (date)=>{\n        let { marker } = date;\n        let format;\n        if (zeroFormat && !marker.getUTCMinutes()) {\n            format = zeroFormat;\n        } else {\n            format = normalFormat;\n        }\n        let s = format.format(marker);\n        return postProcess(s, date, standardDateProps, extendedSettings, context);\n    };\n}\nfunction sanitizeSettings(standardDateProps, extendedSettings) {\n    // deal with a browser inconsistency where formatting the timezone\n    // requires that the hour/minute be present.\n    if (standardDateProps.timeZoneName) {\n        if (!standardDateProps.hour) {\n            standardDateProps.hour = \"2-digit\";\n        }\n        if (!standardDateProps.minute) {\n            standardDateProps.minute = \"2-digit\";\n        }\n    }\n    // only support short timezone names\n    if (standardDateProps.timeZoneName === \"long\") {\n        standardDateProps.timeZoneName = \"short\";\n    }\n    // if requesting to display seconds, MUST display minutes\n    if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {\n        delete extendedSettings.omitZeroMinute;\n    }\n}\nfunction postProcess(s, date, standardDateProps, extendedSettings, context) {\n    s = s.replace(LTR_RE, \"\"); // remove left-to-right control chars. do first. good for other regexes\n    if (standardDateProps.timeZoneName === \"short\") {\n        s = injectTzoStr(s, context.timeZone === \"UTC\" || date.timeZoneOffset == null ? \"UTC\" : formatTimeZoneOffset(date.timeZoneOffset));\n    }\n    if (extendedSettings.omitCommas) {\n        s = s.replace(COMMA_RE, \"\").trim();\n    }\n    if (extendedSettings.omitZeroMinute) {\n        s = s.replace(\":00\", \"\"); // zeroFormat doesn't always achieve this\n    }\n    // ^ do anything that might create adjacent spaces before this point,\n    // because MERIDIEM_RE likes to eat up loading spaces\n    if (extendedSettings.meridiem === false) {\n        s = s.replace(MERIDIEM_RE, \"\").trim();\n    } else if (extendedSettings.meridiem === \"narrow\") {\n        s = s.replace(MERIDIEM_RE, (m0, m1)=>m1.toLocaleLowerCase());\n    } else if (extendedSettings.meridiem === \"short\") {\n        s = s.replace(MERIDIEM_RE, (m0, m1)=>`${m1.toLocaleLowerCase()}m`);\n    } else if (extendedSettings.meridiem === \"lowercase\") {\n        s = s.replace(MERIDIEM_RE, (m0)=>m0.toLocaleLowerCase());\n    }\n    s = s.replace(MULTI_SPACE_RE, \" \");\n    s = s.trim();\n    return s;\n}\nfunction injectTzoStr(s, tzoStr) {\n    let replaced = false;\n    s = s.replace(UTC_RE, ()=>{\n        replaced = true;\n        return tzoStr;\n    });\n    // IE11 doesn't include UTC/GMT in the original string, so append to end\n    if (!replaced) {\n        s += ` ${tzoStr}`;\n    }\n    return s;\n}\nfunction formatWeekNumber(num, weekText, weekTextLong, locale, display) {\n    let parts = [];\n    if (display === \"long\") {\n        parts.push(weekTextLong);\n    } else if (display === \"short\" || display === \"narrow\") {\n        parts.push(weekText);\n    }\n    if (display === \"long\" || display === \"short\") {\n        parts.push(\" \");\n    }\n    parts.push(locale.simpleNumberFormat.format(num));\n    if (locale.options.direction === \"rtl\") {\n        parts.reverse();\n    }\n    return parts.join(\"\");\n}\n// Range Formatting Utils\n// 0 = exactly the same\n// 1 = different by time\n// and bigger\nfunction computeMarkerDiffSeverity(d0, d1, ca) {\n    if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {\n        return 5;\n    }\n    if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {\n        return 4;\n    }\n    if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {\n        return 2;\n    }\n    if (timeAsMs(d0) !== timeAsMs(d1)) {\n        return 1;\n    }\n    return 0;\n}\nfunction computePartialFormattingOptions(options, biggestUnit) {\n    let partialOptions = {};\n    for(let name in options){\n        if (!(name in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)\n        STANDARD_DATE_PROP_SEVERITIES[name] <= biggestUnit) {\n            partialOptions[name] = options[name];\n        }\n    }\n    return partialOptions;\n}\nfunction findCommonInsertion(full0, partial0, full1, partial1) {\n    let i0 = 0;\n    while(i0 < full0.length){\n        let found0 = full0.indexOf(partial0, i0);\n        if (found0 === -1) {\n            break;\n        }\n        let before0 = full0.substr(0, found0);\n        i0 = found0 + partial0.length;\n        let after0 = full0.substr(i0);\n        let i1 = 0;\n        while(i1 < full1.length){\n            let found1 = full1.indexOf(partial1, i1);\n            if (found1 === -1) {\n                break;\n            }\n            let before1 = full1.substr(0, found1);\n            i1 = found1 + partial1.length;\n            let after1 = full1.substr(i1);\n            if (before0 === before1 && after0 === after1) {\n                return {\n                    before: before0,\n                    after: after0\n                };\n            }\n        }\n    }\n    return null;\n}\nfunction expandZonedMarker(dateInfo, calendarSystem) {\n    let a = calendarSystem.markerToArray(dateInfo.marker);\n    return {\n        marker: dateInfo.marker,\n        timeZoneOffset: dateInfo.timeZoneOffset,\n        array: a,\n        year: a[0],\n        month: a[1],\n        day: a[2],\n        hour: a[3],\n        minute: a[4],\n        second: a[5],\n        millisecond: a[6]\n    };\n}\nfunction createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {\n    let startInfo = expandZonedMarker(start, context.calendarSystem);\n    let endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;\n    return {\n        date: startInfo,\n        start: startInfo,\n        end: endInfo,\n        timeZone: context.timeZone,\n        localeCodes: context.locale.codes,\n        defaultSeparator: betterDefaultSeparator || context.defaultSeparator\n    };\n}\n/*\nTODO: fix the terminology of \"formatter\" vs \"formatting func\"\n*/ /*\nAt the time of instantiation, this object does not know which cmd-formatting system it will use.\nIt receives this at the time of formatting, as a setting.\n*/ class CmdFormatter {\n    constructor(cmdStr){\n        this.cmdStr = cmdStr;\n    }\n    format(date, context, betterDefaultSeparator) {\n        return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n    }\n    formatRange(start, end, context, betterDefaultSeparator) {\n        return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n    }\n}\nclass FuncFormatter {\n    constructor(func){\n        this.func = func;\n    }\n    format(date, context, betterDefaultSeparator) {\n        return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n    }\n    formatRange(start, end, context, betterDefaultSeparator) {\n        return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n    }\n}\nfunction createFormatter(input) {\n    if (typeof input === \"object\" && input) {\n        return new NativeFormatter(input);\n    }\n    if (typeof input === \"string\") {\n        return new CmdFormatter(input);\n    }\n    if (typeof input === \"function\") {\n        return new FuncFormatter(input);\n    }\n    return null;\n}\n// base options\n// ------------\nconst BASE_OPTION_REFINERS = {\n    navLinkDayClick: identity,\n    navLinkWeekClick: identity,\n    duration: createDuration,\n    bootstrapFontAwesome: identity,\n    buttonIcons: identity,\n    customButtons: identity,\n    defaultAllDayEventDuration: createDuration,\n    defaultTimedEventDuration: createDuration,\n    nextDayThreshold: createDuration,\n    scrollTime: createDuration,\n    scrollTimeReset: Boolean,\n    slotMinTime: createDuration,\n    slotMaxTime: createDuration,\n    dayPopoverFormat: createFormatter,\n    slotDuration: createDuration,\n    snapDuration: createDuration,\n    headerToolbar: identity,\n    footerToolbar: identity,\n    defaultRangeSeparator: String,\n    titleRangeSeparator: String,\n    forceEventDuration: Boolean,\n    dayHeaders: Boolean,\n    dayHeaderFormat: createFormatter,\n    dayHeaderClassNames: identity,\n    dayHeaderContent: identity,\n    dayHeaderDidMount: identity,\n    dayHeaderWillUnmount: identity,\n    dayCellClassNames: identity,\n    dayCellContent: identity,\n    dayCellDidMount: identity,\n    dayCellWillUnmount: identity,\n    initialView: String,\n    aspectRatio: Number,\n    weekends: Boolean,\n    weekNumberCalculation: identity,\n    weekNumbers: Boolean,\n    weekNumberClassNames: identity,\n    weekNumberContent: identity,\n    weekNumberDidMount: identity,\n    weekNumberWillUnmount: identity,\n    editable: Boolean,\n    viewClassNames: identity,\n    viewDidMount: identity,\n    viewWillUnmount: identity,\n    nowIndicator: Boolean,\n    nowIndicatorClassNames: identity,\n    nowIndicatorContent: identity,\n    nowIndicatorDidMount: identity,\n    nowIndicatorWillUnmount: identity,\n    showNonCurrentDates: Boolean,\n    lazyFetching: Boolean,\n    startParam: String,\n    endParam: String,\n    timeZoneParam: String,\n    timeZone: String,\n    locales: identity,\n    locale: identity,\n    themeSystem: String,\n    dragRevertDuration: Number,\n    dragScroll: Boolean,\n    allDayMaintainDuration: Boolean,\n    unselectAuto: Boolean,\n    dropAccept: identity,\n    eventOrder: parseFieldSpecs,\n    eventOrderStrict: Boolean,\n    handleWindowResize: Boolean,\n    windowResizeDelay: Number,\n    longPressDelay: Number,\n    eventDragMinDistance: Number,\n    expandRows: Boolean,\n    height: identity,\n    contentHeight: identity,\n    direction: String,\n    weekNumberFormat: createFormatter,\n    eventResizableFromStart: Boolean,\n    displayEventTime: Boolean,\n    displayEventEnd: Boolean,\n    weekText: String,\n    weekTextLong: String,\n    progressiveEventRendering: Boolean,\n    businessHours: identity,\n    initialDate: identity,\n    now: identity,\n    eventDataTransform: identity,\n    stickyHeaderDates: identity,\n    stickyFooterScrollbar: identity,\n    viewHeight: identity,\n    defaultAllDay: Boolean,\n    eventSourceFailure: identity,\n    eventSourceSuccess: identity,\n    eventDisplay: String,\n    eventStartEditable: Boolean,\n    eventDurationEditable: Boolean,\n    eventOverlap: identity,\n    eventConstraint: identity,\n    eventAllow: identity,\n    eventBackgroundColor: String,\n    eventBorderColor: String,\n    eventTextColor: String,\n    eventColor: String,\n    eventClassNames: identity,\n    eventContent: identity,\n    eventDidMount: identity,\n    eventWillUnmount: identity,\n    selectConstraint: identity,\n    selectOverlap: identity,\n    selectAllow: identity,\n    droppable: Boolean,\n    unselectCancel: String,\n    slotLabelFormat: identity,\n    slotLaneClassNames: identity,\n    slotLaneContent: identity,\n    slotLaneDidMount: identity,\n    slotLaneWillUnmount: identity,\n    slotLabelClassNames: identity,\n    slotLabelContent: identity,\n    slotLabelDidMount: identity,\n    slotLabelWillUnmount: identity,\n    dayMaxEvents: identity,\n    dayMaxEventRows: identity,\n    dayMinWidth: Number,\n    slotLabelInterval: createDuration,\n    allDayText: String,\n    allDayClassNames: identity,\n    allDayContent: identity,\n    allDayDidMount: identity,\n    allDayWillUnmount: identity,\n    slotMinWidth: Number,\n    navLinks: Boolean,\n    eventTimeFormat: createFormatter,\n    rerenderDelay: Number,\n    moreLinkText: identity,\n    moreLinkHint: identity,\n    selectMinDistance: Number,\n    selectable: Boolean,\n    selectLongPressDelay: Number,\n    eventLongPressDelay: Number,\n    selectMirror: Boolean,\n    eventMaxStack: Number,\n    eventMinHeight: Number,\n    eventMinWidth: Number,\n    eventShortHeight: Number,\n    slotEventOverlap: Boolean,\n    plugins: identity,\n    firstDay: Number,\n    dayCount: Number,\n    dateAlignment: String,\n    dateIncrement: createDuration,\n    hiddenDays: identity,\n    fixedWeekCount: Boolean,\n    validRange: identity,\n    visibleRange: identity,\n    titleFormat: identity,\n    eventInteractive: Boolean,\n    // only used by list-view, but languages define the value, so we need it in base options\n    noEventsText: String,\n    viewHint: identity,\n    navLinkHint: identity,\n    closeHint: String,\n    timeHint: String,\n    eventHint: String,\n    moreLinkClick: identity,\n    moreLinkClassNames: identity,\n    moreLinkContent: identity,\n    moreLinkDidMount: identity,\n    moreLinkWillUnmount: identity,\n    monthStartFormat: createFormatter,\n    // for connectors\n    // (can't be part of plugin system b/c must be provided at runtime)\n    handleCustomRendering: identity,\n    customRenderingMetaMap: identity,\n    customRenderingReplaces: Boolean\n};\n// do NOT give a type here. need `typeof BASE_OPTION_DEFAULTS` to give real results.\n// raw values.\nconst BASE_OPTION_DEFAULTS = {\n    eventDisplay: \"auto\",\n    defaultRangeSeparator: \" - \",\n    titleRangeSeparator: \"  \",\n    defaultTimedEventDuration: \"01:00:00\",\n    defaultAllDayEventDuration: {\n        day: 1\n    },\n    forceEventDuration: false,\n    nextDayThreshold: \"00:00:00\",\n    dayHeaders: true,\n    initialView: \"\",\n    aspectRatio: 1.35,\n    headerToolbar: {\n        start: \"title\",\n        center: \"\",\n        end: \"today prev,next\"\n    },\n    weekends: true,\n    weekNumbers: false,\n    weekNumberCalculation: \"local\",\n    editable: false,\n    nowIndicator: false,\n    scrollTime: \"06:00:00\",\n    scrollTimeReset: true,\n    slotMinTime: \"00:00:00\",\n    slotMaxTime: \"24:00:00\",\n    showNonCurrentDates: true,\n    lazyFetching: true,\n    startParam: \"start\",\n    endParam: \"end\",\n    timeZoneParam: \"timeZone\",\n    timeZone: \"local\",\n    locales: [],\n    locale: \"\",\n    themeSystem: \"standard\",\n    dragRevertDuration: 500,\n    dragScroll: true,\n    allDayMaintainDuration: false,\n    unselectAuto: true,\n    dropAccept: \"*\",\n    eventOrder: \"start,-duration,allDay,title\",\n    dayPopoverFormat: {\n        month: \"long\",\n        day: \"numeric\",\n        year: \"numeric\"\n    },\n    handleWindowResize: true,\n    windowResizeDelay: 100,\n    longPressDelay: 1000,\n    eventDragMinDistance: 5,\n    expandRows: false,\n    navLinks: false,\n    selectable: false,\n    eventMinHeight: 15,\n    eventMinWidth: 30,\n    eventShortHeight: 30,\n    monthStartFormat: {\n        month: \"long\",\n        day: \"numeric\"\n    }\n};\n// calendar listeners\n// ------------------\nconst CALENDAR_LISTENER_REFINERS = {\n    datesSet: identity,\n    eventsSet: identity,\n    eventAdd: identity,\n    eventChange: identity,\n    eventRemove: identity,\n    windowResize: identity,\n    eventClick: identity,\n    eventMouseEnter: identity,\n    eventMouseLeave: identity,\n    select: identity,\n    unselect: identity,\n    loading: identity,\n    // internal\n    _unmount: identity,\n    _beforeprint: identity,\n    _afterprint: identity,\n    _noEventDrop: identity,\n    _noEventResize: identity,\n    _resize: identity,\n    _scrollRequest: identity\n};\n// calendar-specific options\n// -------------------------\nconst CALENDAR_OPTION_REFINERS = {\n    buttonText: identity,\n    buttonHints: identity,\n    views: identity,\n    plugins: identity,\n    initialEvents: identity,\n    events: identity,\n    eventSources: identity\n};\nconst COMPLEX_OPTION_COMPARATORS = {\n    headerToolbar: isMaybeObjectsEqual,\n    footerToolbar: isMaybeObjectsEqual,\n    buttonText: isMaybeObjectsEqual,\n    buttonHints: isMaybeObjectsEqual,\n    buttonIcons: isMaybeObjectsEqual,\n    dateIncrement: isMaybeObjectsEqual,\n    plugins: isMaybeArraysEqual,\n    events: isMaybeArraysEqual,\n    eventSources: isMaybeArraysEqual,\n    [\"resources\"]: isMaybeArraysEqual\n};\nfunction isMaybeObjectsEqual(a, b) {\n    if (typeof a === \"object\" && typeof b === \"object\" && a && b) {\n        return isPropsEqual(a, b);\n    }\n    return a === b;\n}\nfunction isMaybeArraysEqual(a, b) {\n    if (Array.isArray(a) && Array.isArray(b)) {\n        return isArraysEqual(a, b);\n    }\n    return a === b;\n}\n// view-specific options\n// ---------------------\nconst VIEW_OPTION_REFINERS = {\n    type: String,\n    component: identity,\n    buttonText: String,\n    buttonTextKey: String,\n    dateProfileGeneratorClass: identity,\n    usesMinMaxTime: Boolean,\n    classNames: identity,\n    content: identity,\n    didMount: identity,\n    willUnmount: identity\n};\n// util funcs\n// ----------------------------------------------------------------------------------------------------\nfunction mergeRawOptions(optionSets) {\n    return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);\n}\nfunction refineProps(input, refiners) {\n    let refined = {};\n    let extra = {};\n    for(let propName in refiners){\n        if (propName in input) {\n            refined[propName] = refiners[propName](input[propName]);\n        }\n    }\n    for(let propName in input){\n        if (!(propName in refiners)) {\n            extra[propName] = input[propName];\n        }\n    }\n    return {\n        refined,\n        extra\n    };\n}\nfunction identity(raw) {\n    return raw;\n}\nconst { hasOwnProperty } = Object.prototype;\n// Merges an array of objects into a single object.\n// The second argument allows for an array of property names who's object values will be merged together.\nfunction mergeProps(propObjs, complexPropsMap) {\n    let dest = {};\n    if (complexPropsMap) {\n        for(let name in complexPropsMap){\n            if (complexPropsMap[name] === isMaybeObjectsEqual) {\n                let complexObjs = [];\n                // collect the trailing object values, stopping when a non-object is discovered\n                for(let i = propObjs.length - 1; i >= 0; i -= 1){\n                    let val = propObjs[i][name];\n                    if (typeof val === \"object\" && val) {\n                        complexObjs.unshift(val);\n                    } else if (val !== undefined) {\n                        dest[name] = val; // if there were no objects, this value will be used\n                        break;\n                    }\n                }\n                // if the trailing values were objects, use the merged value\n                if (complexObjs.length) {\n                    dest[name] = mergeProps(complexObjs);\n                }\n            }\n        }\n    }\n    // copy values into the destination, going from last to first\n    for(let i = propObjs.length - 1; i >= 0; i -= 1){\n        let props = propObjs[i];\n        for(let name in props){\n            if (!(name in dest)) {\n                dest[name] = props[name];\n            }\n        }\n    }\n    return dest;\n}\nfunction filterHash(hash, func) {\n    let filtered = {};\n    for(let key in hash){\n        if (func(hash[key], key)) {\n            filtered[key] = hash[key];\n        }\n    }\n    return filtered;\n}\nfunction mapHash(hash, func) {\n    let newHash = {};\n    for(let key in hash){\n        newHash[key] = func(hash[key], key);\n    }\n    return newHash;\n}\nfunction arrayToHash(a) {\n    let hash = {};\n    for (let item of a){\n        hash[item] = true;\n    }\n    return hash;\n}\n// TODO: reassess browser support\n// https://caniuse.com/?search=object.values\nfunction hashValuesToArray(obj) {\n    let a = [];\n    for(let key in obj){\n        a.push(obj[key]);\n    }\n    return a;\n}\nfunction isPropsEqual(obj0, obj1) {\n    if (obj0 === obj1) {\n        return true;\n    }\n    for(let key in obj0){\n        if (hasOwnProperty.call(obj0, key)) {\n            if (!(key in obj1)) {\n                return false;\n            }\n        }\n    }\n    for(let key in obj1){\n        if (hasOwnProperty.call(obj1, key)) {\n            if (obj0[key] !== obj1[key]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nconst HANDLER_RE = /^on[A-Z]/;\nfunction isNonHandlerPropsEqual(obj0, obj1) {\n    const keys = getUnequalProps(obj0, obj1);\n    for (let key of keys){\n        if (!HANDLER_RE.test(key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getUnequalProps(obj0, obj1) {\n    let keys = [];\n    for(let key in obj0){\n        if (hasOwnProperty.call(obj0, key)) {\n            if (!(key in obj1)) {\n                keys.push(key);\n            }\n        }\n    }\n    for(let key in obj1){\n        if (hasOwnProperty.call(obj1, key)) {\n            if (obj0[key] !== obj1[key]) {\n                keys.push(key);\n            }\n        }\n    }\n    return keys;\n}\nfunction compareObjs(oldProps, newProps, equalityFuncs = {}) {\n    if (oldProps === newProps) {\n        return true;\n    }\n    for(let key in newProps){\n        if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;\n        else {\n            return false;\n        }\n    }\n    // check for props that were omitted in the new\n    for(let key in oldProps){\n        if (!(key in newProps)) {\n            return false;\n        }\n    }\n    return true;\n}\n/*\nassumed \"true\" equality for handler names like \"onReceiveSomething\"\n*/ function isObjValsEqual(val0, val1, comparator) {\n    if (val0 === val1 || comparator === true) {\n        return true;\n    }\n    if (comparator) {\n        return comparator(val0, val1);\n    }\n    return false;\n}\nfunction collectFromHash(hash, startIndex = 0, endIndex, step = 1) {\n    let res = [];\n    if (endIndex == null) {\n        endIndex = Object.keys(hash).length;\n    }\n    for(let i = startIndex; i < endIndex; i += step){\n        let val = hash[i];\n        if (val !== undefined) {\n            res.push(val);\n        }\n    }\n    return res;\n}\nlet calendarSystemClassMap = {};\nfunction registerCalendarSystem(name, theClass) {\n    calendarSystemClassMap[name] = theClass;\n}\nfunction createCalendarSystem(name) {\n    return new calendarSystemClassMap[name]();\n}\nclass GregorianCalendarSystem {\n    getMarkerYear(d) {\n        return d.getUTCFullYear();\n    }\n    getMarkerMonth(d) {\n        return d.getUTCMonth();\n    }\n    getMarkerDay(d) {\n        return d.getUTCDate();\n    }\n    arrayToMarker(arr) {\n        return arrayToUtcDate(arr);\n    }\n    markerToArray(marker) {\n        return dateToUtcArray(marker);\n    }\n}\nregisterCalendarSystem(\"gregory\", GregorianCalendarSystem);\nconst ISO_RE = /^\\s*(\\d{4})(-?(\\d{2})(-?(\\d{2})([T ](\\d{2}):?(\\d{2})(:?(\\d{2})(\\.(\\d+))?)?(Z|(([-+])(\\d{2})(:?(\\d{2}))?))?)?)?)?$/;\nfunction parse(str) {\n    let m = ISO_RE.exec(str);\n    if (m) {\n        let marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number(`0.${m[12]}`) * 1000 : 0));\n        if (isValidDate(marker)) {\n            let timeZoneOffset = null;\n            if (m[13]) {\n                timeZoneOffset = (m[15] === \"-\" ? -1 : 1) * (Number(m[16] || 0) * 60 + Number(m[18] || 0));\n            }\n            return {\n                marker,\n                isTimeUnspecified: !m[6],\n                timeZoneOffset\n            };\n        }\n    }\n    return null;\n}\nclass DateEnv {\n    constructor(settings){\n        let timeZone = this.timeZone = settings.timeZone;\n        let isNamedTimeZone = timeZone !== \"local\" && timeZone !== \"UTC\";\n        if (settings.namedTimeZoneImpl && isNamedTimeZone) {\n            this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);\n        }\n        this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);\n        this.calendarSystem = createCalendarSystem(settings.calendarSystem);\n        this.locale = settings.locale;\n        this.weekDow = settings.locale.week.dow;\n        this.weekDoy = settings.locale.week.doy;\n        if (settings.weekNumberCalculation === \"ISO\") {\n            this.weekDow = 1;\n            this.weekDoy = 4;\n        }\n        if (typeof settings.firstDay === \"number\") {\n            this.weekDow = settings.firstDay;\n        }\n        if (typeof settings.weekNumberCalculation === \"function\") {\n            this.weekNumberFunc = settings.weekNumberCalculation;\n        }\n        this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;\n        this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;\n        this.cmdFormatter = settings.cmdFormatter;\n        this.defaultSeparator = settings.defaultSeparator;\n    }\n    // Creating / Parsing\n    createMarker(input) {\n        let meta = this.createMarkerMeta(input);\n        if (meta === null) {\n            return null;\n        }\n        return meta.marker;\n    }\n    createNowMarker() {\n        if (this.canComputeOffset) {\n            return this.timestampToMarker(new Date().valueOf());\n        }\n        // if we can't compute the current date val for a timezone,\n        // better to give the current local date vals than UTC\n        return arrayToUtcDate(dateToLocalArray(new Date()));\n    }\n    createMarkerMeta(input) {\n        if (typeof input === \"string\") {\n            return this.parse(input);\n        }\n        let marker = null;\n        if (typeof input === \"number\") {\n            marker = this.timestampToMarker(input);\n        } else if (input instanceof Date) {\n            input = input.valueOf();\n            if (!isNaN(input)) {\n                marker = this.timestampToMarker(input);\n            }\n        } else if (Array.isArray(input)) {\n            marker = arrayToUtcDate(input);\n        }\n        if (marker === null || !isValidDate(marker)) {\n            return null;\n        }\n        return {\n            marker,\n            isTimeUnspecified: false,\n            forcedTzo: null\n        };\n    }\n    parse(s) {\n        let parts = parse(s);\n        if (parts === null) {\n            return null;\n        }\n        let { marker } = parts;\n        let forcedTzo = null;\n        if (parts.timeZoneOffset !== null) {\n            if (this.canComputeOffset) {\n                marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);\n            } else {\n                forcedTzo = parts.timeZoneOffset;\n            }\n        }\n        return {\n            marker,\n            isTimeUnspecified: parts.isTimeUnspecified,\n            forcedTzo\n        };\n    }\n    // Accessors\n    getYear(marker) {\n        return this.calendarSystem.getMarkerYear(marker);\n    }\n    getMonth(marker) {\n        return this.calendarSystem.getMarkerMonth(marker);\n    }\n    getDay(marker) {\n        return this.calendarSystem.getMarkerDay(marker);\n    }\n    // Adding / Subtracting\n    add(marker, dur) {\n        let a = this.calendarSystem.markerToArray(marker);\n        a[0] += dur.years;\n        a[1] += dur.months;\n        a[2] += dur.days;\n        a[6] += dur.milliseconds;\n        return this.calendarSystem.arrayToMarker(a);\n    }\n    subtract(marker, dur) {\n        let a = this.calendarSystem.markerToArray(marker);\n        a[0] -= dur.years;\n        a[1] -= dur.months;\n        a[2] -= dur.days;\n        a[6] -= dur.milliseconds;\n        return this.calendarSystem.arrayToMarker(a);\n    }\n    addYears(marker, n) {\n        let a = this.calendarSystem.markerToArray(marker);\n        a[0] += n;\n        return this.calendarSystem.arrayToMarker(a);\n    }\n    addMonths(marker, n) {\n        let a = this.calendarSystem.markerToArray(marker);\n        a[1] += n;\n        return this.calendarSystem.arrayToMarker(a);\n    }\n    // Diffing Whole Units\n    diffWholeYears(m0, m1) {\n        let { calendarSystem } = this;\n        if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {\n            return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);\n        }\n        return null;\n    }\n    diffWholeMonths(m0, m1) {\n        let { calendarSystem } = this;\n        if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {\n            return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;\n        }\n        return null;\n    }\n    // Range / Duration\n    greatestWholeUnit(m0, m1) {\n        let n = this.diffWholeYears(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"year\",\n                value: n\n            };\n        }\n        n = this.diffWholeMonths(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"month\",\n                value: n\n            };\n        }\n        n = diffWholeWeeks(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"week\",\n                value: n\n            };\n        }\n        n = diffWholeDays(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"day\",\n                value: n\n            };\n        }\n        n = diffHours(m0, m1);\n        if (isInt(n)) {\n            return {\n                unit: \"hour\",\n                value: n\n            };\n        }\n        n = diffMinutes(m0, m1);\n        if (isInt(n)) {\n            return {\n                unit: \"minute\",\n                value: n\n            };\n        }\n        n = diffSeconds(m0, m1);\n        if (isInt(n)) {\n            return {\n                unit: \"second\",\n                value: n\n            };\n        }\n        return {\n            unit: \"millisecond\",\n            value: m1.valueOf() - m0.valueOf()\n        };\n    }\n    countDurationsBetween(m0, m1, d) {\n        // TODO: can use greatestWholeUnit\n        let diff;\n        if (d.years) {\n            diff = this.diffWholeYears(m0, m1);\n            if (diff !== null) {\n                return diff / asRoughYears(d);\n            }\n        }\n        if (d.months) {\n            diff = this.diffWholeMonths(m0, m1);\n            if (diff !== null) {\n                return diff / asRoughMonths(d);\n            }\n        }\n        if (d.days) {\n            diff = diffWholeDays(m0, m1);\n            if (diff !== null) {\n                return diff / asRoughDays(d);\n            }\n        }\n        return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);\n    }\n    // Start-Of\n    // these DON'T return zoned-dates. only UTC start-of dates\n    startOf(m, unit) {\n        if (unit === \"year\") {\n            return this.startOfYear(m);\n        }\n        if (unit === \"month\") {\n            return this.startOfMonth(m);\n        }\n        if (unit === \"week\") {\n            return this.startOfWeek(m);\n        }\n        if (unit === \"day\") {\n            return startOfDay(m);\n        }\n        if (unit === \"hour\") {\n            return startOfHour(m);\n        }\n        if (unit === \"minute\") {\n            return startOfMinute(m);\n        }\n        if (unit === \"second\") {\n            return startOfSecond(m);\n        }\n        return null;\n    }\n    startOfYear(m) {\n        return this.calendarSystem.arrayToMarker([\n            this.calendarSystem.getMarkerYear(m)\n        ]);\n    }\n    startOfMonth(m) {\n        return this.calendarSystem.arrayToMarker([\n            this.calendarSystem.getMarkerYear(m),\n            this.calendarSystem.getMarkerMonth(m)\n        ]);\n    }\n    startOfWeek(m) {\n        return this.calendarSystem.arrayToMarker([\n            this.calendarSystem.getMarkerYear(m),\n            this.calendarSystem.getMarkerMonth(m),\n            m.getUTCDate() - (m.getUTCDay() - this.weekDow + 7) % 7\n        ]);\n    }\n    // Week Number\n    computeWeekNumber(marker) {\n        if (this.weekNumberFunc) {\n            return this.weekNumberFunc(this.toDate(marker));\n        }\n        return weekOfYear(marker, this.weekDow, this.weekDoy);\n    }\n    // TODO: choke on timeZoneName: long\n    format(marker, formatter, dateOptions = {}) {\n        return formatter.format({\n            marker,\n            timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)\n        }, this);\n    }\n    formatRange(start, end, formatter, dateOptions = {}) {\n        if (dateOptions.isEndExclusive) {\n            end = addMs(end, -1);\n        }\n        return formatter.formatRange({\n            marker: start,\n            timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)\n        }, {\n            marker: end,\n            timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)\n        }, this, dateOptions.defaultSeparator);\n    }\n    /*\n    DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,\n    might as well use buildIsoString or some other util directly\n    */ formatIso(marker, extraOptions = {}) {\n        let timeZoneOffset = null;\n        if (!extraOptions.omitTimeZoneOffset) {\n            if (extraOptions.forcedTzo != null) {\n                timeZoneOffset = extraOptions.forcedTzo;\n            } else {\n                timeZoneOffset = this.offsetForMarker(marker);\n            }\n        }\n        return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);\n    }\n    // TimeZone\n    timestampToMarker(ms) {\n        if (this.timeZone === \"local\") {\n            return arrayToUtcDate(dateToLocalArray(new Date(ms)));\n        }\n        if (this.timeZone === \"UTC\" || !this.namedTimeZoneImpl) {\n            return new Date(ms);\n        }\n        return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));\n    }\n    offsetForMarker(m) {\n        if (this.timeZone === \"local\") {\n            return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert \"inverse\" offset to \"normal\" offset\n        }\n        if (this.timeZone === \"UTC\") {\n            return 0;\n        }\n        if (this.namedTimeZoneImpl) {\n            return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));\n        }\n        return null;\n    }\n    // Conversion\n    toDate(m, forcedTzo) {\n        if (this.timeZone === \"local\") {\n            return arrayToLocalDate(dateToUtcArray(m));\n        }\n        if (this.timeZone === \"UTC\") {\n            return new Date(m.valueOf()); // make sure it's a copy\n        }\n        if (!this.namedTimeZoneImpl) {\n            return new Date(m.valueOf() - (forcedTzo || 0));\n        }\n        return new Date(m.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60);\n    }\n}\nclass Theme {\n    constructor(calendarOptions){\n        if (this.iconOverrideOption) {\n            this.setIconOverride(calendarOptions[this.iconOverrideOption]);\n        }\n    }\n    setIconOverride(iconOverrideHash) {\n        let iconClassesCopy;\n        let buttonName;\n        if (typeof iconOverrideHash === \"object\" && iconOverrideHash) {\n            iconClassesCopy = Object.assign({}, this.iconClasses);\n            for(buttonName in iconOverrideHash){\n                iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);\n            }\n            this.iconClasses = iconClassesCopy;\n        } else if (iconOverrideHash === false) {\n            this.iconClasses = {};\n        }\n    }\n    applyIconOverridePrefix(className) {\n        let prefix = this.iconOverridePrefix;\n        if (prefix && className.indexOf(prefix) !== 0) {\n            className = prefix + className;\n        }\n        return className;\n    }\n    getClass(key) {\n        return this.classes[key] || \"\";\n    }\n    getIconClass(buttonName, isRtl) {\n        let className;\n        if (isRtl && this.rtlIconClasses) {\n            className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];\n        } else {\n            className = this.iconClasses[buttonName];\n        }\n        if (className) {\n            return `${this.baseIconClass} ${className}`;\n        }\n        return \"\";\n    }\n    getCustomButtonIconClass(customButtonProps) {\n        let className;\n        if (this.iconOverrideCustomButtonOption) {\n            className = customButtonProps[this.iconOverrideCustomButtonOption];\n            if (className) {\n                return `${this.baseIconClass} ${this.applyIconOverridePrefix(className)}`;\n            }\n        }\n        return \"\";\n    }\n}\nTheme.prototype.classes = {};\nTheme.prototype.iconClasses = {};\nTheme.prototype.baseIconClass = \"\";\nTheme.prototype.iconOverridePrefix = \"\";\n/*\nNOTE: this can be a public API, especially createElement for hooks.\nSee examples/typescript-scheduler/src/index.ts\n*/ function flushSync(runBeforeFlush) {\n    runBeforeFlush();\n    let oldDebounceRendering = preact__WEBPACK_IMPORTED_MODULE_0__.options.debounceRendering; // orig\n    let callbackQ = [];\n    function execCallbackSync(callback) {\n        callbackQ.push(callback);\n    }\n    preact__WEBPACK_IMPORTED_MODULE_0__.options.debounceRendering = execCallbackSync;\n    preact__WEBPACK_IMPORTED_MODULE_0__.render(preact__WEBPACK_IMPORTED_MODULE_0__.createElement(FakeComponent, {}), document.createElement(\"div\"));\n    while(callbackQ.length){\n        callbackQ.shift()();\n    }\n    preact__WEBPACK_IMPORTED_MODULE_0__.options.debounceRendering = oldDebounceRendering;\n}\nclass FakeComponent extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    render() {\n        return preact__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {});\n    }\n    componentDidMount() {\n        this.setState({});\n    }\n}\n// TODO: use preact/compat instead?\nfunction createContext(defaultValue) {\n    let ContextType = preact__WEBPACK_IMPORTED_MODULE_0__.createContext(defaultValue);\n    let origProvider = ContextType.Provider;\n    ContextType.Provider = function() {\n        let isNew = !this.getChildContext;\n        let children = origProvider.apply(this, arguments); // eslint-disable-line prefer-rest-params\n        if (isNew) {\n            let subs = [];\n            this.shouldComponentUpdate = (_props)=>{\n                if (this.props.value !== _props.value) {\n                    subs.forEach((c)=>{\n                        c.context = _props.value;\n                        c.forceUpdate();\n                    });\n                }\n            };\n            this.sub = (c)=>{\n                subs.push(c);\n                let old = c.componentWillUnmount;\n                c.componentWillUnmount = ()=>{\n                    subs.splice(subs.indexOf(c), 1);\n                    old && old.call(c);\n                };\n            };\n        }\n        return children;\n    };\n    return ContextType;\n}\nclass ScrollResponder {\n    constructor(execFunc, emitter, scrollTime, scrollTimeReset){\n        this.execFunc = execFunc;\n        this.emitter = emitter;\n        this.scrollTime = scrollTime;\n        this.scrollTimeReset = scrollTimeReset;\n        this.handleScrollRequest = (request)=>{\n            this.queuedRequest = Object.assign({}, this.queuedRequest || {}, request);\n            this.drain();\n        };\n        emitter.on(\"_scrollRequest\", this.handleScrollRequest);\n        this.fireInitialScroll();\n    }\n    detach() {\n        this.emitter.off(\"_scrollRequest\", this.handleScrollRequest);\n    }\n    update(isDatesNew) {\n        if (isDatesNew && this.scrollTimeReset) {\n            this.fireInitialScroll(); // will drain\n        } else {\n            this.drain();\n        }\n    }\n    fireInitialScroll() {\n        this.handleScrollRequest({\n            time: this.scrollTime\n        });\n    }\n    drain() {\n        if (this.queuedRequest && this.execFunc(this.queuedRequest)) {\n            this.queuedRequest = null;\n        }\n    }\n}\nconst ViewContextType = createContext({}); // for Components\nfunction buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {\n    return {\n        dateEnv,\n        options: viewOptions,\n        pluginHooks,\n        emitter,\n        dispatch,\n        getCurrentData,\n        calendarApi,\n        viewSpec,\n        viewApi,\n        dateProfileGenerator,\n        theme,\n        isRtl: viewOptions.direction === \"rtl\",\n        addResizeHandler (handler) {\n            emitter.on(\"_resize\", handler);\n        },\n        removeResizeHandler (handler) {\n            emitter.off(\"_resize\", handler);\n        },\n        createScrollResponder (execFunc) {\n            return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);\n        },\n        registerInteractiveComponent,\n        unregisterInteractiveComponent\n    };\n}\n/* eslint max-classes-per-file: off */ class PureComponent extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    shouldComponentUpdate(nextProps, nextState) {\n        if (this.debug) {\n            // eslint-disable-next-line no-console\n            console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));\n        }\n        return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);\n    }\n    // HACK for freakin' React StrictMode\n    safeSetState(newState) {\n        if (!compareObjs(this.state, Object.assign(Object.assign({}, this.state), newState), this.stateEquality)) {\n            this.setState(newState);\n        }\n    }\n}\nPureComponent.addPropsEquality = addPropsEquality;\nPureComponent.addStateEquality = addStateEquality;\nPureComponent.contextType = ViewContextType;\nPureComponent.prototype.propEquality = {};\nPureComponent.prototype.stateEquality = {};\nclass BaseComponent extends PureComponent {\n}\nBaseComponent.contextType = ViewContextType;\nfunction addPropsEquality(propEquality) {\n    let hash = Object.create(this.prototype.propEquality);\n    Object.assign(hash, propEquality);\n    this.prototype.propEquality = hash;\n}\nfunction addStateEquality(stateEquality) {\n    let hash = Object.create(this.prototype.stateEquality);\n    Object.assign(hash, stateEquality);\n    this.prototype.stateEquality = hash;\n}\n// use other one\nfunction setRef(ref, current) {\n    if (typeof ref === \"function\") {\n        ref(current);\n    } else if (ref) {\n        // see https://github.com/facebook/react/issues/13029\n        ref.current = current;\n    }\n}\nclass ContentInjector extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.id = guid();\n        this.queuedDomNodes = [];\n        this.currentDomNodes = [];\n        this.handleEl = (el)=>{\n            const { options } = this.context;\n            const { generatorName } = this.props;\n            if (!options.customRenderingReplaces || !hasCustomRenderingHandler(generatorName, options)) {\n                this.updateElRef(el);\n            }\n        };\n        this.updateElRef = (el)=>{\n            if (this.props.elRef) {\n                setRef(this.props.elRef, el);\n            }\n        };\n    }\n    render() {\n        const { props, context } = this;\n        const { options } = context;\n        const { customGenerator, defaultGenerator, renderProps } = props;\n        const attrs = buildElAttrs(props, [], this.handleEl);\n        let useDefault = false;\n        let innerContent;\n        let queuedDomNodes = [];\n        let currentGeneratorMeta;\n        if (customGenerator != null) {\n            const customGeneratorRes = typeof customGenerator === \"function\" ? customGenerator(renderProps, preact__WEBPACK_IMPORTED_MODULE_0__.createElement) : customGenerator;\n            if (customGeneratorRes === true) {\n                useDefault = true;\n            } else {\n                const isObject = customGeneratorRes && typeof customGeneratorRes === \"object\"; // non-null\n                if (isObject && \"html\" in customGeneratorRes) {\n                    attrs.dangerouslySetInnerHTML = {\n                        __html: customGeneratorRes.html\n                    };\n                } else if (isObject && \"domNodes\" in customGeneratorRes) {\n                    queuedDomNodes = Array.prototype.slice.call(customGeneratorRes.domNodes);\n                } else if (isObject ? (0,preact__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(customGeneratorRes) // vdom node\n                 : typeof customGeneratorRes !== \"function\" // primitive value (like string or number)\n                ) {\n                    // use in vdom\n                    innerContent = customGeneratorRes;\n                } else {\n                    // an exotic object for handleCustomRendering\n                    currentGeneratorMeta = customGeneratorRes;\n                }\n            }\n        } else {\n            useDefault = !hasCustomRenderingHandler(props.generatorName, options);\n        }\n        if (useDefault && defaultGenerator) {\n            innerContent = defaultGenerator(renderProps);\n        }\n        this.queuedDomNodes = queuedDomNodes;\n        this.currentGeneratorMeta = currentGeneratorMeta;\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(props.elTag, attrs, innerContent);\n    }\n    componentDidMount() {\n        this.applyQueueudDomNodes();\n        this.triggerCustomRendering(true);\n    }\n    componentDidUpdate() {\n        this.applyQueueudDomNodes();\n        this.triggerCustomRendering(true);\n    }\n    componentWillUnmount() {\n        this.triggerCustomRendering(false); // TODO: different API for removal?\n    }\n    triggerCustomRendering(isActive) {\n        var _a;\n        const { props, context } = this;\n        const { handleCustomRendering, customRenderingMetaMap } = context.options;\n        if (handleCustomRendering) {\n            const generatorMeta = (_a = this.currentGeneratorMeta) !== null && _a !== void 0 ? _a : customRenderingMetaMap === null || customRenderingMetaMap === void 0 ? void 0 : customRenderingMetaMap[props.generatorName];\n            if (generatorMeta) {\n                handleCustomRendering(Object.assign(Object.assign({\n                    id: this.id,\n                    isActive,\n                    containerEl: this.base,\n                    reportNewContainerEl: this.updateElRef,\n                    generatorMeta\n                }, props), {\n                    elClasses: (props.elClasses || []).filter(isTruthy)\n                }));\n            }\n        }\n    }\n    applyQueueudDomNodes() {\n        const { queuedDomNodes, currentDomNodes } = this;\n        const el = this.base;\n        if (!isArraysEqual(queuedDomNodes, currentDomNodes)) {\n            currentDomNodes.forEach(removeElement);\n            for (let newNode of queuedDomNodes){\n                el.appendChild(newNode);\n            }\n            this.currentDomNodes = queuedDomNodes;\n        }\n    }\n}\nContentInjector.addPropsEquality({\n    elClasses: isArraysEqual,\n    elStyle: isPropsEqual,\n    elAttrs: isNonHandlerPropsEqual,\n    renderProps: isPropsEqual\n});\n// Util\n/*\nDoes UI-framework provide custom way of rendering that does not use Preact VDOM\nAND does the calendar's options define custom rendering?\nAKA. Should we NOT render the default content?\n*/ function hasCustomRenderingHandler(generatorName, options) {\n    var _a;\n    return Boolean(options.handleCustomRendering && generatorName && ((_a = options.customRenderingMetaMap) === null || _a === void 0 ? void 0 : _a[generatorName]));\n}\nfunction buildElAttrs(props, extraClassNames, elRef) {\n    const attrs = Object.assign(Object.assign({}, props.elAttrs), {\n        ref: elRef\n    });\n    if (props.elClasses || extraClassNames) {\n        attrs.className = (props.elClasses || []).concat(extraClassNames || []).concat(attrs.className || []).filter(Boolean).join(\" \");\n    }\n    if (props.elStyle) {\n        attrs.style = props.elStyle;\n    }\n    return attrs;\n}\nfunction isTruthy(val) {\n    return Boolean(val);\n}\nconst RenderId = createContext(0);\nclass ContentContainer extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(){\n        super(...arguments);\n        this.InnerContent = InnerContentInjector.bind(undefined, this);\n        this.handleEl = (el)=>{\n            this.el = el;\n            if (this.props.elRef) {\n                setRef(this.props.elRef, el);\n                if (el && this.didMountMisfire) {\n                    this.componentDidMount();\n                }\n            }\n        };\n    }\n    render() {\n        const { props } = this;\n        const generatedClassNames = generateClassNames(props.classNameGenerator, props.renderProps);\n        if (props.children) {\n            const elAttrs = buildElAttrs(props, generatedClassNames, this.handleEl);\n            const children = props.children(this.InnerContent, props.renderProps, elAttrs);\n            if (props.elTag) {\n                return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(props.elTag, elAttrs, children);\n            } else {\n                return children;\n            }\n        } else {\n            return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentInjector, Object.assign(Object.assign({}, props), {\n                elRef: this.handleEl,\n                elTag: props.elTag || \"div\",\n                elClasses: (props.elClasses || []).concat(generatedClassNames),\n                renderId: this.context\n            }));\n        }\n    }\n    componentDidMount() {\n        var _a, _b;\n        if (this.el) {\n            (_b = (_a = this.props).didMount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), {\n                el: this.el\n            }));\n        } else {\n            this.didMountMisfire = true;\n        }\n    }\n    componentWillUnmount() {\n        var _a, _b;\n        (_b = (_a = this.props).willUnmount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), {\n            el: this.el\n        }));\n    }\n}\nContentContainer.contextType = RenderId;\nfunction InnerContentInjector(containerComponent, props) {\n    const parentProps = containerComponent.props;\n    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentInjector, Object.assign({\n        renderProps: parentProps.renderProps,\n        generatorName: parentProps.generatorName,\n        customGenerator: parentProps.customGenerator,\n        defaultGenerator: parentProps.defaultGenerator,\n        renderId: containerComponent.context\n    }, props));\n}\n// Utils\nfunction generateClassNames(classNameGenerator, renderProps) {\n    const classNames = typeof classNameGenerator === \"function\" ? classNameGenerator(renderProps) : classNameGenerator || [];\n    return typeof classNames === \"string\" ? [\n        classNames\n    ] : classNames;\n}\nclass ViewContainer extends BaseComponent {\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let renderProps = {\n            view: context.viewApi\n        };\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, Object.assign({}, props, {\n            elTag: props.elTag || \"div\",\n            elClasses: [\n                ...buildViewClassNames(props.viewSpec),\n                ...props.elClasses || []\n            ],\n            renderProps: renderProps,\n            classNameGenerator: options.viewClassNames,\n            generatorName: undefined,\n            didMount: options.viewDidMount,\n            willUnmount: options.viewWillUnmount\n        }), ()=>props.children);\n    }\n}\nfunction buildViewClassNames(viewSpec) {\n    return [\n        `fc-${viewSpec.type}-view`,\n        \"fc-view\"\n    ];\n}\nfunction parseRange(input, dateEnv) {\n    let start = null;\n    let end = null;\n    if (input.start) {\n        start = dateEnv.createMarker(input.start);\n    }\n    if (input.end) {\n        end = dateEnv.createMarker(input.end);\n    }\n    if (!start && !end) {\n        return null;\n    }\n    if (start && end && end < start) {\n        return null;\n    }\n    return {\n        start,\n        end\n    };\n}\n// SIDE-EFFECT: will mutate ranges.\n// Will return a new array result.\nfunction invertRanges(ranges, constraintRange) {\n    let invertedRanges = [];\n    let { start } = constraintRange; // the end of the previous range. the start of the new range\n    let i;\n    let dateRange;\n    // ranges need to be in order. required for our date-walking algorithm\n    ranges.sort(compareRanges);\n    for(i = 0; i < ranges.length; i += 1){\n        dateRange = ranges[i];\n        // add the span of time before the event (if there is any)\n        if (dateRange.start > start) {\n            invertedRanges.push({\n                start,\n                end: dateRange.start\n            });\n        }\n        if (dateRange.end > start) {\n            start = dateRange.end;\n        }\n    }\n    // add the span of time after the last event (if there is any)\n    if (start < constraintRange.end) {\n        invertedRanges.push({\n            start,\n            end: constraintRange.end\n        });\n    }\n    return invertedRanges;\n}\nfunction compareRanges(range0, range1) {\n    return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first\n}\nfunction intersectRanges(range0, range1) {\n    let { start, end } = range0;\n    let newRange = null;\n    if (range1.start !== null) {\n        if (start === null) {\n            start = range1.start;\n        } else {\n            start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));\n        }\n    }\n    if (range1.end != null) {\n        if (end === null) {\n            end = range1.end;\n        } else {\n            end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));\n        }\n    }\n    if (start === null || end === null || start < end) {\n        newRange = {\n            start,\n            end\n        };\n    }\n    return newRange;\n}\nfunction rangesEqual(range0, range1) {\n    return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());\n}\nfunction rangesIntersect(range0, range1) {\n    return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);\n}\nfunction rangeContainsRange(outerRange, innerRange) {\n    return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);\n}\nfunction rangeContainsMarker(range, date) {\n    return (range.start === null || date >= range.start) && (range.end === null || date < range.end);\n}\n// If the given date is not within the given range, move it inside.\n// (If it's past the end, make it one millisecond before the end).\nfunction constrainMarkerToRange(date, range) {\n    if (range.start != null && date < range.start) {\n        return range.start;\n    }\n    if (range.end != null && date >= range.end) {\n        return new Date(range.end.valueOf() - 1);\n    }\n    return date;\n}\n/* Date stuff that doesn't belong in datelib core\n----------------------------------------------------------------------------------------------------------------------*/ // given a timed range, computes an all-day range that has the same exact duration,\n// but whose start time is aligned with the start of the day.\nfunction computeAlignedDayRange(timedRange) {\n    let dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;\n    let start = startOfDay(timedRange.start);\n    let end = addDays(start, dayCnt);\n    return {\n        start,\n        end\n    };\n}\n// given a timed range, computes an all-day range based on how for the end date bleeds into the next day\n// TODO: give nextDayThreshold a default arg\nfunction computeVisibleDayRange(timedRange, nextDayThreshold = createDuration(0)) {\n    let startDay = null;\n    let endDay = null;\n    if (timedRange.end) {\n        endDay = startOfDay(timedRange.end);\n        let endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`\n        // If the end time is actually inclusively part of the next day and is equal to or\n        // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\n        // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\n        if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {\n            endDay = addDays(endDay, 1);\n        }\n    }\n    if (timedRange.start) {\n        startDay = startOfDay(timedRange.start); // the beginning of the day the range starts\n        // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.\n        if (endDay && endDay <= startDay) {\n            endDay = addDays(startDay, 1);\n        }\n    }\n    return {\n        start: startDay,\n        end: endDay\n    };\n}\n// spans from one day into another?\nfunction isMultiDayRange(range) {\n    let visibleRange = computeVisibleDayRange(range);\n    return diffDays(visibleRange.start, visibleRange.end) > 1;\n}\nfunction diffDates(date0, date1, dateEnv, largeUnit) {\n    if (largeUnit === \"year\") {\n        return createDuration(dateEnv.diffWholeYears(date0, date1), \"year\");\n    }\n    if (largeUnit === \"month\") {\n        return createDuration(dateEnv.diffWholeMonths(date0, date1), \"month\");\n    }\n    return diffDayAndTime(date0, date1); // returns a duration\n}\nfunction reduceCurrentDate(currentDate, action) {\n    switch(action.type){\n        case \"CHANGE_DATE\":\n            return action.dateMarker;\n        default:\n            return currentDate;\n    }\n}\nfunction getInitialDate(options, dateEnv) {\n    let initialDateInput = options.initialDate;\n    // compute the initial ambig-timezone date\n    if (initialDateInput != null) {\n        return dateEnv.createMarker(initialDateInput);\n    }\n    return getNow(options.now, dateEnv); // getNow already returns unzoned\n}\nfunction getNow(nowInput, dateEnv) {\n    if (typeof nowInput === \"function\") {\n        nowInput = nowInput();\n    }\n    if (nowInput == null) {\n        return dateEnv.createNowMarker();\n    }\n    return dateEnv.createMarker(nowInput);\n}\nclass DateProfileGenerator {\n    constructor(props){\n        this.props = props;\n        this.nowDate = getNow(props.nowInput, props.dateEnv);\n        this.initHiddenDays();\n    }\n    /* Date Range Computation\n    ------------------------------------------------------------------------------------------------------------------*/ // Builds a structure with info about what the dates/ranges will be for the \"prev\" view.\n    buildPrev(currentDateProfile, currentDate, forceToValid) {\n        let { dateEnv } = this.props;\n        let prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), currentDateProfile.dateIncrement);\n        return this.build(prevDate, -1, forceToValid);\n    }\n    // Builds a structure with info about what the dates/ranges will be for the \"next\" view.\n    buildNext(currentDateProfile, currentDate, forceToValid) {\n        let { dateEnv } = this.props;\n        let nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), currentDateProfile.dateIncrement);\n        return this.build(nextDate, 1, forceToValid);\n    }\n    // Builds a structure holding dates/ranges for rendering around the given date.\n    // Optional direction param indicates whether the date is being incremented/decremented\n    // from its previous value. decremented = -1, incremented = 1 (default).\n    build(currentDate, direction, forceToValid = true) {\n        let { props } = this;\n        let validRange;\n        let currentInfo;\n        let isRangeAllDay;\n        let renderRange;\n        let activeRange;\n        let isValid;\n        validRange = this.buildValidRange();\n        validRange = this.trimHiddenDays(validRange);\n        if (forceToValid) {\n            currentDate = constrainMarkerToRange(currentDate, validRange);\n        }\n        currentInfo = this.buildCurrentRangeInfo(currentDate, direction);\n        isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);\n        renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);\n        renderRange = this.trimHiddenDays(renderRange);\n        activeRange = renderRange;\n        if (!props.showNonCurrentDates) {\n            activeRange = intersectRanges(activeRange, currentInfo.range);\n        }\n        activeRange = this.adjustActiveRange(activeRange);\n        activeRange = intersectRanges(activeRange, validRange); // might return null\n        // it's invalid if the originally requested date is not contained,\n        // or if the range is completely outside of the valid range.\n        isValid = rangesIntersect(currentInfo.range, validRange);\n        // HACK: constrain to render-range so `currentDate` is more useful to view rendering\n        if (!rangeContainsMarker(renderRange, currentDate)) {\n            currentDate = renderRange.start;\n        }\n        return {\n            currentDate,\n            // constraint for where prev/next operations can go and where events can be dragged/resized to.\n            // an object with optional start and end properties.\n            validRange,\n            // range the view is formally responsible for.\n            // for example, a month view might have 1st-31st, excluding padded dates\n            currentRange: currentInfo.range,\n            // name of largest unit being displayed, like \"month\" or \"week\"\n            currentRangeUnit: currentInfo.unit,\n            isRangeAllDay,\n            // dates that display events and accept drag-n-drop\n            // will be `null` if no dates accept events\n            activeRange,\n            // date range with a rendered skeleton\n            // includes not-active days that need some sort of DOM\n            renderRange,\n            // Duration object that denotes the first visible time of any given day\n            slotMinTime: props.slotMinTime,\n            // Duration object that denotes the exclusive visible end time of any given day\n            slotMaxTime: props.slotMaxTime,\n            isValid,\n            // how far the current date will move for a prev/next operation\n            dateIncrement: this.buildDateIncrement(currentInfo.duration)\n        };\n    }\n    // Builds an object with optional start/end properties.\n    // Indicates the minimum/maximum dates to display.\n    // not responsible for trimming hidden days.\n    buildValidRange() {\n        let input = this.props.validRangeInput;\n        let simpleInput = typeof input === \"function\" ? input.call(this.props.calendarApi, this.nowDate) : input;\n        return this.refineRange(simpleInput) || {\n            start: null,\n            end: null\n        }; // completely open-ended\n    }\n    // Builds a structure with info about the \"current\" range, the range that is\n    // highlighted as being the current month for example.\n    // See build() for a description of `direction`.\n    // Guaranteed to have `range` and `unit` properties. `duration` is optional.\n    buildCurrentRangeInfo(date, direction) {\n        let { props } = this;\n        let duration = null;\n        let unit = null;\n        let range = null;\n        let dayCount;\n        if (props.duration) {\n            duration = props.duration;\n            unit = props.durationUnit;\n            range = this.buildRangeFromDuration(date, direction, duration, unit);\n        } else if (dayCount = this.props.dayCount) {\n            unit = \"day\";\n            range = this.buildRangeFromDayCount(date, direction, dayCount);\n        } else if (range = this.buildCustomVisibleRange(date)) {\n            unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;\n        } else {\n            duration = this.getFallbackDuration();\n            unit = greatestDurationDenominator(duration).unit;\n            range = this.buildRangeFromDuration(date, direction, duration, unit);\n        }\n        return {\n            duration,\n            unit,\n            range\n        };\n    }\n    getFallbackDuration() {\n        return createDuration({\n            day: 1\n        });\n    }\n    // Returns a new activeRange to have time values (un-ambiguate)\n    // slotMinTime or slotMaxTime causes the range to expand.\n    adjustActiveRange(range) {\n        let { dateEnv, usesMinMaxTime, slotMinTime, slotMaxTime } = this.props;\n        let { start, end } = range;\n        if (usesMinMaxTime) {\n            // expand active range if slotMinTime is negative (why not when positive?)\n            if (asRoughDays(slotMinTime) < 0) {\n                start = startOfDay(start); // necessary?\n                start = dateEnv.add(start, slotMinTime);\n            }\n            // expand active range if slotMaxTime is beyond one day (why not when negative?)\n            if (asRoughDays(slotMaxTime) > 1) {\n                end = startOfDay(end); // necessary?\n                end = addDays(end, -1);\n                end = dateEnv.add(end, slotMaxTime);\n            }\n        }\n        return {\n            start,\n            end\n        };\n    }\n    // Builds the \"current\" range when it is specified as an explicit duration.\n    // `unit` is the already-computed greatestDurationDenominator unit of duration.\n    buildRangeFromDuration(date, direction, duration, unit) {\n        let { dateEnv, dateAlignment } = this.props;\n        let start;\n        let end;\n        let res;\n        // compute what the alignment should be\n        if (!dateAlignment) {\n            let { dateIncrement } = this.props;\n            if (dateIncrement) {\n                // use the smaller of the two units\n                if (asRoughMs(dateIncrement) < asRoughMs(duration)) {\n                    dateAlignment = greatestDurationDenominator(dateIncrement).unit;\n                } else {\n                    dateAlignment = unit;\n                }\n            } else {\n                dateAlignment = unit;\n            }\n        }\n        // if the view displays a single day or smaller\n        if (asRoughDays(duration) <= 1) {\n            if (this.isHiddenDay(start)) {\n                start = this.skipHiddenDays(start, direction);\n                start = startOfDay(start);\n            }\n        }\n        function computeRes() {\n            start = dateEnv.startOf(date, dateAlignment);\n            end = dateEnv.add(start, duration);\n            res = {\n                start,\n                end\n            };\n        }\n        computeRes();\n        // if range is completely enveloped by hidden days, go past the hidden days\n        if (!this.trimHiddenDays(res)) {\n            date = this.skipHiddenDays(date, direction);\n            computeRes();\n        }\n        return res;\n    }\n    // Builds the \"current\" range when a dayCount is specified.\n    buildRangeFromDayCount(date, direction, dayCount) {\n        let { dateEnv, dateAlignment } = this.props;\n        let runningCount = 0;\n        let start = date;\n        let end;\n        if (dateAlignment) {\n            start = dateEnv.startOf(start, dateAlignment);\n        }\n        start = startOfDay(start);\n        start = this.skipHiddenDays(start, direction);\n        end = start;\n        do {\n            end = addDays(end, 1);\n            if (!this.isHiddenDay(end)) {\n                runningCount += 1;\n            }\n        }while (runningCount < dayCount);\n        return {\n            start,\n            end\n        };\n    }\n    // Builds a normalized range object for the \"visible\" range,\n    // which is a way to define the currentRange and activeRange at the same time.\n    buildCustomVisibleRange(date) {\n        let { props } = this;\n        let input = props.visibleRangeInput;\n        let simpleInput = typeof input === \"function\" ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;\n        let range = this.refineRange(simpleInput);\n        if (range && (range.start == null || range.end == null)) {\n            return null;\n        }\n        return range;\n    }\n    // Computes the range that will represent the element/cells for *rendering*,\n    // but which may have voided days/times.\n    // not responsible for trimming hidden days.\n    buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {\n        return currentRange;\n    }\n    // Compute the duration value that should be added/substracted to the current date\n    // when a prev/next operation happens.\n    buildDateIncrement(fallback) {\n        let { dateIncrement } = this.props;\n        let customAlignment;\n        if (dateIncrement) {\n            return dateIncrement;\n        }\n        if (customAlignment = this.props.dateAlignment) {\n            return createDuration(1, customAlignment);\n        }\n        if (fallback) {\n            return fallback;\n        }\n        return createDuration({\n            days: 1\n        });\n    }\n    refineRange(rangeInput) {\n        if (rangeInput) {\n            let range = parseRange(rangeInput, this.props.dateEnv);\n            if (range) {\n                range = computeVisibleDayRange(range);\n            }\n            return range;\n        }\n        return null;\n    }\n    /* Hidden Days\n    ------------------------------------------------------------------------------------------------------------------*/ // Initializes internal variables related to calculating hidden days-of-week\n    initHiddenDays() {\n        let hiddenDays = this.props.hiddenDays || []; // array of day-of-week indices that are hidden\n        let isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\n        let dayCnt = 0;\n        let i;\n        if (this.props.weekends === false) {\n            hiddenDays.push(0, 6); // 0=sunday, 6=saturday\n        }\n        for(i = 0; i < 7; i += 1){\n            if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {\n                dayCnt += 1;\n            }\n        }\n        if (!dayCnt) {\n            throw new Error(\"invalid hiddenDays\"); // all days were hidden? bad.\n        }\n        this.isHiddenDayHash = isHiddenDayHash;\n    }\n    // Remove days from the beginning and end of the range that are computed as hidden.\n    // If the whole range is trimmed off, returns null\n    trimHiddenDays(range) {\n        let { start, end } = range;\n        if (start) {\n            start = this.skipHiddenDays(start);\n        }\n        if (end) {\n            end = this.skipHiddenDays(end, -1, true);\n        }\n        if (start == null || end == null || start < end) {\n            return {\n                start,\n                end\n            };\n        }\n        return null;\n    }\n    // Is the current day hidden?\n    // `day` is a day-of-week index (0-6), or a Date (used for UTC)\n    isHiddenDay(day) {\n        if (day instanceof Date) {\n            day = day.getUTCDay();\n        }\n        return this.isHiddenDayHash[day];\n    }\n    // Incrementing the current day until it is no longer a hidden day, returning a copy.\n    // DOES NOT CONSIDER validRange!\n    // If the initial value of `date` is not a hidden day, don't do anything.\n    // Pass `isExclusive` as `true` if you are dealing with an end date.\n    // `inc` defaults to `1` (increment one day forward each time)\n    skipHiddenDays(date, inc = 1, isExclusive = false) {\n        while(this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]){\n            date = addDays(date, inc);\n        }\n        return date;\n    }\n}\nfunction createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {\n    return {\n        instanceId: guid(),\n        defId,\n        range,\n        forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,\n        forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo\n    };\n}\nfunction parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {\n    for(let i = 0; i < recurringTypes.length; i += 1){\n        let parsed = recurringTypes[i].parse(refined, dateEnv);\n        if (parsed) {\n            let { allDay } = refined;\n            if (allDay == null) {\n                allDay = defaultAllDay;\n                if (allDay == null) {\n                    allDay = parsed.allDayGuess;\n                    if (allDay == null) {\n                        allDay = false;\n                    }\n                }\n            }\n            return {\n                allDay,\n                duration: parsed.duration,\n                typeData: parsed.typeData,\n                typeId: i\n            };\n        }\n    }\n    return null;\n}\nfunction expandRecurring(eventStore, framingRange, context) {\n    let { dateEnv, pluginHooks, options } = context;\n    let { defs, instances } = eventStore;\n    // remove existing recurring instances\n    // TODO: bad. always expand events as a second step\n    instances = filterHash(instances, (instance)=>!defs[instance.defId].recurringDef);\n    for(let defId in defs){\n        let def = defs[defId];\n        if (def.recurringDef) {\n            let { duration } = def.recurringDef;\n            if (!duration) {\n                duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;\n            }\n            let starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);\n            for (let start of starts){\n                let instance = createEventInstance(defId, {\n                    start,\n                    end: dateEnv.add(start, duration)\n                });\n                instances[instance.instanceId] = instance;\n            }\n        }\n    }\n    return {\n        defs,\n        instances\n    };\n}\n/*\nEvent MUST have a recurringDef\n*/ function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {\n    let typeDef = recurringTypes[eventDef.recurringDef.typeId];\n    let markers = typeDef.expand(eventDef.recurringDef.typeData, {\n        start: dateEnv.subtract(framingRange.start, duration),\n        end: framingRange.end\n    }, dateEnv);\n    // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to\n    if (eventDef.allDay) {\n        markers = markers.map(startOfDay);\n    }\n    return markers;\n}\nconst EVENT_NON_DATE_REFINERS = {\n    id: String,\n    groupId: String,\n    title: String,\n    url: String,\n    interactive: Boolean\n};\nconst EVENT_DATE_REFINERS = {\n    start: identity,\n    end: identity,\n    date: identity,\n    allDay: Boolean\n};\nconst EVENT_REFINERS = Object.assign(Object.assign(Object.assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), {\n    extendedProps: identity\n});\nfunction parseEvent(raw, eventSource, context, allowOpenRange, refiners = buildEventRefiners(context), defIdMap, instanceIdMap) {\n    let { refined, extra } = refineEventDef(raw, context, refiners);\n    let defaultAllDay = computeIsDefaultAllDay(eventSource, context);\n    let recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);\n    if (recurringRes) {\n        let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : \"\", recurringRes.allDay, Boolean(recurringRes.duration), context, defIdMap);\n        def.recurringDef = {\n            typeId: recurringRes.typeId,\n            typeData: recurringRes.typeData,\n            duration: recurringRes.duration\n        };\n        return {\n            def,\n            instance: null\n        };\n    }\n    let singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);\n    if (singleRes) {\n        let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : \"\", singleRes.allDay, singleRes.hasEnd, context, defIdMap);\n        let instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);\n        if (instanceIdMap && def.publicId && instanceIdMap[def.publicId]) {\n            instance.instanceId = instanceIdMap[def.publicId];\n        }\n        return {\n            def,\n            instance\n        };\n    }\n    return null;\n}\nfunction refineEventDef(raw, context, refiners = buildEventRefiners(context)) {\n    return refineProps(raw, refiners);\n}\nfunction buildEventRefiners(context) {\n    return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);\n}\n/*\nWill NOT populate extendedProps with the leftover properties.\nWill NOT populate date-related props.\n*/ function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context, defIdMap) {\n    let def = {\n        title: refined.title || \"\",\n        groupId: refined.groupId || \"\",\n        publicId: refined.id || \"\",\n        url: refined.url || \"\",\n        recurringDef: null,\n        defId: (defIdMap && refined.id ? defIdMap[refined.id] : \"\") || guid(),\n        sourceId,\n        allDay,\n        hasEnd,\n        interactive: refined.interactive,\n        ui: createEventUi(refined, context),\n        extendedProps: Object.assign(Object.assign({}, refined.extendedProps || {}), extra)\n    };\n    for (let memberAdder of context.pluginHooks.eventDefMemberAdders){\n        Object.assign(def, memberAdder(refined));\n    }\n    // help out EventImpl from having user modify props\n    Object.freeze(def.ui.classNames);\n    Object.freeze(def.extendedProps);\n    return def;\n}\nfunction parseSingle(refined, defaultAllDay, context, allowOpenRange) {\n    let { allDay } = refined;\n    let startMeta;\n    let startMarker = null;\n    let hasEnd = false;\n    let endMeta;\n    let endMarker = null;\n    let startInput = refined.start != null ? refined.start : refined.date;\n    startMeta = context.dateEnv.createMarkerMeta(startInput);\n    if (startMeta) {\n        startMarker = startMeta.marker;\n    } else if (!allowOpenRange) {\n        return null;\n    }\n    if (refined.end != null) {\n        endMeta = context.dateEnv.createMarkerMeta(refined.end);\n    }\n    if (allDay == null) {\n        if (defaultAllDay != null) {\n            allDay = defaultAllDay;\n        } else {\n            // fall back to the date props LAST\n            allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);\n        }\n    }\n    if (allDay && startMarker) {\n        startMarker = startOfDay(startMarker);\n    }\n    if (endMeta) {\n        endMarker = endMeta.marker;\n        if (allDay) {\n            endMarker = startOfDay(endMarker);\n        }\n        if (startMarker && endMarker <= startMarker) {\n            endMarker = null;\n        }\n    }\n    if (endMarker) {\n        hasEnd = true;\n    } else if (!allowOpenRange) {\n        hasEnd = context.options.forceEventDuration || false;\n        endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);\n    }\n    return {\n        allDay,\n        hasEnd,\n        range: {\n            start: startMarker,\n            end: endMarker\n        },\n        forcedStartTzo: startMeta ? startMeta.forcedTzo : null,\n        forcedEndTzo: endMeta ? endMeta.forcedTzo : null\n    };\n}\nfunction computeIsDefaultAllDay(eventSource, context) {\n    let res = null;\n    if (eventSource) {\n        res = eventSource.defaultAllDay;\n    }\n    if (res == null) {\n        res = context.options.defaultAllDay;\n    }\n    return res;\n}\nfunction parseEvents(rawEvents, eventSource, context, allowOpenRange, defIdMap, instanceIdMap) {\n    let eventStore = createEmptyEventStore();\n    let eventRefiners = buildEventRefiners(context);\n    for (let rawEvent of rawEvents){\n        let tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners, defIdMap, instanceIdMap);\n        if (tuple) {\n            eventTupleToStore(tuple, eventStore);\n        }\n    }\n    return eventStore;\n}\nfunction eventTupleToStore(tuple, eventStore = createEmptyEventStore()) {\n    eventStore.defs[tuple.def.defId] = tuple.def;\n    if (tuple.instance) {\n        eventStore.instances[tuple.instance.instanceId] = tuple.instance;\n    }\n    return eventStore;\n}\n// retrieves events that have the same groupId as the instance specified by `instanceId`\n// or they are the same as the instance.\n// why might instanceId not be in the store? an event from another calendar?\nfunction getRelevantEvents(eventStore, instanceId) {\n    let instance = eventStore.instances[instanceId];\n    if (instance) {\n        let def = eventStore.defs[instance.defId];\n        // get events/instances with same group\n        let newStore = filterEventStoreDefs(eventStore, (lookDef)=>isEventDefsGrouped(def, lookDef));\n        // add the original\n        // TODO: wish we could use eventTupleToStore or something like it\n        newStore.defs[def.defId] = def;\n        newStore.instances[instance.instanceId] = instance;\n        return newStore;\n    }\n    return createEmptyEventStore();\n}\nfunction isEventDefsGrouped(def0, def1) {\n    return Boolean(def0.groupId && def0.groupId === def1.groupId);\n}\nfunction createEmptyEventStore() {\n    return {\n        defs: {},\n        instances: {}\n    };\n}\nfunction mergeEventStores(store0, store1) {\n    return {\n        defs: Object.assign(Object.assign({}, store0.defs), store1.defs),\n        instances: Object.assign(Object.assign({}, store0.instances), store1.instances)\n    };\n}\nfunction filterEventStoreDefs(eventStore, filterFunc) {\n    let defs = filterHash(eventStore.defs, filterFunc);\n    let instances = filterHash(eventStore.instances, (instance)=>defs[instance.defId] // still exists?\n    );\n    return {\n        defs,\n        instances\n    };\n}\nfunction excludeSubEventStore(master, sub) {\n    let { defs, instances } = master;\n    let filteredDefs = {};\n    let filteredInstances = {};\n    for(let defId in defs){\n        if (!sub.defs[defId]) {\n            filteredDefs[defId] = defs[defId];\n        }\n    }\n    for(let instanceId in instances){\n        if (!sub.instances[instanceId] && // not explicitly excluded\n        filteredDefs[instances[instanceId].defId] // def wasn't filtered away\n        ) {\n            filteredInstances[instanceId] = instances[instanceId];\n        }\n    }\n    return {\n        defs: filteredDefs,\n        instances: filteredInstances\n    };\n}\nfunction normalizeConstraint(input, context) {\n    if (Array.isArray(input)) {\n        return parseEvents(input, null, context, true); // allowOpenRange=true\n    }\n    if (typeof input === \"object\" && input) {\n        return parseEvents([\n            input\n        ], null, context, true); // allowOpenRange=true\n    }\n    if (input != null) {\n        return String(input);\n    }\n    return null;\n}\nfunction parseClassNames(raw) {\n    if (Array.isArray(raw)) {\n        return raw;\n    }\n    if (typeof raw === \"string\") {\n        return raw.split(/\\s+/);\n    }\n    return [];\n}\n// TODO: better called \"EventSettings\" or \"EventConfig\"\n// TODO: move this file into structs\n// TODO: separate constraint/overlap/allow, because selection uses only that, not other props\nconst EVENT_UI_REFINERS = {\n    display: String,\n    editable: Boolean,\n    startEditable: Boolean,\n    durationEditable: Boolean,\n    constraint: identity,\n    overlap: identity,\n    allow: identity,\n    className: parseClassNames,\n    classNames: parseClassNames,\n    color: String,\n    backgroundColor: String,\n    borderColor: String,\n    textColor: String\n};\nconst EMPTY_EVENT_UI = {\n    display: null,\n    startEditable: null,\n    durationEditable: null,\n    constraints: [],\n    overlap: null,\n    allows: [],\n    backgroundColor: \"\",\n    borderColor: \"\",\n    textColor: \"\",\n    classNames: []\n};\nfunction createEventUi(refined, context) {\n    let constraint = normalizeConstraint(refined.constraint, context);\n    return {\n        display: refined.display || null,\n        startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,\n        durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,\n        constraints: constraint != null ? [\n            constraint\n        ] : [],\n        overlap: refined.overlap != null ? refined.overlap : null,\n        allows: refined.allow != null ? [\n            refined.allow\n        ] : [],\n        backgroundColor: refined.backgroundColor || refined.color || \"\",\n        borderColor: refined.borderColor || refined.color || \"\",\n        textColor: refined.textColor || \"\",\n        classNames: (refined.className || []).concat(refined.classNames || [])\n    };\n}\n// TODO: prevent against problems with <2 args!\nfunction combineEventUis(uis) {\n    return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);\n}\nfunction combineTwoEventUis(item0, item1) {\n    return {\n        display: item1.display != null ? item1.display : item0.display,\n        startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,\n        durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,\n        constraints: item0.constraints.concat(item1.constraints),\n        overlap: typeof item1.overlap === \"boolean\" ? item1.overlap : item0.overlap,\n        allows: item0.allows.concat(item1.allows),\n        backgroundColor: item1.backgroundColor || item0.backgroundColor,\n        borderColor: item1.borderColor || item0.borderColor,\n        textColor: item1.textColor || item0.textColor,\n        classNames: item0.classNames.concat(item1.classNames)\n    };\n}\nconst EVENT_SOURCE_REFINERS = {\n    id: String,\n    defaultAllDay: Boolean,\n    url: String,\n    format: String,\n    events: identity,\n    eventDataTransform: identity,\n    // for any network-related sources\n    success: identity,\n    failure: identity\n};\nfunction parseEventSource(raw, context, refiners = buildEventSourceRefiners(context)) {\n    let rawObj;\n    if (typeof raw === \"string\") {\n        rawObj = {\n            url: raw\n        };\n    } else if (typeof raw === \"function\" || Array.isArray(raw)) {\n        rawObj = {\n            events: raw\n        };\n    } else if (typeof raw === \"object\" && raw) {\n        rawObj = raw;\n    }\n    if (rawObj) {\n        let { refined, extra } = refineProps(rawObj, refiners);\n        let metaRes = buildEventSourceMeta(refined, context);\n        if (metaRes) {\n            return {\n                _raw: raw,\n                isFetching: false,\n                latestFetchId: \"\",\n                fetchRange: null,\n                defaultAllDay: refined.defaultAllDay,\n                eventDataTransform: refined.eventDataTransform,\n                success: refined.success,\n                failure: refined.failure,\n                publicId: refined.id || \"\",\n                sourceId: guid(),\n                sourceDefId: metaRes.sourceDefId,\n                meta: metaRes.meta,\n                ui: createEventUi(refined, context),\n                extendedProps: extra\n            };\n        }\n    }\n    return null;\n}\nfunction buildEventSourceRefiners(context) {\n    return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);\n}\nfunction buildEventSourceMeta(raw, context) {\n    let defs = context.pluginHooks.eventSourceDefs;\n    for(let i = defs.length - 1; i >= 0; i -= 1){\n        let def = defs[i];\n        let meta = def.parseMeta(raw);\n        if (meta) {\n            return {\n                sourceDefId: i,\n                meta\n            };\n        }\n    }\n    return null;\n}\nfunction reduceEventStore(eventStore, action, eventSources, dateProfile, context) {\n    switch(action.type){\n        case \"RECEIVE_EVENTS\":\n            return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);\n        case \"RESET_RAW_EVENTS\":\n            return resetRawEvents(eventStore, eventSources[action.sourceId], action.rawEvents, dateProfile.activeRange, context);\n        case \"ADD_EVENTS\":\n            return addEvent(eventStore, action.eventStore, dateProfile ? dateProfile.activeRange : null, context);\n        case \"RESET_EVENTS\":\n            return action.eventStore;\n        case \"MERGE_EVENTS\":\n            return mergeEventStores(eventStore, action.eventStore);\n        case \"PREV\":\n        case \"NEXT\":\n        case \"CHANGE_DATE\":\n        case \"CHANGE_VIEW_TYPE\":\n            if (dateProfile) {\n                return expandRecurring(eventStore, dateProfile.activeRange, context);\n            }\n            return eventStore;\n        case \"REMOVE_EVENTS\":\n            return excludeSubEventStore(eventStore, action.eventStore);\n        case \"REMOVE_EVENT_SOURCE\":\n            return excludeEventsBySourceId(eventStore, action.sourceId);\n        case \"REMOVE_ALL_EVENT_SOURCES\":\n            return filterEventStoreDefs(eventStore, (eventDef)=>!eventDef.sourceId // only keep events with no source id\n            );\n        case \"REMOVE_ALL_EVENTS\":\n            return createEmptyEventStore();\n        default:\n            return eventStore;\n    }\n}\nfunction receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {\n    if (eventSource && // not already removed\n    fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources\n    ) {\n        let subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);\n        if (fetchRange) {\n            subset = expandRecurring(subset, fetchRange, context);\n        }\n        return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);\n    }\n    return eventStore;\n}\nfunction resetRawEvents(existingEventStore, eventSource, rawEvents, activeRange, context) {\n    const { defIdMap, instanceIdMap } = buildPublicIdMaps(existingEventStore);\n    let newEventStore = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context, false, defIdMap, instanceIdMap);\n    return expandRecurring(newEventStore, activeRange, context);\n}\nfunction transformRawEvents(rawEvents, eventSource, context) {\n    let calEachTransform = context.options.eventDataTransform;\n    let sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;\n    if (sourceEachTransform) {\n        rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);\n    }\n    if (calEachTransform) {\n        rawEvents = transformEachRawEvent(rawEvents, calEachTransform);\n    }\n    return rawEvents;\n}\nfunction transformEachRawEvent(rawEvents, func) {\n    let refinedEvents;\n    if (!func) {\n        refinedEvents = rawEvents;\n    } else {\n        refinedEvents = [];\n        for (let rawEvent of rawEvents){\n            let refinedEvent = func(rawEvent);\n            if (refinedEvent) {\n                refinedEvents.push(refinedEvent);\n            } else if (refinedEvent == null) {\n                refinedEvents.push(rawEvent);\n            } // if a different falsy value, do nothing\n        }\n    }\n    return refinedEvents;\n}\nfunction addEvent(eventStore, subset, expandRange, context) {\n    if (expandRange) {\n        subset = expandRecurring(subset, expandRange, context);\n    }\n    return mergeEventStores(eventStore, subset);\n}\nfunction rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {\n    let { defs } = eventStore;\n    let instances = mapHash(eventStore.instances, (instance)=>{\n        let def = defs[instance.defId];\n        if (def.allDay) {\n            return instance; // isn't dependent on timezone\n        }\n        return Object.assign(Object.assign({}, instance), {\n            range: {\n                start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),\n                end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))\n            },\n            forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo,\n            forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo\n        });\n    });\n    return {\n        defs,\n        instances\n    };\n}\nfunction excludeEventsBySourceId(eventStore, sourceId) {\n    return filterEventStoreDefs(eventStore, (eventDef)=>eventDef.sourceId !== sourceId);\n}\n// QUESTION: why not just return instances? do a general object-property-exclusion util\nfunction excludeInstances(eventStore, removals) {\n    return {\n        defs: eventStore.defs,\n        instances: filterHash(eventStore.instances, (instance)=>!removals[instance.instanceId])\n    };\n}\nfunction buildPublicIdMaps(eventStore) {\n    const { defs, instances } = eventStore;\n    const defIdMap = {};\n    const instanceIdMap = {};\n    for(let defId in defs){\n        const def = defs[defId];\n        const { publicId } = def;\n        if (publicId) {\n            defIdMap[publicId] = defId;\n        }\n    }\n    for(let instanceId in instances){\n        const instance = instances[instanceId];\n        const def = defs[instance.defId];\n        const { publicId } = def;\n        if (publicId) {\n            instanceIdMap[publicId] = instanceId;\n        }\n    }\n    return {\n        defIdMap,\n        instanceIdMap\n    };\n}\nclass Emitter {\n    constructor(){\n        this.handlers = {};\n        this.thisContext = null;\n    }\n    setThisContext(thisContext) {\n        this.thisContext = thisContext;\n    }\n    setOptions(options) {\n        this.options = options;\n    }\n    on(type, handler) {\n        addToHash(this.handlers, type, handler);\n    }\n    off(type, handler) {\n        removeFromHash(this.handlers, type, handler);\n    }\n    trigger(type, ...args) {\n        let attachedHandlers = this.handlers[type] || [];\n        let optionHandler = this.options && this.options[type];\n        let handlers = [].concat(optionHandler || [], attachedHandlers);\n        for (let handler of handlers){\n            handler.apply(this.thisContext, args);\n        }\n    }\n    hasHandlers(type) {\n        return Boolean(this.handlers[type] && this.handlers[type].length || this.options && this.options[type]);\n    }\n}\nfunction addToHash(hash, type, handler) {\n    (hash[type] || (hash[type] = [])).push(handler);\n}\nfunction removeFromHash(hash, type, handler) {\n    if (handler) {\n        if (hash[type]) {\n            hash[type] = hash[type].filter((func)=>func !== handler);\n        }\n    } else {\n        delete hash[type]; // remove all handler funcs for this type\n    }\n}\nconst DEF_DEFAULTS = {\n    startTime: \"09:00\",\n    endTime: \"17:00\",\n    daysOfWeek: [\n        1,\n        2,\n        3,\n        4,\n        5\n    ],\n    display: \"inverse-background\",\n    classNames: \"fc-non-business\",\n    groupId: \"_businessHours\"\n};\n/*\nTODO: pass around as EventDefHash!!!\n*/ function parseBusinessHours(input, context) {\n    return parseEvents(refineInputs(input), null, context);\n}\nfunction refineInputs(input) {\n    let rawDefs;\n    if (input === true) {\n        rawDefs = [\n            {}\n        ]; // will get DEF_DEFAULTS verbatim\n    } else if (Array.isArray(input)) {\n        // if specifying an array, every sub-definition NEEDS a day-of-week\n        rawDefs = input.filter((rawDef)=>rawDef.daysOfWeek);\n    } else if (typeof input === \"object\" && input) {\n        rawDefs = [\n            input\n        ];\n    } else {\n        rawDefs = [];\n    }\n    rawDefs = rawDefs.map((rawDef)=>Object.assign(Object.assign({}, DEF_DEFAULTS), rawDef));\n    return rawDefs;\n}\nfunction triggerDateSelect(selection, pev, context) {\n    context.emitter.trigger(\"select\", Object.assign(Object.assign({}, buildDateSpanApiWithContext(selection, context)), {\n        jsEvent: pev ? pev.origEvent : null,\n        view: context.viewApi || context.calendarApi.view\n    }));\n}\nfunction triggerDateUnselect(pev, context) {\n    context.emitter.trigger(\"unselect\", {\n        jsEvent: pev ? pev.origEvent : null,\n        view: context.viewApi || context.calendarApi.view\n    });\n}\nfunction buildDateSpanApiWithContext(dateSpan, context) {\n    let props = {};\n    for (let transform of context.pluginHooks.dateSpanTransforms){\n        Object.assign(props, transform(dateSpan, context));\n    }\n    Object.assign(props, buildDateSpanApi(dateSpan, context.dateEnv));\n    return props;\n}\n// Given an event's allDay status and start date, return what its fallback end date should be.\n// TODO: rename to computeDefaultEventEnd\nfunction getDefaultEventEnd(allDay, marker, context) {\n    let { dateEnv, options } = context;\n    let end = marker;\n    if (allDay) {\n        end = startOfDay(end);\n        end = dateEnv.add(end, options.defaultAllDayEventDuration);\n    } else {\n        end = dateEnv.add(end, options.defaultTimedEventDuration);\n    }\n    return end;\n}\n// applies the mutation to ALL defs/instances within the event store\nfunction applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {\n    let eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);\n    let dest = createEmptyEventStore();\n    for(let defId in eventStore.defs){\n        let def = eventStore.defs[defId];\n        dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);\n    }\n    for(let instanceId in eventStore.instances){\n        let instance = eventStore.instances[instanceId];\n        let def = dest.defs[instance.defId]; // important to grab the newly modified def\n        dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);\n    }\n    return dest;\n}\nfunction applyMutationToEventDef(eventDef, eventConfig, mutation, context) {\n    let standardProps = mutation.standardProps || {};\n    // if hasEnd has not been specified, guess a good value based on deltas.\n    // if duration will change, there's no way the default duration will persist,\n    // and thus, we need to mark the event as having a real end\n    if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {\n        standardProps.hasEnd = true; // TODO: is this mutation okay?\n    }\n    let copy = Object.assign(Object.assign(Object.assign({}, eventDef), standardProps), {\n        ui: Object.assign(Object.assign({}, eventDef.ui), standardProps.ui)\n    });\n    if (mutation.extendedProps) {\n        copy.extendedProps = Object.assign(Object.assign({}, copy.extendedProps), mutation.extendedProps);\n    }\n    for (let applier of context.pluginHooks.eventDefMutationAppliers){\n        applier(copy, mutation, context);\n    }\n    if (!copy.hasEnd && context.options.forceEventDuration) {\n        copy.hasEnd = true;\n    }\n    return copy;\n}\nfunction applyMutationToEventInstance(eventInstance, eventDef, eventConfig, mutation, context) {\n    let { dateEnv } = context;\n    let forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;\n    let clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;\n    let copy = Object.assign({}, eventInstance);\n    if (forceAllDay) {\n        copy.range = computeAlignedDayRange(copy.range);\n    }\n    if (mutation.datesDelta && eventConfig.startEditable) {\n        copy.range = {\n            start: dateEnv.add(copy.range.start, mutation.datesDelta),\n            end: dateEnv.add(copy.range.end, mutation.datesDelta)\n        };\n    }\n    if (mutation.startDelta && eventConfig.durationEditable) {\n        copy.range = {\n            start: dateEnv.add(copy.range.start, mutation.startDelta),\n            end: copy.range.end\n        };\n    }\n    if (mutation.endDelta && eventConfig.durationEditable) {\n        copy.range = {\n            start: copy.range.start,\n            end: dateEnv.add(copy.range.end, mutation.endDelta)\n        };\n    }\n    if (clearEnd) {\n        copy.range = {\n            start: copy.range.start,\n            end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)\n        };\n    }\n    // in case event was all-day but the supplied deltas were not\n    // better util for this?\n    if (eventDef.allDay) {\n        copy.range = {\n            start: startOfDay(copy.range.start),\n            end: startOfDay(copy.range.end)\n        };\n    }\n    // handle invalid durations\n    if (copy.range.end < copy.range.start) {\n        copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);\n    }\n    return copy;\n}\nclass EventSourceImpl {\n    constructor(context, internalEventSource){\n        this.context = context;\n        this.internalEventSource = internalEventSource;\n    }\n    remove() {\n        this.context.dispatch({\n            type: \"REMOVE_EVENT_SOURCE\",\n            sourceId: this.internalEventSource.sourceId\n        });\n    }\n    refetch() {\n        this.context.dispatch({\n            type: \"FETCH_EVENT_SOURCES\",\n            sourceIds: [\n                this.internalEventSource.sourceId\n            ],\n            isRefetch: true\n        });\n    }\n    get id() {\n        return this.internalEventSource.publicId;\n    }\n    get url() {\n        return this.internalEventSource.meta.url;\n    }\n    get format() {\n        return this.internalEventSource.meta.format; // TODO: bad. not guaranteed\n    }\n}\nclass EventImpl {\n    // instance will be null if expressing a recurring event that has no current instances,\n    // OR if trying to validate an incoming external event that has no dates assigned\n    constructor(context, def, instance){\n        this._context = context;\n        this._def = def;\n        this._instance = instance || null;\n    }\n    /*\n    TODO: make event struct more responsible for this\n    */ setProp(name, val) {\n        if (name in EVENT_DATE_REFINERS) {\n            console.warn(\"Could not set date-related prop 'name'. Use one of the date-related methods instead.\");\n        // TODO: make proper aliasing system?\n        } else if (name === \"id\") {\n            val = EVENT_NON_DATE_REFINERS[name](val);\n            this.mutate({\n                standardProps: {\n                    publicId: val\n                }\n            });\n        } else if (name in EVENT_NON_DATE_REFINERS) {\n            val = EVENT_NON_DATE_REFINERS[name](val);\n            this.mutate({\n                standardProps: {\n                    [name]: val\n                }\n            });\n        } else if (name in EVENT_UI_REFINERS) {\n            let ui = EVENT_UI_REFINERS[name](val);\n            if (name === \"color\") {\n                ui = {\n                    backgroundColor: val,\n                    borderColor: val\n                };\n            } else if (name === \"editable\") {\n                ui = {\n                    startEditable: val,\n                    durationEditable: val\n                };\n            } else {\n                ui = {\n                    [name]: val\n                };\n            }\n            this.mutate({\n                standardProps: {\n                    ui\n                }\n            });\n        } else {\n            console.warn(`Could not set prop '${name}'. Use setExtendedProp instead.`);\n        }\n    }\n    setExtendedProp(name, val) {\n        this.mutate({\n            extendedProps: {\n                [name]: val\n            }\n        });\n    }\n    setStart(startInput, options = {}) {\n        let { dateEnv } = this._context;\n        let start = dateEnv.createMarker(startInput);\n        if (start && this._instance) {\n            let instanceRange = this._instance.range;\n            let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?\n            if (options.maintainDuration) {\n                this.mutate({\n                    datesDelta: startDelta\n                });\n            } else {\n                this.mutate({\n                    startDelta\n                });\n            }\n        }\n    }\n    setEnd(endInput, options = {}) {\n        let { dateEnv } = this._context;\n        let end;\n        if (endInput != null) {\n            end = dateEnv.createMarker(endInput);\n            if (!end) {\n                return; // TODO: warning if parsed bad\n            }\n        }\n        if (this._instance) {\n            if (end) {\n                let endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);\n                this.mutate({\n                    endDelta\n                });\n            } else {\n                this.mutate({\n                    standardProps: {\n                        hasEnd: false\n                    }\n                });\n            }\n        }\n    }\n    setDates(startInput, endInput, options = {}) {\n        let { dateEnv } = this._context;\n        let standardProps = {\n            allDay: options.allDay\n        };\n        let start = dateEnv.createMarker(startInput);\n        let end;\n        if (!start) {\n            return; // TODO: warning if parsed bad\n        }\n        if (endInput != null) {\n            end = dateEnv.createMarker(endInput);\n            if (!end) {\n                return;\n            }\n        }\n        if (this._instance) {\n            let instanceRange = this._instance.range;\n            // when computing the diff for an event being converted to all-day,\n            // compute diff off of the all-day values the way event-mutation does.\n            if (options.allDay === true) {\n                instanceRange = computeAlignedDayRange(instanceRange);\n            }\n            let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);\n            if (end) {\n                let endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);\n                if (durationsEqual(startDelta, endDelta)) {\n                    this.mutate({\n                        datesDelta: startDelta,\n                        standardProps\n                    });\n                } else {\n                    this.mutate({\n                        startDelta,\n                        endDelta,\n                        standardProps\n                    });\n                }\n            } else {\n                standardProps.hasEnd = false;\n                this.mutate({\n                    datesDelta: startDelta,\n                    standardProps\n                });\n            }\n        }\n    }\n    moveStart(deltaInput) {\n        let delta = createDuration(deltaInput);\n        if (delta) {\n            this.mutate({\n                startDelta: delta\n            });\n        }\n    }\n    moveEnd(deltaInput) {\n        let delta = createDuration(deltaInput);\n        if (delta) {\n            this.mutate({\n                endDelta: delta\n            });\n        }\n    }\n    moveDates(deltaInput) {\n        let delta = createDuration(deltaInput);\n        if (delta) {\n            this.mutate({\n                datesDelta: delta\n            });\n        }\n    }\n    setAllDay(allDay, options = {}) {\n        let standardProps = {\n            allDay\n        };\n        let { maintainDuration } = options;\n        if (maintainDuration == null) {\n            maintainDuration = this._context.options.allDayMaintainDuration;\n        }\n        if (this._def.allDay !== allDay) {\n            standardProps.hasEnd = maintainDuration;\n        }\n        this.mutate({\n            standardProps\n        });\n    }\n    formatRange(formatInput) {\n        let { dateEnv } = this._context;\n        let instance = this._instance;\n        let formatter = createFormatter(formatInput);\n        if (this._def.hasEnd) {\n            return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {\n                forcedStartTzo: instance.forcedStartTzo,\n                forcedEndTzo: instance.forcedEndTzo\n            });\n        }\n        return dateEnv.format(instance.range.start, formatter, {\n            forcedTzo: instance.forcedStartTzo\n        });\n    }\n    mutate(mutation) {\n        let instance = this._instance;\n        if (instance) {\n            let def = this._def;\n            let context = this._context;\n            let { eventStore } = context.getCurrentData();\n            let relevantEvents = getRelevantEvents(eventStore, instance.instanceId);\n            let eventConfigBase = {\n                \"\": {\n                    display: \"\",\n                    startEditable: true,\n                    durationEditable: true,\n                    constraints: [],\n                    overlap: null,\n                    allows: [],\n                    backgroundColor: \"\",\n                    borderColor: \"\",\n                    textColor: \"\",\n                    classNames: []\n                }\n            };\n            relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context);\n            let oldEvent = new EventImpl(context, def, instance); // snapshot\n            this._def = relevantEvents.defs[def.defId];\n            this._instance = relevantEvents.instances[instance.instanceId];\n            context.dispatch({\n                type: \"MERGE_EVENTS\",\n                eventStore: relevantEvents\n            });\n            context.emitter.trigger(\"eventChange\", {\n                oldEvent,\n                event: this,\n                relatedEvents: buildEventApis(relevantEvents, context, instance),\n                revert () {\n                    context.dispatch({\n                        type: \"RESET_EVENTS\",\n                        eventStore\n                    });\n                }\n            });\n        }\n    }\n    remove() {\n        let context = this._context;\n        let asStore = eventApiToStore(this);\n        context.dispatch({\n            type: \"REMOVE_EVENTS\",\n            eventStore: asStore\n        });\n        context.emitter.trigger(\"eventRemove\", {\n            event: this,\n            relatedEvents: [],\n            revert () {\n                context.dispatch({\n                    type: \"MERGE_EVENTS\",\n                    eventStore: asStore\n                });\n            }\n        });\n    }\n    get source() {\n        let { sourceId } = this._def;\n        if (sourceId) {\n            return new EventSourceImpl(this._context, this._context.getCurrentData().eventSources[sourceId]);\n        }\n        return null;\n    }\n    get start() {\n        return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;\n    }\n    get end() {\n        return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;\n    }\n    get startStr() {\n        let instance = this._instance;\n        if (instance) {\n            return this._context.dateEnv.formatIso(instance.range.start, {\n                omitTime: this._def.allDay,\n                forcedTzo: instance.forcedStartTzo\n            });\n        }\n        return \"\";\n    }\n    get endStr() {\n        let instance = this._instance;\n        if (instance && this._def.hasEnd) {\n            return this._context.dateEnv.formatIso(instance.range.end, {\n                omitTime: this._def.allDay,\n                forcedTzo: instance.forcedEndTzo\n            });\n        }\n        return \"\";\n    }\n    // computable props that all access the def\n    // TODO: find a TypeScript-compatible way to do this at scale\n    get id() {\n        return this._def.publicId;\n    }\n    get groupId() {\n        return this._def.groupId;\n    }\n    get allDay() {\n        return this._def.allDay;\n    }\n    get title() {\n        return this._def.title;\n    }\n    get url() {\n        return this._def.url;\n    }\n    get display() {\n        return this._def.ui.display || \"auto\";\n    }\n    get startEditable() {\n        return this._def.ui.startEditable;\n    }\n    get durationEditable() {\n        return this._def.ui.durationEditable;\n    }\n    get constraint() {\n        return this._def.ui.constraints[0] || null;\n    }\n    get overlap() {\n        return this._def.ui.overlap;\n    }\n    get allow() {\n        return this._def.ui.allows[0] || null;\n    }\n    get backgroundColor() {\n        return this._def.ui.backgroundColor;\n    }\n    get borderColor() {\n        return this._def.ui.borderColor;\n    }\n    get textColor() {\n        return this._def.ui.textColor;\n    }\n    // NOTE: user can't modify these because Object.freeze was called in event-def parsing\n    get classNames() {\n        return this._def.ui.classNames;\n    }\n    get extendedProps() {\n        return this._def.extendedProps;\n    }\n    toPlainObject(settings = {}) {\n        let def = this._def;\n        let { ui } = def;\n        let { startStr, endStr } = this;\n        let res = {\n            allDay: def.allDay\n        };\n        if (def.title) {\n            res.title = def.title;\n        }\n        if (startStr) {\n            res.start = startStr;\n        }\n        if (endStr) {\n            res.end = endStr;\n        }\n        if (def.publicId) {\n            res.id = def.publicId;\n        }\n        if (def.groupId) {\n            res.groupId = def.groupId;\n        }\n        if (def.url) {\n            res.url = def.url;\n        }\n        if (ui.display && ui.display !== \"auto\") {\n            res.display = ui.display;\n        }\n        // TODO: what about recurring-event properties???\n        // TODO: include startEditable/durationEditable/constraint/overlap/allow\n        if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {\n            res.color = ui.backgroundColor;\n        } else {\n            if (ui.backgroundColor) {\n                res.backgroundColor = ui.backgroundColor;\n            }\n            if (ui.borderColor) {\n                res.borderColor = ui.borderColor;\n            }\n        }\n        if (ui.textColor) {\n            res.textColor = ui.textColor;\n        }\n        if (ui.classNames.length) {\n            res.classNames = ui.classNames;\n        }\n        if (Object.keys(def.extendedProps).length) {\n            if (settings.collapseExtendedProps) {\n                Object.assign(res, def.extendedProps);\n            } else {\n                res.extendedProps = def.extendedProps;\n            }\n        }\n        return res;\n    }\n    toJSON() {\n        return this.toPlainObject();\n    }\n}\nfunction eventApiToStore(eventApi) {\n    let def = eventApi._def;\n    let instance = eventApi._instance;\n    return {\n        defs: {\n            [def.defId]: def\n        },\n        instances: instance ? {\n            [instance.instanceId]: instance\n        } : {}\n    };\n}\nfunction buildEventApis(eventStore, context, excludeInstance) {\n    let { defs, instances } = eventStore;\n    let eventApis = [];\n    let excludeInstanceId = excludeInstance ? excludeInstance.instanceId : \"\";\n    for(let id in instances){\n        let instance = instances[id];\n        let def = defs[instance.defId];\n        if (instance.instanceId !== excludeInstanceId) {\n            eventApis.push(new EventImpl(context, def, instance));\n        }\n    }\n    return eventApis;\n}\n/*\nSpecifying nextDayThreshold signals that all-day ranges should be sliced.\n*/ function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {\n    let inverseBgByGroupId = {};\n    let inverseBgByDefId = {};\n    let defByGroupId = {};\n    let bgRanges = [];\n    let fgRanges = [];\n    let eventUis = compileEventUis(eventStore.defs, eventUiBases);\n    for(let defId in eventStore.defs){\n        let def = eventStore.defs[defId];\n        let ui = eventUis[def.defId];\n        if (ui.display === \"inverse-background\") {\n            if (def.groupId) {\n                inverseBgByGroupId[def.groupId] = [];\n                if (!defByGroupId[def.groupId]) {\n                    defByGroupId[def.groupId] = def;\n                }\n            } else {\n                inverseBgByDefId[defId] = [];\n            }\n        }\n    }\n    for(let instanceId in eventStore.instances){\n        let instance = eventStore.instances[instanceId];\n        let def = eventStore.defs[instance.defId];\n        let ui = eventUis[def.defId];\n        let origRange = instance.range;\n        let normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;\n        let slicedRange = intersectRanges(normalRange, framingRange);\n        if (slicedRange) {\n            if (ui.display === \"inverse-background\") {\n                if (def.groupId) {\n                    inverseBgByGroupId[def.groupId].push(slicedRange);\n                } else {\n                    inverseBgByDefId[instance.defId].push(slicedRange);\n                }\n            } else if (ui.display !== \"none\") {\n                (ui.display === \"background\" ? bgRanges : fgRanges).push({\n                    def,\n                    ui,\n                    instance,\n                    range: slicedRange,\n                    isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),\n                    isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()\n                });\n            }\n        }\n    }\n    for(let groupId in inverseBgByGroupId){\n        let ranges = inverseBgByGroupId[groupId];\n        let invertedRanges = invertRanges(ranges, framingRange);\n        for (let invertedRange of invertedRanges){\n            let def = defByGroupId[groupId];\n            let ui = eventUis[def.defId];\n            bgRanges.push({\n                def,\n                ui,\n                instance: null,\n                range: invertedRange,\n                isStart: false,\n                isEnd: false\n            });\n        }\n    }\n    for(let defId in inverseBgByDefId){\n        let ranges = inverseBgByDefId[defId];\n        let invertedRanges = invertRanges(ranges, framingRange);\n        for (let invertedRange of invertedRanges){\n            bgRanges.push({\n                def: eventStore.defs[defId],\n                ui: eventUis[defId],\n                instance: null,\n                range: invertedRange,\n                isStart: false,\n                isEnd: false\n            });\n        }\n    }\n    return {\n        bg: bgRanges,\n        fg: fgRanges\n    };\n}\nfunction hasBgRendering(def) {\n    return def.ui.display === \"background\" || def.ui.display === \"inverse-background\";\n}\nfunction setElSeg(el, seg) {\n    el.fcSeg = seg;\n}\nfunction getElSeg(el) {\n    return el.fcSeg || el.parentNode.fcSeg || // for the harness\n    null;\n}\n// event ui computation\nfunction compileEventUis(eventDefs, eventUiBases) {\n    return mapHash(eventDefs, (eventDef)=>compileEventUi(eventDef, eventUiBases));\n}\nfunction compileEventUi(eventDef, eventUiBases) {\n    let uis = [];\n    if (eventUiBases[\"\"]) {\n        uis.push(eventUiBases[\"\"]);\n    }\n    if (eventUiBases[eventDef.defId]) {\n        uis.push(eventUiBases[eventDef.defId]);\n    }\n    uis.push(eventDef.ui);\n    return combineEventUis(uis);\n}\nfunction sortEventSegs(segs, eventOrderSpecs) {\n    let objs = segs.map(buildSegCompareObj);\n    objs.sort((obj0, obj1)=>compareByFieldSpecs(obj0, obj1, eventOrderSpecs));\n    return objs.map((c)=>c._seg);\n}\n// returns a object with all primitive props that can be compared\nfunction buildSegCompareObj(seg) {\n    let { eventRange } = seg;\n    let eventDef = eventRange.def;\n    let range = eventRange.instance ? eventRange.instance.range : eventRange.range;\n    let start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events\n    let end = range.end ? range.end.valueOf() : 0; // \"\n    return Object.assign(Object.assign(Object.assign({}, eventDef.extendedProps), eventDef), {\n        id: eventDef.publicId,\n        start,\n        end,\n        duration: end - start,\n        allDay: Number(eventDef.allDay),\n        _seg: seg\n    });\n}\nfunction computeSegDraggable(seg, context) {\n    let { pluginHooks } = context;\n    let transformers = pluginHooks.isDraggableTransformers;\n    let { def, ui } = seg.eventRange;\n    let val = ui.startEditable;\n    for (let transformer of transformers){\n        val = transformer(val, def, ui, context);\n    }\n    return val;\n}\nfunction computeSegStartResizable(seg, context) {\n    return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;\n}\nfunction computeSegEndResizable(seg, context) {\n    return seg.isEnd && seg.eventRange.ui.durationEditable;\n}\nfunction buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, defaultDisplayEventEnd, startOverride, endOverride) {\n    let { dateEnv, options } = context;\n    let { displayEventTime, displayEventEnd } = options;\n    let eventDef = seg.eventRange.def;\n    let eventInstance = seg.eventRange.instance;\n    if (displayEventTime == null) {\n        displayEventTime = defaultDisplayEventTime !== false;\n    }\n    if (displayEventEnd == null) {\n        displayEventEnd = defaultDisplayEventEnd !== false;\n    }\n    let wholeEventStart = eventInstance.range.start;\n    let wholeEventEnd = eventInstance.range.end;\n    let segStart = startOverride || seg.start || seg.eventRange.range.start;\n    let segEnd = endOverride || seg.end || seg.eventRange.range.end;\n    let isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();\n    let isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();\n    if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {\n        segStart = isStartDay ? wholeEventStart : segStart;\n        segEnd = isEndDay ? wholeEventEnd : segEnd;\n        if (displayEventEnd && eventDef.hasEnd) {\n            return dateEnv.formatRange(segStart, segEnd, timeFormat, {\n                forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,\n                forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo\n            });\n        }\n        return dateEnv.format(segStart, timeFormat, {\n            forcedTzo: startOverride ? null : eventInstance.forcedStartTzo\n        });\n    }\n    return \"\";\n}\nfunction getSegMeta(seg, todayRange, nowDate) {\n    let segRange = seg.eventRange.range;\n    return {\n        isPast: segRange.end < (nowDate || todayRange.start),\n        isFuture: segRange.start >= (nowDate || todayRange.end),\n        isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)\n    };\n}\nfunction getEventClassNames(props) {\n    let classNames = [\n        \"fc-event\"\n    ];\n    if (props.isMirror) {\n        classNames.push(\"fc-event-mirror\");\n    }\n    if (props.isDraggable) {\n        classNames.push(\"fc-event-draggable\");\n    }\n    if (props.isStartResizable || props.isEndResizable) {\n        classNames.push(\"fc-event-resizable\");\n    }\n    if (props.isDragging) {\n        classNames.push(\"fc-event-dragging\");\n    }\n    if (props.isResizing) {\n        classNames.push(\"fc-event-resizing\");\n    }\n    if (props.isSelected) {\n        classNames.push(\"fc-event-selected\");\n    }\n    if (props.isStart) {\n        classNames.push(\"fc-event-start\");\n    }\n    if (props.isEnd) {\n        classNames.push(\"fc-event-end\");\n    }\n    if (props.isPast) {\n        classNames.push(\"fc-event-past\");\n    }\n    if (props.isToday) {\n        classNames.push(\"fc-event-today\");\n    }\n    if (props.isFuture) {\n        classNames.push(\"fc-event-future\");\n    }\n    return classNames;\n}\nfunction buildEventRangeKey(eventRange) {\n    return eventRange.instance ? eventRange.instance.instanceId : `${eventRange.def.defId}:${eventRange.range.start.toISOString()}`;\n// inverse-background events don't have specific instances. TODO: better solution\n}\nfunction getSegAnchorAttrs(seg, context) {\n    let { def, instance } = seg.eventRange;\n    let { url } = def;\n    if (url) {\n        return {\n            href: url\n        };\n    }\n    let { emitter, options } = context;\n    let { eventInteractive } = options;\n    if (eventInteractive == null) {\n        eventInteractive = def.interactive;\n        if (eventInteractive == null) {\n            eventInteractive = Boolean(emitter.hasHandlers(\"eventClick\"));\n        }\n    }\n    // mock what happens in EventClicking\n    if (eventInteractive) {\n        // only attach keyboard-related handlers because click handler is already done in EventClicking\n        return createAriaKeyboardAttrs((ev)=>{\n            emitter.trigger(\"eventClick\", {\n                el: ev.target,\n                event: new EventImpl(context, def, instance),\n                jsEvent: ev,\n                view: context.viewApi\n            });\n        });\n    }\n    return {};\n}\nconst STANDARD_PROPS = {\n    start: identity,\n    end: identity,\n    allDay: Boolean\n};\nfunction parseDateSpan(raw, dateEnv, defaultDuration) {\n    let span = parseOpenDateSpan(raw, dateEnv);\n    let { range } = span;\n    if (!range.start) {\n        return null;\n    }\n    if (!range.end) {\n        if (defaultDuration == null) {\n            return null;\n        }\n        range.end = dateEnv.add(range.start, defaultDuration);\n    }\n    return span;\n}\n/*\nTODO: somehow combine with parseRange?\nWill return null if the start/end props were present but parsed invalidly.\n*/ function parseOpenDateSpan(raw, dateEnv) {\n    let { refined: standardProps, extra } = refineProps(raw, STANDARD_PROPS);\n    let startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;\n    let endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;\n    let { allDay } = standardProps;\n    if (allDay == null) {\n        allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);\n    }\n    return Object.assign({\n        range: {\n            start: startMeta ? startMeta.marker : null,\n            end: endMeta ? endMeta.marker : null\n        },\n        allDay\n    }, extra);\n}\nfunction isDateSpansEqual(span0, span1) {\n    return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);\n}\n// the NON-DATE-RELATED props\nfunction isSpanPropsEqual(span0, span1) {\n    for(let propName in span1){\n        if (propName !== \"range\" && propName !== \"allDay\") {\n            if (span0[propName] !== span1[propName]) {\n                return false;\n            }\n        }\n    }\n    // are there any props that span0 has that span1 DOESN'T have?\n    // both have range/allDay, so no need to special-case.\n    for(let propName in span0){\n        if (!(propName in span1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction buildDateSpanApi(span, dateEnv) {\n    return Object.assign(Object.assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), {\n        allDay: span.allDay\n    });\n}\nfunction buildRangeApiWithTimeZone(range, dateEnv, omitTime) {\n    return Object.assign(Object.assign({}, buildRangeApi(range, dateEnv, omitTime)), {\n        timeZone: dateEnv.timeZone\n    });\n}\nfunction buildRangeApi(range, dateEnv, omitTime) {\n    return {\n        start: dateEnv.toDate(range.start),\n        end: dateEnv.toDate(range.end),\n        startStr: dateEnv.formatIso(range.start, {\n            omitTime\n        }),\n        endStr: dateEnv.formatIso(range.end, {\n            omitTime\n        })\n    };\n}\nfunction fabricateEventRange(dateSpan, eventUiBases, context) {\n    let res = refineEventDef({\n        editable: false\n    }, context);\n    let def = parseEventDef(res.refined, res.extra, \"\", dateSpan.allDay, true, context);\n    return {\n        def,\n        ui: compileEventUi(def, eventUiBases),\n        instance: createEventInstance(def.defId, dateSpan.range),\n        range: dateSpan.range,\n        isStart: true,\n        isEnd: true\n    };\n}\n/*\ngiven a function that resolves a result asynchronously.\nthe function can either call passed-in success and failure callbacks,\nor it can return a promise.\nif you need to pass additional params to func, bind them first.\n*/ function unpromisify(func, normalizedSuccessCallback, normalizedFailureCallback) {\n    // guard against success/failure callbacks being called more than once\n    // and guard against a promise AND callback being used together.\n    let isResolved = false;\n    let wrappedSuccess = function(res) {\n        if (!isResolved) {\n            isResolved = true;\n            normalizedSuccessCallback(res);\n        }\n    };\n    let wrappedFailure = function(error) {\n        if (!isResolved) {\n            isResolved = true;\n            normalizedFailureCallback(error);\n        }\n    };\n    let res = func(wrappedSuccess, wrappedFailure);\n    if (res && typeof res.then === \"function\") {\n        res.then(wrappedSuccess, wrappedFailure);\n    }\n}\nclass JsonRequestError extends Error {\n    constructor(message, response){\n        super(message);\n        this.response = response;\n    }\n}\nfunction requestJson(method, url, params) {\n    method = method.toUpperCase();\n    const fetchOptions = {\n        method\n    };\n    if (method === \"GET\") {\n        url += (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + new URLSearchParams(params);\n    } else {\n        fetchOptions.body = new URLSearchParams(params);\n        fetchOptions.headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n        };\n    }\n    return fetch(url, fetchOptions).then((fetchRes)=>{\n        if (fetchRes.ok) {\n            return fetchRes.json().then((parsedResponse)=>{\n                return [\n                    parsedResponse,\n                    fetchRes\n                ];\n            }, ()=>{\n                throw new JsonRequestError(\"Failure parsing JSON\", fetchRes);\n            });\n        } else {\n            throw new JsonRequestError(\"Request failed\", fetchRes);\n        }\n    });\n}\nlet canVGrowWithinCell;\nfunction getCanVGrowWithinCell() {\n    if (canVGrowWithinCell == null) {\n        canVGrowWithinCell = computeCanVGrowWithinCell();\n    }\n    return canVGrowWithinCell;\n}\nfunction computeCanVGrowWithinCell() {\n    // for SSR, because this function is call immediately at top-level\n    // TODO: just make this logic execute top-level, immediately, instead of doing lazily\n    if (typeof document === \"undefined\") {\n        return true;\n    }\n    let el = document.createElement(\"div\");\n    el.style.position = \"absolute\";\n    el.style.top = \"0px\";\n    el.style.left = \"0px\";\n    el.innerHTML = \"<table><tr><td><div></div></td></tr></table>\";\n    el.querySelector(\"table\").style.height = \"100px\";\n    el.querySelector(\"div\").style.height = \"100%\";\n    document.body.appendChild(el);\n    let div = el.querySelector(\"div\");\n    let possible = div.offsetHeight > 0;\n    document.body.removeChild(el);\n    return possible;\n}\nclass CalendarRoot extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.state = {\n            forPrint: false\n        };\n        this.handleBeforePrint = ()=>{\n            this.setState({\n                forPrint: true\n            });\n        };\n        this.handleAfterPrint = ()=>{\n            this.setState({\n                forPrint: false\n            });\n        };\n    }\n    render() {\n        let { props } = this;\n        let { options } = props;\n        let { forPrint } = this.state;\n        let isHeightAuto = forPrint || options.height === \"auto\" || options.contentHeight === \"auto\";\n        let height = !isHeightAuto && options.height != null ? options.height : \"\";\n        let classNames = [\n            \"fc\",\n            forPrint ? \"fc-media-print\" : \"fc-media-screen\",\n            `fc-direction-${options.direction}`,\n            props.theme.getClass(\"root\")\n        ];\n        if (!getCanVGrowWithinCell()) {\n            classNames.push(\"fc-liquid-hack\");\n        }\n        return props.children(classNames, height, isHeightAuto, forPrint);\n    }\n    componentDidMount() {\n        let { emitter } = this.props;\n        emitter.on(\"_beforeprint\", this.handleBeforePrint);\n        emitter.on(\"_afterprint\", this.handleAfterPrint);\n    }\n    componentWillUnmount() {\n        let { emitter } = this.props;\n        emitter.off(\"_beforeprint\", this.handleBeforePrint);\n        emitter.off(\"_afterprint\", this.handleAfterPrint);\n    }\n}\nclass Interaction {\n    constructor(settings){\n        this.component = settings.component;\n        this.isHitComboAllowed = settings.isHitComboAllowed || null;\n    }\n    destroy() {}\n}\nfunction parseInteractionSettings(component, input) {\n    return {\n        component,\n        el: input.el,\n        useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,\n        isHitComboAllowed: input.isHitComboAllowed || null\n    };\n}\nfunction interactionSettingsToStore(settings) {\n    return {\n        [settings.component.uid]: settings\n    };\n}\n// global state\nconst interactionSettingsStore = {};\nclass CalendarImpl {\n    getCurrentData() {\n        return this.currentDataManager.getCurrentData();\n    }\n    dispatch(action) {\n        this.currentDataManager.dispatch(action);\n    }\n    get view() {\n        return this.getCurrentData().viewApi;\n    }\n    batchRendering(callback) {\n        callback();\n    }\n    updateSize() {\n        this.trigger(\"_resize\", true);\n    }\n    // Options\n    // -----------------------------------------------------------------------------------------------------------------\n    setOption(name, val) {\n        this.dispatch({\n            type: \"SET_OPTION\",\n            optionName: name,\n            rawOptionValue: val\n        });\n    }\n    getOption(name) {\n        return this.currentDataManager.currentCalendarOptionsInput[name];\n    }\n    getAvailableLocaleCodes() {\n        return Object.keys(this.getCurrentData().availableRawLocales);\n    }\n    // Trigger\n    // -----------------------------------------------------------------------------------------------------------------\n    on(handlerName, handler) {\n        let { currentDataManager } = this;\n        if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {\n            currentDataManager.emitter.on(handlerName, handler);\n        } else {\n            console.warn(`Unknown listener name '${handlerName}'`);\n        }\n    }\n    off(handlerName, handler) {\n        this.currentDataManager.emitter.off(handlerName, handler);\n    }\n    // not meant for public use\n    trigger(handlerName, ...args) {\n        this.currentDataManager.emitter.trigger(handlerName, ...args);\n    }\n    // View\n    // -----------------------------------------------------------------------------------------------------------------\n    changeView(viewType, dateOrRange) {\n        this.batchRendering(()=>{\n            this.unselect();\n            if (dateOrRange) {\n                if (dateOrRange.start && dateOrRange.end) {\n                    this.dispatch({\n                        type: \"CHANGE_VIEW_TYPE\",\n                        viewType\n                    });\n                    this.dispatch({\n                        type: \"SET_OPTION\",\n                        optionName: \"visibleRange\",\n                        rawOptionValue: dateOrRange\n                    });\n                } else {\n                    let { dateEnv } = this.getCurrentData();\n                    this.dispatch({\n                        type: \"CHANGE_VIEW_TYPE\",\n                        viewType,\n                        dateMarker: dateEnv.createMarker(dateOrRange)\n                    });\n                }\n            } else {\n                this.dispatch({\n                    type: \"CHANGE_VIEW_TYPE\",\n                    viewType\n                });\n            }\n        });\n    }\n    // Forces navigation to a view for the given date.\n    // `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\n    // needs to change\n    zoomTo(dateMarker, viewType) {\n        let state = this.getCurrentData();\n        let spec;\n        viewType = viewType || \"day\"; // day is default zoom\n        spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);\n        this.unselect();\n        if (spec) {\n            this.dispatch({\n                type: \"CHANGE_VIEW_TYPE\",\n                viewType: spec.type,\n                dateMarker\n            });\n        } else {\n            this.dispatch({\n                type: \"CHANGE_DATE\",\n                dateMarker\n            });\n        }\n    }\n    // Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\n    // Preference is given to views that have corresponding buttons.\n    getUnitViewSpec(unit) {\n        let { viewSpecs, toolbarConfig } = this.getCurrentData();\n        let viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);\n        let i;\n        let spec;\n        for(let viewType in viewSpecs){\n            viewTypes.push(viewType);\n        }\n        for(i = 0; i < viewTypes.length; i += 1){\n            spec = viewSpecs[viewTypes[i]];\n            if (spec) {\n                if (spec.singleUnit === unit) {\n                    return spec;\n                }\n            }\n        }\n        return null;\n    }\n    // Current Date\n    // -----------------------------------------------------------------------------------------------------------------\n    prev() {\n        this.unselect();\n        this.dispatch({\n            type: \"PREV\"\n        });\n    }\n    next() {\n        this.unselect();\n        this.dispatch({\n            type: \"NEXT\"\n        });\n    }\n    prevYear() {\n        let state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: state.dateEnv.addYears(state.currentDate, -1)\n        });\n    }\n    nextYear() {\n        let state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: state.dateEnv.addYears(state.currentDate, 1)\n        });\n    }\n    today() {\n        let state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: getNow(state.calendarOptions.now, state.dateEnv)\n        });\n    }\n    gotoDate(zonedDateInput) {\n        let state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: state.dateEnv.createMarker(zonedDateInput)\n        });\n    }\n    incrementDate(deltaInput) {\n        let state = this.getCurrentData();\n        let delta = createDuration(deltaInput);\n        if (delta) {\n            this.unselect();\n            this.dispatch({\n                type: \"CHANGE_DATE\",\n                dateMarker: state.dateEnv.add(state.currentDate, delta)\n            });\n        }\n    }\n    getDate() {\n        let state = this.getCurrentData();\n        return state.dateEnv.toDate(state.currentDate);\n    }\n    // Date Formatting Utils\n    // -----------------------------------------------------------------------------------------------------------------\n    formatDate(d, formatter) {\n        let { dateEnv } = this.getCurrentData();\n        return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));\n    }\n    // `settings` is for formatter AND isEndExclusive\n    formatRange(d0, d1, settings) {\n        let { dateEnv } = this.getCurrentData();\n        return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);\n    }\n    formatIso(d, omitTime) {\n        let { dateEnv } = this.getCurrentData();\n        return dateEnv.formatIso(dateEnv.createMarker(d), {\n            omitTime\n        });\n    }\n    // Date Selection / Event Selection / DayClick\n    // -----------------------------------------------------------------------------------------------------------------\n    select(dateOrObj, endDate) {\n        let selectionInput;\n        if (endDate == null) {\n            if (dateOrObj.start != null) {\n                selectionInput = dateOrObj;\n            } else {\n                selectionInput = {\n                    start: dateOrObj,\n                    end: null\n                };\n            }\n        } else {\n            selectionInput = {\n                start: dateOrObj,\n                end: endDate\n            };\n        }\n        let state = this.getCurrentData();\n        let selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({\n            days: 1\n        }));\n        if (selection) {\n            this.dispatch({\n                type: \"SELECT_DATES\",\n                selection\n            });\n            triggerDateSelect(selection, null, state);\n        }\n    }\n    unselect(pev) {\n        let state = this.getCurrentData();\n        if (state.dateSelection) {\n            this.dispatch({\n                type: \"UNSELECT_DATES\"\n            });\n            triggerDateUnselect(pev, state);\n        }\n    }\n    // Public Events API\n    // -----------------------------------------------------------------------------------------------------------------\n    addEvent(eventInput, sourceInput) {\n        if (eventInput instanceof EventImpl) {\n            let def = eventInput._def;\n            let instance = eventInput._instance;\n            let currentData = this.getCurrentData();\n            // not already present? don't want to add an old snapshot\n            if (!currentData.eventStore.defs[def.defId]) {\n                this.dispatch({\n                    type: \"ADD_EVENTS\",\n                    eventStore: eventTupleToStore({\n                        def,\n                        instance\n                    })\n                });\n                this.triggerEventAdd(eventInput);\n            }\n            return eventInput;\n        }\n        let state = this.getCurrentData();\n        let eventSource;\n        if (sourceInput instanceof EventSourceImpl) {\n            eventSource = sourceInput.internalEventSource;\n        } else if (typeof sourceInput === \"boolean\") {\n            if (sourceInput) {\n                [eventSource] = hashValuesToArray(state.eventSources);\n            }\n        } else if (sourceInput != null) {\n            let sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function\n            if (!sourceApi) {\n                console.warn(`Could not find an event source with ID \"${sourceInput}\"`); // TODO: test\n                return null;\n            }\n            eventSource = sourceApi.internalEventSource;\n        }\n        let tuple = parseEvent(eventInput, eventSource, state, false);\n        if (tuple) {\n            let newEventApi = new EventImpl(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);\n            this.dispatch({\n                type: \"ADD_EVENTS\",\n                eventStore: eventTupleToStore(tuple)\n            });\n            this.triggerEventAdd(newEventApi);\n            return newEventApi;\n        }\n        return null;\n    }\n    triggerEventAdd(eventApi) {\n        let { emitter } = this.getCurrentData();\n        emitter.trigger(\"eventAdd\", {\n            event: eventApi,\n            relatedEvents: [],\n            revert: ()=>{\n                this.dispatch({\n                    type: \"REMOVE_EVENTS\",\n                    eventStore: eventApiToStore(eventApi)\n                });\n            }\n        });\n    }\n    // TODO: optimize\n    getEventById(id) {\n        let state = this.getCurrentData();\n        let { defs, instances } = state.eventStore;\n        id = String(id);\n        for(let defId in defs){\n            let def = defs[defId];\n            if (def.publicId === id) {\n                if (def.recurringDef) {\n                    return new EventImpl(state, def, null);\n                }\n                for(let instanceId in instances){\n                    let instance = instances[instanceId];\n                    if (instance.defId === def.defId) {\n                        return new EventImpl(state, def, instance);\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    getEvents() {\n        let currentData = this.getCurrentData();\n        return buildEventApis(currentData.eventStore, currentData);\n    }\n    removeAllEvents() {\n        this.dispatch({\n            type: \"REMOVE_ALL_EVENTS\"\n        });\n    }\n    // Public Event Sources API\n    // -----------------------------------------------------------------------------------------------------------------\n    getEventSources() {\n        let state = this.getCurrentData();\n        let sourceHash = state.eventSources;\n        let sourceApis = [];\n        for(let internalId in sourceHash){\n            sourceApis.push(new EventSourceImpl(state, sourceHash[internalId]));\n        }\n        return sourceApis;\n    }\n    getEventSourceById(id) {\n        let state = this.getCurrentData();\n        let sourceHash = state.eventSources;\n        id = String(id);\n        for(let sourceId in sourceHash){\n            if (sourceHash[sourceId].publicId === id) {\n                return new EventSourceImpl(state, sourceHash[sourceId]);\n            }\n        }\n        return null;\n    }\n    addEventSource(sourceInput) {\n        let state = this.getCurrentData();\n        if (sourceInput instanceof EventSourceImpl) {\n            // not already present? don't want to add an old snapshot\n            if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {\n                this.dispatch({\n                    type: \"ADD_EVENT_SOURCES\",\n                    sources: [\n                        sourceInput.internalEventSource\n                    ]\n                });\n            }\n            return sourceInput;\n        }\n        let eventSource = parseEventSource(sourceInput, state);\n        if (eventSource) {\n            this.dispatch({\n                type: \"ADD_EVENT_SOURCES\",\n                sources: [\n                    eventSource\n                ]\n            });\n            return new EventSourceImpl(state, eventSource);\n        }\n        return null;\n    }\n    removeAllEventSources() {\n        this.dispatch({\n            type: \"REMOVE_ALL_EVENT_SOURCES\"\n        });\n    }\n    refetchEvents() {\n        this.dispatch({\n            type: \"FETCH_EVENT_SOURCES\",\n            isRefetch: true\n        });\n    }\n    // Scroll\n    // -----------------------------------------------------------------------------------------------------------------\n    scrollToTime(timeInput) {\n        let time = createDuration(timeInput);\n        if (time) {\n            this.trigger(\"_scrollRequest\", {\n                time\n            });\n        }\n    }\n}\nfunction pointInsideRect(point, rect) {\n    return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;\n}\n// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\nfunction intersectRects(rect1, rect2) {\n    let res = {\n        left: Math.max(rect1.left, rect2.left),\n        right: Math.min(rect1.right, rect2.right),\n        top: Math.max(rect1.top, rect2.top),\n        bottom: Math.min(rect1.bottom, rect2.bottom)\n    };\n    if (res.left < res.right && res.top < res.bottom) {\n        return res;\n    }\n    return false;\n}\nfunction translateRect(rect, deltaX, deltaY) {\n    return {\n        left: rect.left + deltaX,\n        right: rect.right + deltaX,\n        top: rect.top + deltaY,\n        bottom: rect.bottom + deltaY\n    };\n}\n// Returns a new point that will have been moved to reside within the given rectangle\nfunction constrainPoint(point, rect) {\n    return {\n        left: Math.min(Math.max(point.left, rect.left), rect.right),\n        top: Math.min(Math.max(point.top, rect.top), rect.bottom)\n    };\n}\n// Returns a point that is the center of the given rectangle\nfunction getRectCenter(rect) {\n    return {\n        left: (rect.left + rect.right) / 2,\n        top: (rect.top + rect.bottom) / 2\n    };\n}\n// Subtracts point2's coordinates from point1's coordinates, returning a delta\nfunction diffPoints(point1, point2) {\n    return {\n        left: point1.left - point2.left,\n        top: point1.top - point2.top\n    };\n}\nconst EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere\nclass Splitter {\n    constructor(){\n        this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);\n        this.splitDateSelection = memoize(this._splitDateSpan);\n        this.splitEventStore = memoize(this._splitEventStore);\n        this.splitIndividualUi = memoize(this._splitIndividualUi);\n        this.splitEventDrag = memoize(this._splitInteraction);\n        this.splitEventResize = memoize(this._splitInteraction);\n        this.eventUiBuilders = {}; // TODO: typescript protection\n    }\n    splitProps(props) {\n        let keyInfos = this.getKeyInfo(props);\n        let defKeys = this.getKeysForEventDefs(props.eventStore);\n        let dateSelections = this.splitDateSelection(props.dateSelection);\n        let individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*\n        let eventStores = this.splitEventStore(props.eventStore, defKeys);\n        let eventDrags = this.splitEventDrag(props.eventDrag);\n        let eventResizes = this.splitEventResize(props.eventResize);\n        let splitProps = {};\n        this.eventUiBuilders = mapHash(keyInfos, (info, key)=>this.eventUiBuilders[key] || memoize(buildEventUiForKey));\n        for(let key in keyInfos){\n            let keyInfo = keyInfos[key];\n            let eventStore = eventStores[key] || EMPTY_EVENT_STORE;\n            let buildEventUi = this.eventUiBuilders[key];\n            splitProps[key] = {\n                businessHours: keyInfo.businessHours || props.businessHours,\n                dateSelection: dateSelections[key] || null,\n                eventStore,\n                eventUiBases: buildEventUi(props.eventUiBases[\"\"], keyInfo.ui, individualUi[key]),\n                eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : \"\",\n                eventDrag: eventDrags[key] || null,\n                eventResize: eventResizes[key] || null\n            };\n        }\n        return splitProps;\n    }\n    _splitDateSpan(dateSpan) {\n        let dateSpans = {};\n        if (dateSpan) {\n            let keys = this.getKeysForDateSpan(dateSpan);\n            for (let key of keys){\n                dateSpans[key] = dateSpan;\n            }\n        }\n        return dateSpans;\n    }\n    _getKeysForEventDefs(eventStore) {\n        return mapHash(eventStore.defs, (eventDef)=>this.getKeysForEventDef(eventDef));\n    }\n    _splitEventStore(eventStore, defKeys) {\n        let { defs, instances } = eventStore;\n        let splitStores = {};\n        for(let defId in defs){\n            for (let key of defKeys[defId]){\n                if (!splitStores[key]) {\n                    splitStores[key] = createEmptyEventStore();\n                }\n                splitStores[key].defs[defId] = defs[defId];\n            }\n        }\n        for(let instanceId in instances){\n            let instance = instances[instanceId];\n            for (let key of defKeys[instance.defId]){\n                if (splitStores[key]) {\n                    splitStores[key].instances[instanceId] = instance;\n                }\n            }\n        }\n        return splitStores;\n    }\n    _splitIndividualUi(eventUiBases, defKeys) {\n        let splitHashes = {};\n        for(let defId in eventUiBases){\n            if (defId) {\n                for (let key of defKeys[defId]){\n                    if (!splitHashes[key]) {\n                        splitHashes[key] = {};\n                    }\n                    splitHashes[key][defId] = eventUiBases[defId];\n                }\n            }\n        }\n        return splitHashes;\n    }\n    _splitInteraction(interaction) {\n        let splitStates = {};\n        if (interaction) {\n            let affectedStores = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents));\n            // can't rely on defKeys because event data is mutated\n            let mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);\n            let mutatedStores = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);\n            let populate = (key)=>{\n                if (!splitStates[key]) {\n                    splitStates[key] = {\n                        affectedEvents: affectedStores[key] || EMPTY_EVENT_STORE,\n                        mutatedEvents: mutatedStores[key] || EMPTY_EVENT_STORE,\n                        isEvent: interaction.isEvent\n                    };\n                }\n            };\n            for(let key in affectedStores){\n                populate(key);\n            }\n            for(let key in mutatedStores){\n                populate(key);\n            }\n        }\n        return splitStates;\n    }\n}\nfunction buildEventUiForKey(allUi, eventUiForKey, individualUi) {\n    let baseParts = [];\n    if (allUi) {\n        baseParts.push(allUi);\n    }\n    if (eventUiForKey) {\n        baseParts.push(eventUiForKey);\n    }\n    let stuff = {\n        \"\": combineEventUis(baseParts)\n    };\n    if (individualUi) {\n        Object.assign(stuff, individualUi);\n    }\n    return stuff;\n}\nfunction getDateMeta(date, todayRange, nowDate, dateProfile) {\n    return {\n        dow: date.getUTCDay(),\n        isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),\n        isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),\n        isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),\n        isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),\n        isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)\n    };\n}\nfunction getDayClassNames(meta, theme) {\n    let classNames = [\n        \"fc-day\",\n        `fc-day-${DAY_IDS[meta.dow]}`\n    ];\n    if (meta.isDisabled) {\n        classNames.push(\"fc-day-disabled\");\n    } else {\n        if (meta.isToday) {\n            classNames.push(\"fc-day-today\");\n            classNames.push(theme.getClass(\"today\"));\n        }\n        if (meta.isPast) {\n            classNames.push(\"fc-day-past\");\n        }\n        if (meta.isFuture) {\n            classNames.push(\"fc-day-future\");\n        }\n        if (meta.isOther) {\n            classNames.push(\"fc-day-other\");\n        }\n    }\n    return classNames;\n}\nfunction getSlotClassNames(meta, theme) {\n    let classNames = [\n        \"fc-slot\",\n        `fc-slot-${DAY_IDS[meta.dow]}`\n    ];\n    if (meta.isDisabled) {\n        classNames.push(\"fc-slot-disabled\");\n    } else {\n        if (meta.isToday) {\n            classNames.push(\"fc-slot-today\");\n            classNames.push(theme.getClass(\"today\"));\n        }\n        if (meta.isPast) {\n            classNames.push(\"fc-slot-past\");\n        }\n        if (meta.isFuture) {\n            classNames.push(\"fc-slot-future\");\n        }\n    }\n    return classNames;\n}\nconst DAY_FORMAT = createFormatter({\n    year: \"numeric\",\n    month: \"long\",\n    day: \"numeric\"\n});\nconst WEEK_FORMAT = createFormatter({\n    week: \"long\"\n});\nfunction buildNavLinkAttrs(context, dateMarker, viewType = \"day\", isTabbable = true) {\n    const { dateEnv, options, calendarApi } = context;\n    let dateStr = dateEnv.format(dateMarker, viewType === \"week\" ? WEEK_FORMAT : DAY_FORMAT);\n    if (options.navLinks) {\n        let zonedDate = dateEnv.toDate(dateMarker);\n        const handleInteraction = (ev)=>{\n            let customAction = viewType === \"day\" ? options.navLinkDayClick : viewType === \"week\" ? options.navLinkWeekClick : null;\n            if (typeof customAction === \"function\") {\n                customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);\n            } else {\n                if (typeof customAction === \"string\") {\n                    viewType = customAction;\n                }\n                calendarApi.zoomTo(dateMarker, viewType);\n            }\n        };\n        return Object.assign({\n            title: formatWithOrdinals(options.navLinkHint, [\n                dateStr,\n                zonedDate\n            ], dateStr),\n            \"data-navlink\": \"\"\n        }, isTabbable ? createAriaClickAttrs(handleInteraction) : {\n            onClick: handleInteraction\n        });\n    }\n    return {\n        \"aria-label\": dateStr\n    };\n}\nlet _isRtlScrollbarOnLeft = null;\nfunction getIsRtlScrollbarOnLeft() {\n    if (_isRtlScrollbarOnLeft === null) {\n        _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();\n    }\n    return _isRtlScrollbarOnLeft;\n}\nfunction computeIsRtlScrollbarOnLeft() {\n    let outerEl = document.createElement(\"div\");\n    applyStyle(outerEl, {\n        position: \"absolute\",\n        top: -1000,\n        left: 0,\n        border: 0,\n        padding: 0,\n        overflow: \"scroll\",\n        direction: \"rtl\"\n    });\n    outerEl.innerHTML = \"<div></div>\";\n    document.body.appendChild(outerEl);\n    let innerEl = outerEl.firstChild;\n    let res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;\n    removeElement(outerEl);\n    return res;\n}\nlet _scrollbarWidths;\nfunction getScrollbarWidths() {\n    if (!_scrollbarWidths) {\n        _scrollbarWidths = computeScrollbarWidths();\n    }\n    return _scrollbarWidths;\n}\nfunction computeScrollbarWidths() {\n    let el = document.createElement(\"div\");\n    el.style.overflow = \"scroll\";\n    el.style.position = \"absolute\";\n    el.style.top = \"-9999px\";\n    el.style.left = \"-9999px\";\n    document.body.appendChild(el);\n    let res = computeScrollbarWidthsForEl(el);\n    document.body.removeChild(el);\n    return res;\n}\n// WARNING: will include border\nfunction computeScrollbarWidthsForEl(el) {\n    return {\n        x: el.offsetHeight - el.clientHeight,\n        y: el.offsetWidth - el.clientWidth\n    };\n}\nfunction computeEdges(el, getPadding = false) {\n    let computedStyle = window.getComputedStyle(el);\n    let borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;\n    let borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;\n    let borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;\n    let borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;\n    let badScrollbarWidths = computeScrollbarWidthsForEl(el); // includes border!\n    let scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;\n    let scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;\n    let res = {\n        borderLeft,\n        borderRight,\n        borderTop,\n        borderBottom,\n        scrollbarBottom,\n        scrollbarLeft: 0,\n        scrollbarRight: 0\n    };\n    if (getIsRtlScrollbarOnLeft() && computedStyle.direction === \"rtl\") {\n        res.scrollbarLeft = scrollbarLeftRight;\n    } else {\n        res.scrollbarRight = scrollbarLeftRight;\n    }\n    if (getPadding) {\n        res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;\n        res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;\n        res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;\n        res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;\n    }\n    return res;\n}\nfunction computeInnerRect(el, goWithinPadding = false, doFromWindowViewport) {\n    let outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);\n    let edges = computeEdges(el, goWithinPadding);\n    let res = {\n        left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,\n        right: outerRect.right - edges.borderRight - edges.scrollbarRight,\n        top: outerRect.top + edges.borderTop,\n        bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom\n    };\n    if (goWithinPadding) {\n        res.left += edges.paddingLeft;\n        res.right -= edges.paddingRight;\n        res.top += edges.paddingTop;\n        res.bottom -= edges.paddingBottom;\n    }\n    return res;\n}\nfunction computeRect(el) {\n    let rect = el.getBoundingClientRect();\n    return {\n        left: rect.left + window.pageXOffset,\n        top: rect.top + window.pageYOffset,\n        right: rect.right + window.pageXOffset,\n        bottom: rect.bottom + window.pageYOffset\n    };\n}\nfunction computeClippedClientRect(el) {\n    let clippingParents = getClippingParents(el);\n    let rect = el.getBoundingClientRect();\n    for (let clippingParent of clippingParents){\n        let intersection = intersectRects(rect, clippingParent.getBoundingClientRect());\n        if (intersection) {\n            rect = intersection;\n        } else {\n            return null;\n        }\n    }\n    return rect;\n}\n// does not return window\nfunction getClippingParents(el) {\n    let parents = [];\n    while(el instanceof HTMLElement){\n        let computedStyle = window.getComputedStyle(el);\n        if (computedStyle.position === \"fixed\") {\n            break;\n        }\n        if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {\n            parents.push(el);\n        }\n        el = el.parentNode;\n    }\n    return parents;\n}\n/*\nRecords offset information for a set of elements, relative to an origin element.\nCan record the left/right OR the top/bottom OR both.\nProvides methods for querying the cache by position.\n*/ class PositionCache {\n    constructor(originEl, els, isHorizontal, isVertical){\n        this.els = els;\n        let originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left\n        if (isHorizontal) {\n            this.buildElHorizontals(originClientRect.left);\n        }\n        if (isVertical) {\n            this.buildElVerticals(originClientRect.top);\n        }\n    }\n    // Populates the left/right internal coordinate arrays\n    buildElHorizontals(originClientLeft) {\n        let lefts = [];\n        let rights = [];\n        for (let el of this.els){\n            let rect = el.getBoundingClientRect();\n            lefts.push(rect.left - originClientLeft);\n            rights.push(rect.right - originClientLeft);\n        }\n        this.lefts = lefts;\n        this.rights = rights;\n    }\n    // Populates the top/bottom internal coordinate arrays\n    buildElVerticals(originClientTop) {\n        let tops = [];\n        let bottoms = [];\n        for (let el of this.els){\n            let rect = el.getBoundingClientRect();\n            tops.push(rect.top - originClientTop);\n            bottoms.push(rect.bottom - originClientTop);\n        }\n        this.tops = tops;\n        this.bottoms = bottoms;\n    }\n    // Given a left offset (from document left), returns the index of the el that it horizontally intersects.\n    // If no intersection is made, returns undefined.\n    leftToIndex(leftPosition) {\n        let { lefts, rights } = this;\n        let len = lefts.length;\n        let i;\n        for(i = 0; i < len; i += 1){\n            if (leftPosition >= lefts[i] && leftPosition < rights[i]) {\n                return i;\n            }\n        }\n        return undefined; // TODO: better\n    }\n    // Given a top offset (from document top), returns the index of the el that it vertically intersects.\n    // If no intersection is made, returns undefined.\n    topToIndex(topPosition) {\n        let { tops, bottoms } = this;\n        let len = tops.length;\n        let i;\n        for(i = 0; i < len; i += 1){\n            if (topPosition >= tops[i] && topPosition < bottoms[i]) {\n                return i;\n            }\n        }\n        return undefined; // TODO: better\n    }\n    // Gets the width of the element at the given index\n    getWidth(leftIndex) {\n        return this.rights[leftIndex] - this.lefts[leftIndex];\n    }\n    // Gets the height of the element at the given index\n    getHeight(topIndex) {\n        return this.bottoms[topIndex] - this.tops[topIndex];\n    }\n    similarTo(otherCache) {\n        return similarNumArrays(this.tops || [], otherCache.tops || []) && similarNumArrays(this.bottoms || [], otherCache.bottoms || []) && similarNumArrays(this.lefts || [], otherCache.lefts || []) && similarNumArrays(this.rights || [], otherCache.rights || []);\n    }\n}\nfunction similarNumArrays(a, b) {\n    const len = a.length;\n    if (len !== b.length) {\n        return false;\n    }\n    for(let i = 0; i < len; i++){\n        if (Math.round(a[i]) !== Math.round(b[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/* eslint max-classes-per-file: \"off\" */ /*\nAn object for getting/setting scroll-related information for an element.\nInternally, this is done very differently for window versus DOM element,\nso this object serves as a common interface.\n*/ class ScrollController {\n    getMaxScrollTop() {\n        return this.getScrollHeight() - this.getClientHeight();\n    }\n    getMaxScrollLeft() {\n        return this.getScrollWidth() - this.getClientWidth();\n    }\n    canScrollVertically() {\n        return this.getMaxScrollTop() > 0;\n    }\n    canScrollHorizontally() {\n        return this.getMaxScrollLeft() > 0;\n    }\n    canScrollUp() {\n        return this.getScrollTop() > 0;\n    }\n    canScrollDown() {\n        return this.getScrollTop() < this.getMaxScrollTop();\n    }\n    canScrollLeft() {\n        return this.getScrollLeft() > 0;\n    }\n    canScrollRight() {\n        return this.getScrollLeft() < this.getMaxScrollLeft();\n    }\n}\nclass ElementScrollController extends ScrollController {\n    constructor(el){\n        super();\n        this.el = el;\n    }\n    getScrollTop() {\n        return this.el.scrollTop;\n    }\n    getScrollLeft() {\n        return this.el.scrollLeft;\n    }\n    setScrollTop(top) {\n        this.el.scrollTop = top;\n    }\n    setScrollLeft(left) {\n        this.el.scrollLeft = left;\n    }\n    getScrollWidth() {\n        return this.el.scrollWidth;\n    }\n    getScrollHeight() {\n        return this.el.scrollHeight;\n    }\n    getClientHeight() {\n        return this.el.clientHeight;\n    }\n    getClientWidth() {\n        return this.el.clientWidth;\n    }\n}\nclass WindowScrollController extends ScrollController {\n    getScrollTop() {\n        return window.pageYOffset;\n    }\n    getScrollLeft() {\n        return window.pageXOffset;\n    }\n    setScrollTop(n) {\n        window.scroll(window.pageXOffset, n);\n    }\n    setScrollLeft(n) {\n        window.scroll(n, window.pageYOffset);\n    }\n    getScrollWidth() {\n        return document.documentElement.scrollWidth;\n    }\n    getScrollHeight() {\n        return document.documentElement.scrollHeight;\n    }\n    getClientHeight() {\n        return document.documentElement.clientHeight;\n    }\n    getClientWidth() {\n        return document.documentElement.clientWidth;\n    }\n}\n/*\nan INTERACTABLE date component\n\nPURPOSES:\n- hook up to fg, fill, and mirror renderers\n- interface for dragging and hits\n*/ class DateComponent extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.uid = guid();\n    }\n    // Hit System\n    // -----------------------------------------------------------------------------------------------------------------\n    prepareHits() {}\n    queryHit(positionLeft, positionTop, elWidth, elHeight) {\n        return null; // this should be abstract\n    }\n    // Pointer Interaction Utils\n    // -----------------------------------------------------------------------------------------------------------------\n    isValidSegDownEl(el) {\n        return !this.props.eventDrag && // HACK\n        !this.props.eventResize && // HACK\n        !elementClosest(el, \".fc-event-mirror\");\n    }\n    isValidDateDownEl(el) {\n        return !elementClosest(el, \".fc-event:not(.fc-bg-event)\") && !elementClosest(el, \".fc-more-link\") && // a \"more..\" link\n        !elementClosest(el, \"a[data-navlink]\") && // a clickable nav link\n        !elementClosest(el, \".fc-popover\"); // hack\n    }\n}\nclass NamedTimeZoneImpl {\n    constructor(timeZoneName){\n        this.timeZoneName = timeZoneName;\n    }\n}\nclass SegHierarchy {\n    constructor(getEntryThickness = (entry)=>{\n        // should return an integer\n        return entry.thickness;\n    }){\n        this.getEntryThickness = getEntryThickness;\n        // settings\n        this.strictOrder = false;\n        this.allowReslicing = false;\n        this.maxCoord = -1; // -1 means no max\n        this.maxStackCnt = -1; // -1 means no max\n        this.levelCoords = []; // ordered\n        this.entriesByLevel = []; // parallel with levelCoords\n        this.stackCnts = {}; // TODO: use better technique!?\n    }\n    addSegs(inputs) {\n        let hiddenEntries = [];\n        for (let input of inputs){\n            this.insertEntry(input, hiddenEntries);\n        }\n        return hiddenEntries;\n    }\n    insertEntry(entry, hiddenEntries) {\n        let insertion = this.findInsertion(entry);\n        if (this.isInsertionValid(insertion, entry)) {\n            this.insertEntryAt(entry, insertion);\n            return 1;\n        }\n        return this.handleInvalidInsertion(insertion, entry, hiddenEntries);\n    }\n    isInsertionValid(insertion, entry) {\n        return (this.maxCoord === -1 || insertion.levelCoord + this.getEntryThickness(entry) <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);\n    }\n    // returns number of new entries inserted\n    handleInvalidInsertion(insertion, entry, hiddenEntries) {\n        if (this.allowReslicing && insertion.touchingEntry) {\n            return this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);\n        }\n        hiddenEntries.push(entry);\n        return 0;\n    }\n    splitEntry(entry, barrier, hiddenEntries) {\n        let partCnt = 0;\n        let splitHiddenEntries = [];\n        let entrySpan = entry.span;\n        let barrierSpan = barrier.span;\n        if (entrySpan.start < barrierSpan.start) {\n            partCnt += this.insertEntry({\n                index: entry.index,\n                thickness: entry.thickness,\n                span: {\n                    start: entrySpan.start,\n                    end: barrierSpan.start\n                }\n            }, splitHiddenEntries);\n        }\n        if (entrySpan.end > barrierSpan.end) {\n            partCnt += this.insertEntry({\n                index: entry.index,\n                thickness: entry.thickness,\n                span: {\n                    start: barrierSpan.end,\n                    end: entrySpan.end\n                }\n            }, splitHiddenEntries);\n        }\n        if (partCnt) {\n            hiddenEntries.push({\n                index: entry.index,\n                thickness: entry.thickness,\n                span: intersectSpans(barrierSpan, entrySpan)\n            }, ...splitHiddenEntries);\n            return partCnt;\n        }\n        hiddenEntries.push(entry);\n        return 0;\n    }\n    insertEntryAt(entry, insertion) {\n        let { entriesByLevel, levelCoords } = this;\n        if (insertion.lateral === -1) {\n            // create a new level\n            insertAt(levelCoords, insertion.level, insertion.levelCoord);\n            insertAt(entriesByLevel, insertion.level, [\n                entry\n            ]);\n        } else {\n            // insert into existing level\n            insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);\n        }\n        this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;\n    }\n    findInsertion(newEntry) {\n        let { levelCoords, entriesByLevel, strictOrder, stackCnts } = this;\n        let levelCnt = levelCoords.length;\n        let candidateCoord = 0;\n        let touchingLevel = -1;\n        let touchingLateral = -1;\n        let touchingEntry = null;\n        let stackCnt = 0;\n        for(let trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1){\n            let trackingCoord = levelCoords[trackingLevel];\n            // if the current level is past the placed entry, we have found a good empty space and can stop.\n            // if strictOrder, keep finding more lateral intersections.\n            if (!strictOrder && trackingCoord >= candidateCoord + this.getEntryThickness(newEntry)) {\n                break;\n            }\n            let trackingEntries = entriesByLevel[trackingLevel];\n            let trackingEntry;\n            let searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd); // find first entry after newEntry's end\n            let lateralIndex = searchRes[0] + searchRes[1]; // if exact match (which doesn't collide), go to next one\n            while((trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list\n            trackingEntry.span.start < newEntry.span.end // and not entirely past newEntry\n            ){\n                let trackingEntryBottom = trackingCoord + this.getEntryThickness(trackingEntry);\n                // intersects into the top of the candidate?\n                if (trackingEntryBottom > candidateCoord) {\n                    candidateCoord = trackingEntryBottom;\n                    touchingEntry = trackingEntry;\n                    touchingLevel = trackingLevel;\n                    touchingLateral = lateralIndex;\n                }\n                // butts up against top of candidate? (will happen if just intersected as well)\n                if (trackingEntryBottom === candidateCoord) {\n                    // accumulate the highest possible stackCnt of the trackingEntries that butt up\n                    stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);\n                }\n                lateralIndex += 1;\n            }\n        }\n        // the destination level will be after touchingEntry's level. find it\n        let destLevel = 0;\n        if (touchingEntry) {\n            destLevel = touchingLevel + 1;\n            while(destLevel < levelCnt && levelCoords[destLevel] < candidateCoord){\n                destLevel += 1;\n            }\n        }\n        // if adding to an existing level, find where to insert\n        let destLateral = -1;\n        if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {\n            destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];\n        }\n        return {\n            touchingLevel,\n            touchingLateral,\n            touchingEntry,\n            stackCnt,\n            levelCoord: candidateCoord,\n            level: destLevel,\n            lateral: destLateral\n        };\n    }\n    // sorted by levelCoord (lowest to highest)\n    toRects() {\n        let { entriesByLevel, levelCoords } = this;\n        let levelCnt = entriesByLevel.length;\n        let rects = [];\n        for(let level = 0; level < levelCnt; level += 1){\n            let entries = entriesByLevel[level];\n            let levelCoord = levelCoords[level];\n            for (let entry of entries){\n                rects.push(Object.assign(Object.assign({}, entry), {\n                    thickness: this.getEntryThickness(entry),\n                    levelCoord\n                }));\n            }\n        }\n        return rects;\n    }\n}\nfunction getEntrySpanEnd(entry) {\n    return entry.span.end;\n}\nfunction buildEntryKey(entry) {\n    return entry.index + \":\" + entry.span.start;\n}\n// returns groups with entries sorted by input order\nfunction groupIntersectingEntries(entries) {\n    let merges = [];\n    for (let entry of entries){\n        let filteredMerges = [];\n        let hungryMerge = {\n            span: entry.span,\n            entries: [\n                entry\n            ]\n        };\n        for (let merge of merges){\n            if (intersectSpans(merge.span, hungryMerge.span)) {\n                hungryMerge = {\n                    entries: merge.entries.concat(hungryMerge.entries),\n                    span: joinSpans(merge.span, hungryMerge.span)\n                };\n            } else {\n                filteredMerges.push(merge);\n            }\n        }\n        filteredMerges.push(hungryMerge);\n        merges = filteredMerges;\n    }\n    return merges;\n}\nfunction joinSpans(span0, span1) {\n    return {\n        start: Math.min(span0.start, span1.start),\n        end: Math.max(span0.end, span1.end)\n    };\n}\nfunction intersectSpans(span0, span1) {\n    let start = Math.max(span0.start, span1.start);\n    let end = Math.min(span0.end, span1.end);\n    if (start < end) {\n        return {\n            start,\n            end\n        };\n    }\n    return null;\n}\n// general util\n// ---------------------------------------------------------------------------------------------------------------------\nfunction insertAt(arr, index, item) {\n    arr.splice(index, 0, item);\n}\nfunction binarySearch(a, searchVal, getItemVal) {\n    let startIndex = 0;\n    let endIndex = a.length; // exclusive\n    if (!endIndex || searchVal < getItemVal(a[startIndex])) {\n        return [\n            0,\n            0\n        ];\n    }\n    if (searchVal > getItemVal(a[endIndex - 1])) {\n        return [\n            endIndex,\n            0\n        ];\n    }\n    while(startIndex < endIndex){\n        let middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);\n        let middleVal = getItemVal(a[middleIndex]);\n        if (searchVal < middleVal) {\n            endIndex = middleIndex;\n        } else if (searchVal > middleVal) {\n            startIndex = middleIndex + 1;\n        } else {\n            return [\n                middleIndex,\n                1\n            ];\n        }\n    }\n    return [\n        startIndex,\n        0\n    ];\n}\n/*\nAn abstraction for a dragging interaction originating on an event.\nDoes higher-level things than PointerDragger, such as possibly:\n- a \"mirror\" that moves with the pointer\n- a minimum number of pixels or other criteria for a true drag to begin\n\nsubclasses must emit:\n- pointerdown\n- dragstart\n- dragmove\n- pointerup\n- dragend\n*/ class ElementDragging {\n    constructor(el, selector){\n        this.emitter = new Emitter();\n    }\n    destroy() {}\n    setMirrorIsVisible(bool) {\n    // optional if subclass doesn't want to support a mirror\n    }\n    setMirrorNeedsRevert(bool) {\n    // optional if subclass doesn't want to support a mirror\n    }\n    setAutoScrollEnabled(bool) {\n    // optional\n    }\n}\n// TODO: get rid of this in favor of options system,\n// tho it's really easy to access this globally rather than pass thru options.\nconst config = {};\n/*\nInformation about what will happen when an external element is dragged-and-dropped\nonto a calendar. Contains information for creating an event.\n*/ const DRAG_META_REFINERS = {\n    startTime: createDuration,\n    duration: createDuration,\n    create: Boolean,\n    sourceId: String\n};\nfunction parseDragMeta(raw) {\n    let { refined, extra } = refineProps(raw, DRAG_META_REFINERS);\n    return {\n        startTime: refined.startTime || null,\n        duration: refined.duration || null,\n        create: refined.create != null ? refined.create : true,\n        sourceId: refined.sourceId,\n        leftoverProps: extra\n    };\n}\n// Computes a default column header formatting string if `colFormat` is not explicitly defined\nfunction computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {\n    // if more than one week row, or if there are a lot of columns with not much space,\n    // put just the day numbers will be in each cell\n    if (!datesRepDistinctDays || dayCnt > 10) {\n        return createFormatter({\n            weekday: \"short\"\n        }); // \"Sat\"\n    }\n    if (dayCnt > 1) {\n        return createFormatter({\n            weekday: \"short\",\n            month: \"numeric\",\n            day: \"numeric\",\n            omitCommas: true\n        }); // \"Sat 11/12\"\n    }\n    return createFormatter({\n        weekday: \"long\"\n    }); // \"Saturday\"\n}\nconst CLASS_NAME = \"fc-col-header-cell\"; // do the cushion too? no\nfunction renderInner$1(renderProps) {\n    return renderProps.text;\n}\n// BAD name for this class now. used in the Header\nclass TableDateCell extends BaseComponent {\n    render() {\n        let { dateEnv, options, theme, viewApi } = this.context;\n        let { props } = this;\n        let { date, dateProfile } = props;\n        let dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);\n        let classNames = [\n            CLASS_NAME\n        ].concat(getDayClassNames(dayMeta, theme));\n        let text = dateEnv.format(date, props.dayHeaderFormat);\n        // if colCnt is 1, we are already in a day-view and don't need a navlink\n        let navLinkAttrs = !dayMeta.isDisabled && props.colCnt > 1 ? buildNavLinkAttrs(this.context, date) : {};\n        let renderProps = Object.assign(Object.assign(Object.assign({\n            date: dateEnv.toDate(date),\n            view: viewApi\n        }, props.extraRenderProps), {\n            text\n        }), dayMeta);\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, {\n            elTag: \"th\",\n            elClasses: classNames,\n            elAttrs: Object.assign({\n                role: \"columnheader\",\n                colSpan: props.colSpan,\n                \"data-date\": !dayMeta.isDisabled ? formatDayString(date) : undefined\n            }, props.extraDataAttrs),\n            renderProps: renderProps,\n            generatorName: \"dayHeaderContent\",\n            customGenerator: options.dayHeaderContent,\n            defaultGenerator: renderInner$1,\n            classNameGenerator: options.dayHeaderClassNames,\n            didMount: options.dayHeaderDidMount,\n            willUnmount: options.dayHeaderWillUnmount\n        }, (InnerContainer)=>(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n                className: \"fc-scrollgrid-sync-inner\"\n            }, !dayMeta.isDisabled && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(InnerContainer, {\n                elTag: \"a\",\n                elAttrs: navLinkAttrs,\n                elClasses: [\n                    \"fc-col-header-cell-cushion\",\n                    props.isSticky && \"fc-sticky\"\n                ]\n            })));\n    }\n}\nconst WEEKDAY_FORMAT = createFormatter({\n    weekday: \"long\"\n});\nclass TableDowCell extends BaseComponent {\n    render() {\n        let { props } = this;\n        let { dateEnv, theme, viewApi, options } = this.context;\n        let date = addDays(new Date(259200000), props.dow); // start with Sun, 04 Jan 1970 00:00:00 GMT\n        let dateMeta = {\n            dow: props.dow,\n            isDisabled: false,\n            isFuture: false,\n            isPast: false,\n            isToday: false,\n            isOther: false\n        };\n        let text = dateEnv.format(date, props.dayHeaderFormat);\n        let renderProps = Object.assign(Object.assign(Object.assign(Object.assign({\n            date\n        }, dateMeta), {\n            view: viewApi\n        }), props.extraRenderProps), {\n            text\n        });\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, {\n            elTag: \"th\",\n            elClasses: [\n                CLASS_NAME,\n                ...getDayClassNames(dateMeta, theme),\n                ...props.extraClassNames || []\n            ],\n            elAttrs: Object.assign({\n                role: \"columnheader\",\n                colSpan: props.colSpan\n            }, props.extraDataAttrs),\n            renderProps: renderProps,\n            generatorName: \"dayHeaderContent\",\n            customGenerator: options.dayHeaderContent,\n            defaultGenerator: renderInner$1,\n            classNameGenerator: options.dayHeaderClassNames,\n            didMount: options.dayHeaderDidMount,\n            willUnmount: options.dayHeaderWillUnmount\n        }, (InnerContent)=>(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n                className: \"fc-scrollgrid-sync-inner\"\n            }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(InnerContent, {\n                elTag: \"a\",\n                elClasses: [\n                    \"fc-col-header-cell-cushion\",\n                    props.isSticky && \"fc-sticky\"\n                ],\n                elAttrs: {\n                    \"aria-label\": dateEnv.format(date, WEEKDAY_FORMAT)\n                }\n            })));\n    }\n}\nclass NowTimer extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props, context){\n        super(props, context);\n        this.initialNowDate = getNow(context.options.now, context.dateEnv);\n        this.initialNowQueriedMs = new Date().valueOf();\n        this.state = this.computeTiming().currentState;\n    }\n    render() {\n        let { props, state } = this;\n        return props.children(state.nowDate, state.todayRange);\n    }\n    componentDidMount() {\n        this.setTimeout();\n    }\n    componentDidUpdate(prevProps) {\n        if (prevProps.unit !== this.props.unit) {\n            this.clearTimeout();\n            this.setTimeout();\n        }\n    }\n    componentWillUnmount() {\n        this.clearTimeout();\n    }\n    computeTiming() {\n        let { props, context } = this;\n        let unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);\n        let currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);\n        let nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));\n        let waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();\n        // there is a max setTimeout ms value (https://stackoverflow.com/a/3468650/96342)\n        // ensure no longer than a day\n        waitMs = Math.min(1000 * 60 * 60 * 24, waitMs);\n        return {\n            currentState: {\n                nowDate: currentUnitStart,\n                todayRange: buildDayRange(currentUnitStart)\n            },\n            nextState: {\n                nowDate: nextUnitStart,\n                todayRange: buildDayRange(nextUnitStart)\n            },\n            waitMs\n        };\n    }\n    setTimeout() {\n        let { nextState, waitMs } = this.computeTiming();\n        this.timeoutId = setTimeout(()=>{\n            this.setState(nextState, ()=>{\n                this.setTimeout();\n            });\n        }, waitMs);\n    }\n    clearTimeout() {\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n        }\n    }\n}\nNowTimer.contextType = ViewContextType;\nfunction buildDayRange(date) {\n    let start = startOfDay(date);\n    let end = addDays(start, 1);\n    return {\n        start,\n        end\n    };\n}\nclass DayHeader extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);\n    }\n    render() {\n        let { context } = this;\n        let { dates, dateProfile, datesRepDistinctDays, renderIntro } = this.props;\n        let dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(NowTimer, {\n            unit: \"day\"\n        }, (nowDate, todayRange)=>(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tr\", {\n                role: \"row\"\n            }, renderIntro && renderIntro(\"day\"), dates.map((date)=>datesRepDistinctDays ? (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(TableDateCell, {\n                    key: date.toISOString(),\n                    date: date,\n                    dateProfile: dateProfile,\n                    todayRange: todayRange,\n                    colCnt: dates.length,\n                    dayHeaderFormat: dayHeaderFormat\n                }) : (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(TableDowCell, {\n                    key: date.getUTCDay(),\n                    dow: date.getUTCDay(),\n                    dayHeaderFormat: dayHeaderFormat\n                }))));\n    }\n}\nfunction createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {\n    return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);\n}\nclass DaySeriesModel {\n    constructor(range, dateProfileGenerator){\n        let date = range.start;\n        let { end } = range;\n        let indices = [];\n        let dates = [];\n        let dayIndex = -1;\n        while(date < end){\n            if (dateProfileGenerator.isHiddenDay(date)) {\n                indices.push(dayIndex + 0.5); // mark that it's between indices\n            } else {\n                dayIndex += 1;\n                indices.push(dayIndex);\n                dates.push(date);\n            }\n            date = addDays(date, 1);\n        }\n        this.dates = dates;\n        this.indices = indices;\n        this.cnt = dates.length;\n    }\n    sliceRange(range) {\n        let firstIndex = this.getDateDayIndex(range.start); // inclusive first index\n        let lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index\n        let clippedFirstIndex = Math.max(0, firstIndex);\n        let clippedLastIndex = Math.min(this.cnt - 1, lastIndex);\n        // deal with in-between indices\n        clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell\n        clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell\n        if (clippedFirstIndex <= clippedLastIndex) {\n            return {\n                firstIndex: clippedFirstIndex,\n                lastIndex: clippedLastIndex,\n                isStart: firstIndex === clippedFirstIndex,\n                isEnd: lastIndex === clippedLastIndex\n            };\n        }\n        return null;\n    }\n    // Given a date, returns its chronolocial cell-index from the first cell of the grid.\n    // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\n    // If before the first offset, returns a negative number.\n    // If after the last offset, returns an offset past the last cell offset.\n    // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\n    getDateDayIndex(date) {\n        let { indices } = this;\n        let dayOffset = Math.floor(diffDays(this.dates[0], date));\n        if (dayOffset < 0) {\n            return indices[0] - 1;\n        }\n        if (dayOffset >= indices.length) {\n            return indices[indices.length - 1] + 1;\n        }\n        return indices[dayOffset];\n    }\n}\nclass DayTableModel {\n    constructor(daySeries, breakOnWeeks){\n        let { dates } = daySeries;\n        let daysPerRow;\n        let firstDay;\n        let rowCnt;\n        if (breakOnWeeks) {\n            // count columns until the day-of-week repeats\n            firstDay = dates[0].getUTCDay();\n            for(daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1){\n                if (dates[daysPerRow].getUTCDay() === firstDay) {\n                    break;\n                }\n            }\n            rowCnt = Math.ceil(dates.length / daysPerRow);\n        } else {\n            rowCnt = 1;\n            daysPerRow = dates.length;\n        }\n        this.rowCnt = rowCnt;\n        this.colCnt = daysPerRow;\n        this.daySeries = daySeries;\n        this.cells = this.buildCells();\n        this.headerDates = this.buildHeaderDates();\n    }\n    buildCells() {\n        let rows = [];\n        for(let row = 0; row < this.rowCnt; row += 1){\n            let cells = [];\n            for(let col = 0; col < this.colCnt; col += 1){\n                cells.push(this.buildCell(row, col));\n            }\n            rows.push(cells);\n        }\n        return rows;\n    }\n    buildCell(row, col) {\n        let date = this.daySeries.dates[row * this.colCnt + col];\n        return {\n            key: date.toISOString(),\n            date\n        };\n    }\n    buildHeaderDates() {\n        let dates = [];\n        for(let col = 0; col < this.colCnt; col += 1){\n            dates.push(this.cells[0][col].date);\n        }\n        return dates;\n    }\n    sliceRange(range) {\n        let { colCnt } = this;\n        let seriesSeg = this.daySeries.sliceRange(range);\n        let segs = [];\n        if (seriesSeg) {\n            let { firstIndex, lastIndex } = seriesSeg;\n            let index = firstIndex;\n            while(index <= lastIndex){\n                let row = Math.floor(index / colCnt);\n                let nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);\n                segs.push({\n                    row,\n                    firstCol: index % colCnt,\n                    lastCol: (nextIndex - 1) % colCnt,\n                    isStart: seriesSeg.isStart && index === firstIndex,\n                    isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex\n                });\n                index = nextIndex;\n            }\n        }\n        return segs;\n    }\n}\nclass Slicer {\n    constructor(){\n        this.sliceBusinessHours = memoize(this._sliceBusinessHours);\n        this.sliceDateSelection = memoize(this._sliceDateSpan);\n        this.sliceEventStore = memoize(this._sliceEventStore);\n        this.sliceEventDrag = memoize(this._sliceInteraction);\n        this.sliceEventResize = memoize(this._sliceInteraction);\n        this.forceDayIfListItem = false; // hack\n    }\n    sliceProps(props, dateProfile, nextDayThreshold, context, ...extraArgs) {\n        let { eventUiBases } = props;\n        let eventSegs = this.sliceEventStore(props.eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs);\n        return {\n            dateSelectionSegs: this.sliceDateSelection(props.dateSelection, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs),\n            businessHourSegs: this.sliceBusinessHours(props.businessHours, dateProfile, nextDayThreshold, context, ...extraArgs),\n            fgEventSegs: eventSegs.fg,\n            bgEventSegs: eventSegs.bg,\n            eventDrag: this.sliceEventDrag(props.eventDrag, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),\n            eventResize: this.sliceEventResize(props.eventResize, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),\n            eventSelection: props.eventSelection\n        }; // TODO: give interactionSegs?\n    }\n    sliceNowDate(date, dateProfile, nextDayThreshold, context, ...extraArgs) {\n        return this._sliceDateSpan({\n            range: {\n                start: date,\n                end: addMs(date, 1)\n            },\n            allDay: false\n        }, dateProfile, nextDayThreshold, {}, context, ...extraArgs);\n    }\n    _sliceBusinessHours(businessHours, dateProfile, nextDayThreshold, context, ...extraArgs) {\n        if (!businessHours) {\n            return [];\n        }\n        return this._sliceEventStore(expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context), {}, dateProfile, nextDayThreshold, ...extraArgs).bg;\n    }\n    _sliceEventStore(eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {\n        if (eventStore) {\n            let rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n            return {\n                bg: this.sliceEventRanges(rangeRes.bg, extraArgs),\n                fg: this.sliceEventRanges(rangeRes.fg, extraArgs)\n            };\n        }\n        return {\n            bg: [],\n            fg: []\n        };\n    }\n    _sliceInteraction(interaction, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {\n        if (!interaction) {\n            return null;\n        }\n        let rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n        return {\n            segs: this.sliceEventRanges(rangeRes.fg, extraArgs),\n            affectedInstances: interaction.affectedEvents.instances,\n            isEvent: interaction.isEvent\n        };\n    }\n    _sliceDateSpan(dateSpan, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs) {\n        if (!dateSpan) {\n            return [];\n        }\n        let activeRange = computeActiveRange(dateProfile, Boolean(nextDayThreshold));\n        let activeDateSpanRange = intersectRanges(dateSpan.range, activeRange);\n        if (activeDateSpanRange) {\n            dateSpan = Object.assign(Object.assign({}, dateSpan), {\n                range: activeDateSpanRange\n            });\n            let eventRange = fabricateEventRange(dateSpan, eventUiBases, context);\n            let segs = this.sliceRange(dateSpan.range, ...extraArgs);\n            for (let seg of segs){\n                seg.eventRange = eventRange;\n            }\n            return segs;\n        }\n        return [];\n    }\n    /*\n    \"complete\" seg means it has component and eventRange\n    */ sliceEventRanges(eventRanges, extraArgs) {\n        let segs = [];\n        for (let eventRange of eventRanges){\n            segs.push(...this.sliceEventRange(eventRange, extraArgs));\n        }\n        return segs;\n    }\n    /*\n    \"complete\" seg means it has component and eventRange\n    */ sliceEventRange(eventRange, extraArgs) {\n        let dateRange = eventRange.range;\n        // hack to make multi-day events that are being force-displayed as list-items to take up only one day\n        if (this.forceDayIfListItem && eventRange.ui.display === \"list-item\") {\n            dateRange = {\n                start: dateRange.start,\n                end: addDays(dateRange.start, 1)\n            };\n        }\n        let segs = this.sliceRange(dateRange, ...extraArgs);\n        for (let seg of segs){\n            seg.eventRange = eventRange;\n            seg.isStart = eventRange.isStart && seg.isStart;\n            seg.isEnd = eventRange.isEnd && seg.isEnd;\n        }\n        return segs;\n    }\n}\n/*\nfor incorporating slotMinTime/slotMaxTime if appropriate\nTODO: should be part of DateProfile!\nTimelineDateProfile already does this btw\n*/ function computeActiveRange(dateProfile, isComponentAllDay) {\n    let range = dateProfile.activeRange;\n    if (isComponentAllDay) {\n        return range;\n    }\n    return {\n        start: addMs(range.start, dateProfile.slotMinTime.milliseconds),\n        end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5)\n    };\n}\n// high-level segmenting-aware tester functions\n// ------------------------------------------------------------------------------------------------------------------------\nfunction isInteractionValid(interaction, dateProfile, context) {\n    let { instances } = interaction.mutatedEvents;\n    for(let instanceId in instances){\n        if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {\n            return false;\n        }\n    }\n    return isNewPropsValid({\n        eventDrag: interaction\n    }, context); // HACK: the eventDrag props is used for ALL interactions\n}\nfunction isDateSelectionValid(dateSelection, dateProfile, context) {\n    if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {\n        return false;\n    }\n    return isNewPropsValid({\n        dateSelection\n    }, context);\n}\nfunction isNewPropsValid(newProps, context) {\n    let calendarState = context.getCurrentData();\n    let props = Object.assign({\n        businessHours: calendarState.businessHours,\n        dateSelection: \"\",\n        eventStore: calendarState.eventStore,\n        eventUiBases: calendarState.eventUiBases,\n        eventSelection: \"\",\n        eventDrag: null,\n        eventResize: null\n    }, newProps);\n    return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);\n}\nfunction isPropsValid(state, context, dateSpanMeta = {}, filterConfig) {\n    if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n        return false;\n    }\n    if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n        return false;\n    }\n    return true;\n}\n// Moving Event Validation\n// ------------------------------------------------------------------------------------------------------------------------\nfunction isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {\n    let currentState = context.getCurrentData();\n    let interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions\n    let subjectEventStore = interaction.mutatedEvents;\n    let subjectDefs = subjectEventStore.defs;\n    let subjectInstances = subjectEventStore.instances;\n    let subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : {\n        \"\": currentState.selectionConfig\n    });\n    if (filterConfig) {\n        subjectConfigs = mapHash(subjectConfigs, filterConfig);\n    }\n    // exclude the subject events. TODO: exclude defs too?\n    let otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);\n    let otherDefs = otherEventStore.defs;\n    let otherInstances = otherEventStore.instances;\n    let otherConfigs = compileEventUis(otherDefs, state.eventUiBases);\n    for(let subjectInstanceId in subjectInstances){\n        let subjectInstance = subjectInstances[subjectInstanceId];\n        let subjectRange = subjectInstance.range;\n        let subjectConfig = subjectConfigs[subjectInstance.defId];\n        let subjectDef = subjectDefs[subjectInstance.defId];\n        // constraint\n        if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {\n            return false;\n        }\n        // overlap\n        let { eventOverlap } = context.options;\n        let eventOverlapFunc = typeof eventOverlap === \"function\" ? eventOverlap : null;\n        for(let otherInstanceId in otherInstances){\n            let otherInstance = otherInstances[otherInstanceId];\n            // intersect! evaluate\n            if (rangesIntersect(subjectRange, otherInstance.range)) {\n                let otherOverlap = otherConfigs[otherInstance.defId].overlap;\n                // consider the other event's overlap. only do this if the subject event is a \"real\" event\n                if (otherOverlap === false && interaction.isEvent) {\n                    return false;\n                }\n                if (subjectConfig.overlap === false) {\n                    return false;\n                }\n                if (eventOverlapFunc && !eventOverlapFunc(new EventImpl(context, otherDefs[otherInstance.defId], otherInstance), new EventImpl(context, subjectDef, subjectInstance))) {\n                    return false;\n                }\n            }\n        }\n        // allow (a function)\n        let calendarEventStore = currentState.eventStore; // need global-to-calendar, not local to component (splittable)state\n        for (let subjectAllow of subjectConfig.allows){\n            let subjectDateSpan = Object.assign(Object.assign({}, dateSpanMeta), {\n                range: subjectInstance.range,\n                allDay: subjectDef.allDay\n            });\n            let origDef = calendarEventStore.defs[subjectDef.defId];\n            let origInstance = calendarEventStore.instances[subjectInstanceId];\n            let eventApi;\n            if (origDef) {\n                eventApi = new EventImpl(context, origDef, origInstance);\n            } else {\n                eventApi = new EventImpl(context, subjectDef); // no instance, because had no dates\n            }\n            if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n// Date Selection Validation\n// ------------------------------------------------------------------------------------------------------------------------\nfunction isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {\n    let relevantEventStore = state.eventStore;\n    let relevantDefs = relevantEventStore.defs;\n    let relevantInstances = relevantEventStore.instances;\n    let selection = state.dateSelection;\n    let selectionRange = selection.range;\n    let { selectionConfig } = context.getCurrentData();\n    if (filterConfig) {\n        selectionConfig = filterConfig(selectionConfig);\n    }\n    // constraint\n    if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {\n        return false;\n    }\n    // overlap\n    let { selectOverlap } = context.options;\n    let selectOverlapFunc = typeof selectOverlap === \"function\" ? selectOverlap : null;\n    for(let relevantInstanceId in relevantInstances){\n        let relevantInstance = relevantInstances[relevantInstanceId];\n        // intersect! evaluate\n        if (rangesIntersect(selectionRange, relevantInstance.range)) {\n            if (selectionConfig.overlap === false) {\n                return false;\n            }\n            if (selectOverlapFunc && !selectOverlapFunc(new EventImpl(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {\n                return false;\n            }\n        }\n    }\n    // allow (a function)\n    for (let selectionAllow of selectionConfig.allows){\n        let fullDateSpan = Object.assign(Object.assign({}, dateSpanMeta), selection);\n        if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {\n            return false;\n        }\n    }\n    return true;\n}\n// Constraint Utils\n// ------------------------------------------------------------------------------------------------------------------------\nfunction allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n    for (let constraint of constraints){\n        if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n    if (constraint === \"businessHours\") {\n        return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));\n    }\n    if (typeof constraint === \"string\") {\n        return eventStoreToRanges(filterEventStoreDefs(otherEventStore, (eventDef)=>eventDef.groupId === constraint));\n    }\n    if (typeof constraint === \"object\" && constraint) {\n        return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));\n    }\n    return []; // if it's false\n}\n// TODO: move to event-store file?\nfunction eventStoreToRanges(eventStore) {\n    let { instances } = eventStore;\n    let ranges = [];\n    for(let instanceId in instances){\n        ranges.push(instances[instanceId].range);\n    }\n    return ranges;\n}\n// TODO: move to geom file?\nfunction anyRangesContainRange(outerRanges, innerRange) {\n    for (let outerRange of outerRanges){\n        if (rangeContainsRange(outerRange, innerRange)) {\n            return true;\n        }\n    }\n    return false;\n}\nconst VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;\nclass Scroller extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.handleEl = (el)=>{\n            this.el = el;\n            setRef(this.props.elRef, el);\n        };\n    }\n    render() {\n        let { props } = this;\n        let { liquid, liquidIsAbsolute } = props;\n        let isAbsolute = liquid && liquidIsAbsolute;\n        let className = [\n            \"fc-scroller\"\n        ];\n        if (liquid) {\n            if (liquidIsAbsolute) {\n                className.push(\"fc-scroller-liquid-absolute\");\n            } else {\n                className.push(\"fc-scroller-liquid\");\n            }\n        }\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n            ref: this.handleEl,\n            className: className.join(\" \"),\n            style: {\n                overflowX: props.overflowX,\n                overflowY: props.overflowY,\n                left: isAbsolute && -(props.overcomeLeft || 0) || \"\",\n                right: isAbsolute && -(props.overcomeRight || 0) || \"\",\n                bottom: isAbsolute && -(props.overcomeBottom || 0) || \"\",\n                marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || \"\",\n                marginRight: !isAbsolute && -(props.overcomeRight || 0) || \"\",\n                marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || \"\",\n                maxHeight: props.maxHeight || \"\"\n            }\n        }, props.children);\n    }\n    needsXScrolling() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n            return false;\n        }\n        // testing scrollWidth>clientWidth is unreliable cross-browser when pixel heights aren't integers.\n        // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n        // inner-child margins and absolute positioning\n        let { el } = this;\n        let realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();\n        let { children } = el;\n        for(let i = 0; i < children.length; i += 1){\n            let childEl = children[i];\n            if (childEl.getBoundingClientRect().width > realClientWidth) {\n                return true;\n            }\n        }\n        return false;\n    }\n    needsYScrolling() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n            return false;\n        }\n        // testing scrollHeight>clientHeight is unreliable cross-browser when pixel heights aren't integers.\n        // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n        // inner-child margins and absolute positioning\n        let { el } = this;\n        let realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();\n        let { children } = el;\n        for(let i = 0; i < children.length; i += 1){\n            let childEl = children[i];\n            if (childEl.getBoundingClientRect().height > realClientHeight) {\n                return true;\n            }\n        }\n        return false;\n    }\n    getXScrollbarWidth() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n            return 0;\n        }\n        return this.el.offsetHeight - this.el.clientHeight; // only works because we guarantee no borders. TODO: add to CSS with important?\n    }\n    getYScrollbarWidth() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n            return 0;\n        }\n        return this.el.offsetWidth - this.el.clientWidth; // only works because we guarantee no borders. TODO: add to CSS with important?\n    }\n}\n/*\nTODO: somehow infer OtherArgs from masterCallback?\nTODO: infer RefType from masterCallback if provided\n*/ class RefMap {\n    constructor(masterCallback){\n        this.masterCallback = masterCallback;\n        this.currentMap = {};\n        this.depths = {};\n        this.callbackMap = {};\n        this.handleValue = (val, key)=>{\n            let { depths, currentMap } = this;\n            let removed = false;\n            let added = false;\n            if (val !== null) {\n                // for bug... ACTUALLY: can probably do away with this now that callers don't share numeric indices anymore\n                removed = key in currentMap;\n                currentMap[key] = val;\n                depths[key] = (depths[key] || 0) + 1;\n                added = true;\n            } else {\n                depths[key] -= 1;\n                if (!depths[key]) {\n                    delete currentMap[key];\n                    delete this.callbackMap[key];\n                    removed = true;\n                }\n            }\n            if (this.masterCallback) {\n                if (removed) {\n                    this.masterCallback(null, String(key));\n                }\n                if (added) {\n                    this.masterCallback(val, String(key));\n                }\n            }\n        };\n    }\n    createRef(key) {\n        let refCallback = this.callbackMap[key];\n        if (!refCallback) {\n            refCallback = this.callbackMap[key] = (val)=>{\n                this.handleValue(val, String(key));\n            };\n        }\n        return refCallback;\n    }\n    // TODO: check callers that don't care about order. should use getAll instead\n    // NOTE: this method has become less valuable now that we are encouraged to map order by some other index\n    // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and \"collect\"\n    collect(startIndex, endIndex, step) {\n        return collectFromHash(this.currentMap, startIndex, endIndex, step);\n    }\n    getAll() {\n        return hashValuesToArray(this.currentMap);\n    }\n}\nfunction computeShrinkWidth(chunkEls) {\n    let shrinkCells = findElements(chunkEls, \".fc-scrollgrid-shrink\");\n    let largestWidth = 0;\n    for (let shrinkCell of shrinkCells){\n        largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));\n    }\n    return Math.ceil(largestWidth); // <table> elements work best with integers. round up to ensure contents fits\n}\nfunction getSectionHasLiquidHeight(props, sectionConfig) {\n    return props.liquid && sectionConfig.liquid; // does the section do liquid-height? (need to have whole scrollgrid liquid-height as well)\n}\nfunction getAllowYScrolling(props, sectionConfig) {\n    return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars\n    getSectionHasLiquidHeight(props, sectionConfig); // if the section is liquid height, it might condense enough to require scrollbars\n}\n// TODO: ONLY use `arg`. force out internal function to use same API\nfunction renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {\n    let { expandRows } = arg;\n    let content = typeof chunkConfig.content === \"function\" ? chunkConfig.content(arg) : (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"table\", {\n        role: \"presentation\",\n        className: [\n            chunkConfig.tableClassName,\n            sectionConfig.syncRowHeights ? \"fc-scrollgrid-sync-table\" : \"\"\n        ].join(\" \"),\n        style: {\n            minWidth: arg.tableMinWidth,\n            width: arg.clientWidth,\n            height: expandRows ? arg.clientHeight : \"\"\n        }\n    }, arg.tableColGroupNode, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(isHeader ? \"thead\" : \"tbody\", {\n        role: \"presentation\"\n    }, typeof chunkConfig.rowContent === \"function\" ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));\n    return content;\n}\nfunction isColPropsEqual(cols0, cols1) {\n    return isArraysEqual(cols0, cols1, isPropsEqual);\n}\nfunction renderMicroColGroup(cols, shrinkWidth) {\n    let colNodes = [];\n    /*\n    for ColProps with spans, it would have been great to make a single <col span=\"\">\n    HOWEVER, Chrome was getting messing up distributing the width to <td>/<th> elements with colspans.\n    SOLUTION: making individual <col> elements makes Chrome behave.\n    */ for (let colProps of cols){\n        let span = colProps.span || 1;\n        for(let i = 0; i < span; i += 1){\n            colNodes.push((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"col\", {\n                style: {\n                    width: colProps.width === \"shrink\" ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || \"\",\n                    minWidth: colProps.minWidth || \"\"\n                }\n            }));\n        }\n    }\n    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"colgroup\", {}, ...colNodes);\n}\nfunction sanitizeShrinkWidth(shrinkWidth) {\n    /* why 4? if we do 0, it will kill any border, which are needed for computeSmallestCellWidth\n    4 accounts for 2 2-pixel borders. TODO: better solution? */ return shrinkWidth == null ? 4 : shrinkWidth;\n}\nfunction hasShrinkWidth(cols) {\n    for (let col of cols){\n        if (col.width === \"shrink\") {\n            return true;\n        }\n    }\n    return false;\n}\nfunction getScrollGridClassNames(liquid, context) {\n    let classNames = [\n        \"fc-scrollgrid\",\n        context.theme.getClass(\"table\")\n    ];\n    if (liquid) {\n        classNames.push(\"fc-scrollgrid-liquid\");\n    }\n    return classNames;\n}\nfunction getSectionClassNames(sectionConfig, wholeTableVGrow) {\n    let classNames = [\n        \"fc-scrollgrid-section\",\n        `fc-scrollgrid-section-${sectionConfig.type}`,\n        sectionConfig.className\n    ];\n    if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {\n        classNames.push(\"fc-scrollgrid-section-liquid\");\n    }\n    if (sectionConfig.isSticky) {\n        classNames.push(\"fc-scrollgrid-section-sticky\");\n    }\n    return classNames;\n}\nfunction renderScrollShim(arg) {\n    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-scrollgrid-sticky-shim\",\n        style: {\n            width: arg.clientWidth,\n            minWidth: arg.tableMinWidth\n        }\n    });\n}\nfunction getStickyHeaderDates(options) {\n    let { stickyHeaderDates } = options;\n    if (stickyHeaderDates == null || stickyHeaderDates === \"auto\") {\n        stickyHeaderDates = options.height === \"auto\" || options.viewHeight === \"auto\";\n    }\n    return stickyHeaderDates;\n}\nfunction getStickyFooterScrollbar(options) {\n    let { stickyFooterScrollbar } = options;\n    if (stickyFooterScrollbar == null || stickyFooterScrollbar === \"auto\") {\n        stickyFooterScrollbar = options.height === \"auto\" || options.viewHeight === \"auto\";\n    }\n    return stickyFooterScrollbar;\n}\nclass SimpleScrollGrid extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.processCols = memoize((a)=>a, isColPropsEqual); // so we get same `cols` props every time\n        // yucky to memoize VNodes, but much more efficient for consumers\n        this.renderMicroColGroup = memoize(renderMicroColGroup);\n        this.scrollerRefs = new RefMap();\n        this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));\n        this.state = {\n            shrinkWidth: null,\n            forceYScrollbars: false,\n            scrollerClientWidths: {},\n            scrollerClientHeights: {}\n        };\n        // TODO: can do a really simple print-view. dont need to join rows\n        this.handleSizing = ()=>{\n            this.safeSetState(Object.assign({\n                shrinkWidth: this.computeShrinkWidth()\n            }, this.computeScrollerDims()));\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let sectionConfigs = props.sections || [];\n        let cols = this.processCols(props.cols);\n        let microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);\n        let classNames = getScrollGridClassNames(props.liquid, context);\n        if (props.collapsibleWidth) {\n            classNames.push(\"fc-scrollgrid-collapsible\");\n        }\n        // TODO: make DRY\n        let configCnt = sectionConfigs.length;\n        let configI = 0;\n        let currentConfig;\n        let headSectionNodes = [];\n        let bodySectionNodes = [];\n        let footSectionNodes = [];\n        while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === \"header\"){\n            headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n            configI += 1;\n        }\n        while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === \"body\"){\n            bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));\n            configI += 1;\n        }\n        while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === \"footer\"){\n            footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n            configI += 1;\n        }\n        // firefox bug: when setting height on table and there is a thead or tfoot,\n        // the necessary height:100% on the liquid-height body section forces the *whole* table to be taller. (bug #5524)\n        // use getCanVGrowWithinCell as a way to detect table-stupid firefox.\n        // if so, use a simpler dom structure, jam everything into a lone tbody.\n        let isBuggy = !getCanVGrowWithinCell();\n        const roleAttrs = {\n            role: \"rowgroup\"\n        };\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"table\", {\n            role: \"grid\",\n            className: classNames.join(\" \"),\n            style: {\n                height: props.height\n            }\n        }, Boolean(!isBuggy && headSectionNodes.length) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"thead\", roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tbody\", roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tfoot\", roleAttrs, ...footSectionNodes), isBuggy && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tbody\", roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));\n    }\n    renderSection(sectionConfig, microColGroupNode, isHeader) {\n        if (\"outerContent\" in sectionConfig) {\n            return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                key: sectionConfig.key\n            }, sectionConfig.outerContent);\n        }\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tr\", {\n            key: sectionConfig.key,\n            role: \"presentation\",\n            className: getSectionClassNames(sectionConfig, this.props.liquid).join(\" \")\n        }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader));\n    }\n    renderChunkTd(sectionConfig, microColGroupNode, chunkConfig, isHeader) {\n        if (\"outerContent\" in chunkConfig) {\n            return chunkConfig.outerContent;\n        }\n        let { props } = this;\n        let { forceYScrollbars, scrollerClientWidths, scrollerClientHeights } = this.state;\n        let needsYScrolling = getAllowYScrolling(props, sectionConfig); // TODO: do lazily. do in section config?\n        let isLiquid = getSectionHasLiquidHeight(props, sectionConfig);\n        // for `!props.liquid` - is WHOLE scrollgrid natural height?\n        // TODO: do same thing in advanced scrollgrid? prolly not b/c always has horizontal scrollbars\n        let overflowY = !props.liquid ? \"visible\" : forceYScrollbars ? \"scroll\" : !needsYScrolling ? \"hidden\" : \"auto\";\n        let sectionKey = sectionConfig.key;\n        let content = renderChunkContent(sectionConfig, chunkConfig, {\n            tableColGroupNode: microColGroupNode,\n            tableMinWidth: \"\",\n            clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== undefined ? scrollerClientWidths[sectionKey] : null,\n            clientHeight: scrollerClientHeights[sectionKey] !== undefined ? scrollerClientHeights[sectionKey] : null,\n            expandRows: sectionConfig.expandRows,\n            syncRowHeights: false,\n            rowSyncHeights: [],\n            reportRowHeightChange: ()=>{}\n        }, isHeader);\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(isHeader ? \"th\" : \"td\", {\n            ref: chunkConfig.elRef,\n            role: \"presentation\"\n        }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n            className: `fc-scroller-harness${isLiquid ? \" fc-scroller-harness-liquid\" : \"\"}`\n        }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(Scroller, {\n            ref: this.scrollerRefs.createRef(sectionKey),\n            elRef: this.scrollerElRefs.createRef(sectionKey),\n            overflowY: overflowY,\n            overflowX: !props.liquid ? \"visible\" : \"hidden\" /* natural height? */ ,\n            maxHeight: sectionConfig.maxHeight,\n            liquid: isLiquid,\n            liquidIsAbsolute: true\n        }, content)));\n    }\n    _handleScrollerEl(scrollerEl, key) {\n        let section = getSectionByKey(this.props.sections, key);\n        if (section) {\n            setRef(section.chunk.scrollerElRef, scrollerEl);\n        }\n    }\n    componentDidMount() {\n        this.handleSizing();\n        this.context.addResizeHandler(this.handleSizing);\n    }\n    componentDidUpdate() {\n        // TODO: need better solution when state contains non-sizing things\n        this.handleSizing();\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleSizing);\n    }\n    computeShrinkWidth() {\n        return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;\n    }\n    computeScrollerDims() {\n        let scrollbarWidth = getScrollbarWidths();\n        let { scrollerRefs, scrollerElRefs } = this;\n        let forceYScrollbars = false;\n        let scrollerClientWidths = {};\n        let scrollerClientHeights = {};\n        for(let sectionKey in scrollerRefs.currentMap){\n            let scroller = scrollerRefs.currentMap[sectionKey];\n            if (scroller && scroller.needsYScrolling()) {\n                forceYScrollbars = true;\n                break;\n            }\n        }\n        for (let section of this.props.sections){\n            let sectionKey = section.key;\n            let scrollerEl = scrollerElRefs.currentMap[sectionKey];\n            if (scrollerEl) {\n                let harnessEl = scrollerEl.parentNode; // TODO: weird way to get this. need harness b/c doesn't include table borders\n                scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n                 : 0));\n                scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);\n            }\n        }\n        return {\n            forceYScrollbars,\n            scrollerClientWidths,\n            scrollerClientHeights\n        };\n    }\n}\nSimpleScrollGrid.addStateEquality({\n    scrollerClientWidths: isPropsEqual,\n    scrollerClientHeights: isPropsEqual\n});\nfunction getSectionByKey(sections, key) {\n    for (let section of sections){\n        if (section.key === key) {\n            return section;\n        }\n    }\n    return null;\n}\nclass EventContainer extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.handleEl = (el)=>{\n            this.el = el;\n            if (el) {\n                setElSeg(el, this.props.seg);\n            }\n        };\n    }\n    render() {\n        const { props, context } = this;\n        const { options } = context;\n        const { seg } = props;\n        const { eventRange } = seg;\n        const { ui } = eventRange;\n        const renderProps = {\n            event: new EventImpl(context, eventRange.def, eventRange.instance),\n            view: context.viewApi,\n            timeText: props.timeText,\n            textColor: ui.textColor,\n            backgroundColor: ui.backgroundColor,\n            borderColor: ui.borderColor,\n            isDraggable: !props.disableDragging && computeSegDraggable(seg, context),\n            isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),\n            isEndResizable: !props.disableResizing && computeSegEndResizable(seg),\n            isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),\n            isStart: Boolean(seg.isStart),\n            isEnd: Boolean(seg.isEnd),\n            isPast: Boolean(props.isPast),\n            isFuture: Boolean(props.isFuture),\n            isToday: Boolean(props.isToday),\n            isSelected: Boolean(props.isSelected),\n            isDragging: Boolean(props.isDragging),\n            isResizing: Boolean(props.isResizing)\n        };\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, Object.assign({}, props /* contains children */ , {\n            elRef: this.handleEl,\n            elClasses: [\n                ...getEventClassNames(renderProps),\n                ...seg.eventRange.ui.classNames,\n                ...props.elClasses || []\n            ],\n            renderProps: renderProps,\n            generatorName: \"eventContent\",\n            customGenerator: options.eventContent,\n            defaultGenerator: props.defaultGenerator,\n            classNameGenerator: options.eventClassNames,\n            didMount: options.eventDidMount,\n            willUnmount: options.eventWillUnmount\n        }));\n    }\n    componentDidUpdate(prevProps) {\n        if (this.el && this.props.seg !== prevProps.seg) {\n            setElSeg(this.el, this.props.seg);\n        }\n    }\n}\n// should not be a purecomponent\nclass StandardEvent extends BaseComponent {\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let { seg } = props;\n        let { ui } = seg.eventRange;\n        let timeFormat = options.eventTimeFormat || props.defaultTimeFormat;\n        let timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(EventContainer, Object.assign({}, props /* includes elRef */ , {\n            elTag: \"a\",\n            elStyle: {\n                borderColor: ui.borderColor,\n                backgroundColor: ui.backgroundColor\n            },\n            elAttrs: getSegAnchorAttrs(seg, context),\n            defaultGenerator: renderInnerContent$1,\n            timeText: timeText\n        }), (InnerContent, eventContentArg)=>(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(InnerContent, {\n                elTag: \"div\",\n                elClasses: [\n                    \"fc-event-main\"\n                ],\n                elStyle: {\n                    color: eventContentArg.textColor\n                }\n            }), Boolean(eventContentArg.isStartResizable) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n                className: \"fc-event-resizer fc-event-resizer-start\"\n            }), Boolean(eventContentArg.isEndResizable) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n                className: \"fc-event-resizer fc-event-resizer-end\"\n            })));\n    }\n}\nfunction renderInnerContent$1(innerProps) {\n    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-event-main-frame\"\n    }, innerProps.timeText && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-event-time\"\n    }, innerProps.timeText), (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-event-title-container\"\n    }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-event-title fc-sticky\"\n    }, innerProps.event.title || (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, \"\\xa0\"))));\n}\nconst NowIndicatorContainer = (props)=>(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ViewContextType.Consumer, null, (context)=>{\n        let { options } = context;\n        let renderProps = {\n            isAxis: props.isAxis,\n            date: context.dateEnv.toDate(props.date),\n            view: context.viewApi\n        };\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, Object.assign({}, props /* includes children */ , {\n            elTag: props.elTag || \"div\",\n            renderProps: renderProps,\n            generatorName: \"nowIndicatorContent\",\n            customGenerator: options.nowIndicatorContent,\n            classNameGenerator: options.nowIndicatorClassNames,\n            didMount: options.nowIndicatorDidMount,\n            willUnmount: options.nowIndicatorWillUnmount\n        }));\n    });\nconst DAY_NUM_FORMAT = createFormatter({\n    day: \"numeric\"\n});\nclass DayCellContainer extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.refineRenderProps = memoizeObjArg(refineRenderProps);\n    }\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let renderProps = this.refineRenderProps({\n            date: props.date,\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            isMonthStart: props.isMonthStart || false,\n            showDayNumber: props.showDayNumber,\n            extraRenderProps: props.extraRenderProps,\n            viewApi: context.viewApi,\n            dateEnv: context.dateEnv,\n            monthStartFormat: options.monthStartFormat\n        });\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, Object.assign({}, props /* includes children */ , {\n            elClasses: [\n                ...getDayClassNames(renderProps, context.theme),\n                ...props.elClasses || []\n            ],\n            elAttrs: Object.assign(Object.assign({}, props.elAttrs), renderProps.isDisabled ? {} : {\n                \"data-date\": formatDayString(props.date)\n            }),\n            renderProps: renderProps,\n            generatorName: \"dayCellContent\",\n            customGenerator: options.dayCellContent,\n            defaultGenerator: props.defaultGenerator,\n            classNameGenerator: // don't use custom classNames if disabled\n            renderProps.isDisabled ? undefined : options.dayCellClassNames,\n            didMount: options.dayCellDidMount,\n            willUnmount: options.dayCellWillUnmount\n        }));\n    }\n}\nfunction hasCustomDayCellContent(options) {\n    return Boolean(options.dayCellContent || hasCustomRenderingHandler(\"dayCellContent\", options));\n}\nfunction refineRenderProps(raw) {\n    let { date, dateEnv, dateProfile, isMonthStart } = raw;\n    let dayMeta = getDateMeta(date, raw.todayRange, null, dateProfile);\n    let dayNumberText = raw.showDayNumber ? dateEnv.format(date, isMonthStart ? raw.monthStartFormat : DAY_NUM_FORMAT) : \"\";\n    return Object.assign(Object.assign(Object.assign({\n        date: dateEnv.toDate(date),\n        view: raw.viewApi\n    }, dayMeta), {\n        isMonthStart,\n        dayNumberText\n    }), raw.extraRenderProps);\n}\nclass BgEvent extends BaseComponent {\n    render() {\n        let { props } = this;\n        let { seg } = props;\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(EventContainer, {\n            elTag: \"div\",\n            elClasses: [\n                \"fc-bg-event\"\n            ],\n            elStyle: {\n                backgroundColor: seg.eventRange.ui.backgroundColor\n            },\n            defaultGenerator: renderInnerContent,\n            seg: seg,\n            timeText: \"\",\n            isDragging: false,\n            isResizing: false,\n            isDateSelecting: false,\n            isSelected: false,\n            isPast: props.isPast,\n            isFuture: props.isFuture,\n            isToday: props.isToday,\n            disableDragging: true,\n            disableResizing: true\n        });\n    }\n}\nfunction renderInnerContent(props) {\n    let { title } = props.event;\n    return title && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-event-title\"\n    }, props.event.title);\n}\nfunction renderFill(fillType) {\n    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: `fc-${fillType}`\n    });\n}\nconst WeekNumberContainer = (props)=>(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ViewContextType.Consumer, null, (context)=>{\n        let { dateEnv, options } = context;\n        let { date } = props;\n        let format = options.weekNumberFormat || props.defaultFormat;\n        let num = dateEnv.computeWeekNumber(date); // TODO: somehow use for formatting as well?\n        let text = dateEnv.format(date, format);\n        let renderProps = {\n            num,\n            text,\n            date\n        };\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer // why isn't WeekNumberContentArg being auto-detected?\n        , Object.assign({}, props /* includes children */ , {\n            renderProps: renderProps,\n            generatorName: \"weekNumberContent\",\n            customGenerator: options.weekNumberContent,\n            defaultGenerator: renderInner,\n            classNameGenerator: options.weekNumberClassNames,\n            didMount: options.weekNumberDidMount,\n            willUnmount: options.weekNumberWillUnmount\n        }));\n    });\nfunction renderInner(innerProps) {\n    return innerProps.text;\n}\nconst PADDING_FROM_VIEWPORT = 10;\nclass Popover extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.state = {\n            titleId: getUniqueDomId()\n        };\n        this.handleRootEl = (el)=>{\n            this.rootEl = el;\n            if (this.props.elRef) {\n                setRef(this.props.elRef, el);\n            }\n        };\n        // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n        this.handleDocumentMouseDown = (ev)=>{\n            // only hide the popover if the click happened outside the popover\n            const target = getEventTargetViaRoot(ev);\n            if (!this.rootEl.contains(target)) {\n                this.handleCloseClick();\n            }\n        };\n        this.handleDocumentKeyDown = (ev)=>{\n            if (ev.key === \"Escape\") {\n                this.handleCloseClick();\n            }\n        };\n        this.handleCloseClick = ()=>{\n            let { onClose } = this.props;\n            if (onClose) {\n                onClose();\n            }\n        };\n    }\n    render() {\n        let { theme, options } = this.context;\n        let { props, state } = this;\n        let classNames = [\n            \"fc-popover\",\n            theme.getClass(\"popover\")\n        ].concat(props.extraClassNames || []);\n        return (0,preact_compat__WEBPACK_IMPORTED_MODULE_1__.createPortal)((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", Object.assign({}, props.extraAttrs, {\n            id: props.id,\n            className: classNames.join(\" \"),\n            \"aria-labelledby\": state.titleId,\n            ref: this.handleRootEl\n        }), (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n            className: \"fc-popover-header \" + theme.getClass(\"popoverHeader\")\n        }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", {\n            className: \"fc-popover-title\",\n            id: state.titleId\n        }, props.title), (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", {\n            className: \"fc-popover-close \" + theme.getIconClass(\"close\"),\n            title: options.closeHint,\n            onClick: this.handleCloseClick\n        })), (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n            className: \"fc-popover-body \" + theme.getClass(\"popoverContent\")\n        }, props.children)), props.parentEl);\n    }\n    componentDidMount() {\n        document.addEventListener(\"mousedown\", this.handleDocumentMouseDown);\n        document.addEventListener(\"keydown\", this.handleDocumentKeyDown);\n        this.updateSize();\n    }\n    componentWillUnmount() {\n        document.removeEventListener(\"mousedown\", this.handleDocumentMouseDown);\n        document.removeEventListener(\"keydown\", this.handleDocumentKeyDown);\n    }\n    updateSize() {\n        let { isRtl } = this.context;\n        let { alignmentEl, alignGridTop } = this.props;\n        let { rootEl } = this;\n        let alignmentRect = computeClippedClientRect(alignmentEl);\n        if (alignmentRect) {\n            let popoverDims = rootEl.getBoundingClientRect();\n            // position relative to viewport\n            let popoverTop = alignGridTop ? elementClosest(alignmentEl, \".fc-scrollgrid\").getBoundingClientRect().top : alignmentRect.top;\n            let popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left;\n            // constrain\n            popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);\n            popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);\n            popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);\n            let origin = rootEl.offsetParent.getBoundingClientRect();\n            applyStyle(rootEl, {\n                top: popoverTop - origin.top,\n                left: popoverLeft - origin.left\n            });\n        }\n    }\n}\nclass MorePopover extends DateComponent {\n    constructor(){\n        super(...arguments);\n        this.handleRootEl = (rootEl)=>{\n            this.rootEl = rootEl;\n            if (rootEl) {\n                this.context.registerInteractiveComponent(this, {\n                    el: rootEl,\n                    useEventCenter: false\n                });\n            } else {\n                this.context.unregisterInteractiveComponent(this);\n            }\n        };\n    }\n    render() {\n        let { options, dateEnv } = this.context;\n        let { props } = this;\n        let { startDate, todayRange, dateProfile } = props;\n        let title = dateEnv.format(startDate, options.dayPopoverFormat);\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(DayCellContainer, {\n            elRef: this.handleRootEl,\n            date: startDate,\n            dateProfile: dateProfile,\n            todayRange: todayRange\n        }, (InnerContent, renderProps, elAttrs)=>(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(Popover, {\n                elRef: elAttrs.ref,\n                id: props.id,\n                title: title,\n                extraClassNames: [\n                    \"fc-more-popover\"\n                ].concat(elAttrs.className || []),\n                extraAttrs: elAttrs /* TODO: make these time-based when not whole-day? */ ,\n                parentEl: props.parentEl,\n                alignmentEl: props.alignmentEl,\n                alignGridTop: props.alignGridTop,\n                onClose: props.onClose\n            }, hasCustomDayCellContent(options) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(InnerContent, {\n                elTag: \"div\",\n                elClasses: [\n                    \"fc-more-popover-misc\"\n                ]\n            }), props.children));\n    }\n    queryHit(positionLeft, positionTop, elWidth, elHeight) {\n        let { rootEl, props } = this;\n        if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {\n            return {\n                dateProfile: props.dateProfile,\n                dateSpan: Object.assign({\n                    allDay: !props.forceTimed,\n                    range: {\n                        start: props.startDate,\n                        end: props.endDate\n                    }\n                }, props.extraDateSpan),\n                dayEl: rootEl,\n                rect: {\n                    left: 0,\n                    top: 0,\n                    right: elWidth,\n                    bottom: elHeight\n                },\n                layer: 1\n            };\n        }\n        return null;\n    }\n}\nclass MoreLinkContainer extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.state = {\n            isPopoverOpen: false,\n            popoverId: getUniqueDomId()\n        };\n        this.handleLinkEl = (linkEl)=>{\n            this.linkEl = linkEl;\n            if (this.props.elRef) {\n                setRef(this.props.elRef, linkEl);\n            }\n        };\n        this.handleClick = (ev)=>{\n            let { props, context } = this;\n            let { moreLinkClick } = context.options;\n            let date = computeRange(props).start;\n            function buildPublicSeg(seg) {\n                let { def, instance, range } = seg.eventRange;\n                return {\n                    event: new EventImpl(context, def, instance),\n                    start: context.dateEnv.toDate(range.start),\n                    end: context.dateEnv.toDate(range.end),\n                    isStart: seg.isStart,\n                    isEnd: seg.isEnd\n                };\n            }\n            if (typeof moreLinkClick === \"function\") {\n                moreLinkClick = moreLinkClick({\n                    date,\n                    allDay: Boolean(props.allDayDate),\n                    allSegs: props.allSegs.map(buildPublicSeg),\n                    hiddenSegs: props.hiddenSegs.map(buildPublicSeg),\n                    jsEvent: ev,\n                    view: context.viewApi\n                });\n            }\n            if (!moreLinkClick || moreLinkClick === \"popover\") {\n                this.setState({\n                    isPopoverOpen: true\n                });\n            } else if (typeof moreLinkClick === \"string\") {\n                context.calendarApi.zoomTo(date, moreLinkClick);\n            }\n        };\n        this.handlePopoverClose = ()=>{\n            this.setState({\n                isPopoverOpen: false\n            });\n        };\n    }\n    render() {\n        let { props, state } = this;\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ViewContextType.Consumer, null, (context)=>{\n            let { viewApi, options, calendarApi } = context;\n            let { moreLinkText } = options;\n            let { moreCnt } = props;\n            let range = computeRange(props);\n            let text = typeof moreLinkText === \"function\" // TODO: eventually use formatWithOrdinals\n             ? moreLinkText.call(calendarApi, moreCnt) : `+${moreCnt} ${moreLinkText}`;\n            let hint = formatWithOrdinals(options.moreLinkHint, [\n                moreCnt\n            ], text);\n            let renderProps = {\n                num: moreCnt,\n                shortText: `+${moreCnt}`,\n                text,\n                view: viewApi\n            };\n            return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, Boolean(props.moreCnt) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, {\n                elTag: props.elTag || \"a\",\n                elRef: this.handleLinkEl,\n                elClasses: [\n                    ...props.elClasses || [],\n                    \"fc-more-link\"\n                ],\n                elStyle: props.elStyle,\n                elAttrs: Object.assign(Object.assign(Object.assign({}, props.elAttrs), createAriaClickAttrs(this.handleClick)), {\n                    title: hint,\n                    \"aria-expanded\": state.isPopoverOpen,\n                    \"aria-controls\": state.isPopoverOpen ? state.popoverId : \"\"\n                }),\n                renderProps: renderProps,\n                generatorName: \"moreLinkContent\",\n                customGenerator: options.moreLinkContent,\n                defaultGenerator: props.defaultGenerator || renderMoreLinkInner,\n                classNameGenerator: options.moreLinkClassNames,\n                didMount: options.moreLinkDidMount,\n                willUnmount: options.moreLinkWillUnmount\n            }, props.children), state.isPopoverOpen && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(MorePopover, {\n                id: state.popoverId,\n                startDate: range.start,\n                endDate: range.end,\n                dateProfile: props.dateProfile,\n                todayRange: props.todayRange,\n                extraDateSpan: props.extraDateSpan,\n                parentEl: this.parentEl,\n                alignmentEl: props.alignmentElRef ? props.alignmentElRef.current : this.linkEl,\n                alignGridTop: props.alignGridTop,\n                forceTimed: props.forceTimed,\n                onClose: this.handlePopoverClose\n            }, props.popoverContent()));\n        });\n    }\n    componentDidMount() {\n        this.updateParentEl();\n    }\n    componentDidUpdate() {\n        this.updateParentEl();\n    }\n    updateParentEl() {\n        if (this.linkEl) {\n            this.parentEl = elementClosest(this.linkEl, \".fc-view-harness\");\n        }\n    }\n}\nfunction renderMoreLinkInner(props) {\n    return props.text;\n}\nfunction computeRange(props) {\n    if (props.allDayDate) {\n        return {\n            start: props.allDayDate,\n            end: addDays(props.allDayDate, 1)\n        };\n    }\n    let { hiddenSegs } = props;\n    return {\n        start: computeEarliestSegStart(hiddenSegs),\n        end: computeLatestSegEnd(hiddenSegs)\n    };\n}\nfunction computeEarliestSegStart(segs) {\n    return segs.reduce(pickEarliestStart).eventRange.range.start;\n}\nfunction pickEarliestStart(seg0, seg1) {\n    return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;\n}\nfunction computeLatestSegEnd(segs) {\n    return segs.reduce(pickLatestEnd).eventRange.range.end;\n}\nfunction pickLatestEnd(seg0, seg1) {\n    return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;\n}\nclass Store {\n    constructor(){\n        this.handlers = [];\n    }\n    set(value) {\n        this.currentValue = value;\n        for (let handler of this.handlers){\n            handler(value);\n        }\n    }\n    subscribe(handler) {\n        this.handlers.push(handler);\n        if (this.currentValue !== undefined) {\n            handler(this.currentValue);\n        }\n    }\n}\n/*\nSubscribers will get a LIST of CustomRenderings\n*/ class CustomRenderingStore extends Store {\n    constructor(){\n        super(...arguments);\n        this.map = new Map();\n    }\n    // for consistent order\n    handle(customRendering) {\n        const { map } = this;\n        let updated = false;\n        if (customRendering.isActive) {\n            map.set(customRendering.id, customRendering);\n            updated = true;\n        } else if (map.has(customRendering.id)) {\n            map.delete(customRendering.id);\n            updated = true;\n        }\n        if (updated) {\n            this.set(map);\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLWNvbW1vbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUM7QUFDMkM7QUFDL0I7QUFFN0MsTUFBTU0sYUFBYSxFQUFFO0FBQ3JCLE1BQU1DLFdBQVcsSUFBSUM7QUFDckIsU0FBU0MsYUFBYUMsU0FBUztJQUMzQkosV0FBV0ssSUFBSSxDQUFDRDtJQUNoQkgsU0FBU0ssT0FBTyxDQUFDLENBQUNDO1FBQ2RDLGVBQWVELFNBQVNIO0lBQzVCO0FBQ0o7QUFDQSxTQUFTSyxrQkFBa0JDLEVBQUU7SUFDekIsSUFBSUEsR0FBR0MsV0FBVyxFQUFFO1FBQ2hCQyxtQkFBbUJGLEdBQUdHLFdBQVc7SUFDckM7QUFDSjtBQUNBLFNBQVNELG1CQUFtQkUsUUFBUTtJQUNoQyxJQUFJUCxVQUFVTixTQUFTYyxHQUFHLENBQUNEO0lBQzNCLElBQUksQ0FBQ1AsV0FBVyxDQUFDQSxRQUFRSSxXQUFXLEVBQUU7UUFDbENKLFVBQVVPLFNBQVNFLGFBQWEsQ0FBQztRQUNqQyxJQUFJLENBQUNULFNBQVM7WUFDVkEsVUFBVVUsU0FBU3JCLGFBQWEsQ0FBQztZQUNqQ1csUUFBUVcsWUFBWSxDQUFDLHFCQUFxQjtZQUMxQyxNQUFNQyxRQUFRQztZQUNkLElBQUlELE9BQU87Z0JBQ1BaLFFBQVFZLEtBQUssR0FBR0E7WUFDcEI7WUFDQSxNQUFNRSxXQUFXUCxhQUFhRyxXQUFXQSxTQUFTSyxJQUFJLEdBQUdSO1lBQ3pE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QU9DLGVBQWUsRUFBRTtRQUNwQixNQUFNLEVBQUUxOEIsR0FBRyxFQUFFLEdBQUcsSUFBSTtRQUNwQixJQUFJMjhCLFVBQVU7UUFDZCxJQUFJRCxnQkFBZ0Iva0MsUUFBUSxFQUFFO1lBQzFCcUksSUFBSWgrQixHQUFHLENBQUMwNkQsZ0JBQWdCMW1DLEVBQUUsRUFBRTBtQztZQUM1QkMsVUFBVTtRQUNkLE9BQ0ssSUFBSTM4QixJQUFJNDhCLEdBQUcsQ0FBQ0YsZ0JBQWdCMW1DLEVBQUUsR0FBRztZQUNsQ2dLLElBQUk2OEIsTUFBTSxDQUFDSCxnQkFBZ0IxbUMsRUFBRTtZQUM3QjJtQyxVQUFVO1FBQ2Q7UUFDQSxJQUFJQSxTQUFTO1lBQ1QsSUFBSSxDQUFDMzZELEdBQUcsQ0FBQ2crQjtRQUNiO0lBQ0o7QUFDSjtBQUVnekoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvaW50ZXJuYWwtY29tbW9uLmpzPzU1OWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcHJlYWN0IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnQsIGlzVmFsaWRFbGVtZW50LCBGcmFnbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tICdwcmVhY3QvY29tcGF0JztcblxuY29uc3Qgc3R5bGVUZXh0cyA9IFtdO1xuY29uc3Qgc3R5bGVFbHMgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBpbmplY3RTdHlsZXMoc3R5bGVUZXh0KSB7XG4gICAgc3R5bGVUZXh0cy5wdXNoKHN0eWxlVGV4dCk7XG4gICAgc3R5bGVFbHMuZm9yRWFjaCgoc3R5bGVFbCkgPT4ge1xuICAgICAgICBhcHBlbmRTdHlsZXNUbyhzdHlsZUVsLCBzdHlsZVRleHQpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZW5zdXJlRWxIYXNTdHlsZXMoZWwpIHtcbiAgICBpZiAoZWwuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgcmVnaXN0ZXJTdHlsZXNSb290KGVsLmdldFJvb3ROb2RlKCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyU3R5bGVzUm9vdChyb290Tm9kZSkge1xuICAgIGxldCBzdHlsZUVsID0gc3R5bGVFbHMuZ2V0KHJvb3ROb2RlKTtcbiAgICBpZiAoIXN0eWxlRWwgfHwgIXN0eWxlRWwuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgc3R5bGVFbCA9IHJvb3ROb2RlLnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtZnVsbGNhbGVuZGFyXScpO1xuICAgICAgICBpZiAoIXN0eWxlRWwpIHtcbiAgICAgICAgICAgIHN0eWxlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgc3R5bGVFbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZnVsbGNhbGVuZGFyJywgJycpO1xuICAgICAgICAgICAgY29uc3Qgbm9uY2UgPSBnZXROb25jZVZhbHVlKCk7XG4gICAgICAgICAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgICAgICAgICBzdHlsZUVsLm5vbmNlID0gbm9uY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRFbCA9IHJvb3ROb2RlID09PSBkb2N1bWVudCA/IGRvY3VtZW50LmhlYWQgOiByb290Tm9kZTtcbiAgICAgICAgICAgIGNvbnN0IGluc2VydEJlZm9yZSA9IHJvb3ROb2RlID09PSBkb2N1bWVudFxuICAgICAgICAgICAgICAgID8gcGFyZW50RWwucXVlcnlTZWxlY3Rvcignc2NyaXB0LGxpbmtbcmVsPXN0eWxlc2hlZXRdLGxpbmtbYXM9c3R5bGVdLHN0eWxlJylcbiAgICAgICAgICAgICAgICA6IHBhcmVudEVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBwYXJlbnRFbC5pbnNlcnRCZWZvcmUoc3R5bGVFbCwgaW5zZXJ0QmVmb3JlKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZUVscy5zZXQocm9vdE5vZGUsIHN0eWxlRWwpO1xuICAgICAgICBoeWRyYXRlU3R5bGVzUm9vdChzdHlsZUVsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoeWRyYXRlU3R5bGVzUm9vdChzdHlsZUVsKSB7XG4gICAgZm9yIChjb25zdCBzdHlsZVRleHQgb2Ygc3R5bGVUZXh0cykge1xuICAgICAgICBhcHBlbmRTdHlsZXNUbyhzdHlsZUVsLCBzdHlsZVRleHQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGVuZFN0eWxlc1RvKHN0eWxlRWwsIHN0eWxlVGV4dCkge1xuICAgIGNvbnN0IHsgc2hlZXQgfSA9IHN0eWxlRWw7XG4gICAgY29uc3QgcnVsZUNudCA9IHNoZWV0LmNzc1J1bGVzLmxlbmd0aDtcbiAgICBzdHlsZVRleHQuc3BsaXQoJ30nKS5mb3JFYWNoKChzdHlsZVN0ciwgaSkgPT4ge1xuICAgICAgICBzdHlsZVN0ciA9IHN0eWxlU3RyLnRyaW0oKTtcbiAgICAgICAgaWYgKHN0eWxlU3RyKSB7XG4gICAgICAgICAgICBzaGVldC5pbnNlcnRSdWxlKHN0eWxlU3RyICsgJ30nLCBydWxlQ250ICsgaSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIG5vbmNlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5sZXQgcXVlcmllZE5vbmNlVmFsdWU7XG5mdW5jdGlvbiBnZXROb25jZVZhbHVlKCkge1xuICAgIGlmIChxdWVyaWVkTm9uY2VWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHF1ZXJpZWROb25jZVZhbHVlID0gcXVlcnlOb25jZVZhbHVlKCk7XG4gICAgfVxuICAgIHJldHVybiBxdWVyaWVkTm9uY2VWYWx1ZTtcbn1cbi8qXG5UT0RPOiBkaXNjb3VyYWdlIG1ldGEgdGFnIGFuZCBpbnN0ZWFkIHB1dCBub25jZSBhdHRyaWJ1dGUgb24gcGxhY2Vob2xkZXIgPHN0eWxlPiB0YWdcbiovXG5mdW5jdGlvbiBxdWVyeU5vbmNlVmFsdWUoKSB7XG4gICAgY29uc3QgbWV0YVdpdGhOb25jZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT1cImNzcC1ub25jZVwiXScpO1xuICAgIGlmIChtZXRhV2l0aE5vbmNlICYmIG1ldGFXaXRoTm9uY2UuaGFzQXR0cmlidXRlKCdjb250ZW50JykpIHtcbiAgICAgICAgcmV0dXJuIG1ldGFXaXRoTm9uY2UuZ2V0QXR0cmlidXRlKCdjb250ZW50Jyk7XG4gICAgfVxuICAgIGNvbnN0IGVsV2l0aE5vbmNlID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2NyaXB0W25vbmNlXScpO1xuICAgIGlmIChlbFdpdGhOb25jZSkge1xuICAgICAgICByZXR1cm4gZWxXaXRoTm9uY2Uubm9uY2UgfHwgJyc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cbi8vIG1haW5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmVnaXN0ZXJTdHlsZXNSb290KGRvY3VtZW50KTtcbn1cblxudmFyIGNzc18yNDh6ID0gXCI6cm9vdHstLWZjLXNtYWxsLWZvbnQtc2l6ZTouODVlbTstLWZjLXBhZ2UtYmctY29sb3I6I2ZmZjstLWZjLW5ldXRyYWwtYmctY29sb3I6aHNsYSgwLDAlLDgyJSwuMyk7LS1mYy1uZXV0cmFsLXRleHQtY29sb3I6Z3JleTstLWZjLWJvcmRlci1jb2xvcjojZGRkOy0tZmMtYnV0dG9uLXRleHQtY29sb3I6I2ZmZjstLWZjLWJ1dHRvbi1iZy1jb2xvcjojMmMzZTUwOy0tZmMtYnV0dG9uLWJvcmRlci1jb2xvcjojMmMzZTUwOy0tZmMtYnV0dG9uLWhvdmVyLWJnLWNvbG9yOiMxZTJiMzc7LS1mYy1idXR0b24taG92ZXItYm9yZGVyLWNvbG9yOiMxYTI1MmY7LS1mYy1idXR0b24tYWN0aXZlLWJnLWNvbG9yOiMxYTI1MmY7LS1mYy1idXR0b24tYWN0aXZlLWJvcmRlci1jb2xvcjojMTUxZTI3Oy0tZmMtZXZlbnQtYmctY29sb3I6IzM3ODhkODstLWZjLWV2ZW50LWJvcmRlci1jb2xvcjojMzc4OGQ4Oy0tZmMtZXZlbnQtdGV4dC1jb2xvcjojZmZmOy0tZmMtZXZlbnQtc2VsZWN0ZWQtb3ZlcmxheS1jb2xvcjpyZ2JhKDAsMCwwLC4yNSk7LS1mYy1tb3JlLWxpbmstYmctY29sb3I6I2QwZDBkMDstLWZjLW1vcmUtbGluay10ZXh0LWNvbG9yOmluaGVyaXQ7LS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzczo4cHg7LS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aDo4cHg7LS1mYy1ldmVudC1yZXNpemVyLWRvdC1ib3JkZXItd2lkdGg6MXB4Oy0tZmMtbm9uLWJ1c2luZXNzLWNvbG9yOmhzbGEoMCwwJSw4NCUsLjMpOy0tZmMtYmctZXZlbnQtY29sb3I6IzhmZGY4MjstLWZjLWJnLWV2ZW50LW9wYWNpdHk6MC4zOy0tZmMtaGlnaGxpZ2h0LWNvbG9yOnJnYmEoMTg4LDIzMiwyNDEsLjMpOy0tZmMtdG9kYXktYmctY29sb3I6cmdiYSgyNTUsMjIwLDQwLC4xNSk7LS1mYy1ub3ctaW5kaWNhdG9yLWNvbG9yOnJlZH0uZmMtbm90LWFsbG93ZWQsLmZjLW5vdC1hbGxvd2VkIC5mYy1ldmVudHtjdXJzb3I6bm90LWFsbG93ZWR9LmZje2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47Zm9udC1zaXplOjFlbX0uZmMsLmZjICosLmZjIDphZnRlciwuZmMgOmJlZm9yZXtib3gtc2l6aW5nOmJvcmRlci1ib3h9LmZjIHRhYmxle2JvcmRlci1jb2xsYXBzZTpjb2xsYXBzZTtib3JkZXItc3BhY2luZzowO2ZvbnQtc2l6ZToxZW19LmZjIHRoe3RleHQtYWxpZ246Y2VudGVyfS5mYyB0ZCwuZmMgdGh7cGFkZGluZzowO3ZlcnRpY2FsLWFsaWduOnRvcH0uZmMgYVtkYXRhLW5hdmxpbmtde2N1cnNvcjpwb2ludGVyfS5mYyBhW2RhdGEtbmF2bGlua106aG92ZXJ7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZX0uZmMtZGlyZWN0aW9uLWx0cntkaXJlY3Rpb246bHRyO3RleHQtYWxpZ246bGVmdH0uZmMtZGlyZWN0aW9uLXJ0bHtkaXJlY3Rpb246cnRsO3RleHQtYWxpZ246cmlnaHR9LmZjLXRoZW1lLXN0YW5kYXJkIHRkLC5mYy10aGVtZS1zdGFuZGFyZCB0aHtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZjLWJvcmRlci1jb2xvcil9LmZjLWxpcXVpZC1oYWNrIHRkLC5mYy1saXF1aWQtaGFjayB0aHtwb3NpdGlvbjpyZWxhdGl2ZX1AZm9udC1mYWNle2ZvbnQtZmFtaWx5OmZjaWNvbnM7Zm9udC1zdHlsZTpub3JtYWw7Zm9udC13ZWlnaHQ6NDAwO3NyYzp1cmwoXFxcImRhdGE6YXBwbGljYXRpb24veC1mb250LXR0ZjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxBQUVBQUFBTEFJQUFBd0F3VDFNdk1nOFNCZkFBQUFDOEFBQUFZR050WVhBWFZ0S05BQUFCSEFBQUFGUm5ZWE53QUFBQUVBQUFBWEFBQUFBSVoyeDVaZ1l5ZHhJQUFBRjRBQUFGTkdobFlXUVVKN2NJQUFBR3JBQUFBRFpvYUdWaEIyMER6QUFBQnVRQUFBQWthRzEwZUNJQUJoUUFBQWNJQUFBQUxHeHZZMkVENEFVNkFBQUhOQUFBQUJodFlYaHdBQThBakFBQUIwd0FBQUFnYm1GdFpYc3I2OTBBQUFkc0FBQUJobkJ2YzNRQUF3QUFBQUFJOUFBQUFDQUFBd1BBQVpBQUJRQUFBcGtDekFBQUFJOENtUUxNQUFBQjZ3QXpBUWtBQUFBQUFBQUFBQUFBQUFBQUFBQUJFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBQURwQmdQQS84QUFRQVBBQUVBQUFBQUJBQUFBQUFBQUFBQUFBQUFnQUFBQUFBQURBQUFBQXdBQUFCd0FBUUFEQUFBQUhBQURBQUVBQUFBY0FBUUFPQUFBQUFvQUNBQUNBQUlBQVFBZzZRYi8vZi8vQUFBQUFBQWc2UUQvL2YvL0FBSC80eGNFQUFNQUFRQUFBQUFBQUFBQUFBQUFBUUFCLy84QUR3QUJBQUFBQUFBQUFBQUFBZ0FBTnprQkFBQUFBQUVBQUFBQUFBQUFBQUFDQUFBM09RRUFBQUFBQVFBQUFBQUFBQUFBQUFJQUFEYzVBUUFBQUFBQkFXSUFqUUtlQXNrQUV3QUFKU2MzTmpRbkppSUhBUVlVRndFV01qYzJOQ2NDbnVMaURRME1KQXovQUEwTkFRQU1KQXdORGNuaTRnd2pEUXdNL3dBTkl3ei9BQTBORENNTkFBQUFBUUZpQUkwQ25nTEpBQk1BQUNVQk5qUW5BU1lpQndZVUh3RUhCaFFYRmpJM0FaNEJBQTBOL3dBTUpBd05EZUxpRFEwTUpBeU5BUUFNSXcwQkFBd01EU01NNHVJTkl3d05EUUFBQUFJQTRnQzNBeDRDbmdBVEFDY0FBQ1VuTnpZMEp5WWlEd0VHRkI4QkZqSTNOalFuSVNjM05qUW5KaUlQQVFZVUh3RVdNamMyTkNjQjg3ZTNEUTBNSXczVkRRM1ZEU01NRFEwQks3ZTNEUTBNSkF6VkRRM1ZEQ1FNRFEzenVMY01KQXdORGRVTkl3eldEQXdOSXd5NHR3d2tEQTBOMVEwakROWU1EQTBqREFBQUFnRGlBTGNESGdLZUFCTUFKd0FBSlRjMk5DOEJKaUlIQmhRZkFRY0dGQmNXTWpjaE56WTBMd0VtSWdjR0ZCOEJCd1lVRnhZeU53SkoxUTBOMVEwakRBME50N2NORFF3akRmN1YxUTBOMVF3a0RBME50N2NORFF3a0RMZldEQ01OMVEwTkRDUU10N2dNSXcwTUROWU1JdzNWRFEwTUpBeTN1QXdqRFF3TUFBQURBRlVBQUFPckExVUFNd0JvQUhjQUFCTWlCZ2NPQVFjT0FRY09BUlVSRkJZWEhnRVhIZ0VYSGdFeklUSTJOejRCTno0Qk56NEJOUkUwSmljdUFTY3VBU2N1QVNNRklUSVdGeDRCRng0QkZ4NEJGUkVVQmdjT0FRY09BUWNPQVNNaElpWW5MZ0VuTGdFbkxnRTFFVFEyTno0Qk56NEJOejRCTXhNaE1qWTFOQ1lqSVNJR0ZSUVdNOVVOR0F3TEZRa0pEZ1VGQlFVRkJRNEpDUlVMREJnTkFsWU5HQXdMRlFrSkRnVUZCUVVGQlE0SkNSVUxEQmdOL2FvQ1ZnUUlCQVFIQXdNRkFRSUJBUUlCQlFNREJ3UUVDQVQ5cWdRSUJBUUhBd01GQVFJQkFRSUJCUU1EQndRRUNBU0FBVllSR1JrUi9xb1JHUmtSQTFVRkJBVU9DUWtWREFzWkRmMnJEUmtMREJVSkNBNEZCUVVGQlFVT0NRZ1ZEQXNaRFFKVkRSa0xEQlVKQ1E0RkJBVlZBZ0VDQlFNQ0J3UUVDQVg5cXdRSkF3UUhBd01GQVFJQ0FnSUJCUU1EQndRRENRUUNWUVVJQkFRSEFnTUZBZ0VDL29BWkVoRVpHUkVTR1FBQUFBQURBRlVBQUFPckExVUFNd0JvQUlrQUFCTWlCZ2NPQVFjT0FRY09BUlVSRkJZWEhnRVhIZ0VYSGdFeklUSTJOejRCTno0Qk56NEJOUkUwSmljdUFTY3VBU2N1QVNNRklUSVdGeDRCRng0QkZ4NEJGUkVVQmdjT0FRY09BUWNPQVNNaElpWW5MZ0VuTGdFbkxnRTFFVFEyTno0Qk56NEJOejRCTXhNekZSUVdNekkyUFFFek1qWTFOQ1lyQVRVMEppTWlCaDBCSXlJR0ZSUVdNOVVOR0F3TEZRa0pEZ1VGQlFVRkJRNEpDUlVMREJnTkFsWU5HQXdMRlFrSkRnVUZCUVVGQlE0SkNSVUxEQmdOL2FvQ1ZnUUlCQVFIQXdNRkFRSUJBUUlCQlFNREJ3UUVDQVQ5cWdRSUJBUUhBd01GQVFJQkFRSUJCUU1EQndRRUNBU0FnQmtTRWhtQUVSa1pFWUFaRWhJWmdCRVpHUkVEVlFVRUJRNEpDUlVNQ3hrTi9hc05HUXNNRlFrSURnVUZCUVVGQlE0SkNCVU1DeGtOQWxVTkdRc01GUWtKRGdVRUJWVUNBUUlGQXdJSEJBUUlCZjJyQkFrREJBY0RBd1VCQWdJQ0FnRUZBd01IQkFNSkJBSlZCUWdFQkFjQ0F3VUNBUUwrZ0lBU0dSa1NnQmtTRVJtQUVoa1pFb0FaRVJJWkFBQUJBT0lBalFNZUFza0FJQUFBRXhjSEJoUVhGakkvQVJjV01qYzJOQzhCTnpZMEp5WWlEd0VuSmlJSEJoUVg0dUxpRFEwTUpBemk0Z3drREEwTjR1SU5EUXdrRE9MaURDUU1EUTBDamVMaURTTU1EUTNoNFEwTkRDTU40dUlNSXcwTURPTGlEQXdOSXd3QUFBQUJBQUFBQVFBQWE1bjB5MThQUFBVQUN3UUFBQUFBQU5pdk9Wc0FBQUFBMks4NVd3QUFBQUFEcXdOVkFBQUFDQUFDQUFBQUFBQUFBQUVBQUFQQS84QUFBQVFBQUFBQUFBT3JBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUxCQUFBQUFBQUFBQUFBQUFBQWdBQUFBUUFBV0lFQUFGaUJBQUE0Z1FBQU9JRUFBQlZCQUFBVlFRQUFPSUFBQUFBQUFvQUZBQWVBRVFBYWdDcUFPb0JuZ0prQXBvQUFRQUFBQXNBaWdBREFBQUFBQUFDQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE0QXJnQUJBQUFBQUFBQkFBY0FBQUFCQUFBQUFBQUNBQWNBWUFBQkFBQUFBQUFEQUFjQU5nQUJBQUFBQUFBRUFBY0FkUUFCQUFBQUFBQUZBQXNBRlFBQkFBQUFBQUFHQUFjQVN3QUJBQUFBQUFBS0FCb0FpZ0FEQUFFRUNRQUJBQTRBQndBREFBRUVDUUFDQUE0QVp3QURBQUVFQ1FBREFBNEFQUUFEQUFFRUNRQUVBQTRBZkFBREFBRUVDUUFGQUJZQUlBQURBQUVFQ1FBR0FBNEFVZ0FEQUFFRUNRQUtBRFFBcEdaamFXTnZibk1BWmdCakFHa0FZd0J2QUc0QWMxWmxjbk5wYjI0Z01TNHdBRllBWlFCeUFITUFhUUJ2QUc0QUlBQXhBQzRBTUdaamFXTnZibk1BWmdCakFHa0FZd0J2QUc0QWMyWmphV052Ym5NQVpnQmpBR2tBWXdCdkFHNEFjMUpsWjNWc1lYSUFVZ0JsQUdjQWRRQnNBR0VBY21aamFXTnZibk1BWmdCakFHa0FZd0J2QUc0QWMwWnZiblFnWjJWdVpYSmhkR1ZrSUdKNUlFbGpiMDF2YjI0dUFFWUFid0J1QUhRQUlBQm5BR1VBYmdCbEFISUFZUUIwQUdVQVpBQWdBR0lBZVFBZ0FFa0FZd0J2QUUwQWJ3QnZBRzRBTGdBQUFBTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE9XFxcIikgZm9ybWF0KFxcXCJ0cnVldHlwZVxcXCIpfS5mYy1pY29ue3NwZWFrOm5vbmU7LXdlYmtpdC1mb250LXNtb290aGluZzphbnRpYWxpYXNlZDstbW96LW9zeC1mb250LXNtb290aGluZzpncmF5c2NhbGU7ZGlzcGxheTppbmxpbmUtYmxvY2s7Zm9udC1mYW1pbHk6ZmNpY29ucyFpbXBvcnRhbnQ7Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDo0MDA7aGVpZ2h0OjFlbTtsaW5lLWhlaWdodDoxO3RleHQtYWxpZ246Y2VudGVyO3RleHQtdHJhbnNmb3JtOm5vbmU7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO3dpZHRoOjFlbX0uZmMtaWNvbi1jaGV2cm9uLWxlZnQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTAwXFxcIn0uZmMtaWNvbi1jaGV2cm9uLXJpZ2h0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwMVxcXCJ9LmZjLWljb24tY2hldnJvbnMtbGVmdDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDJcXFwifS5mYy1pY29uLWNoZXZyb25zLXJpZ2h0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwM1xcXCJ9LmZjLWljb24tbWludXMtc3F1YXJlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwNFxcXCJ9LmZjLWljb24tcGx1cy1zcXVhcmU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTA1XFxcIn0uZmMtaWNvbi14OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwNlxcXCJ9LmZjIC5mYy1idXR0b257Ym9yZGVyLXJhZGl1czowO2ZvbnQtZmFtaWx5OmluaGVyaXQ7Zm9udC1zaXplOmluaGVyaXQ7bGluZS1oZWlnaHQ6aW5oZXJpdDttYXJnaW46MDtvdmVyZmxvdzp2aXNpYmxlO3RleHQtdHJhbnNmb3JtOm5vbmV9LmZjIC5mYy1idXR0b246Zm9jdXN7b3V0bGluZToxcHggZG90dGVkO291dGxpbmU6NXB4IGF1dG8gLXdlYmtpdC1mb2N1cy1yaW5nLWNvbG9yfS5mYyAuZmMtYnV0dG9uey13ZWJraXQtYXBwZWFyYW5jZTpidXR0b259LmZjIC5mYy1idXR0b246bm90KDpkaXNhYmxlZCl7Y3Vyc29yOnBvaW50ZXJ9LmZjIC5mYy1idXR0b257YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXI6MXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yYWRpdXM6LjI1ZW07ZGlzcGxheTppbmxpbmUtYmxvY2s7Zm9udC1zaXplOjFlbTtmb250LXdlaWdodDo0MDA7bGluZS1oZWlnaHQ6MS41O3BhZGRpbmc6LjRlbSAuNjVlbTt0ZXh0LWFsaWduOmNlbnRlcjstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7dmVydGljYWwtYWxpZ246bWlkZGxlfS5mYyAuZmMtYnV0dG9uOmhvdmVye3RleHQtZGVjb3JhdGlvbjpub25lfS5mYyAuZmMtYnV0dG9uOmZvY3Vze2JveC1zaGFkb3c6MCAwIDAgLjJyZW0gcmdiYSg0NCw2Miw4MCwuMjUpO291dGxpbmU6MH0uZmMgLmZjLWJ1dHRvbjpkaXNhYmxlZHtvcGFjaXR5Oi42NX0uZmMgLmZjLWJ1dHRvbi1wcmltYXJ5e2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtYnV0dG9uLWJnLWNvbG9yKTtib3JkZXItY29sb3I6dmFyKC0tZmMtYnV0dG9uLWJvcmRlci1jb2xvcik7Y29sb3I6dmFyKC0tZmMtYnV0dG9uLXRleHQtY29sb3IpfS5mYyAuZmMtYnV0dG9uLXByaW1hcnk6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1idXR0b24taG92ZXItYmctY29sb3IpO2JvcmRlci1jb2xvcjp2YXIoLS1mYy1idXR0b24taG92ZXItYm9yZGVyLWNvbG9yKTtjb2xvcjp2YXIoLS1mYy1idXR0b24tdGV4dC1jb2xvcil9LmZjIC5mYy1idXR0b24tcHJpbWFyeTpkaXNhYmxlZHtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1iZy1jb2xvcik7Ym9yZGVyLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1ib3JkZXItY29sb3IpO2NvbG9yOnZhcigtLWZjLWJ1dHRvbi10ZXh0LWNvbG9yKX0uZmMgLmZjLWJ1dHRvbi1wcmltYXJ5OmZvY3Vze2JveC1zaGFkb3c6MCAwIDAgLjJyZW0gcmdiYSg3Niw5MSwxMDYsLjUpfS5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCkuZmMtYnV0dG9uLWFjdGl2ZSwuZmMgLmZjLWJ1dHRvbi1wcmltYXJ5Om5vdCg6ZGlzYWJsZWQpOmFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1hY3RpdmUtYmctY29sb3IpO2JvcmRlci1jb2xvcjp2YXIoLS1mYy1idXR0b24tYWN0aXZlLWJvcmRlci1jb2xvcik7Y29sb3I6dmFyKC0tZmMtYnV0dG9uLXRleHQtY29sb3IpfS5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCkuZmMtYnV0dG9uLWFjdGl2ZTpmb2N1cywuZmMgLmZjLWJ1dHRvbi1wcmltYXJ5Om5vdCg6ZGlzYWJsZWQpOmFjdGl2ZTpmb2N1c3tib3gtc2hhZG93OjAgMCAwIC4ycmVtIHJnYmEoNzYsOTEsMTA2LC41KX0uZmMgLmZjLWJ1dHRvbiAuZmMtaWNvbntmb250LXNpemU6MS41ZW07dmVydGljYWwtYWxpZ246bWlkZGxlfS5mYyAuZmMtYnV0dG9uLWdyb3Vwe2Rpc3BsYXk6aW5saW5lLWZsZXg7cG9zaXRpb246cmVsYXRpdmU7dmVydGljYWwtYWxpZ246bWlkZGxlfS5mYyAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b257ZmxleDoxIDEgYXV0bztwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uLmZjLWJ1dHRvbi1hY3RpdmUsLmZjIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjphY3RpdmUsLmZjIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpmb2N1cywuZmMgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOmhvdmVye3otaW5kZXg6MX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b246bm90KDpmaXJzdC1jaGlsZCl7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowO2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MDttYXJnaW4tbGVmdDotMXB4fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpub3QoOmxhc3QtY2hpbGQpe2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjA7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6MH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b246bm90KDpmaXJzdC1jaGlsZCl7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowO21hcmdpbi1yaWdodDotMXB4fS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpub3QoOmxhc3QtY2hpbGQpe2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MDtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjB9LmZjIC5mYy10b29sYmFye2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59LmZjIC5mYy10b29sYmFyLmZjLWhlYWRlci10b29sYmFye21hcmdpbi1ib3R0b206MS41ZW19LmZjIC5mYy10b29sYmFyLmZjLWZvb3Rlci10b29sYmFye21hcmdpbi10b3A6MS41ZW19LmZjIC5mYy10b29sYmFyLXRpdGxle2ZvbnQtc2l6ZToxLjc1ZW07bWFyZ2luOjB9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLXRvb2xiYXI+Kj46bm90KDpmaXJzdC1jaGlsZCl7bWFyZ2luLWxlZnQ6Ljc1ZW19LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRvb2xiYXI+Kj46bm90KDpmaXJzdC1jaGlsZCl7bWFyZ2luLXJpZ2h0Oi43NWVtfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy10b29sYmFyLWx0cntmbGV4LWRpcmVjdGlvbjpyb3ctcmV2ZXJzZX0uZmMgLmZjLXNjcm9sbGVyey13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNoO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtc2Nyb2xsZXItbGlxdWlke2hlaWdodDoxMDAlfS5mYyAuZmMtc2Nyb2xsZXItbGlxdWlkLWFic29sdXRle2JvdHRvbTowO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYyAuZmMtc2Nyb2xsZXItaGFybmVzc3tkaXJlY3Rpb246bHRyO292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLXNjcm9sbGVyLWhhcm5lc3MtbGlxdWlke2hlaWdodDoxMDAlfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1zY3JvbGxlci1oYXJuZXNzPi5mYy1zY3JvbGxlcntkaXJlY3Rpb246cnRsfS5mYy10aGVtZS1zdGFuZGFyZCAuZmMtc2Nyb2xsZ3JpZHtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZjLWJvcmRlci1jb2xvcil9LmZjIC5mYy1zY3JvbGxncmlkLC5mYyAuZmMtc2Nyb2xsZ3JpZCB0YWJsZXt0YWJsZS1sYXlvdXQ6Zml4ZWQ7d2lkdGg6MTAwJX0uZmMgLmZjLXNjcm9sbGdyaWQgdGFibGV7Ym9yZGVyLWxlZnQtc3R5bGU6aGlkZGVuO2JvcmRlci1yaWdodC1zdHlsZTpoaWRkZW47Ym9yZGVyLXRvcC1zdHlsZTpoaWRkZW59LmZjIC5mYy1zY3JvbGxncmlke2JvcmRlci1ib3R0b20td2lkdGg6MDtib3JkZXItY29sbGFwc2U6c2VwYXJhdGU7Ym9yZGVyLXJpZ2h0LXdpZHRoOjB9LmZjIC5mYy1zY3JvbGxncmlkLWxpcXVpZHtoZWlnaHQ6MTAwJX0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbiwuZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbiB0YWJsZSwuZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbj50ZHtoZWlnaHQ6MXB4fS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWxpcXVpZD50ZHtoZWlnaHQ6MTAwJX0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbj4qe2JvcmRlci1sZWZ0LXdpZHRoOjA7Ym9yZGVyLXRvcC13aWR0aDowfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWZvb3Rlcj4qLC5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWhlYWRlcj4qe2JvcmRlci1ib3R0b20td2lkdGg6MH0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1ib2R5IHRhYmxlLC5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWZvb3RlciB0YWJsZXtib3JkZXItYm90dG9tLXN0eWxlOmhpZGRlbn0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1zdGlja3k+KntiYWNrZ3JvdW5kOnZhcigtLWZjLXBhZ2UtYmctY29sb3IpO3Bvc2l0aW9uOnN0aWNreTt6LWluZGV4OjN9LmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24taGVhZGVyLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1zdGlja3k+Knt0b3A6MH0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1mb290ZXIuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreT4qe2JvdHRvbTowfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zdGlja3ktc2hpbXtoZWlnaHQ6MXB4O21hcmdpbi1ib3R0b206LTFweH0uZmMtc3RpY2t5e3Bvc2l0aW9uOnN0aWNreX0uZmMgLmZjLXZpZXctaGFybmVzc3tmbGV4LWdyb3c6MTtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLXZpZXctaGFybmVzcy1hY3RpdmU+LmZjLXZpZXd7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjIC5mYy1jb2wtaGVhZGVyLWNlbGwtY3VzaGlvbntkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjJweCA0cHh9LmZjIC5mYy1iZy1ldmVudCwuZmMgLmZjLWhpZ2hsaWdodCwuZmMgLmZjLW5vbi1idXNpbmVzc3tib3R0b206MDtsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0b3A6MH0uZmMgLmZjLW5vbi1idXNpbmVzc3tiYWNrZ3JvdW5kOnZhcigtLWZjLW5vbi1idXNpbmVzcy1jb2xvcil9LmZjIC5mYy1iZy1ldmVudHtiYWNrZ3JvdW5kOnZhcigtLWZjLWJnLWV2ZW50LWNvbG9yKTtvcGFjaXR5OnZhcigtLWZjLWJnLWV2ZW50LW9wYWNpdHkpfS5mYyAuZmMtYmctZXZlbnQgLmZjLWV2ZW50LXRpdGxle2ZvbnQtc2l6ZTp2YXIoLS1mYy1zbWFsbC1mb250LXNpemUpO2ZvbnQtc3R5bGU6aXRhbGljO21hcmdpbjouNWVtfS5mYyAuZmMtaGlnaGxpZ2h0e2JhY2tncm91bmQ6dmFyKC0tZmMtaGlnaGxpZ2h0LWNvbG9yKX0uZmMgLmZjLWNlbGwtc2hhZGVkLC5mYyAuZmMtZGF5LWRpc2FibGVke2JhY2tncm91bmQ6dmFyKC0tZmMtbmV1dHJhbC1iZy1jb2xvcil9YS5mYy1ldmVudCxhLmZjLWV2ZW50OmhvdmVye3RleHQtZGVjb3JhdGlvbjpub25lfS5mYy1ldmVudC5mYy1ldmVudC1kcmFnZ2FibGUsLmZjLWV2ZW50W2hyZWZde2N1cnNvcjpwb2ludGVyfS5mYy1ldmVudCAuZmMtZXZlbnQtbWFpbntwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjJ9LmZjLWV2ZW50LWRyYWdnaW5nOm5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpe29wYWNpdHk6Ljc1fS5mYy1ldmVudC1kcmFnZ2luZy5mYy1ldmVudC1zZWxlY3RlZHtib3gtc2hhZG93OjAgMnB4IDdweCByZ2JhKDAsMCwwLC4zKX0uZmMtZXZlbnQgLmZjLWV2ZW50LXJlc2l6ZXJ7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6NH0uZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXIsLmZjLWV2ZW50OmhvdmVyIC5mYy1ldmVudC1yZXNpemVye2Rpc3BsYXk6YmxvY2t9LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVye2JhY2tncm91bmQ6dmFyKC0tZmMtcGFnZS1iZy1jb2xvcik7Ym9yZGVyLWNvbG9yOmluaGVyaXQ7Ym9yZGVyLXJhZGl1czpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKS8yKTtib3JkZXItc3R5bGU6c29saWQ7Ym9yZGVyLXdpZHRoOnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LWJvcmRlci13aWR0aCk7aGVpZ2h0OnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKTt3aWR0aDp2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCl9LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyOmJlZm9yZXtib3R0b206LTIwcHg7Y29udGVudDpcXFwiXFxcIjtsZWZ0Oi0yMHB4O3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0Oi0yMHB4O3RvcDotMjBweH0uZmMtZXZlbnQtc2VsZWN0ZWQsLmZjLWV2ZW50OmZvY3Vze2JveC1zaGFkb3c6MCAycHggNXB4IHJnYmEoMCwwLDAsLjIpfS5mYy1ldmVudC1zZWxlY3RlZDpiZWZvcmUsLmZjLWV2ZW50OmZvY3VzOmJlZm9yZXtib3R0b206MDtjb250ZW50OlxcXCJcXFwiO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowO3otaW5kZXg6M30uZmMtZXZlbnQtc2VsZWN0ZWQ6YWZ0ZXIsLmZjLWV2ZW50OmZvY3VzOmFmdGVye2JhY2tncm91bmQ6dmFyKC0tZmMtZXZlbnQtc2VsZWN0ZWQtb3ZlcmxheS1jb2xvcik7Ym90dG9tOi0xcHg7Y29udGVudDpcXFwiXFxcIjtsZWZ0Oi0xcHg7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6LTFweDt0b3A6LTFweDt6LWluZGV4OjF9LmZjLWgtZXZlbnR7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1ldmVudC1iZy1jb2xvcik7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mYy1ldmVudC1ib3JkZXItY29sb3IpO2Rpc3BsYXk6YmxvY2t9LmZjLWgtZXZlbnQgLmZjLWV2ZW50LW1haW57Y29sb3I6dmFyKC0tZmMtZXZlbnQtdGV4dC1jb2xvcil9LmZjLWgtZXZlbnQgLmZjLWV2ZW50LW1haW4tZnJhbWV7ZGlzcGxheTpmbGV4fS5mYy1oLWV2ZW50IC5mYy1ldmVudC10aW1le21heC13aWR0aDoxMDAlO292ZXJmbG93OmhpZGRlbn0uZmMtaC1ldmVudCAuZmMtZXZlbnQtdGl0bGUtY29udGFpbmVye2ZsZXgtZ3JvdzoxO2ZsZXgtc2hyaW5rOjE7bWluLXdpZHRoOjB9LmZjLWgtZXZlbnQgLmZjLWV2ZW50LXRpdGxle2Rpc3BsYXk6aW5saW5lLWJsb2NrO2xlZnQ6MDttYXgtd2lkdGg6MTAwJTtvdmVyZmxvdzpoaWRkZW47cmlnaHQ6MDt2ZXJ0aWNhbC1hbGlnbjp0b3B9LmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQ6YmVmb3Jle2JvdHRvbTotMTBweDt0b3A6LTEwcHh9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtYmxvY2stZXZlbnQ6bm90KC5mYy1ldmVudC1zdGFydCksLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtYmxvY2stZXZlbnQ6bm90KC5mYy1ldmVudC1lbmQpe2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MDtib3JkZXItbGVmdC13aWR0aDowO2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LWVuZCksLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtYmxvY2stZXZlbnQ6bm90KC5mYy1ldmVudC1zdGFydCl7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItcmlnaHQtd2lkdGg6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowfS5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVye2JvdHRvbTowO3RvcDowO3dpZHRoOnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzKX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1zdGFydCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1lbmR7Y3Vyc29yOnctcmVzaXplO2xlZnQ6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcykqLS41KX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1lbmQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWgtZXZlbnQ6bm90KC5mYy1ldmVudC1zZWxlY3RlZCkgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnR7Y3Vyc29yOmUtcmVzaXplO3JpZ2h0OmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci10aGlja25lc3MpKi0uNSl9LmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXJ7bWFyZ2luLXRvcDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKSotLjUpO3RvcDo1MCV9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItZW5ke2xlZnQ6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCkqLS41KX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1lbmQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnR7cmlnaHQ6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCkqLS41KX0uZmMgLmZjLXBvcG92ZXJ7Ym94LXNoYWRvdzowIDJweCA2cHggcmdiYSgwLDAsMCwuMTUpO3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6OTk5OX0uZmMgLmZjLXBvcG92ZXItaGVhZGVye2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246cm93O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO3BhZGRpbmc6M3B4IDRweH0uZmMgLmZjLXBvcG92ZXItdGl0bGV7bWFyZ2luOjAgMnB4fS5mYyAuZmMtcG9wb3Zlci1jbG9zZXtjdXJzb3I6cG9pbnRlcjtmb250LXNpemU6MS4xZW07b3BhY2l0eTouNjV9LmZjLXRoZW1lLXN0YW5kYXJkIC5mYy1wb3BvdmVye2JhY2tncm91bmQ6dmFyKC0tZmMtcGFnZS1iZy1jb2xvcik7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mYy1ib3JkZXItY29sb3IpfS5mYy10aGVtZS1zdGFuZGFyZCAuZmMtcG9wb3Zlci1oZWFkZXJ7YmFja2dyb3VuZDp2YXIoLS1mYy1uZXV0cmFsLWJnLWNvbG9yKX1cIjtcbmluamVjdFN0eWxlcyhjc3NfMjQ4eik7XG5cbmNsYXNzIERlbGF5ZWRSdW5uZXIge1xuICAgIGNvbnN0cnVjdG9yKGRyYWluZWRPcHRpb24pIHtcbiAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uID0gZHJhaW5lZE9wdGlvbjtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGF1c2VEZXB0aHMgPSB7fTtcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSAwO1xuICAgIH1cbiAgICByZXF1ZXN0KGRlbGF5KSB7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgICAgICAgaWYgKGRlbGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeURyYWluKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoLy8gTk9UIE9QVElNQUwhIFRPRE86IGxvb2sgYXQgZGVib3VuY2VcbiAgICAgICAgICAgICAgICB0aGlzLnRyeURyYWluLmJpbmQodGhpcyksIGRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXVzZShzY29wZSA9ICcnKSB7XG4gICAgICAgIGxldCB7IHBhdXNlRGVwdGhzIH0gPSB0aGlzO1xuICAgICAgICBwYXVzZURlcHRoc1tzY29wZV0gPSAocGF1c2VEZXB0aHNbc2NvcGVdIHx8IDApICsgMTtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICB9XG4gICAgcmVzdW1lKHNjb3BlID0gJycsIGZvcmNlKSB7XG4gICAgICAgIGxldCB7IHBhdXNlRGVwdGhzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoc2NvcGUgaW4gcGF1c2VEZXB0aHMpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXVzZURlcHRoc1tzY29wZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXVzZURlcHRoc1tzY29wZV0gLT0gMTtcbiAgICAgICAgICAgICAgICBsZXQgZGVwdGggPSBwYXVzZURlcHRoc1tzY29wZV07XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhdXNlRGVwdGhzW3Njb3BlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyeURyYWluKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNQYXVzZWQoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnBhdXNlRGVwdGhzKS5sZW5ndGg7XG4gICAgfVxuICAgIHRyeURyYWluKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nICYmICF0aGlzLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWluZWQoKTsgLy8gbWlnaHQgc2V0IGlzRGlydHkgdG8gdHJ1ZSBhZ2FpblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGF1c2VEZXB0aHMgPSB7fTtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhaW5lZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhaW5lZE9wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWwpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICB9XG59XG4vLyBRdWVyeWluZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gZWxlbWVudENsb3Nlc3QoZWwsIHNlbGVjdG9yKSB7XG4gICAgaWYgKGVsLmNsb3Nlc3QpIHtcbiAgICAgICAgcmV0dXJuIGVsLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICAgICAgICAvLyByZWFsbHkgYmFkIGZhbGxiYWNrIGZvciBJRVxuICAgICAgICAvLyBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2Nsb3Nlc3RcbiAgICB9XG4gICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZWwpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkbyB7XG4gICAgICAgIGlmIChlbGVtZW50TWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSAoZWwucGFyZW50RWxlbWVudCB8fCBlbC5wYXJlbnROb2RlKTtcbiAgICB9IHdoaWxlIChlbCAhPT0gbnVsbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlcyhlbCwgc2VsZWN0b3IpIHtcbiAgICBsZXQgbWV0aG9kID0gZWwubWF0Y2hlcyB8fCBlbC5tYXRjaGVzU2VsZWN0b3IgfHwgZWwubXNNYXRjaGVzU2VsZWN0b3I7XG4gICAgcmV0dXJuIG1ldGhvZC5jYWxsKGVsLCBzZWxlY3Rvcik7XG59XG4vLyBhY2NlcHRzIG11bHRpcGxlIHN1YmplY3QgZWxzXG4vLyByZXR1cm5zIGEgcmVhbCBhcnJheS4gZ29vZCBmb3IgbWV0aG9kcyBsaWtlIGZvckVhY2hcbi8vIFRPRE86IGFjY2VwdCB0aGUgZG9jdW1lbnRcbmZ1bmN0aW9uIGZpbmRFbGVtZW50cyhjb250YWluZXIsIHNlbGVjdG9yKSB7XG4gICAgbGV0IGNvbnRhaW5lcnMgPSBjb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IFtjb250YWluZXJdIDogY29udGFpbmVyO1xuICAgIGxldCBhbGxNYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250YWluZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBtYXRjaGVzID0gY29udGFpbmVyc1tpXS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRjaGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBhbGxNYXRjaGVzLnB1c2gobWF0Y2hlc1tqXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFsbE1hdGNoZXM7XG59XG4vLyBhY2NlcHRzIG11bHRpcGxlIHN1YmplY3QgZWxzXG4vLyBvbmx5IHF1ZXJpZXMgZGlyZWN0IGNoaWxkIGVsZW1lbnRzIC8vIFRPRE86IHJlbmFtZSB0byBmaW5kRGlyZWN0Q2hpbGRyZW4hXG5mdW5jdGlvbiBmaW5kRGlyZWN0Q2hpbGRyZW4ocGFyZW50LCBzZWxlY3Rvcikge1xuICAgIGxldCBwYXJlbnRzID0gcGFyZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBbcGFyZW50XSA6IHBhcmVudDtcbiAgICBsZXQgYWxsTWF0Y2hlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBsZXQgY2hpbGROb2RlcyA9IHBhcmVudHNbaV0uY2hpbGRyZW47IC8vIG9ubHkgZXZlciBlbGVtZW50c1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkTm9kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2pdO1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RvciB8fCBlbGVtZW50TWF0Y2hlcyhjaGlsZE5vZGUsIHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIGFsbE1hdGNoZXMucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbGxNYXRjaGVzO1xufVxuLy8gU3R5bGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNvbnN0IFBJWEVMX1BST1BfUkUgPSAvKHRvcHxsZWZ0fHJpZ2h0fGJvdHRvbXx3aWR0aHxoZWlnaHQpJC9pO1xuZnVuY3Rpb24gYXBwbHlTdHlsZShlbCwgcHJvcHMpIHtcbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgICAgICBhcHBseVN0eWxlUHJvcChlbCwgcHJvcE5hbWUsIHByb3BzW3Byb3BOYW1lXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlTdHlsZVByb3AoZWwsIG5hbWUsIHZhbCkge1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICBlbC5zdHlsZVtuYW1lXSA9ICcnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiBQSVhFTF9QUk9QX1JFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZWwuc3R5bGVbbmFtZV0gPSBgJHt2YWx9cHhgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWwuc3R5bGVbbmFtZV0gPSB2YWw7XG4gICAgfVxufVxuLy8gRXZlbnQgSGFuZGxpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGlmIGludGVyY2VwdGluZyBidWJibGVkIGV2ZW50cyBhdCB0aGUgZG9jdW1lbnQvd2luZG93L2JvZHkgbGV2ZWwsXG4vLyBhbmQgd2FudCB0byBzZWUgb3JpZ2luYXRpbmcgZWxlbWVudCAodGhlICd0YXJnZXQnKSwgdXNlIHRoaXMgdXRpbCBpbnN0ZWFkXG4vLyBvZiBgZXYudGFyZ2V0YCBiZWNhdXNlIGl0IGdvZXMgd2l0aGluIHdlYi1jb21wb25lbnQgYm91bmRhcmllcy5cbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0VmlhUm9vdChldikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IGV2LmNvbXBvc2VkUGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZXYpWzBdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBldi50YXJnZXQ7XG59XG4vLyBVbmlxdWUgSUQgZm9yIERPTSBhdHRyaWJ1dGVcbmxldCBndWlkJDEgPSAwO1xuZnVuY3Rpb24gZ2V0VW5pcXVlRG9tSWQoKSB7XG4gICAgZ3VpZCQxICs9IDE7XG4gICAgcmV0dXJuICdmYy1kb20tJyArIGd1aWQkMTtcbn1cblxuLy8gU3RvcHMgYSBtb3VzZS90b3VjaCBldmVudCBmcm9tIGRvaW5nIGl0J3MgbmF0aXZlIGJyb3dzZXIgYWN0aW9uXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldikge1xuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG59XG4vLyBFdmVudCBEZWxlZ2F0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBidWlsZERlbGVnYXRpb25IYW5kbGVyKHNlbGVjdG9yLCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuIChldikgPT4ge1xuICAgICAgICBsZXQgbWF0Y2hlZENoaWxkID0gZWxlbWVudENsb3Nlc3QoZXYudGFyZ2V0LCBzZWxlY3Rvcik7XG4gICAgICAgIGlmIChtYXRjaGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbChtYXRjaGVkQ2hpbGQsIGV2LCBtYXRjaGVkQ2hpbGQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxpc3RlbkJ5U2VsZWN0b3IoY29udGFpbmVyLCBldmVudFR5cGUsIHNlbGVjdG9yLCBoYW5kbGVyKSB7XG4gICAgbGV0IGF0dGFjaGVkSGFuZGxlciA9IGJ1aWxkRGVsZWdhdGlvbkhhbmRsZXIoc2VsZWN0b3IsIGhhbmRsZXIpO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgYXR0YWNoZWRIYW5kbGVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGF0dGFjaGVkSGFuZGxlcik7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxpc3RlblRvSG92ZXJCeVNlbGVjdG9yKGNvbnRhaW5lciwgc2VsZWN0b3IsIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlKSB7XG4gICAgbGV0IGN1cnJlbnRNYXRjaGVkQ2hpbGQ7XG4gICAgcmV0dXJuIGxpc3RlbkJ5U2VsZWN0b3IoY29udGFpbmVyLCAnbW91c2VvdmVyJywgc2VsZWN0b3IsIChtb3VzZU92ZXJFdiwgbWF0Y2hlZENoaWxkKSA9PiB7XG4gICAgICAgIGlmIChtYXRjaGVkQ2hpbGQgIT09IGN1cnJlbnRNYXRjaGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRNYXRjaGVkQ2hpbGQgPSBtYXRjaGVkQ2hpbGQ7XG4gICAgICAgICAgICBvbk1vdXNlRW50ZXIobW91c2VPdmVyRXYsIG1hdGNoZWRDaGlsZCk7XG4gICAgICAgICAgICBsZXQgcmVhbE9uTW91c2VMZWF2ZSA9IChtb3VzZUxlYXZlRXYpID0+IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWF0Y2hlZENoaWxkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmUobW91c2VMZWF2ZUV2LCBtYXRjaGVkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIG1hdGNoZWRDaGlsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gbGlzdGVuIHRvIHRoZSBuZXh0IG1vdXNlbGVhdmUsIGFuZCB0aGVuIHVuYXR0YWNoXG4gICAgICAgICAgICBtYXRjaGVkQ2hpbGQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHJlYWxPbk1vdXNlTGVhdmUpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyBBbmltYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNvbnN0IHRyYW5zaXRpb25FdmVudE5hbWVzID0gW1xuICAgICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAnb3RyYW5zaXRpb25lbmQnLFxuICAgICdvVHJhbnNpdGlvbkVuZCcsXG4gICAgJ21zVHJhbnNpdGlvbkVuZCcsXG4gICAgJ3RyYW5zaXRpb25lbmQnLFxuXTtcbi8vIHRyaWdnZXJlZCBvbmx5IHdoZW4gdGhlIG5leHQgc2luZ2xlIHN1YnNlcXVlbnQgdHJhbnNpdGlvbiBmaW5pc2hlc1xuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25Eb25lKGVsLCBjYWxsYmFjaykge1xuICAgIGxldCByZWFsQ2FsbGJhY2sgPSAoZXYpID0+IHtcbiAgICAgICAgY2FsbGJhY2soZXYpO1xuICAgICAgICB0cmFuc2l0aW9uRXZlbnROYW1lcy5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCByZWFsQ2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRyYW5zaXRpb25FdmVudE5hbWVzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgcmVhbENhbGxiYWNrKTsgLy8gY3Jvc3MtYnJvd3NlciB3YXkgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIHRyYW5zaXRpb24gZmluaXNoZXNcbiAgICB9KTtcbn1cbi8vIEFSSUEgd29ya2Fyb3VuZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGNyZWF0ZUFyaWFDbGlja0F0dHJzKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IG9uQ2xpY2s6IGhhbmRsZXIgfSwgY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoaGFuZGxlcikpO1xufVxuZnVuY3Rpb24gY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoaGFuZGxlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICBvbktleURvd24oZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5rZXkgPT09ICdFbnRlcicgfHwgZXYua2V5ID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGV2KTtcbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpOyAvLyBpZiBzcGFjZSwgZG9uJ3Qgc2Nyb2xsIGRvd24gcGFnZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG5cbmxldCBndWlkTnVtYmVyID0gMDtcbmZ1bmN0aW9uIGd1aWQoKSB7XG4gICAgZ3VpZE51bWJlciArPSAxO1xuICAgIHJldHVybiBTdHJpbmcoZ3VpZE51bWJlcik7XG59XG4vKiBGdWxsQ2FsZW5kYXItc3BlY2lmaWMgRE9NIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBNYWtlIHRoZSBtb3VzZSBjdXJzb3IgZXhwcmVzcyB0aGF0IGFuIGV2ZW50IGlzIG5vdCBhbGxvd2VkIGluIHRoZSBjdXJyZW50IGFyZWFcbmZ1bmN0aW9uIGRpc2FibGVDdXJzb3IoKSB7XG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdmYy1ub3QtYWxsb3dlZCcpO1xufVxuLy8gUmV0dXJucyB0aGUgbW91c2UgY3Vyc29yIHRvIGl0cyBvcmlnaW5hbCBsb29rXG5mdW5jdGlvbiBlbmFibGVDdXJzb3IoKSB7XG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdmYy1ub3QtYWxsb3dlZCcpO1xufVxuLyogU2VsZWN0aW9uXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIHByZXZlbnRTZWxlY3Rpb24oZWwpIHtcbiAgICBlbC5zdHlsZS51c2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgIGVsLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG5mdW5jdGlvbiBhbGxvd1NlbGVjdGlvbihlbCkge1xuICAgIGVsLnN0eWxlLnVzZXJTZWxlY3QgPSAnJztcbiAgICBlbC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gJyc7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG4vKiBDb250ZXh0IE1lbnVcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gcHJldmVudENvbnRleHRNZW51KGVsKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG5mdW5jdGlvbiBhbGxvd0NvbnRleHRNZW51KGVsKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG5mdW5jdGlvbiBwYXJzZUZpZWxkU3BlY3MoaW5wdXQpIHtcbiAgICBsZXQgc3BlY3MgPSBbXTtcbiAgICBsZXQgdG9rZW5zID0gW107XG4gICAgbGV0IGk7XG4gICAgbGV0IHRva2VuO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRva2VucyA9IGlucHV0LnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRva2VucyA9IFtpbnB1dF07XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHRva2VucyA9IGlucHV0O1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc3BlY3MucHVzaCh0b2tlbi5jaGFyQXQoMCkgPT09ICctJyA/XG4gICAgICAgICAgICAgICAgeyBmaWVsZDogdG9rZW4uc3Vic3RyaW5nKDEpLCBvcmRlcjogLTEgfSA6XG4gICAgICAgICAgICAgICAgeyBmaWVsZDogdG9rZW4sIG9yZGVyOiAxIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3BlY3MucHVzaCh7IGZ1bmM6IHRva2VuIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGVjcztcbn1cbmZ1bmN0aW9uIGNvbXBhcmVCeUZpZWxkU3BlY3Mob2JqMCwgb2JqMSwgZmllbGRTcGVjcykge1xuICAgIGxldCBpO1xuICAgIGxldCBjbXA7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpZWxkU3BlY3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY21wID0gY29tcGFyZUJ5RmllbGRTcGVjKG9iajAsIG9iajEsIGZpZWxkU3BlY3NbaV0pO1xuICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gY29tcGFyZUJ5RmllbGRTcGVjKG9iajAsIG9iajEsIGZpZWxkU3BlYykge1xuICAgIGlmIChmaWVsZFNwZWMuZnVuYykge1xuICAgICAgICByZXR1cm4gZmllbGRTcGVjLmZ1bmMob2JqMCwgb2JqMSk7XG4gICAgfVxuICAgIHJldHVybiBmbGV4aWJsZUNvbXBhcmUob2JqMFtmaWVsZFNwZWMuZmllbGRdLCBvYmoxW2ZpZWxkU3BlYy5maWVsZF0pXG4gICAgICAgICogKGZpZWxkU3BlYy5vcmRlciB8fCAxKTtcbn1cbmZ1bmN0aW9uIGZsZXhpYmxlQ29tcGFyZShhLCBiKSB7XG4gICAgaWYgKCFhICYmICFiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoYiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhhKS5sb2NhbGVDb21wYXJlKFN0cmluZyhiKSk7XG4gICAgfVxuICAgIHJldHVybiBhIC0gYjtcbn1cbi8qIFN0cmluZyBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gcGFkU3RhcnQodmFsLCBsZW4pIHtcbiAgICBsZXQgcyA9IFN0cmluZyh2YWwpO1xuICAgIHJldHVybiAnMDAwJy5zdWJzdHIoMCwgbGVuIC0gcy5sZW5ndGgpICsgcztcbn1cbmZ1bmN0aW9uIGZvcm1hdFdpdGhPcmRpbmFscyhmb3JtYXR0ZXIsIGFyZ3MsIGZhbGxiYWNrVGV4dCkge1xuICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIoLi4uYXJncyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnc3RyaW5nJykgeyAvLyBub24tYmxhbmsgc3RyaW5nXG4gICAgICAgIHJldHVybiBhcmdzLnJlZHVjZSgoc3RyLCBhcmcsIGluZGV4KSA9PiAoc3RyLnJlcGxhY2UoJyQnICsgaW5kZXgsIGFyZyB8fCAnJykpLCBmb3JtYXR0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsbGJhY2tUZXh0O1xufVxuLyogTnVtYmVyIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBjb21wYXJlTnVtYmVycyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuZnVuY3Rpb24gaXNJbnQobikge1xuICAgIHJldHVybiBuICUgMSA9PT0gMDtcbn1cbi8qIEZDLXNwZWNpZmljIERPTSBkaW1lbnNpb24gc3R1ZmZcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoKGNlbGxFbCkge1xuICAgIGxldCBhbGxXaWR0aEVsID0gY2VsbEVsLnF1ZXJ5U2VsZWN0b3IoJy5mYy1zY3JvbGxncmlkLXNocmluay1mcmFtZScpO1xuICAgIGxldCBjb250ZW50V2lkdGhFbCA9IGNlbGxFbC5xdWVyeVNlbGVjdG9yKCcuZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbicpO1xuICAgIGlmICghYWxsV2lkdGhFbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWRzIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lIGNsYXNzTmFtZScpOyAvLyBUT0RPOiB1c2UgY29uc3RcbiAgICB9XG4gICAgaWYgKCFjb250ZW50V2lkdGhFbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWRzIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24gY2xhc3NOYW1lJyk7XG4gICAgfVxuICAgIHJldHVybiBjZWxsRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSBhbGxXaWR0aEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICsgLy8gdGhlIGNlbGwgcGFkZGluZytib3JkZXJcbiAgICAgICAgY29udGVudFdpZHRoRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG59XG5cbmNvbnN0IElOVEVSTkFMX1VOSVRTID0gWyd5ZWFycycsICdtb250aHMnLCAnZGF5cycsICdtaWxsaXNlY29uZHMnXTtcbmNvbnN0IFBBUlNFX1JFID0gL14oLT8pKD86KFxcZCspXFwuKT8oXFxkKyk6KFxcZFxcZCkoPzo6KFxcZFxcZCkoPzpcXC4oXFxkXFxkXFxkKSk/KT8vO1xuLy8gUGFyc2luZyBhbmQgQ3JlYXRpb25cbmZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uKGlucHV0LCB1bml0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nKGlucHV0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgIHJldHVybiBwYXJzZU9iamVjdChpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBwYXJzZU9iamVjdCh7IFt1bml0IHx8ICdtaWxsaXNlY29uZHMnXTogaW5wdXQgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VTdHJpbmcocykge1xuICAgIGxldCBtID0gUEFSU0VfUkUuZXhlYyhzKTtcbiAgICBpZiAobSkge1xuICAgICAgICBsZXQgc2lnbiA9IG1bMV0gPyAtMSA6IDE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgICAgIGRheXM6IHNpZ24gKiAobVsyXSA/IHBhcnNlSW50KG1bMl0sIDEwKSA6IDApLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBzaWduICogKChtWzNdID8gcGFyc2VJbnQobVszXSwgMTApIDogMCkgKiA2MCAqIDYwICogMTAwMCArIC8vIGhvdXJzXG4gICAgICAgICAgICAgICAgKG1bNF0gPyBwYXJzZUludChtWzRdLCAxMCkgOiAwKSAqIDYwICogMTAwMCArIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgICAgICAobVs1XSA/IHBhcnNlSW50KG1bNV0sIDEwKSA6IDApICogMTAwMCArIC8vIHNlY29uZHNcbiAgICAgICAgICAgICAgICAobVs2XSA/IHBhcnNlSW50KG1bNl0sIDEwKSA6IDApIC8vIG1zXG4gICAgICAgICAgICApLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KG9iaikge1xuICAgIGxldCBkdXJhdGlvbiA9IHtcbiAgICAgICAgeWVhcnM6IG9iai55ZWFycyB8fCBvYmoueWVhciB8fCAwLFxuICAgICAgICBtb250aHM6IG9iai5tb250aHMgfHwgb2JqLm1vbnRoIHx8IDAsXG4gICAgICAgIGRheXM6IG9iai5kYXlzIHx8IG9iai5kYXkgfHwgMCxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiAob2JqLmhvdXJzIHx8IG9iai5ob3VyIHx8IDApICogNjAgKiA2MCAqIDEwMDAgKyAvLyBob3Vyc1xuICAgICAgICAgICAgKG9iai5taW51dGVzIHx8IG9iai5taW51dGUgfHwgMCkgKiA2MCAqIDEwMDAgKyAvLyBtaW51dGVzXG4gICAgICAgICAgICAob2JqLnNlY29uZHMgfHwgb2JqLnNlY29uZCB8fCAwKSAqIDEwMDAgKyAvLyBzZWNvbmRzXG4gICAgICAgICAgICAob2JqLm1pbGxpc2Vjb25kcyB8fCBvYmoubWlsbGlzZWNvbmQgfHwgb2JqLm1zIHx8IDApLCAvLyBtc1xuICAgIH07XG4gICAgbGV0IHdlZWtzID0gb2JqLndlZWtzIHx8IG9iai53ZWVrO1xuICAgIGlmICh3ZWVrcykge1xuICAgICAgICBkdXJhdGlvbi5kYXlzICs9IHdlZWtzICogNztcbiAgICAgICAgZHVyYXRpb24uc3BlY2lmaWVkV2Vla3MgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZHVyYXRpb247XG59XG4vLyBFcXVhbGl0eVxuZnVuY3Rpb24gZHVyYXRpb25zRXF1YWwoZDAsIGQxKSB7XG4gICAgcmV0dXJuIGQwLnllYXJzID09PSBkMS55ZWFycyAmJlxuICAgICAgICBkMC5tb250aHMgPT09IGQxLm1vbnRocyAmJlxuICAgICAgICBkMC5kYXlzID09PSBkMS5kYXlzICYmXG4gICAgICAgIGQwLm1pbGxpc2Vjb25kcyA9PT0gZDEubWlsbGlzZWNvbmRzO1xufVxuZnVuY3Rpb24gYXNDbGVhbkRheXMoZHVyKSB7XG4gICAgaWYgKCFkdXIueWVhcnMgJiYgIWR1ci5tb250aHMgJiYgIWR1ci5taWxsaXNlY29uZHMpIHtcbiAgICAgICAgcmV0dXJuIGR1ci5kYXlzO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbi8vIFNpbXBsZSBNYXRoXG5mdW5jdGlvbiBhZGREdXJhdGlvbnMoZDAsIGQxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IGQwLnllYXJzICsgZDEueWVhcnMsXG4gICAgICAgIG1vbnRoczogZDAubW9udGhzICsgZDEubW9udGhzLFxuICAgICAgICBkYXlzOiBkMC5kYXlzICsgZDEuZGF5cyxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBkMC5taWxsaXNlY29uZHMgKyBkMS5taWxsaXNlY29uZHMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN1YnRyYWN0RHVyYXRpb25zKGQxLCBkMCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHllYXJzOiBkMS55ZWFycyAtIGQwLnllYXJzLFxuICAgICAgICBtb250aHM6IGQxLm1vbnRocyAtIGQwLm1vbnRocyxcbiAgICAgICAgZGF5czogZDEuZGF5cyAtIGQwLmRheXMsXG4gICAgICAgIG1pbGxpc2Vjb25kczogZDEubWlsbGlzZWNvbmRzIC0gZDAubWlsbGlzZWNvbmRzLFxuICAgIH07XG59XG5mdW5jdGlvbiBtdWx0aXBseUR1cmF0aW9uKGQsIG4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogZC55ZWFycyAqIG4sXG4gICAgICAgIG1vbnRoczogZC5tb250aHMgKiBuLFxuICAgICAgICBkYXlzOiBkLmRheXMgKiBuLFxuICAgICAgICBtaWxsaXNlY29uZHM6IGQubWlsbGlzZWNvbmRzICogbixcbiAgICB9O1xufVxuLy8gQ29udmVyc2lvbnNcbi8vIFwiUm91Z2hcIiBiZWNhdXNlIHRoZXkgYXJlIGJhc2VkIG9uIGF2ZXJhZ2UtY2FzZSBHcmVnb3JpYW4gbW9udGhzL3llYXJzXG5mdW5jdGlvbiBhc1JvdWdoWWVhcnMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hEYXlzKGR1cikgLyAzNjU7XG59XG5mdW5jdGlvbiBhc1JvdWdoTW9udGhzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoRGF5cyhkdXIpIC8gMzA7XG59XG5mdW5jdGlvbiBhc1JvdWdoRGF5cyhkdXIpIHtcbiAgICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyA4NjRlNTtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNaW51dGVzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvICgxMDAwICogNjApO1xufVxuZnVuY3Rpb24gYXNSb3VnaFNlY29uZHMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hNcyhkdXIpIC8gMTAwMDtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNcyhkdXIpIHtcbiAgICByZXR1cm4gZHVyLnllYXJzICogKDM2NSAqIDg2NGU1KSArXG4gICAgICAgIGR1ci5tb250aHMgKiAoMzAgKiA4NjRlNSkgK1xuICAgICAgICBkdXIuZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgZHVyLm1pbGxpc2Vjb25kcztcbn1cbi8vIEFkdmFuY2VkIE1hdGhcbmZ1bmN0aW9uIHdob2xlRGl2aWRlRHVyYXRpb25zKG51bWVyYXRvciwgZGVub21pbmF0b3IpIHtcbiAgICBsZXQgcmVzID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IElOVEVSTkFMX1VOSVRTLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCB1bml0ID0gSU5URVJOQUxfVU5JVFNbaV07XG4gICAgICAgIGlmIChkZW5vbWluYXRvclt1bml0XSkge1xuICAgICAgICAgICAgbGV0IGxvY2FsUmVzID0gbnVtZXJhdG9yW3VuaXRdIC8gZGVub21pbmF0b3JbdW5pdF07XG4gICAgICAgICAgICBpZiAoIWlzSW50KGxvY2FsUmVzKSB8fCAocmVzICE9PSBudWxsICYmIHJlcyAhPT0gbG9jYWxSZXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSBsb2NhbFJlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW1lcmF0b3JbdW5pdF0pIHtcbiAgICAgICAgICAgIC8vIG5lZWRzIHRvIGRpdmlkZSBieSBzb21ldGhpbmcgYnV0IGNhbid0IVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXIpIHtcbiAgICBsZXQgbXMgPSBkdXIubWlsbGlzZWNvbmRzO1xuICAgIGlmIChtcykge1xuICAgICAgICBpZiAobXMgJSAxMDAwICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogbXMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwKSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3NlY29uZCcsIHZhbHVlOiBtcyAvIDEwMDAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwICogNjApICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWludXRlJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCkgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdob3VyJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCAqIDYwKSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkdXIuZGF5cykge1xuICAgICAgICBpZiAoZHVyLnNwZWNpZmllZFdlZWtzICYmIGR1ci5kYXlzICUgNyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3dlZWsnLCB2YWx1ZTogZHVyLmRheXMgLyA3IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2RheScsIHZhbHVlOiBkdXIuZGF5cyB9O1xuICAgIH1cbiAgICBpZiAoZHVyLm1vbnRocykge1xuICAgICAgICByZXR1cm4geyB1bml0OiAnbW9udGgnLCB2YWx1ZTogZHVyLm1vbnRocyB9O1xuICAgIH1cbiAgICBpZiAoZHVyLnllYXJzKSB7XG4gICAgICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IGR1ci55ZWFycyB9O1xuICAgIH1cbiAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogMCB9O1xufVxuXG4vLyBUT0RPOiBuZXcgdXRpbCBhcnJheWlmeT9cbmZ1bmN0aW9uIHJlbW92ZUV4YWN0KGFycmF5LCBleGFjdFZhbCkge1xuICAgIGxldCByZW1vdmVDbnQgPSAwO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICBpZiAoYXJyYXlbaV0gPT09IGV4YWN0VmFsKSB7XG4gICAgICAgICAgICBhcnJheS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZW1vdmVDbnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVtb3ZlQ250O1xufVxuZnVuY3Rpb24gaXNBcnJheXNFcXVhbChhMCwgYTEsIGVxdWFsaXR5RnVuYykge1xuICAgIGlmIChhMCA9PT0gYTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBsZW4gPSBhMC5sZW5ndGg7XG4gICAgbGV0IGk7XG4gICAgaWYgKGxlbiAhPT0gYTEubGVuZ3RoKSB7IC8vIG5vdCBhcnJheT8gb3Igbm90IHNhbWUgbGVuZ3RoP1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoIShlcXVhbGl0eUZ1bmMgPyBlcXVhbGl0eUZ1bmMoYTBbaV0sIGExW2ldKSA6IGEwW2ldID09PSBhMVtpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgREFZX0lEUyA9IFsnc3VuJywgJ21vbicsICd0dWUnLCAnd2VkJywgJ3RodScsICdmcmknLCAnc2F0J107XG4vLyBBZGRpbmdcbmZ1bmN0aW9uIGFkZFdlZWtzKG0sIG4pIHtcbiAgICBsZXQgYSA9IGRhdGVUb1V0Y0FycmF5KG0pO1xuICAgIGFbMl0gKz0gbiAqIDc7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuZnVuY3Rpb24gYWRkRGF5cyhtLCBuKSB7XG4gICAgbGV0IGEgPSBkYXRlVG9VdGNBcnJheShtKTtcbiAgICBhWzJdICs9IG47XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuZnVuY3Rpb24gYWRkTXMobSwgbikge1xuICAgIGxldCBhID0gZGF0ZVRvVXRjQXJyYXkobSk7XG4gICAgYVs2XSArPSBuO1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhKTtcbn1cbi8vIERpZmZpbmcgKGFsbCByZXR1cm4gZmxvYXRzKVxuLy8gVE9ETzogd2h5IG5vdCB1c2UgcmFuZ2VzP1xuZnVuY3Rpb24gZGlmZldlZWtzKG0wLCBtMSkge1xuICAgIHJldHVybiBkaWZmRGF5cyhtMCwgbTEpIC8gNztcbn1cbmZ1bmN0aW9uIGRpZmZEYXlzKG0wLCBtMSkge1xuICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KTtcbn1cbmZ1bmN0aW9uIGRpZmZIb3VycyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAoMTAwMCAqIDYwICogNjApO1xufVxuZnVuY3Rpb24gZGlmZk1pbnV0ZXMobTAsIG0xKSB7XG4gICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gKDEwMDAgKiA2MCk7XG59XG5mdW5jdGlvbiBkaWZmU2Vjb25kcyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAxMDAwO1xufVxuZnVuY3Rpb24gZGlmZkRheUFuZFRpbWUobTAsIG0xKSB7XG4gICAgbGV0IG0wZGF5ID0gc3RhcnRPZkRheShtMCk7XG4gICAgbGV0IG0xZGF5ID0gc3RhcnRPZkRheShtMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IDAsXG4gICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgZGF5czogTWF0aC5yb3VuZChkaWZmRGF5cyhtMGRheSwgbTFkYXkpKSxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiAobTEudmFsdWVPZigpIC0gbTFkYXkudmFsdWVPZigpKSAtIChtMC52YWx1ZU9mKCkgLSBtMGRheS52YWx1ZU9mKCkpLFxuICAgIH07XG59XG4vLyBEaWZmaW5nIFdob2xlIFVuaXRzXG5mdW5jdGlvbiBkaWZmV2hvbGVXZWVrcyhtMCwgbTEpIHtcbiAgICBsZXQgZCA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICBpZiAoZCAhPT0gbnVsbCAmJiBkICUgNyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZCAvIDc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGlmZldob2xlRGF5cyhtMCwgbTEpIHtcbiAgICBpZiAodGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoZGlmZkRheXMobTAsIG0xKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gU3RhcnQtT2ZcbmZ1bmN0aW9uIHN0YXJ0T2ZEYXkobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZIb3VyKG0pIHtcbiAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoW1xuICAgICAgICBtLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgIG0uZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgbS5nZXRVVENEYXRlKCksXG4gICAgICAgIG0uZ2V0VVRDSG91cnMoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZNaW51dGUobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZTZWNvbmQobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSxcbiAgICAgICAgbS5nZXRVVENTZWNvbmRzKCksXG4gICAgXSk7XG59XG4vLyBXZWVrIENvbXB1dGF0aW9uXG5mdW5jdGlvbiB3ZWVrT2ZZZWFyKG1hcmtlciwgZG93LCBkb3kpIHtcbiAgICBsZXQgeSA9IG1hcmtlci5nZXRVVENGdWxsWWVhcigpO1xuICAgIGxldCB3ID0gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSwgZG93LCBkb3kpO1xuICAgIGlmICh3IDwgMSkge1xuICAgICAgICByZXR1cm4gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSAtIDEsIGRvdywgZG95KTtcbiAgICB9XG4gICAgbGV0IG5leHRXID0gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSArIDEsIGRvdywgZG95KTtcbiAgICBpZiAobmV4dFcgPj0gMSkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4odywgbmV4dFcpO1xuICAgIH1cbiAgICByZXR1cm4gdztcbn1cbmZ1bmN0aW9uIHdlZWtPZkdpdmVuWWVhcihtYXJrZXIsIHllYXIsIGRvdywgZG95KSB7XG4gICAgbGV0IGZpcnN0V2Vla1N0YXJ0ID0gYXJyYXlUb1V0Y0RhdGUoW3llYXIsIDAsIDEgKyBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpXSk7XG4gICAgbGV0IGRheVN0YXJ0ID0gc3RhcnRPZkRheShtYXJrZXIpO1xuICAgIGxldCBkYXlzID0gTWF0aC5yb3VuZChkaWZmRGF5cyhmaXJzdFdlZWtTdGFydCwgZGF5U3RhcnQpKTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlzIC8gNykgKyAxOyAvLyB6ZXJvLWluZGV4ZWRcbn1cbi8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG5mdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICBsZXQgZndkID0gNyArIGRvdyAtIGRveTtcbiAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgbGV0IGZ3ZGx3ID0gKDcgKyBhcnJheVRvVXRjRGF0ZShbeWVhciwgMCwgZndkXSkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcbiAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbn1cbi8vIEFycmF5IENvbnZlcnNpb25cbmZ1bmN0aW9uIGRhdGVUb0xvY2FsQXJyYXkoZGF0ZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGRhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgZGF0ZS5nZXRNb250aCgpLFxuICAgICAgICBkYXRlLmdldERhdGUoKSxcbiAgICAgICAgZGF0ZS5nZXRIb3VycygpLFxuICAgICAgICBkYXRlLmdldE1pbnV0ZXMoKSxcbiAgICAgICAgZGF0ZS5nZXRTZWNvbmRzKCksXG4gICAgICAgIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCksXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGFycmF5VG9Mb2NhbERhdGUoYSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShhWzBdLCBhWzFdIHx8IDAsIGFbMl0gPT0gbnVsbCA/IDEgOiBhWzJdLCAvLyBkYXkgb2YgbW9udGhcbiAgICBhWzNdIHx8IDAsIGFbNF0gfHwgMCwgYVs1XSB8fCAwKTtcbn1cbmZ1bmN0aW9uIGRhdGVUb1V0Y0FycmF5KGRhdGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBkYXRlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENEYXRlKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENNaW51dGVzKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDU2Vjb25kcygpLFxuICAgICAgICBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpLFxuICAgIF07XG59XG5mdW5jdGlvbiBhcnJheVRvVXRjRGF0ZShhKSB7XG4gICAgLy8gYWNjb3JkaW5nIHRvIHdlYiBzdGFuZGFyZHMgKGFuZCBTYWZhcmkpLCBhIG1vbnRoIGluZGV4IGlzIHJlcXVpcmVkLlxuICAgIC8vIG1hc3NhZ2UgaWYgb25seSBnaXZlbiBhIHllYXIuXG4gICAgaWYgKGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGEgPSBhLmNvbmNhdChbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoLi4uYSkpO1xufVxuLy8gT3RoZXIgVXRpbHNcbmZ1bmN0aW9uIGlzVmFsaWREYXRlKG0pIHtcbiAgICByZXR1cm4gIWlzTmFOKG0udmFsdWVPZigpKTtcbn1cbmZ1bmN0aW9uIHRpbWVBc01zKG0pIHtcbiAgICByZXR1cm4gbS5nZXRVVENIb3VycygpICogMTAwMCAqIDYwICogNjAgK1xuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSAqIDEwMDAgKiA2MCArXG4gICAgICAgIG0uZ2V0VVRDU2Vjb25kcygpICogMTAwMCArXG4gICAgICAgIG0uZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG59XG5cbi8vIHRpbWVab25lT2Zmc2V0IGlzIGluIG1pbnV0ZXNcbmZ1bmN0aW9uIGJ1aWxkSXNvU3RyaW5nKG1hcmtlciwgdGltZVpvbmVPZmZzZXQsIHN0cmlwWmVyb1RpbWUgPSBmYWxzZSkge1xuICAgIGxldCBzID0gbWFya2VyLnRvSVNPU3RyaW5nKCk7XG4gICAgcyA9IHMucmVwbGFjZSgnLjAwMCcsICcnKTtcbiAgICBpZiAoc3RyaXBaZXJvVGltZSkge1xuICAgICAgICBzID0gcy5yZXBsYWNlKCdUMDA6MDA6MDBaJywgJycpO1xuICAgIH1cbiAgICBpZiAocy5sZW5ndGggPiAxMCkgeyAvLyB0aW1lIHBhcnQgd2Fzbid0IHN0cmlwcGVkLCBjYW4gYWRkIHRpbWV6b25lIGluZm9cbiAgICAgICAgaWYgKHRpbWVab25lT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJ1onLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGltZVpvbmVPZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJ1onLCBmb3JtYXRUaW1lWm9uZU9mZnNldCh0aW1lWm9uZU9mZnNldCwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSwgaXRzIFVUQy0wIGFuZCB3ZSB3YW50IHRvIGtlZXAgdGhlIFpcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG4vLyBmb3JtYXRzIHRoZSBkYXRlLCBidXQgd2l0aCBubyB0aW1lIHBhcnRcbi8vIFRPRE86IHNvbWVob3cgbWVyZ2Ugd2l0aCBidWlsZElzb1N0cmluZyBhbmQgc3RyaXBaZXJvVGltZVxuLy8gVE9ETzogcmVuYW1lLiBvbWl0IFwic3RyaW5nXCJcbmZ1bmN0aW9uIGZvcm1hdERheVN0cmluZyhtYXJrZXIpIHtcbiAgICByZXR1cm4gbWFya2VyLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvVC4qJC8sICcnKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdElzb01vbnRoU3RyKG1hcmtlcikge1xuICAgIHJldHVybiBtYXJrZXIudG9JU09TdHJpbmcoKS5tYXRjaCgvXlxcZHs0fS1cXGR7Mn0vKVswXTtcbn1cbi8vIFRPRE86IHVzZSBEYXRlOjp0b0lTT1N0cmluZyBhbmQgdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIFQ/XG5mdW5jdGlvbiBmb3JtYXRJc29UaW1lU3RyaW5nKG1hcmtlcikge1xuICAgIHJldHVybiBwYWRTdGFydChtYXJrZXIuZ2V0VVRDSG91cnMoKSwgMikgKyAnOicgK1xuICAgICAgICBwYWRTdGFydChtYXJrZXIuZ2V0VVRDTWludXRlcygpLCAyKSArICc6JyArXG4gICAgICAgIHBhZFN0YXJ0KG1hcmtlci5nZXRVVENTZWNvbmRzKCksIDIpO1xufVxuZnVuY3Rpb24gZm9ybWF0VGltZVpvbmVPZmZzZXQobWludXRlcywgZG9Jc28gPSBmYWxzZSkge1xuICAgIGxldCBzaWduID0gbWludXRlcyA8IDAgPyAnLScgOiAnKyc7XG4gICAgbGV0IGFicyA9IE1hdGguYWJzKG1pbnV0ZXMpO1xuICAgIGxldCBob3VycyA9IE1hdGguZmxvb3IoYWJzIC8gNjApO1xuICAgIGxldCBtaW5zID0gTWF0aC5yb3VuZChhYnMgJSA2MCk7XG4gICAgaWYgKGRvSXNvKSB7XG4gICAgICAgIHJldHVybiBgJHtzaWduICsgcGFkU3RhcnQoaG91cnMsIDIpfToke3BhZFN0YXJ0KG1pbnMsIDIpfWA7XG4gICAgfVxuICAgIHJldHVybiBgR01UJHtzaWdufSR7aG91cnN9JHttaW5zID8gYDoke3BhZFN0YXJ0KG1pbnMsIDIpfWAgOiAnJ31gO1xufVxuXG5mdW5jdGlvbiBtZW1vaXplKHdvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcbiAgICBsZXQgY3VycmVudEFyZ3M7XG4gICAgbGV0IGN1cnJlbnRSZXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5uZXdBcmdzKSB7XG4gICAgICAgIGlmICghY3VycmVudEFyZ3MpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc0FycmF5c0VxdWFsKGN1cnJlbnRBcmdzLCBuZXdBcmdzKSkge1xuICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgICAgICAgICAgaWYgKCFyZXNFcXVhbGl0eSB8fCAhcmVzRXF1YWxpdHkocmVzLCBjdXJyZW50UmVzKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSZXMgPSByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEFyZ3MgPSBuZXdBcmdzO1xuICAgICAgICByZXR1cm4gY3VycmVudFJlcztcbiAgICB9O1xufVxuZnVuY3Rpb24gbWVtb2l6ZU9iakFyZyh3b3JrZXJGdW5jLCByZXNFcXVhbGl0eSwgdGVhcmRvd25GdW5jKSB7XG4gICAgbGV0IGN1cnJlbnRBcmc7XG4gICAgbGV0IGN1cnJlbnRSZXM7XG4gICAgcmV0dXJuIChuZXdBcmcpID0+IHtcbiAgICAgICAgaWYgKCFjdXJyZW50QXJnKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVzID0gd29ya2VyRnVuYy5jYWxsKHRoaXMsIG5ld0FyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzUHJvcHNFcXVhbChjdXJyZW50QXJnLCBuZXdBcmcpKSB7XG4gICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlcyA9IHdvcmtlckZ1bmMuY2FsbCh0aGlzLCBuZXdBcmcpO1xuICAgICAgICAgICAgaWYgKCFyZXNFcXVhbGl0eSB8fCAhcmVzRXF1YWxpdHkocmVzLCBjdXJyZW50UmVzKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSZXMgPSByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEFyZyA9IG5ld0FyZztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1lbW9pemVBcnJheWxpa2UoLy8gdXNlZCBhdCBhbGw/XG53b3JrZXJGdW5jLCByZXNFcXVhbGl0eSwgdGVhcmRvd25GdW5jKSB7XG4gICAgbGV0IGN1cnJlbnRBcmdTZXRzID0gW107XG4gICAgbGV0IGN1cnJlbnRSZXN1bHRzID0gW107XG4gICAgcmV0dXJuIChuZXdBcmdTZXRzKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50TGVuID0gY3VycmVudEFyZ1NldHMubGVuZ3RoO1xuICAgICAgICBsZXQgbmV3TGVuID0gbmV3QXJnU2V0cy5sZW5ndGg7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBjdXJyZW50TGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICghbmV3QXJnU2V0c1tpXSkgeyAvLyBvbmUgb2YgdGhlIG9sZCBzZXRzIG5vIGxvbmdlciBleGlzdHNcbiAgICAgICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzdWx0c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ1NldHNbaV0sIG5ld0FyZ1NldHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlc3VsdHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdTZXRzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc0VxdWFsaXR5IHx8ICFyZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXN1bHRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzdWx0c1tpXSA9IHJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCBuZXdMZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgY3VycmVudFJlc3VsdHNbaV0gPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ1NldHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmdTZXRzID0gbmV3QXJnU2V0cztcbiAgICAgICAgY3VycmVudFJlc3VsdHMuc3BsaWNlKG5ld0xlbik7IC8vIHJlbW92ZSBleGNlc3NcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXN1bHRzO1xuICAgIH07XG59XG5mdW5jdGlvbiBtZW1vaXplSGFzaGxpa2Uod29ya2VyRnVuYywgcmVzRXF1YWxpdHksIHRlYXJkb3duRnVuYykge1xuICAgIGxldCBjdXJyZW50QXJnSGFzaCA9IHt9O1xuICAgIGxldCBjdXJyZW50UmVzSGFzaCA9IHt9O1xuICAgIHJldHVybiAobmV3QXJnSGFzaCkgPT4ge1xuICAgICAgICBsZXQgbmV3UmVzSGFzaCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gbmV3QXJnSGFzaCkge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50UmVzSGFzaFtrZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3UmVzSGFzaFtrZXldID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdIYXNoW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ0hhc2hba2V5XSwgbmV3QXJnSGFzaFtrZXldKSkge1xuICAgICAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXNIYXNoW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdIYXNoW2tleV0pO1xuICAgICAgICAgICAgICAgIG5ld1Jlc0hhc2hba2V5XSA9IChyZXNFcXVhbGl0eSAmJiByZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXNIYXNoW2tleV0pKVxuICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnRSZXNIYXNoW2tleV1cbiAgICAgICAgICAgICAgICAgICAgOiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdSZXNIYXNoW2tleV0gPSBjdXJyZW50UmVzSGFzaFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmdIYXNoID0gbmV3QXJnSGFzaDtcbiAgICAgICAgY3VycmVudFJlc0hhc2ggPSBuZXdSZXNIYXNoO1xuICAgICAgICByZXR1cm4gbmV3UmVzSGFzaDtcbiAgICB9O1xufVxuXG5jb25zdCBFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFUyA9IHtcbiAgICB3ZWVrOiAzLFxuICAgIHNlcGFyYXRvcjogMCxcbiAgICBvbWl0WmVyb01pbnV0ZTogMCxcbiAgICBtZXJpZGllbTogMCxcbiAgICBvbWl0Q29tbWFzOiAwLFxufTtcbmNvbnN0IFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTID0ge1xuICAgIHRpbWVab25lTmFtZTogNyxcbiAgICBlcmE6IDYsXG4gICAgeWVhcjogNSxcbiAgICBtb250aDogNCxcbiAgICBkYXk6IDIsXG4gICAgd2Vla2RheTogMixcbiAgICBob3VyOiAxLFxuICAgIG1pbnV0ZTogMSxcbiAgICBzZWNvbmQ6IDEsXG59O1xuY29uc3QgTUVSSURJRU1fUkUgPSAvXFxzKihbYXBdKVxcLj9tXFwuPy9pOyAvLyBlYXRzIHVwIGxlYWRpbmcgc3BhY2VzIHRvb1xuY29uc3QgQ09NTUFfUkUgPSAvLC9nOyAvLyB3ZSBuZWVkIHJlIGZvciBnbG9iYWxuZXNzXG5jb25zdCBNVUxUSV9TUEFDRV9SRSA9IC9cXHMrL2c7XG5jb25zdCBMVFJfUkUgPSAvXFx1MjAwZS9nOyAvLyBjb250cm9sIGNoYXJhY3RlclxuY29uc3QgVVRDX1JFID0gL1VUQ3xHTVQvO1xuY2xhc3MgTmF0aXZlRm9ybWF0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihmb3JtYXRTZXR0aW5ncykge1xuICAgICAgICBsZXQgc3RhbmRhcmREYXRlUHJvcHMgPSB7fTtcbiAgICAgICAgbGV0IGV4dGVuZGVkU2V0dGluZ3MgPSB7fTtcbiAgICAgICAgbGV0IHNldmVyaXR5ID0gMDtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBmb3JtYXRTZXR0aW5ncykge1xuICAgICAgICAgICAgaWYgKG5hbWUgaW4gRVhURU5ERURfU0VUVElOR1NfQU5EX1NFVkVSSVRJRVMpIHtcbiAgICAgICAgICAgICAgICBleHRlbmRlZFNldHRpbmdzW25hbWVdID0gZm9ybWF0U2V0dGluZ3NbbmFtZV07XG4gICAgICAgICAgICAgICAgc2V2ZXJpdHkgPSBNYXRoLm1heChFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFU1tuYW1lXSwgc2V2ZXJpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHNbbmFtZV0gPSBmb3JtYXRTZXR0aW5nc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUykgeyAvLyBUT0RPOiB3aGF0IGFib3V0IGhvdXIxMj8gbm8gc2V2ZXJpdHlcbiAgICAgICAgICAgICAgICAgICAgc2V2ZXJpdHkgPSBNYXRoLm1heChTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFU1tuYW1lXSwgc2V2ZXJpdHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YW5kYXJkRGF0ZVByb3BzID0gc3RhbmRhcmREYXRlUHJvcHM7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWRTZXR0aW5ncyA9IGV4dGVuZGVkU2V0dGluZ3M7XG4gICAgICAgIHRoaXMuc2V2ZXJpdHkgPSBzZXZlcml0eTtcbiAgICAgICAgdGhpcy5idWlsZEZvcm1hdHRpbmdGdW5jID0gbWVtb2l6ZShidWlsZEZvcm1hdHRpbmdGdW5jKTtcbiAgICB9XG4gICAgZm9ybWF0KGRhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRGb3JtYXR0aW5nRnVuYyh0aGlzLnN0YW5kYXJkRGF0ZVByb3BzLCB0aGlzLmV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpKGRhdGUpO1xuICAgIH1cbiAgICBmb3JtYXRSYW5nZShzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgICAgIGxldCB7IHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZGlmZlNldmVyaXR5ID0gY29tcHV0ZU1hcmtlckRpZmZTZXZlcml0eShzdGFydC5tYXJrZXIsIGVuZC5tYXJrZXIsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pO1xuICAgICAgICBpZiAoIWRpZmZTZXZlcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHN0YXJ0LCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID0gZGlmZlNldmVyaXR5O1xuICAgICAgICBpZiAoYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID4gMSAmJiAvLyB0aGUgdHdvIGRhdGVzIGFyZSBkaWZmZXJlbnQgaW4gYSB3YXkgdGhhdCdzIGxhcmdlciBzY2FsZSB0aGFuIHRpbWVcbiAgICAgICAgICAgIChzdGFuZGFyZERhdGVQcm9wcy55ZWFyID09PSAnbnVtZXJpYycgfHwgc3RhbmRhcmREYXRlUHJvcHMueWVhciA9PT0gJzItZGlnaXQnKSAmJlxuICAgICAgICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLm1vbnRoID09PSAnbnVtZXJpYycgfHwgc3RhbmRhcmREYXRlUHJvcHMubW9udGggPT09ICcyLWRpZ2l0JykgJiZcbiAgICAgICAgICAgIChzdGFuZGFyZERhdGVQcm9wcy5kYXkgPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy5kYXkgPT09ICcyLWRpZ2l0JykpIHtcbiAgICAgICAgICAgIGJpZ2dlc3RVbml0Rm9yUGFydGlhbCA9IDE7IC8vIG1ha2UgaXQgbG9vayBsaWtlIHRoZSBkYXRlcyBhcmUgb25seSBkaWZmZXJlbnQgaW4gdGVybXMgb2YgdGltZVxuICAgICAgICB9XG4gICAgICAgIGxldCBmdWxsMCA9IHRoaXMuZm9ybWF0KHN0YXJ0LCBjb250ZXh0KTtcbiAgICAgICAgbGV0IGZ1bGwxID0gdGhpcy5mb3JtYXQoZW5kLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGZ1bGwwID09PSBmdWxsMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bGwwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJ0aWFsRGF0ZVByb3BzID0gY29tcHV0ZVBhcnRpYWxGb3JtYXR0aW5nT3B0aW9ucyhzdGFuZGFyZERhdGVQcm9wcywgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsKTtcbiAgICAgICAgbGV0IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyA9IGJ1aWxkRm9ybWF0dGluZ0Z1bmMocGFydGlhbERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCk7XG4gICAgICAgIGxldCBwYXJ0aWFsMCA9IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyhzdGFydCk7XG4gICAgICAgIGxldCBwYXJ0aWFsMSA9IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyhlbmQpO1xuICAgICAgICBsZXQgaW5zZXJ0aW9uID0gZmluZENvbW1vbkluc2VydGlvbihmdWxsMCwgcGFydGlhbDAsIGZ1bGwxLCBwYXJ0aWFsMSk7XG4gICAgICAgIGxldCBzZXBhcmF0b3IgPSBleHRlbmRlZFNldHRpbmdzLnNlcGFyYXRvciB8fCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yIHx8IGNvbnRleHQuZGVmYXVsdFNlcGFyYXRvciB8fCAnJztcbiAgICAgICAgaWYgKGluc2VydGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydGlvbi5iZWZvcmUgKyBwYXJ0aWFsMCArIHNlcGFyYXRvciArIHBhcnRpYWwxICsgaW5zZXJ0aW9uLmFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdWxsMCArIHNlcGFyYXRvciArIGZ1bGwxO1xuICAgIH1cbiAgICBnZXRMYXJnZXN0VW5pdCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNldmVyaXR5KSB7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd5ZWFyJztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21vbnRoJztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3dlZWsnO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiAnZGF5JztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd0aW1lJzsgLy8gcmVhbGx5P1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIGxldCBzdGFuZGFyZERhdGVQcm9wQ250ID0gT2JqZWN0LmtleXMoc3RhbmRhcmREYXRlUHJvcHMpLmxlbmd0aDtcbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcENudCA9PT0gMSAmJiBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdzaG9ydCcpIHtcbiAgICAgICAgcmV0dXJuIChkYXRlKSA9PiAoZm9ybWF0VGltZVpvbmVPZmZzZXQoZGF0ZS50aW1lWm9uZU9mZnNldCkpO1xuICAgIH1cbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcENudCA9PT0gMCAmJiBleHRlbmRlZFNldHRpbmdzLndlZWspIHtcbiAgICAgICAgcmV0dXJuIChkYXRlKSA9PiAoZm9ybWF0V2Vla051bWJlcihjb250ZXh0LmNvbXB1dGVXZWVrTnVtYmVyKGRhdGUubWFya2VyKSwgY29udGV4dC53ZWVrVGV4dCwgY29udGV4dC53ZWVrVGV4dExvbmcsIGNvbnRleHQubG9jYWxlLCBleHRlbmRlZFNldHRpbmdzLndlZWspKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWxkTmF0aXZlRm9ybWF0dGluZ0Z1bmMoc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gYnVpbGROYXRpdmVGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIHN0YW5kYXJkRGF0ZVByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhbmRhcmREYXRlUHJvcHMpOyAvLyBjb3B5XG4gICAgZXh0ZW5kZWRTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIGV4dGVuZGVkU2V0dGluZ3MpOyAvLyBjb3B5XG4gICAgc2FuaXRpemVTZXR0aW5ncyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncyk7XG4gICAgc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmUgPSAnVVRDJzsgLy8gd2UgbGV2ZXJhZ2UgdGhlIG9ubHkgZ3VhcmFudGVlZCB0aW1lWm9uZSBmb3Igb3VyIFVUQyBtYXJrZXJzXG4gICAgbGV0IG5vcm1hbEZvcm1hdCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGNvbnRleHQubG9jYWxlLmNvZGVzLCBzdGFuZGFyZERhdGVQcm9wcyk7XG4gICAgbGV0IHplcm9Gb3JtYXQ7IC8vIG5lZWRlZD9cbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSkge1xuICAgICAgICBsZXQgemVyb1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhbmRhcmREYXRlUHJvcHMpO1xuICAgICAgICBkZWxldGUgemVyb1Byb3BzLm1pbnV0ZTsgLy8gc2Vjb25kcyBhbmQgbXMgd2VyZSBhbHJlYWR5IGNvbnNpZGVyZWQgaW4gc2FuaXRpemVTZXR0aW5nc1xuICAgICAgICB6ZXJvRm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoY29udGV4dC5sb2NhbGUuY29kZXMsIHplcm9Qcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiAoZGF0ZSkgPT4ge1xuICAgICAgICBsZXQgeyBtYXJrZXIgfSA9IGRhdGU7XG4gICAgICAgIGxldCBmb3JtYXQ7XG4gICAgICAgIGlmICh6ZXJvRm9ybWF0ICYmICFtYXJrZXIuZ2V0VVRDTWludXRlcygpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSB6ZXJvRm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gbm9ybWFsRm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzID0gZm9ybWF0LmZvcm1hdChtYXJrZXIpO1xuICAgICAgICByZXR1cm4gcG9zdFByb2Nlc3MocywgZGF0ZSwgc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzYW5pdGl6ZVNldHRpbmdzKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzKSB7XG4gICAgLy8gZGVhbCB3aXRoIGEgYnJvd3NlciBpbmNvbnNpc3RlbmN5IHdoZXJlIGZvcm1hdHRpbmcgdGhlIHRpbWV6b25lXG4gICAgLy8gcmVxdWlyZXMgdGhhdCB0aGUgaG91ci9taW51dGUgYmUgcHJlc2VudC5cbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lKSB7XG4gICAgICAgIGlmICghc3RhbmRhcmREYXRlUHJvcHMuaG91cikge1xuICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMuaG91ciA9ICcyLWRpZ2l0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YW5kYXJkRGF0ZVByb3BzLm1pbnV0ZSkge1xuICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMubWludXRlID0gJzItZGlnaXQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG9ubHkgc3VwcG9ydCBzaG9ydCB0aW1lem9uZSBuYW1lc1xuICAgIGlmIChzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdsb25nJykge1xuICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPSAnc2hvcnQnO1xuICAgIH1cbiAgICAvLyBpZiByZXF1ZXN0aW5nIHRvIGRpc3BsYXkgc2Vjb25kcywgTVVTVCBkaXNwbGF5IG1pbnV0ZXNcbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSAmJiAoc3RhbmRhcmREYXRlUHJvcHMuc2Vjb25kIHx8IHN0YW5kYXJkRGF0ZVByb3BzLm1pbGxpc2Vjb25kKSkge1xuICAgICAgICBkZWxldGUgZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBwb3N0UHJvY2VzcyhzLCBkYXRlLCBzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIHMgPSBzLnJlcGxhY2UoTFRSX1JFLCAnJyk7IC8vIHJlbW92ZSBsZWZ0LXRvLXJpZ2h0IGNvbnRyb2wgY2hhcnMuIGRvIGZpcnN0LiBnb29kIGZvciBvdGhlciByZWdleGVzXG4gICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ3Nob3J0Jykge1xuICAgICAgICBzID0gaW5qZWN0VHpvU3RyKHMsIChjb250ZXh0LnRpbWVab25lID09PSAnVVRDJyB8fCBkYXRlLnRpbWVab25lT2Zmc2V0ID09IG51bGwpID9cbiAgICAgICAgICAgICdVVEMnIDogLy8gaW1wb3J0YW50IHRvIG5vcm1hbGl6ZSBmb3IgSUUsIHdoaWNoIGRvZXMgXCJHTVRcIlxuICAgICAgICAgICAgZm9ybWF0VGltZVpvbmVPZmZzZXQoZGF0ZS50aW1lWm9uZU9mZnNldCkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0Q29tbWFzKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoQ09NTUFfUkUsICcnKS50cmltKCk7XG4gICAgfVxuICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJzowMCcsICcnKTsgLy8gemVyb0Zvcm1hdCBkb2Vzbid0IGFsd2F5cyBhY2hpZXZlIHRoaXNcbiAgICB9XG4gICAgLy8gXiBkbyBhbnl0aGluZyB0aGF0IG1pZ2h0IGNyZWF0ZSBhZGphY2VudCBzcGFjZXMgYmVmb3JlIHRoaXMgcG9pbnQsXG4gICAgLy8gYmVjYXVzZSBNRVJJRElFTV9SRSBsaWtlcyB0byBlYXQgdXAgbG9hZGluZyBzcGFjZXNcbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgJycpLnRyaW0oKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gJ25hcnJvdycpIHsgLy8gYS9wXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIChtMCwgbTEpID0+IG0xLnRvTG9jYWxlTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnc2hvcnQnKSB7IC8vIGFtL3BtXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIChtMCwgbTEpID0+IGAke20xLnRvTG9jYWxlTG93ZXJDYXNlKCl9bWApO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnbG93ZXJjYXNlJykgeyAvLyBvdGhlciBtZXJpZGllbSB0cmFuc2Zvcm1lcnMgYWxyZWFkeSBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIChtMCkgPT4gbTAudG9Mb2NhbGVMb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHMgPSBzLnJlcGxhY2UoTVVMVElfU1BBQ0VfUkUsICcgJyk7XG4gICAgcyA9IHMudHJpbSgpO1xuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gaW5qZWN0VHpvU3RyKHMsIHR6b1N0cikge1xuICAgIGxldCByZXBsYWNlZCA9IGZhbHNlO1xuICAgIHMgPSBzLnJlcGxhY2UoVVRDX1JFLCAoKSA9PiB7XG4gICAgICAgIHJlcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHR6b1N0cjtcbiAgICB9KTtcbiAgICAvLyBJRTExIGRvZXNuJ3QgaW5jbHVkZSBVVEMvR01UIGluIHRoZSBvcmlnaW5hbCBzdHJpbmcsIHNvIGFwcGVuZCB0byBlbmRcbiAgICBpZiAoIXJlcGxhY2VkKSB7XG4gICAgICAgIHMgKz0gYCAke3R6b1N0cn1gO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXIobnVtLCB3ZWVrVGV4dCwgd2Vla1RleHRMb25nLCBsb2NhbGUsIGRpc3BsYXkpIHtcbiAgICBsZXQgcGFydHMgPSBbXTtcbiAgICBpZiAoZGlzcGxheSA9PT0gJ2xvbmcnKSB7XG4gICAgICAgIHBhcnRzLnB1c2god2Vla1RleHRMb25nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzcGxheSA9PT0gJ3Nob3J0JyB8fCBkaXNwbGF5ID09PSAnbmFycm93Jykge1xuICAgICAgICBwYXJ0cy5wdXNoKHdlZWtUZXh0KTtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXkgPT09ICdsb25nJyB8fCBkaXNwbGF5ID09PSAnc2hvcnQnKSB7XG4gICAgICAgIHBhcnRzLnB1c2goJyAnKTtcbiAgICB9XG4gICAgcGFydHMucHVzaChsb2NhbGUuc2ltcGxlTnVtYmVyRm9ybWF0LmZvcm1hdChudW0pKTtcbiAgICBpZiAobG9jYWxlLm9wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJykgeyAvLyBUT0RPOiB1c2UgY29udHJvbCBjaGFyYWN0ZXJzIGluc3RlYWQ/XG4gICAgICAgIHBhcnRzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xufVxuLy8gUmFuZ2UgRm9ybWF0dGluZyBVdGlsc1xuLy8gMCA9IGV4YWN0bHkgdGhlIHNhbWVcbi8vIDEgPSBkaWZmZXJlbnQgYnkgdGltZVxuLy8gYW5kIGJpZ2dlclxuZnVuY3Rpb24gY29tcHV0ZU1hcmtlckRpZmZTZXZlcml0eShkMCwgZDEsIGNhKSB7XG4gICAgaWYgKGNhLmdldE1hcmtlclllYXIoZDApICE9PSBjYS5nZXRNYXJrZXJZZWFyKGQxKSkge1xuICAgICAgICByZXR1cm4gNTtcbiAgICB9XG4gICAgaWYgKGNhLmdldE1hcmtlck1vbnRoKGQwKSAhPT0gY2EuZ2V0TWFya2VyTW9udGgoZDEpKSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgICBpZiAoY2EuZ2V0TWFya2VyRGF5KGQwKSAhPT0gY2EuZ2V0TWFya2VyRGF5KGQxKSkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgaWYgKHRpbWVBc01zKGQwKSAhPT0gdGltZUFzTXMoZDEpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVQYXJ0aWFsRm9ybWF0dGluZ09wdGlvbnMob3B0aW9ucywgYmlnZ2VzdFVuaXQpIHtcbiAgICBsZXQgcGFydGlhbE9wdGlvbnMgPSB7fTtcbiAgICBmb3IgKGxldCBuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEobmFtZSBpbiBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUykgfHwgLy8gbm90IGEgZGF0ZSBwYXJ0IHByb3AgKGxpa2UgdGltZVpvbmUpXG4gICAgICAgICAgICBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFU1tuYW1lXSA8PSBiaWdnZXN0VW5pdCkge1xuICAgICAgICAgICAgcGFydGlhbE9wdGlvbnNbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aWFsT3B0aW9ucztcbn1cbmZ1bmN0aW9uIGZpbmRDb21tb25JbnNlcnRpb24oZnVsbDAsIHBhcnRpYWwwLCBmdWxsMSwgcGFydGlhbDEpIHtcbiAgICBsZXQgaTAgPSAwO1xuICAgIHdoaWxlIChpMCA8IGZ1bGwwLmxlbmd0aCkge1xuICAgICAgICBsZXQgZm91bmQwID0gZnVsbDAuaW5kZXhPZihwYXJ0aWFsMCwgaTApO1xuICAgICAgICBpZiAoZm91bmQwID09PSAtMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJlZm9yZTAgPSBmdWxsMC5zdWJzdHIoMCwgZm91bmQwKTtcbiAgICAgICAgaTAgPSBmb3VuZDAgKyBwYXJ0aWFsMC5sZW5ndGg7XG4gICAgICAgIGxldCBhZnRlcjAgPSBmdWxsMC5zdWJzdHIoaTApO1xuICAgICAgICBsZXQgaTEgPSAwO1xuICAgICAgICB3aGlsZSAoaTEgPCBmdWxsMS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZDEgPSBmdWxsMS5pbmRleE9mKHBhcnRpYWwxLCBpMSk7XG4gICAgICAgICAgICBpZiAoZm91bmQxID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJlZm9yZTEgPSBmdWxsMS5zdWJzdHIoMCwgZm91bmQxKTtcbiAgICAgICAgICAgIGkxID0gZm91bmQxICsgcGFydGlhbDEubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGFmdGVyMSA9IGZ1bGwxLnN1YnN0cihpMSk7XG4gICAgICAgICAgICBpZiAoYmVmb3JlMCA9PT0gYmVmb3JlMSAmJiBhZnRlcjAgPT09IGFmdGVyMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZTogYmVmb3JlMCxcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXI6IGFmdGVyMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBleHBhbmRab25lZE1hcmtlcihkYXRlSW5mbywgY2FsZW5kYXJTeXN0ZW0pIHtcbiAgICBsZXQgYSA9IGNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkoZGF0ZUluZm8ubWFya2VyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtYXJrZXI6IGRhdGVJbmZvLm1hcmtlcixcbiAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVJbmZvLnRpbWVab25lT2Zmc2V0LFxuICAgICAgICBhcnJheTogYSxcbiAgICAgICAgeWVhcjogYVswXSxcbiAgICAgICAgbW9udGg6IGFbMV0sXG4gICAgICAgIGRheTogYVsyXSxcbiAgICAgICAgaG91cjogYVszXSxcbiAgICAgICAgbWludXRlOiBhWzRdLFxuICAgICAgICBzZWNvbmQ6IGFbNV0sXG4gICAgICAgIG1pbGxpc2Vjb25kOiBhWzZdLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICBsZXQgc3RhcnRJbmZvID0gZXhwYW5kWm9uZWRNYXJrZXIoc3RhcnQsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pO1xuICAgIGxldCBlbmRJbmZvID0gZW5kID8gZXhwYW5kWm9uZWRNYXJrZXIoZW5kLCBjb250ZXh0LmNhbGVuZGFyU3lzdGVtKSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZTogc3RhcnRJbmZvLFxuICAgICAgICBzdGFydDogc3RhcnRJbmZvLFxuICAgICAgICBlbmQ6IGVuZEluZm8sXG4gICAgICAgIHRpbWVab25lOiBjb250ZXh0LnRpbWVab25lLFxuICAgICAgICBsb2NhbGVDb2RlczogY29udGV4dC5sb2NhbGUuY29kZXMsXG4gICAgICAgIGRlZmF1bHRTZXBhcmF0b3I6IGJldHRlckRlZmF1bHRTZXBhcmF0b3IgfHwgY29udGV4dC5kZWZhdWx0U2VwYXJhdG9yLFxuICAgIH07XG59XG5cbi8qXG5UT0RPOiBmaXggdGhlIHRlcm1pbm9sb2d5IG9mIFwiZm9ybWF0dGVyXCIgdnMgXCJmb3JtYXR0aW5nIGZ1bmNcIlxuKi9cbi8qXG5BdCB0aGUgdGltZSBvZiBpbnN0YW50aWF0aW9uLCB0aGlzIG9iamVjdCBkb2VzIG5vdCBrbm93IHdoaWNoIGNtZC1mb3JtYXR0aW5nIHN5c3RlbSBpdCB3aWxsIHVzZS5cbkl0IHJlY2VpdmVzIHRoaXMgYXQgdGhlIHRpbWUgb2YgZm9ybWF0dGluZywgYXMgYSBzZXR0aW5nLlxuKi9cbmNsYXNzIENtZEZvcm1hdHRlciB7XG4gICAgY29uc3RydWN0b3IoY21kU3RyKSB7XG4gICAgICAgIHRoaXMuY21kU3RyID0gY21kU3RyO1xuICAgIH1cbiAgICBmb3JtYXQoZGF0ZSwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jbWRGb3JtYXR0ZXIodGhpcy5jbWRTdHIsIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKGRhdGUsIG51bGwsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9XG4gICAgZm9ybWF0UmFuZ2Uoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jbWRGb3JtYXR0ZXIodGhpcy5jbWRTdHIsIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9XG59XG5cbmNsYXNzIEZ1bmNGb3JtYXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZ1bmMpIHtcbiAgICAgICAgdGhpcy5mdW5jID0gZnVuYztcbiAgICB9XG4gICAgZm9ybWF0KGRhdGUsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyhjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhkYXRlLCBudWxsLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSk7XG4gICAgfVxuICAgIGZvcm1hdFJhbmdlKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyhjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXIoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVGb3JtYXR0ZXIoaW5wdXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IENtZEZvcm1hdHRlcihpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jRm9ybWF0dGVyKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8vIGJhc2Ugb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tXG5jb25zdCBCQVNFX09QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBuYXZMaW5rRGF5Q2xpY2s6IGlkZW50aXR5LFxuICAgIG5hdkxpbmtXZWVrQ2xpY2s6IGlkZW50aXR5LFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBib290c3RyYXBGb250QXdlc29tZTogaWRlbnRpdHksXG4gICAgYnV0dG9uSWNvbnM6IGlkZW50aXR5LFxuICAgIGN1c3RvbUJ1dHRvbnM6IGlkZW50aXR5LFxuICAgIGRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkZWZhdWx0VGltZWRFdmVudER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBuZXh0RGF5VGhyZXNob2xkOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzY3JvbGxUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzY3JvbGxUaW1lUmVzZXQ6IEJvb2xlYW4sXG4gICAgc2xvdE1pblRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIHNsb3RNYXhUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkYXlQb3BvdmVyRm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgc2xvdER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzbmFwRHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGhlYWRlclRvb2xiYXI6IGlkZW50aXR5LFxuICAgIGZvb3RlclRvb2xiYXI6IGlkZW50aXR5LFxuICAgIGRlZmF1bHRSYW5nZVNlcGFyYXRvcjogU3RyaW5nLFxuICAgIHRpdGxlUmFuZ2VTZXBhcmF0b3I6IFN0cmluZyxcbiAgICBmb3JjZUV2ZW50RHVyYXRpb246IEJvb2xlYW4sXG4gICAgZGF5SGVhZGVyczogQm9vbGVhbixcbiAgICBkYXlIZWFkZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICBkYXlIZWFkZXJDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBkYXlIZWFkZXJDb250ZW50OiBpZGVudGl0eSxcbiAgICBkYXlIZWFkZXJEaWRNb3VudDogaWRlbnRpdHksXG4gICAgZGF5SGVhZGVyV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGRheUNlbGxDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBkYXlDZWxsQ29udGVudDogaWRlbnRpdHksXG4gICAgZGF5Q2VsbERpZE1vdW50OiBpZGVudGl0eSxcbiAgICBkYXlDZWxsV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGluaXRpYWxWaWV3OiBTdHJpbmcsXG4gICAgYXNwZWN0UmF0aW86IE51bWJlcixcbiAgICB3ZWVrZW5kczogQm9vbGVhbixcbiAgICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb246IGlkZW50aXR5LFxuICAgIHdlZWtOdW1iZXJzOiBCb29sZWFuLFxuICAgIHdlZWtOdW1iZXJDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICB3ZWVrTnVtYmVyQ29udGVudDogaWRlbnRpdHksXG4gICAgd2Vla051bWJlckRpZE1vdW50OiBpZGVudGl0eSxcbiAgICB3ZWVrTnVtYmVyV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGVkaXRhYmxlOiBCb29sZWFuLFxuICAgIHZpZXdDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICB2aWV3RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIHZpZXdXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgbm93SW5kaWNhdG9yOiBCb29sZWFuLFxuICAgIG5vd0luZGljYXRvckNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIG5vd0luZGljYXRvckNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIG5vd0luZGljYXRvckRpZE1vdW50OiBpZGVudGl0eSxcbiAgICBub3dJbmRpY2F0b3JXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgc2hvd05vbkN1cnJlbnREYXRlczogQm9vbGVhbixcbiAgICBsYXp5RmV0Y2hpbmc6IEJvb2xlYW4sXG4gICAgc3RhcnRQYXJhbTogU3RyaW5nLFxuICAgIGVuZFBhcmFtOiBTdHJpbmcsXG4gICAgdGltZVpvbmVQYXJhbTogU3RyaW5nLFxuICAgIHRpbWVab25lOiBTdHJpbmcsXG4gICAgbG9jYWxlczogaWRlbnRpdHksXG4gICAgbG9jYWxlOiBpZGVudGl0eSxcbiAgICB0aGVtZVN5c3RlbTogU3RyaW5nLFxuICAgIGRyYWdSZXZlcnREdXJhdGlvbjogTnVtYmVyLFxuICAgIGRyYWdTY3JvbGw6IEJvb2xlYW4sXG4gICAgYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjogQm9vbGVhbixcbiAgICB1bnNlbGVjdEF1dG86IEJvb2xlYW4sXG4gICAgZHJvcEFjY2VwdDogaWRlbnRpdHksXG4gICAgZXZlbnRPcmRlcjogcGFyc2VGaWVsZFNwZWNzLFxuICAgIGV2ZW50T3JkZXJTdHJpY3Q6IEJvb2xlYW4sXG4gICAgaGFuZGxlV2luZG93UmVzaXplOiBCb29sZWFuLFxuICAgIHdpbmRvd1Jlc2l6ZURlbGF5OiBOdW1iZXIsXG4gICAgbG9uZ1ByZXNzRGVsYXk6IE51bWJlcixcbiAgICBldmVudERyYWdNaW5EaXN0YW5jZTogTnVtYmVyLFxuICAgIGV4cGFuZFJvd3M6IEJvb2xlYW4sXG4gICAgaGVpZ2h0OiBpZGVudGl0eSxcbiAgICBjb250ZW50SGVpZ2h0OiBpZGVudGl0eSxcbiAgICBkaXJlY3Rpb246IFN0cmluZyxcbiAgICB3ZWVrTnVtYmVyRm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgZXZlbnRSZXNpemFibGVGcm9tU3RhcnQ6IEJvb2xlYW4sXG4gICAgZGlzcGxheUV2ZW50VGltZTogQm9vbGVhbixcbiAgICBkaXNwbGF5RXZlbnRFbmQ6IEJvb2xlYW4sXG4gICAgd2Vla1RleHQ6IFN0cmluZyxcbiAgICB3ZWVrVGV4dExvbmc6IFN0cmluZyxcbiAgICBwcm9ncmVzc2l2ZUV2ZW50UmVuZGVyaW5nOiBCb29sZWFuLFxuICAgIGJ1c2luZXNzSG91cnM6IGlkZW50aXR5LFxuICAgIGluaXRpYWxEYXRlOiBpZGVudGl0eSxcbiAgICBub3c6IGlkZW50aXR5LFxuICAgIGV2ZW50RGF0YVRyYW5zZm9ybTogaWRlbnRpdHksXG4gICAgc3RpY2t5SGVhZGVyRGF0ZXM6IGlkZW50aXR5LFxuICAgIHN0aWNreUZvb3RlclNjcm9sbGJhcjogaWRlbnRpdHksXG4gICAgdmlld0hlaWdodDogaWRlbnRpdHksXG4gICAgZGVmYXVsdEFsbERheTogQm9vbGVhbixcbiAgICBldmVudFNvdXJjZUZhaWx1cmU6IGlkZW50aXR5LFxuICAgIGV2ZW50U291cmNlU3VjY2VzczogaWRlbnRpdHksXG4gICAgZXZlbnREaXNwbGF5OiBTdHJpbmcsXG4gICAgZXZlbnRTdGFydEVkaXRhYmxlOiBCb29sZWFuLFxuICAgIGV2ZW50RHVyYXRpb25FZGl0YWJsZTogQm9vbGVhbixcbiAgICBldmVudE92ZXJsYXA6IGlkZW50aXR5LFxuICAgIGV2ZW50Q29uc3RyYWludDogaWRlbnRpdHksXG4gICAgZXZlbnRBbGxvdzogaWRlbnRpdHksXG4gICAgZXZlbnRCYWNrZ3JvdW5kQ29sb3I6IFN0cmluZyxcbiAgICBldmVudEJvcmRlckNvbG9yOiBTdHJpbmcsXG4gICAgZXZlbnRUZXh0Q29sb3I6IFN0cmluZyxcbiAgICBldmVudENvbG9yOiBTdHJpbmcsXG4gICAgZXZlbnRDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBldmVudENvbnRlbnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50V2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdENvbnN0cmFpbnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdE92ZXJsYXA6IGlkZW50aXR5LFxuICAgIHNlbGVjdEFsbG93OiBpZGVudGl0eSxcbiAgICBkcm9wcGFibGU6IEJvb2xlYW4sXG4gICAgdW5zZWxlY3RDYW5jZWw6IFN0cmluZyxcbiAgICBzbG90TGFiZWxGb3JtYXQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYW5lQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgc2xvdExhbmVDb250ZW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFuZURpZE1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFuZVdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxDb250ZW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxEaWRNb3VudDogaWRlbnRpdHksXG4gICAgc2xvdExhYmVsV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGRheU1heEV2ZW50czogaWRlbnRpdHksXG4gICAgZGF5TWF4RXZlbnRSb3dzOiBpZGVudGl0eSxcbiAgICBkYXlNaW5XaWR0aDogTnVtYmVyLFxuICAgIHNsb3RMYWJlbEludGVydmFsOiBjcmVhdGVEdXJhdGlvbixcbiAgICBhbGxEYXlUZXh0OiBTdHJpbmcsXG4gICAgYWxsRGF5Q2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgYWxsRGF5Q29udGVudDogaWRlbnRpdHksXG4gICAgYWxsRGF5RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIGFsbERheVdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TWluV2lkdGg6IE51bWJlcixcbiAgICBuYXZMaW5rczogQm9vbGVhbixcbiAgICBldmVudFRpbWVGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICByZXJlbmRlckRlbGF5OiBOdW1iZXIsXG4gICAgbW9yZUxpbmtUZXh0OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua0hpbnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdE1pbkRpc3RhbmNlOiBOdW1iZXIsXG4gICAgc2VsZWN0YWJsZTogQm9vbGVhbixcbiAgICBzZWxlY3RMb25nUHJlc3NEZWxheTogTnVtYmVyLFxuICAgIGV2ZW50TG9uZ1ByZXNzRGVsYXk6IE51bWJlcixcbiAgICBzZWxlY3RNaXJyb3I6IEJvb2xlYW4sXG4gICAgZXZlbnRNYXhTdGFjazogTnVtYmVyLFxuICAgIGV2ZW50TWluSGVpZ2h0OiBOdW1iZXIsXG4gICAgZXZlbnRNaW5XaWR0aDogTnVtYmVyLFxuICAgIGV2ZW50U2hvcnRIZWlnaHQ6IE51bWJlcixcbiAgICBzbG90RXZlbnRPdmVybGFwOiBCb29sZWFuLFxuICAgIHBsdWdpbnM6IGlkZW50aXR5LFxuICAgIGZpcnN0RGF5OiBOdW1iZXIsXG4gICAgZGF5Q291bnQ6IE51bWJlcixcbiAgICBkYXRlQWxpZ25tZW50OiBTdHJpbmcsXG4gICAgZGF0ZUluY3JlbWVudDogY3JlYXRlRHVyYXRpb24sXG4gICAgaGlkZGVuRGF5czogaWRlbnRpdHksXG4gICAgZml4ZWRXZWVrQ291bnQ6IEJvb2xlYW4sXG4gICAgdmFsaWRSYW5nZTogaWRlbnRpdHksXG4gICAgdmlzaWJsZVJhbmdlOiBpZGVudGl0eSxcbiAgICB0aXRsZUZvcm1hdDogaWRlbnRpdHksXG4gICAgZXZlbnRJbnRlcmFjdGl2ZTogQm9vbGVhbixcbiAgICAvLyBvbmx5IHVzZWQgYnkgbGlzdC12aWV3LCBidXQgbGFuZ3VhZ2VzIGRlZmluZSB0aGUgdmFsdWUsIHNvIHdlIG5lZWQgaXQgaW4gYmFzZSBvcHRpb25zXG4gICAgbm9FdmVudHNUZXh0OiBTdHJpbmcsXG4gICAgdmlld0hpbnQ6IGlkZW50aXR5LFxuICAgIG5hdkxpbmtIaW50OiBpZGVudGl0eSxcbiAgICBjbG9zZUhpbnQ6IFN0cmluZyxcbiAgICB0aW1lSGludDogU3RyaW5nLFxuICAgIGV2ZW50SGludDogU3RyaW5nLFxuICAgIG1vcmVMaW5rQ2xpY2s6IGlkZW50aXR5LFxuICAgIG1vcmVMaW5rQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgbW9yZUxpbmtDb250ZW50OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua0RpZE1vdW50OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua1dpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBtb250aFN0YXJ0Rm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgLy8gZm9yIGNvbm5lY3RvcnNcbiAgICAvLyAoY2FuJ3QgYmUgcGFydCBvZiBwbHVnaW4gc3lzdGVtIGIvYyBtdXN0IGJlIHByb3ZpZGVkIGF0IHJ1bnRpbWUpXG4gICAgaGFuZGxlQ3VzdG9tUmVuZGVyaW5nOiBpZGVudGl0eSxcbiAgICBjdXN0b21SZW5kZXJpbmdNZXRhTWFwOiBpZGVudGl0eSxcbiAgICBjdXN0b21SZW5kZXJpbmdSZXBsYWNlczogQm9vbGVhbixcbn07XG4vLyBkbyBOT1QgZ2l2ZSBhIHR5cGUgaGVyZS4gbmVlZCBgdHlwZW9mIEJBU0VfT1BUSU9OX0RFRkFVTFRTYCB0byBnaXZlIHJlYWwgcmVzdWx0cy5cbi8vIHJhdyB2YWx1ZXMuXG5jb25zdCBCQVNFX09QVElPTl9ERUZBVUxUUyA9IHtcbiAgICBldmVudERpc3BsYXk6ICdhdXRvJyxcbiAgICBkZWZhdWx0UmFuZ2VTZXBhcmF0b3I6ICcgLSAnLFxuICAgIHRpdGxlUmFuZ2VTZXBhcmF0b3I6ICcgXFx1MjAxMyAnLFxuICAgIGRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb246ICcwMTowMDowMCcsXG4gICAgZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb246IHsgZGF5OiAxIH0sXG4gICAgZm9yY2VFdmVudER1cmF0aW9uOiBmYWxzZSxcbiAgICBuZXh0RGF5VGhyZXNob2xkOiAnMDA6MDA6MDAnLFxuICAgIGRheUhlYWRlcnM6IHRydWUsXG4gICAgaW5pdGlhbFZpZXc6ICcnLFxuICAgIGFzcGVjdFJhdGlvOiAxLjM1LFxuICAgIGhlYWRlclRvb2xiYXI6IHtcbiAgICAgICAgc3RhcnQ6ICd0aXRsZScsXG4gICAgICAgIGNlbnRlcjogJycsXG4gICAgICAgIGVuZDogJ3RvZGF5IHByZXYsbmV4dCcsXG4gICAgfSxcbiAgICB3ZWVrZW5kczogdHJ1ZSxcbiAgICB3ZWVrTnVtYmVyczogZmFsc2UsXG4gICAgd2Vla051bWJlckNhbGN1bGF0aW9uOiAnbG9jYWwnLFxuICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICBub3dJbmRpY2F0b3I6IGZhbHNlLFxuICAgIHNjcm9sbFRpbWU6ICcwNjowMDowMCcsXG4gICAgc2Nyb2xsVGltZVJlc2V0OiB0cnVlLFxuICAgIHNsb3RNaW5UaW1lOiAnMDA6MDA6MDAnLFxuICAgIHNsb3RNYXhUaW1lOiAnMjQ6MDA6MDAnLFxuICAgIHNob3dOb25DdXJyZW50RGF0ZXM6IHRydWUsXG4gICAgbGF6eUZldGNoaW5nOiB0cnVlLFxuICAgIHN0YXJ0UGFyYW06ICdzdGFydCcsXG4gICAgZW5kUGFyYW06ICdlbmQnLFxuICAgIHRpbWVab25lUGFyYW06ICd0aW1lWm9uZScsXG4gICAgdGltZVpvbmU6ICdsb2NhbCcsXG4gICAgbG9jYWxlczogW10sXG4gICAgbG9jYWxlOiAnJyxcbiAgICB0aGVtZVN5c3RlbTogJ3N0YW5kYXJkJyxcbiAgICBkcmFnUmV2ZXJ0RHVyYXRpb246IDUwMCxcbiAgICBkcmFnU2Nyb2xsOiB0cnVlLFxuICAgIGFsbERheU1haW50YWluRHVyYXRpb246IGZhbHNlLFxuICAgIHVuc2VsZWN0QXV0bzogdHJ1ZSxcbiAgICBkcm9wQWNjZXB0OiAnKicsXG4gICAgZXZlbnRPcmRlcjogJ3N0YXJ0LC1kdXJhdGlvbixhbGxEYXksdGl0bGUnLFxuICAgIGRheVBvcG92ZXJGb3JtYXQ6IHsgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycsIHllYXI6ICdudW1lcmljJyB9LFxuICAgIGhhbmRsZVdpbmRvd1Jlc2l6ZTogdHJ1ZSxcbiAgICB3aW5kb3dSZXNpemVEZWxheTogMTAwLFxuICAgIGxvbmdQcmVzc0RlbGF5OiAxMDAwLFxuICAgIGV2ZW50RHJhZ01pbkRpc3RhbmNlOiA1LFxuICAgIGV4cGFuZFJvd3M6IGZhbHNlLFxuICAgIG5hdkxpbmtzOiBmYWxzZSxcbiAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICBldmVudE1pbkhlaWdodDogMTUsXG4gICAgZXZlbnRNaW5XaWR0aDogMzAsXG4gICAgZXZlbnRTaG9ydEhlaWdodDogMzAsXG4gICAgbW9udGhTdGFydEZvcm1hdDogeyBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJyB9LFxufTtcbi8vIGNhbGVuZGFyIGxpc3RlbmVyc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5jb25zdCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyA9IHtcbiAgICBkYXRlc1NldDogaWRlbnRpdHksXG4gICAgZXZlbnRzU2V0OiBpZGVudGl0eSxcbiAgICBldmVudEFkZDogaWRlbnRpdHksXG4gICAgZXZlbnRDaGFuZ2U6IGlkZW50aXR5LFxuICAgIGV2ZW50UmVtb3ZlOiBpZGVudGl0eSxcbiAgICB3aW5kb3dSZXNpemU6IGlkZW50aXR5LFxuICAgIGV2ZW50Q2xpY2s6IGlkZW50aXR5LFxuICAgIGV2ZW50TW91c2VFbnRlcjogaWRlbnRpdHksXG4gICAgZXZlbnRNb3VzZUxlYXZlOiBpZGVudGl0eSxcbiAgICBzZWxlY3Q6IGlkZW50aXR5LFxuICAgIHVuc2VsZWN0OiBpZGVudGl0eSxcbiAgICBsb2FkaW5nOiBpZGVudGl0eSxcbiAgICAvLyBpbnRlcm5hbFxuICAgIF91bm1vdW50OiBpZGVudGl0eSxcbiAgICBfYmVmb3JlcHJpbnQ6IGlkZW50aXR5LFxuICAgIF9hZnRlcnByaW50OiBpZGVudGl0eSxcbiAgICBfbm9FdmVudERyb3A6IGlkZW50aXR5LFxuICAgIF9ub0V2ZW50UmVzaXplOiBpZGVudGl0eSxcbiAgICBfcmVzaXplOiBpZGVudGl0eSxcbiAgICBfc2Nyb2xsUmVxdWVzdDogaWRlbnRpdHksXG59O1xuLy8gY2FsZW5kYXItc3BlY2lmaWMgb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTID0ge1xuICAgIGJ1dHRvblRleHQ6IGlkZW50aXR5LFxuICAgIGJ1dHRvbkhpbnRzOiBpZGVudGl0eSxcbiAgICB2aWV3czogaWRlbnRpdHksXG4gICAgcGx1Z2luczogaWRlbnRpdHksXG4gICAgaW5pdGlhbEV2ZW50czogaWRlbnRpdHksXG4gICAgZXZlbnRzOiBpZGVudGl0eSxcbiAgICBldmVudFNvdXJjZXM6IGlkZW50aXR5LFxufTtcbmNvbnN0IENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTID0ge1xuICAgIGhlYWRlclRvb2xiYXI6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG4gICAgZm9vdGVyVG9vbGJhcjogaXNNYXliZU9iamVjdHNFcXVhbCxcbiAgICBidXR0b25UZXh0OiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGJ1dHRvbkhpbnRzOiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGJ1dHRvbkljb25zOiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGRhdGVJbmNyZW1lbnQ6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG4gICAgcGx1Z2luczogaXNNYXliZUFycmF5c0VxdWFsLFxuICAgIGV2ZW50czogaXNNYXliZUFycmF5c0VxdWFsLFxuICAgIGV2ZW50U291cmNlczogaXNNYXliZUFycmF5c0VxdWFsLFxuICAgIFsncmVzb3VyY2VzJ106IGlzTWF5YmVBcnJheXNFcXVhbCxcbn07XG5mdW5jdGlvbiBpc01heWJlT2JqZWN0c0VxdWFsKGEsIGIpIHtcbiAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiID09PSAnb2JqZWN0JyAmJiBhICYmIGIpIHsgLy8gYm90aCBub24tbnVsbCBvYmplY3RzXG4gICAgICAgIHJldHVybiBpc1Byb3BzRXF1YWwoYSwgYik7XG4gICAgfVxuICAgIHJldHVybiBhID09PSBiO1xufVxuZnVuY3Rpb24gaXNNYXliZUFycmF5c0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5c0VxdWFsKGEsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gYSA9PT0gYjtcbn1cbi8vIHZpZXctc3BlY2lmaWMgb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jb25zdCBWSUVXX09QVElPTl9SRUZJTkVSUyA9IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgY29tcG9uZW50OiBpZGVudGl0eSxcbiAgICBidXR0b25UZXh0OiBTdHJpbmcsXG4gICAgYnV0dG9uVGV4dEtleTogU3RyaW5nLFxuICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3M6IGlkZW50aXR5LFxuICAgIHVzZXNNaW5NYXhUaW1lOiBCb29sZWFuLFxuICAgIGNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIGNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIGRpZE1vdW50OiBpZGVudGl0eSxcbiAgICB3aWxsVW5tb3VudDogaWRlbnRpdHksXG59O1xuLy8gdXRpbCBmdW5jc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gbWVyZ2VSYXdPcHRpb25zKG9wdGlvblNldHMpIHtcbiAgICByZXR1cm4gbWVyZ2VQcm9wcyhvcHRpb25TZXRzLCBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUyk7XG59XG5mdW5jdGlvbiByZWZpbmVQcm9wcyhpbnB1dCwgcmVmaW5lcnMpIHtcbiAgICBsZXQgcmVmaW5lZCA9IHt9O1xuICAgIGxldCBleHRyYSA9IHt9O1xuICAgIGZvciAobGV0IHByb3BOYW1lIGluIHJlZmluZXJzKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgcmVmaW5lZFtwcm9wTmFtZV0gPSByZWZpbmVyc1twcm9wTmFtZV0oaW5wdXRbcHJvcE5hbWVdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBpbnB1dCkge1xuICAgICAgICBpZiAoIShwcm9wTmFtZSBpbiByZWZpbmVycykpIHtcbiAgICAgICAgICAgIGV4dHJhW3Byb3BOYW1lXSA9IGlucHV0W3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyByZWZpbmVkLCBleHRyYSB9O1xufVxuZnVuY3Rpb24gaWRlbnRpdHkocmF3KSB7XG4gICAgcmV0dXJuIHJhdztcbn1cblxuY29uc3QgeyBoYXNPd25Qcm9wZXJ0eSB9ID0gT2JqZWN0LnByb3RvdHlwZTtcbi8vIE1lcmdlcyBhbiBhcnJheSBvZiBvYmplY3RzIGludG8gYSBzaW5nbGUgb2JqZWN0LlxuLy8gVGhlIHNlY29uZCBhcmd1bWVudCBhbGxvd3MgZm9yIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHdobydzIG9iamVjdCB2YWx1ZXMgd2lsbCBiZSBtZXJnZWQgdG9nZXRoZXIuXG5mdW5jdGlvbiBtZXJnZVByb3BzKHByb3BPYmpzLCBjb21wbGV4UHJvcHNNYXApIHtcbiAgICBsZXQgZGVzdCA9IHt9O1xuICAgIGlmIChjb21wbGV4UHJvcHNNYXApIHtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBjb21wbGV4UHJvcHNNYXApIHtcbiAgICAgICAgICAgIGlmIChjb21wbGV4UHJvcHNNYXBbbmFtZV0gPT09IGlzTWF5YmVPYmplY3RzRXF1YWwpIHsgLy8gaW1wbGllcyB0aGF0IGl0J3Mgb2JqZWN0LW1lcmdlYWJsZVxuICAgICAgICAgICAgICAgIGxldCBjb21wbGV4T2JqcyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIGNvbGxlY3QgdGhlIHRyYWlsaW5nIG9iamVjdCB2YWx1ZXMsIHN0b3BwaW5nIHdoZW4gYSBub24tb2JqZWN0IGlzIGRpc2NvdmVyZWRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcHJvcE9ianMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHByb3BPYmpzW2ldW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsKSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxleE9ianMudW5zaGlmdCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0W25hbWVdID0gdmFsOyAvLyBpZiB0aGVyZSB3ZXJlIG5vIG9iamVjdHMsIHRoaXMgdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdHJhaWxpbmcgdmFsdWVzIHdlcmUgb2JqZWN0cywgdXNlIHRoZSBtZXJnZWQgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxleE9ianMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RbbmFtZV0gPSBtZXJnZVByb3BzKGNvbXBsZXhPYmpzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY29weSB2YWx1ZXMgaW50byB0aGUgZGVzdGluYXRpb24sIGdvaW5nIGZyb20gbGFzdCB0byBmaXJzdFxuICAgIGZvciAobGV0IGkgPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBsZXQgcHJvcHMgPSBwcm9wT2Jqc1tpXTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcm9wcykge1xuICAgICAgICAgICAgaWYgKCEobmFtZSBpbiBkZXN0KSkgeyAvLyBpZiBhbHJlYWR5IGFzc2lnbmVkIGJ5IHByZXZpb3VzIHByb3BzIG9yIGNvbXBsZXggcHJvcHMsIGRvbid0IHJlYXNzaWduXG4gICAgICAgICAgICAgICAgZGVzdFtuYW1lXSA9IHByb3BzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuZnVuY3Rpb24gZmlsdGVySGFzaChoYXNoLCBmdW5jKSB7XG4gICAgbGV0IGZpbHRlcmVkID0ge307XG4gICAgZm9yIChsZXQga2V5IGluIGhhc2gpIHtcbiAgICAgICAgaWYgKGZ1bmMoaGFzaFtrZXldLCBrZXkpKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZFtrZXldID0gaGFzaFtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJlZDtcbn1cbmZ1bmN0aW9uIG1hcEhhc2goaGFzaCwgZnVuYykge1xuICAgIGxldCBuZXdIYXNoID0ge307XG4gICAgZm9yIChsZXQga2V5IGluIGhhc2gpIHtcbiAgICAgICAgbmV3SGFzaFtrZXldID0gZnVuYyhoYXNoW2tleV0sIGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdIYXNoO1xufVxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYSkge1xuICAgIGxldCBoYXNoID0ge307XG4gICAgZm9yIChsZXQgaXRlbSBvZiBhKSB7XG4gICAgICAgIGhhc2hbaXRlbV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbn1cbi8vIFRPRE86IHJlYXNzZXNzIGJyb3dzZXIgc3VwcG9ydFxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8/c2VhcmNoPW9iamVjdC52YWx1ZXNcbmZ1bmN0aW9uIGhhc2hWYWx1ZXNUb0FycmF5KG9iaikge1xuICAgIGxldCBhID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgICAgICBhLnB1c2gob2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIGlzUHJvcHNFcXVhbChvYmowLCBvYmoxKSB7XG4gICAgaWYgKG9iajAgPT09IG9iajEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAobGV0IGtleSBpbiBvYmowKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajAsIGtleSkpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBvYmoxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqMSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmoxLCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAob2JqMFtrZXldICE9PSBvYmoxW2tleV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBIQU5ETEVSX1JFID0gL15vbltBLVpdLztcbmZ1bmN0aW9uIGlzTm9uSGFuZGxlclByb3BzRXF1YWwob2JqMCwgb2JqMSkge1xuICAgIGNvbnN0IGtleXMgPSBnZXRVbmVxdWFsUHJvcHMob2JqMCwgb2JqMSk7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgICAgaWYgKCFIQU5ETEVSX1JFLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0VW5lcXVhbFByb3BzKG9iajAsIG9iajEpIHtcbiAgICBsZXQga2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvYmowKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajAsIGtleSkpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBvYmoxKSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGtleSBpbiBvYmoxKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajEsIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChvYmowW2tleV0gIT09IG9iajFba2V5XSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gY29tcGFyZU9ianMob2xkUHJvcHMsIG5ld1Byb3BzLCBlcXVhbGl0eUZ1bmNzID0ge30pIHtcbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgaWYgKGtleSBpbiBvbGRQcm9wcyAmJiBpc09ialZhbHNFcXVhbChvbGRQcm9wc1trZXldLCBuZXdQcm9wc1trZXldLCBlcXVhbGl0eUZ1bmNzW2tleV0pKSA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBwcm9wcyB0aGF0IHdlcmUgb21pdHRlZCBpbiB0aGUgbmV3XG4gICAgZm9yIChsZXQga2V5IGluIG9sZFByb3BzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBuZXdQcm9wcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qXG5hc3N1bWVkIFwidHJ1ZVwiIGVxdWFsaXR5IGZvciBoYW5kbGVyIG5hbWVzIGxpa2UgXCJvblJlY2VpdmVTb21ldGhpbmdcIlxuKi9cbmZ1bmN0aW9uIGlzT2JqVmFsc0VxdWFsKHZhbDAsIHZhbDEsIGNvbXBhcmF0b3IpIHtcbiAgICBpZiAodmFsMCA9PT0gdmFsMSB8fCBjb21wYXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29tcGFyYXRvcih2YWwwLCB2YWwxKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29sbGVjdEZyb21IYXNoKGhhc2gsIHN0YXJ0SW5kZXggPSAwLCBlbmRJbmRleCwgc3RlcCA9IDEpIHtcbiAgICBsZXQgcmVzID0gW107XG4gICAgaWYgKGVuZEluZGV4ID09IG51bGwpIHtcbiAgICAgICAgZW5kSW5kZXggPSBPYmplY3Qua2V5cyhoYXNoKS5sZW5ndGg7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkgKz0gc3RlcCkge1xuICAgICAgICBsZXQgdmFsID0gaGFzaFtpXTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7IC8vIHdpbGwgZGlzcmVnYXJkIHVuZGVmaW5lZCBmb3Igc3BhcnNlIGFycmF5c1xuICAgICAgICAgICAgcmVzLnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5sZXQgY2FsZW5kYXJTeXN0ZW1DbGFzc01hcCA9IHt9O1xuZnVuY3Rpb24gcmVnaXN0ZXJDYWxlbmRhclN5c3RlbShuYW1lLCB0aGVDbGFzcykge1xuICAgIGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0gPSB0aGVDbGFzcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhbGVuZGFyU3lzdGVtKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0oKTtcbn1cbmNsYXNzIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtIHtcbiAgICBnZXRNYXJrZXJZZWFyKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICB9XG4gICAgZ2V0TWFya2VyTW9udGgoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENNb250aCgpO1xuICAgIH1cbiAgICBnZXRNYXJrZXJEYXkoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENEYXRlKCk7XG4gICAgfVxuICAgIGFycmF5VG9NYXJrZXIoYXJyKSB7XG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhcnIpO1xuICAgIH1cbiAgICBtYXJrZXJUb0FycmF5KG1hcmtlcikge1xuICAgICAgICByZXR1cm4gZGF0ZVRvVXRjQXJyYXkobWFya2VyKTtcbiAgICB9XG59XG5yZWdpc3RlckNhbGVuZGFyU3lzdGVtKCdncmVnb3J5JywgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0pO1xuXG5jb25zdCBJU09fUkUgPSAvXlxccyooXFxkezR9KSgtPyhcXGR7Mn0pKC0/KFxcZHsyfSkoW1QgXShcXGR7Mn0pOj8oXFxkezJ9KSg6PyhcXGR7Mn0pKFxcLihcXGQrKSk/KT8oWnwoKFstK10pKFxcZHsyfSkoOj8oXFxkezJ9KSk/KSk/KT8pPyk/JC87XG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgICBsZXQgbSA9IElTT19SRS5leGVjKHN0cik7XG4gICAgaWYgKG0pIHtcbiAgICAgICAgbGV0IG1hcmtlciA9IG5ldyBEYXRlKERhdGUuVVRDKE51bWJlcihtWzFdKSwgbVszXSA/IE51bWJlcihtWzNdKSAtIDEgOiAwLCBOdW1iZXIobVs1XSB8fCAxKSwgTnVtYmVyKG1bN10gfHwgMCksIE51bWJlcihtWzhdIHx8IDApLCBOdW1iZXIobVsxMF0gfHwgMCksIG1bMTJdID8gTnVtYmVyKGAwLiR7bVsxMl19YCkgKiAxMDAwIDogMCkpO1xuICAgICAgICBpZiAoaXNWYWxpZERhdGUobWFya2VyKSkge1xuICAgICAgICAgICAgbGV0IHRpbWVab25lT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChtWzEzXSkge1xuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0ID0gKG1bMTVdID09PSAnLScgPyAtMSA6IDEpICogKE51bWJlcihtWzE2XSB8fCAwKSAqIDYwICtcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyKG1bMThdIHx8IDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWFya2VyLFxuICAgICAgICAgICAgICAgIGlzVGltZVVuc3BlY2lmaWVkOiAhbVs2XSxcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNsYXNzIERhdGVFbnYge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIGxldCB0aW1lWm9uZSA9IHRoaXMudGltZVpvbmUgPSBzZXR0aW5ncy50aW1lWm9uZTtcbiAgICAgICAgbGV0IGlzTmFtZWRUaW1lWm9uZSA9IHRpbWVab25lICE9PSAnbG9jYWwnICYmIHRpbWVab25lICE9PSAnVVRDJztcbiAgICAgICAgaWYgKHNldHRpbmdzLm5hbWVkVGltZVpvbmVJbXBsICYmIGlzTmFtZWRUaW1lWm9uZSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lZFRpbWVab25lSW1wbCA9IG5ldyBzZXR0aW5ncy5uYW1lZFRpbWVab25lSW1wbCh0aW1lWm9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5Db21wdXRlT2Zmc2V0ID0gQm9vbGVhbighaXNOYW1lZFRpbWVab25lIHx8IHRoaXMubmFtZWRUaW1lWm9uZUltcGwpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtID0gY3JlYXRlQ2FsZW5kYXJTeXN0ZW0oc2V0dGluZ3MuY2FsZW5kYXJTeXN0ZW0pO1xuICAgICAgICB0aGlzLmxvY2FsZSA9IHNldHRpbmdzLmxvY2FsZTtcbiAgICAgICAgdGhpcy53ZWVrRG93ID0gc2V0dGluZ3MubG9jYWxlLndlZWsuZG93O1xuICAgICAgICB0aGlzLndlZWtEb3kgPSBzZXR0aW5ncy5sb2NhbGUud2Vlay5kb3k7XG4gICAgICAgIGlmIChzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdJU08nKSB7XG4gICAgICAgICAgICB0aGlzLndlZWtEb3cgPSAxO1xuICAgICAgICAgICAgdGhpcy53ZWVrRG95ID0gNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmZpcnN0RGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrRG93ID0gc2V0dGluZ3MuZmlyc3REYXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMud2Vla051bWJlckZ1bmMgPSBzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53ZWVrVGV4dCA9IHNldHRpbmdzLndlZWtUZXh0ICE9IG51bGwgPyBzZXR0aW5ncy53ZWVrVGV4dCA6IHNldHRpbmdzLmxvY2FsZS5vcHRpb25zLndlZWtUZXh0O1xuICAgICAgICB0aGlzLndlZWtUZXh0TG9uZyA9IChzZXR0aW5ncy53ZWVrVGV4dExvbmcgIT0gbnVsbCA/IHNldHRpbmdzLndlZWtUZXh0TG9uZyA6IHNldHRpbmdzLmxvY2FsZS5vcHRpb25zLndlZWtUZXh0TG9uZykgfHwgdGhpcy53ZWVrVGV4dDtcbiAgICAgICAgdGhpcy5jbWRGb3JtYXR0ZXIgPSBzZXR0aW5ncy5jbWRGb3JtYXR0ZXI7XG4gICAgICAgIHRoaXMuZGVmYXVsdFNlcGFyYXRvciA9IHNldHRpbmdzLmRlZmF1bHRTZXBhcmF0b3I7XG4gICAgfVxuICAgIC8vIENyZWF0aW5nIC8gUGFyc2luZ1xuICAgIGNyZWF0ZU1hcmtlcihpbnB1dCkge1xuICAgICAgICBsZXQgbWV0YSA9IHRoaXMuY3JlYXRlTWFya2VyTWV0YShpbnB1dCk7XG4gICAgICAgIGlmIChtZXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0YS5tYXJrZXI7XG4gICAgfVxuICAgIGNyZWF0ZU5vd01hcmtlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuQ29tcHV0ZU9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wVG9NYXJrZXIobmV3IERhdGUoKS52YWx1ZU9mKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGNhbid0IGNvbXB1dGUgdGhlIGN1cnJlbnQgZGF0ZSB2YWwgZm9yIGEgdGltZXpvbmUsXG4gICAgICAgIC8vIGJldHRlciB0byBnaXZlIHRoZSBjdXJyZW50IGxvY2FsIGRhdGUgdmFscyB0aGFuIFVUQ1xuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoZGF0ZVRvTG9jYWxBcnJheShuZXcgRGF0ZSgpKSk7XG4gICAgfVxuICAgIGNyZWF0ZU1hcmtlck1ldGEoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWFya2VyID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBtYXJrZXIgPSBhcnJheVRvVXRjRGF0ZShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlciA9PT0gbnVsbCB8fCAhaXNWYWxpZERhdGUobWFya2VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWFya2VyLCBpc1RpbWVVbnNwZWNpZmllZDogZmFsc2UsIGZvcmNlZFR6bzogbnVsbCB9O1xuICAgIH1cbiAgICBwYXJzZShzKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IHBhcnNlKHMpO1xuICAgICAgICBpZiAocGFydHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IG1hcmtlciB9ID0gcGFydHM7XG4gICAgICAgIGxldCBmb3JjZWRUem8gPSBudWxsO1xuICAgICAgICBpZiAocGFydHMudGltZVpvbmVPZmZzZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbkNvbXB1dGVPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgPSB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKG1hcmtlci52YWx1ZU9mKCkgLSBwYXJ0cy50aW1lWm9uZU9mZnNldCAqIDYwICogMTAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JjZWRUem8gPSBwYXJ0cy50aW1lWm9uZU9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXJrZXIsIGlzVGltZVVuc3BlY2lmaWVkOiBwYXJ0cy5pc1RpbWVVbnNwZWNpZmllZCwgZm9yY2VkVHpvIH07XG4gICAgfVxuICAgIC8vIEFjY2Vzc29yc1xuICAgIGdldFllYXIobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobWFya2VyKTtcbiAgICB9XG4gICAgZ2V0TW9udGgobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG1hcmtlcik7XG4gICAgfVxuICAgIGdldERheShtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIEFkZGluZyAvIFN1YnRyYWN0aW5nXG4gICAgYWRkKG1hcmtlciwgZHVyKSB7XG4gICAgICAgIGxldCBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgIGFbMF0gKz0gZHVyLnllYXJzO1xuICAgICAgICBhWzFdICs9IGR1ci5tb250aHM7XG4gICAgICAgIGFbMl0gKz0gZHVyLmRheXM7XG4gICAgICAgIGFbNl0gKz0gZHVyLm1pbGxpc2Vjb25kcztcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcbiAgICB9XG4gICAgc3VidHJhY3QobWFya2VyLCBkdXIpIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKTtcbiAgICAgICAgYVswXSAtPSBkdXIueWVhcnM7XG4gICAgICAgIGFbMV0gLT0gZHVyLm1vbnRocztcbiAgICAgICAgYVsyXSAtPSBkdXIuZGF5cztcbiAgICAgICAgYVs2XSAtPSBkdXIubWlsbGlzZWNvbmRzO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpO1xuICAgIH1cbiAgICBhZGRZZWFycyhtYXJrZXIsIG4pIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKTtcbiAgICAgICAgYVswXSArPSBuO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpO1xuICAgIH1cbiAgICBhZGRNb250aHMobWFya2VyLCBuKSB7XG4gICAgICAgIGxldCBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgIGFbMV0gKz0gbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcbiAgICB9XG4gICAgLy8gRGlmZmluZyBXaG9sZSBVbml0c1xuICAgIGRpZmZXaG9sZVllYXJzKG0wLCBtMSkge1xuICAgICAgICBsZXQgeyBjYWxlbmRhclN5c3RlbSB9ID0gdGhpcztcbiAgICAgICAgaWYgKHRpbWVBc01zKG0wKSA9PT0gdGltZUFzTXMobTEpICYmXG4gICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTApID09PSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTEpICYmXG4gICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMCkgPT09IGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0xKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRpZmZXaG9sZU1vbnRocyhtMCwgbTEpIHtcbiAgICAgICAgbGV0IHsgY2FsZW5kYXJTeXN0ZW0gfSA9IHRoaXM7XG4gICAgICAgIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSAmJlxuICAgICAgICAgICAgY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0wKSA9PT0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0xKSkge1xuICAgICAgICAgICAgcmV0dXJuIChjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMCkpICtcbiAgICAgICAgICAgICAgICAoY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0wKSkgKiAxMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gUmFuZ2UgLyBEdXJhdGlvblxuICAgIGdyZWF0ZXN0V2hvbGVVbml0KG0wLCBtMSkge1xuICAgICAgICBsZXQgbiA9IHRoaXMuZGlmZldob2xlWWVhcnMobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gdGhpcy5kaWZmV2hvbGVNb250aHMobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtb250aCcsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZXaG9sZVdlZWtzKG0wLCBtMSk7XG4gICAgICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnd2VlaycsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdkYXknLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSBkaWZmSG91cnMobTAsIG0xKTtcbiAgICAgICAgaWYgKGlzSW50KG4pKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnaG91cicsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZNaW51dGVzKG0wLCBtMSk7XG4gICAgICAgIGlmIChpc0ludChuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21pbnV0ZScsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZTZWNvbmRzKG0wLCBtMSk7XG4gICAgICAgIGlmIChpc0ludChuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3NlY29uZCcsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21pbGxpc2Vjb25kJywgdmFsdWU6IG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSB9O1xuICAgIH1cbiAgICBjb3VudER1cmF0aW9uc0JldHdlZW4obTAsIG0xLCBkKSB7XG4gICAgICAgIC8vIFRPRE86IGNhbiB1c2UgZ3JlYXRlc3RXaG9sZVVuaXRcbiAgICAgICAgbGV0IGRpZmY7XG4gICAgICAgIGlmIChkLnllYXJzKSB7XG4gICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmV2hvbGVZZWFycyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hZZWFycyhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZC5tb250aHMpIHtcbiAgICAgICAgICAgIGRpZmYgPSB0aGlzLmRpZmZXaG9sZU1vbnRocyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hNb250aHMoZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQuZGF5cykge1xuICAgICAgICAgICAgZGlmZiA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICAgICAgICAgIGlmIChkaWZmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgLyBhc1JvdWdoRGF5cyhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyBhc1JvdWdoTXMoZCk7XG4gICAgfVxuICAgIC8vIFN0YXJ0LU9mXG4gICAgLy8gdGhlc2UgRE9OJ1QgcmV0dXJuIHpvbmVkLWRhdGVzLiBvbmx5IFVUQyBzdGFydC1vZiBkYXRlc1xuICAgIHN0YXJ0T2YobSwgdW5pdCkge1xuICAgICAgICBpZiAodW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mWWVhcihtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZk1vbnRoKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZXZWVrKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnZGF5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZEYXkobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdob3VyJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZIb3VyKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnbWludXRlJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZNaW51dGUobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRPZlNlY29uZChtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RhcnRPZlllYXIobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKFtcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtKSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHN0YXJ0T2ZNb250aChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoW1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtKSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHN0YXJ0T2ZXZWVrKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0pLFxuICAgICAgICAgICAgbS5nZXRVVENEYXRlKCkgLSAoKG0uZ2V0VVRDRGF5KCkgLSB0aGlzLndlZWtEb3cgKyA3KSAlIDcpLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLy8gV2VlayBOdW1iZXJcbiAgICBjb21wdXRlV2Vla051bWJlcihtYXJrZXIpIHtcbiAgICAgICAgaWYgKHRoaXMud2Vla051bWJlckZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlZWtOdW1iZXJGdW5jKHRoaXMudG9EYXRlKG1hcmtlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1hcmtlciwgdGhpcy53ZWVrRG93LCB0aGlzLndlZWtEb3kpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBjaG9rZSBvbiB0aW1lWm9uZU5hbWU6IGxvbmdcbiAgICBmb3JtYXQobWFya2VyLCBmb3JtYXR0ZXIsIGRhdGVPcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQoe1xuICAgICAgICAgICAgbWFya2VyLFxuICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVPcHRpb25zLmZvcmNlZFR6byAhPSBudWxsID9cbiAgICAgICAgICAgICAgICBkYXRlT3B0aW9ucy5mb3JjZWRUem8gOlxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0Rm9yTWFya2VyKG1hcmtlciksXG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBmb3JtYXRSYW5nZShzdGFydCwgZW5kLCBmb3JtYXR0ZXIsIGRhdGVPcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKGRhdGVPcHRpb25zLmlzRW5kRXhjbHVzaXZlKSB7XG4gICAgICAgICAgICBlbmQgPSBhZGRNcyhlbmQsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdFJhbmdlKHtcbiAgICAgICAgICAgIG1hcmtlcjogc3RhcnQsXG4gICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkU3RhcnRUem8gIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkU3RhcnRUem8gOlxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0Rm9yTWFya2VyKHN0YXJ0KSxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWFya2VyOiBlbmQsXG4gICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkRW5kVHpvICE9IG51bGwgP1xuICAgICAgICAgICAgICAgIGRhdGVPcHRpb25zLmZvcmNlZEVuZFR6byA6XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRGb3JNYXJrZXIoZW5kKSxcbiAgICAgICAgfSwgdGhpcywgZGF0ZU9wdGlvbnMuZGVmYXVsdFNlcGFyYXRvcik7XG4gICAgfVxuICAgIC8qXG4gICAgRFVNQjogdGhlIG9taXRUaW1lIGFyZyBpcyBkdW1iLiBpZiB3ZSBvbWl0IHRoZSB0aW1lLCB3ZSB3YW50IHRvIG9taXQgdGhlIHRpbWV6b25lIG9mZnNldC4gYW5kIGlmIHdlIGRvIHRoYXQsXG4gICAgbWlnaHQgYXMgd2VsbCB1c2UgYnVpbGRJc29TdHJpbmcgb3Igc29tZSBvdGhlciB1dGlsIGRpcmVjdGx5XG4gICAgKi9cbiAgICBmb3JtYXRJc28obWFya2VyLCBleHRyYU9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgdGltZVpvbmVPZmZzZXQgPSBudWxsO1xuICAgICAgICBpZiAoIWV4dHJhT3B0aW9ucy5vbWl0VGltZVpvbmVPZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChleHRyYU9wdGlvbnMuZm9yY2VkVHpvICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCA9IGV4dHJhT3B0aW9ucy5mb3JjZWRUem87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCA9IHRoaXMub2Zmc2V0Rm9yTWFya2VyKG1hcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkSXNvU3RyaW5nKG1hcmtlciwgdGltZVpvbmVPZmZzZXQsIGV4dHJhT3B0aW9ucy5vbWl0VGltZSk7XG4gICAgfVxuICAgIC8vIFRpbWVab25lXG4gICAgdGltZXN0YW1wVG9NYXJrZXIobXMpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShkYXRlVG9Mb2NhbEFycmF5KG5ldyBEYXRlKG1zKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJyB8fCAhdGhpcy5uYW1lZFRpbWVab25lSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUodGhpcy5uYW1lZFRpbWVab25lSW1wbC50aW1lc3RhbXBUb0FycmF5KG1zKSk7XG4gICAgfVxuICAgIG9mZnNldEZvck1hcmtlcihtKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gLWFycmF5VG9Mb2NhbERhdGUoZGF0ZVRvVXRjQXJyYXkobSkpLmdldFRpbWV6b25lT2Zmc2V0KCk7IC8vIGNvbnZlcnQgXCJpbnZlcnNlXCIgb2Zmc2V0IHRvIFwibm9ybWFsXCIgb2Zmc2V0XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdVVEMnKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uYW1lZFRpbWVab25lSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZWRUaW1lWm9uZUltcGwub2Zmc2V0Rm9yQXJyYXkoZGF0ZVRvVXRjQXJyYXkobSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBDb252ZXJzaW9uXG4gICAgdG9EYXRlKG0sIGZvcmNlZFR6bykge1xuICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5VG9Mb2NhbERhdGUoZGF0ZVRvVXRjQXJyYXkobSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG0udmFsdWVPZigpKTsgLy8gbWFrZSBzdXJlIGl0J3MgYSBjb3B5XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm5hbWVkVGltZVpvbmVJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkgLSAoZm9yY2VkVHpvIHx8IDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkgLVxuICAgICAgICAgICAgdGhpcy5uYW1lZFRpbWVab25lSW1wbC5vZmZzZXRGb3JBcnJheShkYXRlVG9VdGNBcnJheShtKSkgKiAxMDAwICogNjApO1xuICAgIH1cbn1cblxuY2xhc3MgVGhlbWUge1xuICAgIGNvbnN0cnVjdG9yKGNhbGVuZGFyT3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5pY29uT3ZlcnJpZGVPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SWNvbk92ZXJyaWRlKGNhbGVuZGFyT3B0aW9uc1t0aGlzLmljb25PdmVycmlkZU9wdGlvbl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEljb25PdmVycmlkZShpY29uT3ZlcnJpZGVIYXNoKSB7XG4gICAgICAgIGxldCBpY29uQ2xhc3Nlc0NvcHk7XG4gICAgICAgIGxldCBidXR0b25OYW1lO1xuICAgICAgICBpZiAodHlwZW9mIGljb25PdmVycmlkZUhhc2ggPT09ICdvYmplY3QnICYmIGljb25PdmVycmlkZUhhc2gpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgICAgICBpY29uQ2xhc3Nlc0NvcHkgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmljb25DbGFzc2VzKTtcbiAgICAgICAgICAgIGZvciAoYnV0dG9uTmFtZSBpbiBpY29uT3ZlcnJpZGVIYXNoKSB7XG4gICAgICAgICAgICAgICAgaWNvbkNsYXNzZXNDb3B5W2J1dHRvbk5hbWVdID0gdGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChpY29uT3ZlcnJpZGVIYXNoW2J1dHRvbk5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaWNvbkNsYXNzZXMgPSBpY29uQ2xhc3Nlc0NvcHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWNvbk92ZXJyaWRlSGFzaCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuaWNvbkNsYXNzZXMgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseUljb25PdmVycmlkZVByZWZpeChjbGFzc05hbWUpIHtcbiAgICAgICAgbGV0IHByZWZpeCA9IHRoaXMuaWNvbk92ZXJyaWRlUHJlZml4O1xuICAgICAgICBpZiAocHJlZml4ICYmIGNsYXNzTmFtZS5pbmRleE9mKHByZWZpeCkgIT09IDApIHsgLy8gaWYgbm90IGFscmVhZHkgcHJlc2VudFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgfVxuICAgIGdldENsYXNzKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc2VzW2tleV0gfHwgJyc7XG4gICAgfVxuICAgIGdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkge1xuICAgICAgICBsZXQgY2xhc3NOYW1lO1xuICAgICAgICBpZiAoaXNSdGwgJiYgdGhpcy5ydGxJY29uQ2xhc3Nlcykge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gdGhpcy5ydGxJY29uQ2xhc3Nlc1tidXR0b25OYW1lXSB8fCB0aGlzLmljb25DbGFzc2VzW2J1dHRvbk5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gdGhpcy5pY29uQ2xhc3Nlc1tidXR0b25OYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5iYXNlSWNvbkNsYXNzfSAke2NsYXNzTmFtZX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzKGN1c3RvbUJ1dHRvblByb3BzKSB7XG4gICAgICAgIGxldCBjbGFzc05hbWU7XG4gICAgICAgIGlmICh0aGlzLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbikge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gY3VzdG9tQnV0dG9uUHJvcHNbdGhpcy5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb25dO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmJhc2VJY29uQ2xhc3N9ICR7dGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChjbGFzc05hbWUpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cblRoZW1lLnByb3RvdHlwZS5jbGFzc2VzID0ge307XG5UaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7fTtcblRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJyc7XG5UaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJyc7XG5cbi8qXG5OT1RFOiB0aGlzIGNhbiBiZSBhIHB1YmxpYyBBUEksIGVzcGVjaWFsbHkgY3JlYXRlRWxlbWVudCBmb3IgaG9va3MuXG5TZWUgZXhhbXBsZXMvdHlwZXNjcmlwdC1zY2hlZHVsZXIvc3JjL2luZGV4LnRzXG4qL1xuZnVuY3Rpb24gZmx1c2hTeW5jKHJ1bkJlZm9yZUZsdXNoKSB7XG4gICAgcnVuQmVmb3JlRmx1c2goKTtcbiAgICBsZXQgb2xkRGVib3VuY2VSZW5kZXJpbmcgPSBwcmVhY3Qub3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZzsgLy8gb3JpZ1xuICAgIGxldCBjYWxsYmFja1EgPSBbXTtcbiAgICBmdW5jdGlvbiBleGVjQ2FsbGJhY2tTeW5jKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrUS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcHJlYWN0Lm9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSBleGVjQ2FsbGJhY2tTeW5jO1xuICAgIHByZWFjdC5yZW5kZXIocHJlYWN0LmNyZWF0ZUVsZW1lbnQoRmFrZUNvbXBvbmVudCwge30pLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgd2hpbGUgKGNhbGxiYWNrUS5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2tRLnNoaWZ0KCkoKTtcbiAgICB9XG4gICAgcHJlYWN0Lm9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSBvbGREZWJvdW5jZVJlbmRlcmluZztcbn1cbmNsYXNzIEZha2VDb21wb25lbnQgZXh0ZW5kcyBwcmVhY3QuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7IHJldHVybiBwcmVhY3QuY3JlYXRlRWxlbWVudCgnZGl2Jywge30pOyB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7IHRoaXMuc2V0U3RhdGUoe30pOyB9XG59XG4vLyBUT0RPOiB1c2UgcHJlYWN0L2NvbXBhdCBpbnN0ZWFkP1xuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpIHtcbiAgICBsZXQgQ29udGV4dFR5cGUgPSBwcmVhY3QuY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpO1xuICAgIGxldCBvcmlnUHJvdmlkZXIgPSBDb250ZXh0VHlwZS5Qcm92aWRlcjtcbiAgICBDb250ZXh0VHlwZS5Qcm92aWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IGlzTmV3ID0gIXRoaXMuZ2V0Q2hpbGRDb250ZXh0O1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBvcmlnUHJvdmlkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgaWYgKGlzTmV3KSB7XG4gICAgICAgICAgICBsZXQgc3VicyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSAoX3Byb3BzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMudmFsdWUgIT09IF9wcm9wcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuY29udGV4dCA9IF9wcm9wcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc3ViID0gKGMpID0+IHtcbiAgICAgICAgICAgICAgICBzdWJzLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgbGV0IG9sZCA9IGMuY29tcG9uZW50V2lsbFVubW91bnQ7XG4gICAgICAgICAgICAgICAgYy5jb21wb25lbnRXaWxsVW5tb3VudCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3Vicy5zcGxpY2Uoc3Vicy5pbmRleE9mKGMpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkICYmIG9sZC5jYWxsKGMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9O1xuICAgIHJldHVybiBDb250ZXh0VHlwZTtcbn1cblxuY2xhc3MgU2Nyb2xsUmVzcG9uZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihleGVjRnVuYywgZW1pdHRlciwgc2Nyb2xsVGltZSwgc2Nyb2xsVGltZVJlc2V0KSB7XG4gICAgICAgIHRoaXMuZXhlY0Z1bmMgPSBleGVjRnVuYztcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gZW1pdHRlcjtcbiAgICAgICAgdGhpcy5zY3JvbGxUaW1lID0gc2Nyb2xsVGltZTtcbiAgICAgICAgdGhpcy5zY3JvbGxUaW1lUmVzZXQgPSBzY3JvbGxUaW1lUmVzZXQ7XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlZFJlcXVlc3QgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnF1ZXVlZFJlcXVlc3QgfHwge30sIHJlcXVlc3QpO1xuICAgICAgICAgICAgdGhpcy5kcmFpbigpO1xuICAgICAgICB9O1xuICAgICAgICBlbWl0dGVyLm9uKCdfc2Nyb2xsUmVxdWVzdCcsIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCk7XG4gICAgICAgIHRoaXMuZmlyZUluaXRpYWxTY3JvbGwoKTtcbiAgICB9XG4gICAgZGV0YWNoKCkge1xuICAgICAgICB0aGlzLmVtaXR0ZXIub2ZmKCdfc2Nyb2xsUmVxdWVzdCcsIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCk7XG4gICAgfVxuICAgIHVwZGF0ZShpc0RhdGVzTmV3KSB7XG4gICAgICAgIGlmIChpc0RhdGVzTmV3ICYmIHRoaXMuc2Nyb2xsVGltZVJlc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVJbml0aWFsU2Nyb2xsKCk7IC8vIHdpbGwgZHJhaW5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHJhaW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaXJlSW5pdGlhbFNjcm9sbCgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KHtcbiAgICAgICAgICAgIHRpbWU6IHRoaXMuc2Nyb2xsVGltZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRyYWluKCkge1xuICAgICAgICBpZiAodGhpcy5xdWV1ZWRSZXF1ZXN0ICYmIHRoaXMuZXhlY0Z1bmModGhpcy5xdWV1ZWRSZXF1ZXN0KSkge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgVmlld0NvbnRleHRUeXBlID0gY3JlYXRlQ29udGV4dCh7fSk7IC8vIGZvciBDb21wb25lbnRzXG5mdW5jdGlvbiBidWlsZFZpZXdDb250ZXh0KHZpZXdTcGVjLCB2aWV3QXBpLCB2aWV3T3B0aW9ucywgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIGRhdGVFbnYsIHRoZW1lLCBwbHVnaW5Ib29rcywgZGlzcGF0Y2gsIGdldEN1cnJlbnREYXRhLCBlbWl0dGVyLCBjYWxlbmRhckFwaSwgcmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCwgdW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZUVudixcbiAgICAgICAgb3B0aW9uczogdmlld09wdGlvbnMsXG4gICAgICAgIHBsdWdpbkhvb2tzLFxuICAgICAgICBlbWl0dGVyLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgZ2V0Q3VycmVudERhdGEsXG4gICAgICAgIGNhbGVuZGFyQXBpLFxuICAgICAgICB2aWV3U3BlYyxcbiAgICAgICAgdmlld0FwaSxcbiAgICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsXG4gICAgICAgIHRoZW1lLFxuICAgICAgICBpc1J0bDogdmlld09wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJyxcbiAgICAgICAgYWRkUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgICAgICBlbWl0dGVyLm9uKCdfcmVzaXplJywgaGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZVJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICAgICAgZW1pdHRlci5vZmYoJ19yZXNpemUnLCBoYW5kbGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlU2Nyb2xsUmVzcG9uZGVyKGV4ZWNGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNjcm9sbFJlc3BvbmRlcihleGVjRnVuYywgZW1pdHRlciwgY3JlYXRlRHVyYXRpb24odmlld09wdGlvbnMuc2Nyb2xsVGltZSksIHZpZXdPcHRpb25zLnNjcm9sbFRpbWVSZXNldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsXG4gICAgICAgIHVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCxcbiAgICB9O1xufVxuXG4vKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IG9mZiAqL1xuY2xhc3MgUHVyZUNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS5sb2coZ2V0VW5lcXVhbFByb3BzKG5leHRQcm9wcywgdGhpcy5wcm9wcyksIGdldFVuZXF1YWxQcm9wcyhuZXh0U3RhdGUsIHRoaXMuc3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWNvbXBhcmVPYmpzKHRoaXMucHJvcHMsIG5leHRQcm9wcywgdGhpcy5wcm9wRXF1YWxpdHkpIHx8XG4gICAgICAgICAgICAhY29tcGFyZU9ianModGhpcy5zdGF0ZSwgbmV4dFN0YXRlLCB0aGlzLnN0YXRlRXF1YWxpdHkpO1xuICAgIH1cbiAgICAvLyBIQUNLIGZvciBmcmVha2luJyBSZWFjdCBTdHJpY3RNb2RlXG4gICAgc2FmZVNldFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIGlmICghY29tcGFyZU9ianModGhpcy5zdGF0ZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlKSwgbmV3U3RhdGUpLCB0aGlzLnN0YXRlRXF1YWxpdHkpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblB1cmVDb21wb25lbnQuYWRkUHJvcHNFcXVhbGl0eSA9IGFkZFByb3BzRXF1YWxpdHk7XG5QdXJlQ29tcG9uZW50LmFkZFN0YXRlRXF1YWxpdHkgPSBhZGRTdGF0ZUVxdWFsaXR5O1xuUHVyZUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcblB1cmVDb21wb25lbnQucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IHt9O1xuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSA9IHt9O1xuY2xhc3MgQmFzZUNvbXBvbmVudCBleHRlbmRzIFB1cmVDb21wb25lbnQge1xufVxuQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcbmZ1bmN0aW9uIGFkZFByb3BzRXF1YWxpdHkocHJvcEVxdWFsaXR5KSB7XG4gICAgbGV0IGhhc2ggPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlLnByb3BFcXVhbGl0eSk7XG4gICAgT2JqZWN0LmFzc2lnbihoYXNoLCBwcm9wRXF1YWxpdHkpO1xuICAgIHRoaXMucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IGhhc2g7XG59XG5mdW5jdGlvbiBhZGRTdGF0ZUVxdWFsaXR5KHN0YXRlRXF1YWxpdHkpIHtcbiAgICBsZXQgaGFzaCA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSk7XG4gICAgT2JqZWN0LmFzc2lnbihoYXNoLCBzdGF0ZUVxdWFsaXR5KTtcbiAgICB0aGlzLnByb3RvdHlwZS5zdGF0ZUVxdWFsaXR5ID0gaGFzaDtcbn1cbi8vIHVzZSBvdGhlciBvbmVcbmZ1bmN0aW9uIHNldFJlZihyZWYsIGN1cnJlbnQpIHtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZWYoY3VycmVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlZikge1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzAyOVxuICAgICAgICByZWYuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgfVxufVxuXG5jbGFzcyBDb250ZW50SW5qZWN0b3IgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pZCA9IGd1aWQoKTtcbiAgICAgICAgdGhpcy5xdWV1ZWREb21Ob2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnREb21Ob2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmhhbmRsZUVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2VuZXJhdG9yTmFtZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5jdXN0b21SZW5kZXJpbmdSZXBsYWNlcyB8fCAhaGFzQ3VzdG9tUmVuZGVyaW5nSGFuZGxlcihnZW5lcmF0b3JOYW1lLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRWxSZWYoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUVsUmVmID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5lbFJlZikge1xuICAgICAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBjb25zdCB7IGN1c3RvbUdlbmVyYXRvciwgZGVmYXVsdEdlbmVyYXRvciwgcmVuZGVyUHJvcHMgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBhdHRycyA9IGJ1aWxkRWxBdHRycyhwcm9wcywgW10sIHRoaXMuaGFuZGxlRWwpO1xuICAgICAgICBsZXQgdXNlRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICBsZXQgaW5uZXJDb250ZW50O1xuICAgICAgICBsZXQgcXVldWVkRG9tTm9kZXMgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnRHZW5lcmF0b3JNZXRhO1xuICAgICAgICBpZiAoY3VzdG9tR2VuZXJhdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbUdlbmVyYXRvclJlcyA9IHR5cGVvZiBjdXN0b21HZW5lcmF0b3IgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgIGN1c3RvbUdlbmVyYXRvcihyZW5kZXJQcm9wcywgY3JlYXRlRWxlbWVudCkgOlxuICAgICAgICAgICAgICAgIGN1c3RvbUdlbmVyYXRvcjtcbiAgICAgICAgICAgIGlmIChjdXN0b21HZW5lcmF0b3JSZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB1c2VEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzT2JqZWN0ID0gY3VzdG9tR2VuZXJhdG9yUmVzICYmIHR5cGVvZiBjdXN0b21HZW5lcmF0b3JSZXMgPT09ICdvYmplY3QnOyAvLyBub24tbnVsbFxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCAmJiAoJ2h0bWwnIGluIGN1c3RvbUdlbmVyYXRvclJlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPSB7IF9faHRtbDogY3VzdG9tR2VuZXJhdG9yUmVzLmh0bWwgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QgJiYgKCdkb21Ob2RlcycgaW4gY3VzdG9tR2VuZXJhdG9yUmVzKSkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZWREb21Ob2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGN1c3RvbUdlbmVyYXRvclJlcy5kb21Ob2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0XG4gICAgICAgICAgICAgICAgICAgID8gaXNWYWxpZEVsZW1lbnQoY3VzdG9tR2VuZXJhdG9yUmVzKSAvLyB2ZG9tIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgY3VzdG9tR2VuZXJhdG9yUmVzICE9PSAnZnVuY3Rpb24nIC8vIHByaW1pdGl2ZSB2YWx1ZSAobGlrZSBzdHJpbmcgb3IgbnVtYmVyKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgaW4gdmRvbVxuICAgICAgICAgICAgICAgICAgICBpbm5lckNvbnRlbnQgPSBjdXN0b21HZW5lcmF0b3JSZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBleG90aWMgb2JqZWN0IGZvciBoYW5kbGVDdXN0b21SZW5kZXJpbmdcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEdlbmVyYXRvck1ldGEgPSBjdXN0b21HZW5lcmF0b3JSZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXNlRGVmYXVsdCA9ICFoYXNDdXN0b21SZW5kZXJpbmdIYW5kbGVyKHByb3BzLmdlbmVyYXRvck5hbWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VEZWZhdWx0ICYmIGRlZmF1bHRHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGlubmVyQ29udGVudCA9IGRlZmF1bHRHZW5lcmF0b3IocmVuZGVyUHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucXVldWVkRG9tTm9kZXMgPSBxdWV1ZWREb21Ob2RlcztcbiAgICAgICAgdGhpcy5jdXJyZW50R2VuZXJhdG9yTWV0YSA9IGN1cnJlbnRHZW5lcmF0b3JNZXRhO1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChwcm9wcy5lbFRhZywgYXR0cnMsIGlubmVyQ29udGVudCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLmFwcGx5UXVldWV1ZERvbU5vZGVzKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyh0cnVlKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLmFwcGx5UXVldWV1ZERvbU5vZGVzKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyh0cnVlKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyhmYWxzZSk7IC8vIFRPRE86IGRpZmZlcmVudCBBUEkgZm9yIHJlbW92YWw/XG4gICAgfVxuICAgIHRyaWdnZXJDdXN0b21SZW5kZXJpbmcoaXNBY3RpdmUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGhhbmRsZUN1c3RvbVJlbmRlcmluZywgY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCB9ID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICBpZiAoaGFuZGxlQ3VzdG9tUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0b3JNZXRhID0gKF9hID0gdGhpcy5jdXJyZW50R2VuZXJhdG9yTWV0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCA9PT0gbnVsbCB8fCBjdXN0b21SZW5kZXJpbmdNZXRhTWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXN0b21SZW5kZXJpbmdNZXRhTWFwW3Byb3BzLmdlbmVyYXRvck5hbWVdO1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRvck1ldGEpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVDdXN0b21SZW5kZXJpbmcoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgaWQ6IHRoaXMuaWQsIGlzQWN0aXZlLCBjb250YWluZXJFbDogdGhpcy5iYXNlLCByZXBvcnROZXdDb250YWluZXJFbDogdGhpcy51cGRhdGVFbFJlZiwgLy8gZnJvbnQtZW5kIGZyYW1ld29yayB0ZWxscyB1cyBhYm91dCBuZXcgY29udGFpbmVyIGVsc1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0b3JNZXRhIH0sIHByb3BzKSwgeyBlbENsYXNzZXM6IChwcm9wcy5lbENsYXNzZXMgfHwgW10pLmZpbHRlcihpc1RydXRoeSkgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5UXVldWV1ZERvbU5vZGVzKCkge1xuICAgICAgICBjb25zdCB7IHF1ZXVlZERvbU5vZGVzLCBjdXJyZW50RG9tTm9kZXMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5iYXNlO1xuICAgICAgICBpZiAoIWlzQXJyYXlzRXF1YWwocXVldWVkRG9tTm9kZXMsIGN1cnJlbnREb21Ob2RlcykpIHtcbiAgICAgICAgICAgIGN1cnJlbnREb21Ob2Rlcy5mb3JFYWNoKHJlbW92ZUVsZW1lbnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgbmV3Tm9kZSBvZiBxdWV1ZWREb21Ob2Rlcykge1xuICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKG5ld05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RG9tTm9kZXMgPSBxdWV1ZWREb21Ob2RlcztcbiAgICAgICAgfVxuICAgIH1cbn1cbkNvbnRlbnRJbmplY3Rvci5hZGRQcm9wc0VxdWFsaXR5KHtcbiAgICBlbENsYXNzZXM6IGlzQXJyYXlzRXF1YWwsXG4gICAgZWxTdHlsZTogaXNQcm9wc0VxdWFsLFxuICAgIGVsQXR0cnM6IGlzTm9uSGFuZGxlclByb3BzRXF1YWwsXG4gICAgcmVuZGVyUHJvcHM6IGlzUHJvcHNFcXVhbCxcbn0pO1xuLy8gVXRpbFxuLypcbkRvZXMgVUktZnJhbWV3b3JrIHByb3ZpZGUgY3VzdG9tIHdheSBvZiByZW5kZXJpbmcgdGhhdCBkb2VzIG5vdCB1c2UgUHJlYWN0IFZET01cbkFORCBkb2VzIHRoZSBjYWxlbmRhcidzIG9wdGlvbnMgZGVmaW5lIGN1c3RvbSByZW5kZXJpbmc/XG5BS0EuIFNob3VsZCB3ZSBOT1QgcmVuZGVyIHRoZSBkZWZhdWx0IGNvbnRlbnQ/XG4qL1xuZnVuY3Rpb24gaGFzQ3VzdG9tUmVuZGVyaW5nSGFuZGxlcihnZW5lcmF0b3JOYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBCb29sZWFuKG9wdGlvbnMuaGFuZGxlQ3VzdG9tUmVuZGVyaW5nICYmXG4gICAgICAgIGdlbmVyYXRvck5hbWUgJiZcbiAgICAgICAgKChfYSA9IG9wdGlvbnMuY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2dlbmVyYXRvck5hbWVdKSk7XG59XG5mdW5jdGlvbiBidWlsZEVsQXR0cnMocHJvcHMsIGV4dHJhQ2xhc3NOYW1lcywgZWxSZWYpIHtcbiAgICBjb25zdCBhdHRycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMuZWxBdHRycyksIHsgcmVmOiBlbFJlZiB9KTtcbiAgICBpZiAocHJvcHMuZWxDbGFzc2VzIHx8IGV4dHJhQ2xhc3NOYW1lcykge1xuICAgICAgICBhdHRycy5jbGFzc05hbWUgPSAocHJvcHMuZWxDbGFzc2VzIHx8IFtdKVxuICAgICAgICAgICAgLmNvbmNhdChleHRyYUNsYXNzTmFtZXMgfHwgW10pXG4gICAgICAgICAgICAuY29uY2F0KGF0dHJzLmNsYXNzTmFtZSB8fCBbXSlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgIC5qb2luKCcgJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5lbFN0eWxlKSB7XG4gICAgICAgIGF0dHJzLnN0eWxlID0gcHJvcHMuZWxTdHlsZTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJzO1xufVxuZnVuY3Rpb24gaXNUcnV0aHkodmFsKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odmFsKTtcbn1cblxuY29uc3QgUmVuZGVySWQgPSBjcmVhdGVDb250ZXh0KDApO1xuXG5jbGFzcyBDb250ZW50Q29udGFpbmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5Jbm5lckNvbnRlbnQgPSBJbm5lckNvbnRlbnRJbmplY3Rvci5iaW5kKHVuZGVmaW5lZCwgdGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlRWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgICAgICAgICBpZiAoZWwgJiYgdGhpcy5kaWRNb3VudE1pc2ZpcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBnZW5lcmF0ZWRDbGFzc05hbWVzID0gZ2VuZXJhdGVDbGFzc05hbWVzKHByb3BzLmNsYXNzTmFtZUdlbmVyYXRvciwgcHJvcHMucmVuZGVyUHJvcHMpO1xuICAgICAgICBpZiAocHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGVsQXR0cnMgPSBidWlsZEVsQXR0cnMocHJvcHMsIGdlbmVyYXRlZENsYXNzTmFtZXMsIHRoaXMuaGFuZGxlRWwpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbih0aGlzLklubmVyQ29udGVudCwgcHJvcHMucmVuZGVyUHJvcHMsIGVsQXR0cnMpO1xuICAgICAgICAgICAgaWYgKHByb3BzLmVsVGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQocHJvcHMuZWxUYWcsIGVsQXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KChDb250ZW50SW5qZWN0b3IpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSwgeyBlbFJlZjogdGhpcy5oYW5kbGVFbCwgZWxUYWc6IHByb3BzLmVsVGFnIHx8ICdkaXYnLCBlbENsYXNzZXM6IChwcm9wcy5lbENsYXNzZXMgfHwgW10pLmNvbmNhdChnZW5lcmF0ZWRDbGFzc05hbWVzKSwgcmVuZGVySWQ6IHRoaXMuY29udGV4dCB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmVsKSB7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnByb3BzKS5kaWRNb3VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcy5yZW5kZXJQcm9wcyksIHsgZWw6IHRoaXMuZWwgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaWRNb3VudE1pc2ZpcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnByb3BzKS53aWxsVW5tb3VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcy5yZW5kZXJQcm9wcyksIHsgZWw6IHRoaXMuZWwgfSkpO1xuICAgIH1cbn1cbkNvbnRlbnRDb250YWluZXIuY29udGV4dFR5cGUgPSBSZW5kZXJJZDtcbmZ1bmN0aW9uIElubmVyQ29udGVudEluamVjdG9yKGNvbnRhaW5lckNvbXBvbmVudCwgcHJvcHMpIHtcbiAgICBjb25zdCBwYXJlbnRQcm9wcyA9IGNvbnRhaW5lckNvbXBvbmVudC5wcm9wcztcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgoQ29udGVudEluamVjdG9yKSwgT2JqZWN0LmFzc2lnbih7IHJlbmRlclByb3BzOiBwYXJlbnRQcm9wcy5yZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogcGFyZW50UHJvcHMuZ2VuZXJhdG9yTmFtZSwgY3VzdG9tR2VuZXJhdG9yOiBwYXJlbnRQcm9wcy5jdXN0b21HZW5lcmF0b3IsIGRlZmF1bHRHZW5lcmF0b3I6IHBhcmVudFByb3BzLmRlZmF1bHRHZW5lcmF0b3IsIHJlbmRlcklkOiBjb250YWluZXJDb21wb25lbnQuY29udGV4dCB9LCBwcm9wcykpO1xufVxuLy8gVXRpbHNcbmZ1bmN0aW9uIGdlbmVyYXRlQ2xhc3NOYW1lcyhjbGFzc05hbWVHZW5lcmF0b3IsIHJlbmRlclByb3BzKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IHR5cGVvZiBjbGFzc05hbWVHZW5lcmF0b3IgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICBjbGFzc05hbWVHZW5lcmF0b3IocmVuZGVyUHJvcHMpIDpcbiAgICAgICAgY2xhc3NOYW1lR2VuZXJhdG9yIHx8IFtdO1xuICAgIHJldHVybiB0eXBlb2YgY2xhc3NOYW1lcyA9PT0gJ3N0cmluZycgPyBbY2xhc3NOYW1lc10gOiBjbGFzc05hbWVzO1xufVxuXG5jbGFzcyBWaWV3Q29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHJlbmRlclByb3BzID0geyB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGVsVGFnOiBwcm9wcy5lbFRhZyB8fCAnZGl2JywgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgLi4uYnVpbGRWaWV3Q2xhc3NOYW1lcyhwcm9wcy52aWV3U3BlYyksXG4gICAgICAgICAgICAgICAgLi4uKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSksXG4gICAgICAgICAgICBdLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy52aWV3Q2xhc3NOYW1lcywgZ2VuZXJhdG9yTmFtZTogdW5kZWZpbmVkLCBkaWRNb3VudDogb3B0aW9ucy52aWV3RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLnZpZXdXaWxsVW5tb3VudCB9KSwgKCkgPT4gcHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZFZpZXdDbGFzc05hbWVzKHZpZXdTcGVjKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYGZjLSR7dmlld1NwZWMudHlwZX0tdmlld2AsXG4gICAgICAgICdmYy12aWV3JyxcbiAgICBdO1xufVxuXG5mdW5jdGlvbiBwYXJzZVJhbmdlKGlucHV0LCBkYXRlRW52KSB7XG4gICAgbGV0IHN0YXJ0ID0gbnVsbDtcbiAgICBsZXQgZW5kID0gbnVsbDtcbiAgICBpZiAoaW5wdXQuc3RhcnQpIHtcbiAgICAgICAgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihpbnB1dC5zdGFydCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5lbmQpIHtcbiAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoaW5wdXQuZW5kKTtcbiAgICB9XG4gICAgaWYgKCFzdGFydCAmJiAhZW5kKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgJiYgZW5kICYmIGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG59XG4vLyBTSURFLUVGRkVDVDogd2lsbCBtdXRhdGUgcmFuZ2VzLlxuLy8gV2lsbCByZXR1cm4gYSBuZXcgYXJyYXkgcmVzdWx0LlxuZnVuY3Rpb24gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgY29uc3RyYWludFJhbmdlKSB7XG4gICAgbGV0IGludmVydGVkUmFuZ2VzID0gW107XG4gICAgbGV0IHsgc3RhcnQgfSA9IGNvbnN0cmFpbnRSYW5nZTsgLy8gdGhlIGVuZCBvZiB0aGUgcHJldmlvdXMgcmFuZ2UuIHRoZSBzdGFydCBvZiB0aGUgbmV3IHJhbmdlXG4gICAgbGV0IGk7XG4gICAgbGV0IGRhdGVSYW5nZTtcbiAgICAvLyByYW5nZXMgbmVlZCB0byBiZSBpbiBvcmRlci4gcmVxdWlyZWQgZm9yIG91ciBkYXRlLXdhbGtpbmcgYWxnb3JpdGhtXG4gICAgcmFuZ2VzLnNvcnQoY29tcGFyZVJhbmdlcyk7XG4gICAgZm9yIChpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBkYXRlUmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgIC8vIGFkZCB0aGUgc3BhbiBvZiB0aW1lIGJlZm9yZSB0aGUgZXZlbnQgKGlmIHRoZXJlIGlzIGFueSlcbiAgICAgICAgaWYgKGRhdGVSYW5nZS5zdGFydCA+IHN0YXJ0KSB7IC8vIGNvbXBhcmUgbWlsbGlzZWNvbmQgdGltZSAoc2tpcCBhbnkgYW1iaWcgbG9naWMpXG4gICAgICAgICAgICBpbnZlcnRlZFJhbmdlcy5wdXNoKHsgc3RhcnQsIGVuZDogZGF0ZVJhbmdlLnN0YXJ0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRlUmFuZ2UuZW5kID4gc3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZVJhbmdlLmVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgdGhlIHNwYW4gb2YgdGltZSBhZnRlciB0aGUgbGFzdCBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxuICAgIGlmIChzdGFydCA8IGNvbnN0cmFpbnRSYW5nZS5lbmQpIHsgLy8gY29tcGFyZSBtaWxsaXNlY29uZCB0aW1lIChza2lwIGFueSBhbWJpZyBsb2dpYylcbiAgICAgICAgaW52ZXJ0ZWRSYW5nZXMucHVzaCh7IHN0YXJ0LCBlbmQ6IGNvbnN0cmFpbnRSYW5nZS5lbmQgfSk7XG4gICAgfVxuICAgIHJldHVybiBpbnZlcnRlZFJhbmdlcztcbn1cbmZ1bmN0aW9uIGNvbXBhcmVSYW5nZXMocmFuZ2UwLCByYW5nZTEpIHtcbiAgICByZXR1cm4gcmFuZ2UwLnN0YXJ0LnZhbHVlT2YoKSAtIHJhbmdlMS5zdGFydC52YWx1ZU9mKCk7IC8vIGVhcmxpZXIgcmFuZ2VzIGdvIGZpcnN0XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RSYW5nZXMocmFuZ2UwLCByYW5nZTEpIHtcbiAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSByYW5nZTA7XG4gICAgbGV0IG5ld1JhbmdlID0gbnVsbDtcbiAgICBpZiAocmFuZ2UxLnN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhcnQgPSByYW5nZTEuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydCA9IG5ldyBEYXRlKE1hdGgubWF4KHN0YXJ0LnZhbHVlT2YoKSwgcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyYW5nZTEuZW5kICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gcmFuZ2UxLmVuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZCA9IG5ldyBEYXRlKE1hdGgubWluKGVuZC52YWx1ZU9mKCksIHJhbmdlMS5lbmQudmFsdWVPZigpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IGVuZCA9PT0gbnVsbCB8fCBzdGFydCA8IGVuZCkge1xuICAgICAgICBuZXdSYW5nZSA9IHsgc3RhcnQsIGVuZCB9O1xuICAgIH1cbiAgICByZXR1cm4gbmV3UmFuZ2U7XG59XG5mdW5jdGlvbiByYW5nZXNFcXVhbChyYW5nZTAsIHJhbmdlMSkge1xuICAgIHJldHVybiAocmFuZ2UwLnN0YXJ0ID09PSBudWxsID8gbnVsbCA6IHJhbmdlMC5zdGFydC52YWx1ZU9mKCkpID09PSAocmFuZ2UxLnN0YXJ0ID09PSBudWxsID8gbnVsbCA6IHJhbmdlMS5zdGFydC52YWx1ZU9mKCkpICYmXG4gICAgICAgIChyYW5nZTAuZW5kID09PSBudWxsID8gbnVsbCA6IHJhbmdlMC5lbmQudmFsdWVPZigpKSA9PT0gKHJhbmdlMS5lbmQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UxLmVuZC52YWx1ZU9mKCkpO1xufVxuZnVuY3Rpb24gcmFuZ2VzSW50ZXJzZWN0KHJhbmdlMCwgcmFuZ2UxKSB7XG4gICAgcmV0dXJuIChyYW5nZTAuZW5kID09PSBudWxsIHx8IHJhbmdlMS5zdGFydCA9PT0gbnVsbCB8fCByYW5nZTAuZW5kID4gcmFuZ2UxLnN0YXJ0KSAmJlxuICAgICAgICAocmFuZ2UwLnN0YXJ0ID09PSBudWxsIHx8IHJhbmdlMS5lbmQgPT09IG51bGwgfHwgcmFuZ2UwLnN0YXJ0IDwgcmFuZ2UxLmVuZCk7XG59XG5mdW5jdGlvbiByYW5nZUNvbnRhaW5zUmFuZ2Uob3V0ZXJSYW5nZSwgaW5uZXJSYW5nZSkge1xuICAgIHJldHVybiAob3V0ZXJSYW5nZS5zdGFydCA9PT0gbnVsbCB8fCAoaW5uZXJSYW5nZS5zdGFydCAhPT0gbnVsbCAmJiBpbm5lclJhbmdlLnN0YXJ0ID49IG91dGVyUmFuZ2Uuc3RhcnQpKSAmJlxuICAgICAgICAob3V0ZXJSYW5nZS5lbmQgPT09IG51bGwgfHwgKGlubmVyUmFuZ2UuZW5kICE9PSBudWxsICYmIGlubmVyUmFuZ2UuZW5kIDw9IG91dGVyUmFuZ2UuZW5kKSk7XG59XG5mdW5jdGlvbiByYW5nZUNvbnRhaW5zTWFya2VyKHJhbmdlLCBkYXRlKSB7XG4gICAgcmV0dXJuIChyYW5nZS5zdGFydCA9PT0gbnVsbCB8fCBkYXRlID49IHJhbmdlLnN0YXJ0KSAmJlxuICAgICAgICAocmFuZ2UuZW5kID09PSBudWxsIHx8IGRhdGUgPCByYW5nZS5lbmQpO1xufVxuLy8gSWYgdGhlIGdpdmVuIGRhdGUgaXMgbm90IHdpdGhpbiB0aGUgZ2l2ZW4gcmFuZ2UsIG1vdmUgaXQgaW5zaWRlLlxuLy8gKElmIGl0J3MgcGFzdCB0aGUgZW5kLCBtYWtlIGl0IG9uZSBtaWxsaXNlY29uZCBiZWZvcmUgdGhlIGVuZCkuXG5mdW5jdGlvbiBjb25zdHJhaW5NYXJrZXJUb1JhbmdlKGRhdGUsIHJhbmdlKSB7XG4gICAgaWYgKHJhbmdlLnN0YXJ0ICE9IG51bGwgJiYgZGF0ZSA8IHJhbmdlLnN0YXJ0KSB7XG4gICAgICAgIHJldHVybiByYW5nZS5zdGFydDtcbiAgICB9XG4gICAgaWYgKHJhbmdlLmVuZCAhPSBudWxsICYmIGRhdGUgPj0gcmFuZ2UuZW5kKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShyYW5nZS5lbmQudmFsdWVPZigpIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xufVxuXG4vKiBEYXRlIHN0dWZmIHRoYXQgZG9lc24ndCBiZWxvbmcgaW4gZGF0ZWxpYiBjb3JlXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIGdpdmVuIGEgdGltZWQgcmFuZ2UsIGNvbXB1dGVzIGFuIGFsbC1kYXkgcmFuZ2UgdGhhdCBoYXMgdGhlIHNhbWUgZXhhY3QgZHVyYXRpb24sXG4vLyBidXQgd2hvc2Ugc3RhcnQgdGltZSBpcyBhbGlnbmVkIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSBkYXkuXG5mdW5jdGlvbiBjb21wdXRlQWxpZ25lZERheVJhbmdlKHRpbWVkUmFuZ2UpIHtcbiAgICBsZXQgZGF5Q250ID0gTWF0aC5mbG9vcihkaWZmRGF5cyh0aW1lZFJhbmdlLnN0YXJ0LCB0aW1lZFJhbmdlLmVuZCkpIHx8IDE7XG4gICAgbGV0IHN0YXJ0ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLnN0YXJ0KTtcbiAgICBsZXQgZW5kID0gYWRkRGF5cyhzdGFydCwgZGF5Q250KTtcbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG59XG4vLyBnaXZlbiBhIHRpbWVkIHJhbmdlLCBjb21wdXRlcyBhbiBhbGwtZGF5IHJhbmdlIGJhc2VkIG9uIGhvdyBmb3IgdGhlIGVuZCBkYXRlIGJsZWVkcyBpbnRvIHRoZSBuZXh0IGRheVxuLy8gVE9ETzogZ2l2ZSBuZXh0RGF5VGhyZXNob2xkIGEgZGVmYXVsdCBhcmdcbmZ1bmN0aW9uIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UodGltZWRSYW5nZSwgbmV4dERheVRocmVzaG9sZCA9IGNyZWF0ZUR1cmF0aW9uKDApKSB7XG4gICAgbGV0IHN0YXJ0RGF5ID0gbnVsbDtcbiAgICBsZXQgZW5kRGF5ID0gbnVsbDtcbiAgICBpZiAodGltZWRSYW5nZS5lbmQpIHtcbiAgICAgICAgZW5kRGF5ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLmVuZCk7XG4gICAgICAgIGxldCBlbmRUaW1lTVMgPSB0aW1lZFJhbmdlLmVuZC52YWx1ZU9mKCkgLSBlbmREYXkudmFsdWVPZigpOyAvLyAjIG9mIG1pbGxpc2Vjb25kcyBpbnRvIGBlbmREYXlgXG4gICAgICAgIC8vIElmIHRoZSBlbmQgdGltZSBpcyBhY3R1YWxseSBpbmNsdXNpdmVseSBwYXJ0IG9mIHRoZSBuZXh0IGRheSBhbmQgaXMgZXF1YWwgdG8gb3JcbiAgICAgICAgLy8gYmV5b25kIHRoZSBuZXh0IGRheSB0aHJlc2hvbGQsIGFkanVzdCB0aGUgZW5kIHRvIGJlIHRoZSBleGNsdXNpdmUgZW5kIG9mIGBlbmREYXlgLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGxlYXZpbmcgaXQgYXMgaW5jbHVzaXZlIHdpbGwgY2F1c2UgaXQgdG8gZXhjbHVkZSBgZW5kRGF5YC5cbiAgICAgICAgaWYgKGVuZFRpbWVNUyAmJiBlbmRUaW1lTVMgPj0gYXNSb3VnaE1zKG5leHREYXlUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgICBlbmREYXkgPSBhZGREYXlzKGVuZERheSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVkUmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgc3RhcnREYXkgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2Uuc3RhcnQpOyAvLyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkYXkgdGhlIHJhbmdlIHN0YXJ0c1xuICAgICAgICAvLyBJZiBlbmQgaXMgd2l0aGluIGBzdGFydERheWAgYnV0IG5vdCBwYXN0IG5leHREYXlUaHJlc2hvbGQsIGFzc2lnbiB0aGUgZGVmYXVsdCBkdXJhdGlvbiBvZiBvbmUgZGF5LlxuICAgICAgICBpZiAoZW5kRGF5ICYmIGVuZERheSA8PSBzdGFydERheSkge1xuICAgICAgICAgICAgZW5kRGF5ID0gYWRkRGF5cyhzdGFydERheSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0RGF5LCBlbmQ6IGVuZERheSB9O1xufVxuLy8gc3BhbnMgZnJvbSBvbmUgZGF5IGludG8gYW5vdGhlcj9cbmZ1bmN0aW9uIGlzTXVsdGlEYXlSYW5nZShyYW5nZSkge1xuICAgIGxldCB2aXNpYmxlUmFuZ2UgPSBjb21wdXRlVmlzaWJsZURheVJhbmdlKHJhbmdlKTtcbiAgICByZXR1cm4gZGlmZkRheXModmlzaWJsZVJhbmdlLnN0YXJ0LCB2aXNpYmxlUmFuZ2UuZW5kKSA+IDE7XG59XG5mdW5jdGlvbiBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBkYXRlRW52LCBsYXJnZVVuaXQpIHtcbiAgICBpZiAobGFyZ2VVbml0ID09PSAneWVhcicpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKGRhdGVFbnYuZGlmZldob2xlWWVhcnMoZGF0ZTAsIGRhdGUxKSwgJ3llYXInKTtcbiAgICB9XG4gICAgaWYgKGxhcmdlVW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oZGF0ZUVudi5kaWZmV2hvbGVNb250aHMoZGF0ZTAsIGRhdGUxKSwgJ21vbnRoJyk7XG4gICAgfVxuICAgIHJldHVybiBkaWZmRGF5QW5kVGltZShkYXRlMCwgZGF0ZTEpOyAvLyByZXR1cm5zIGEgZHVyYXRpb25cbn1cblxuZnVuY3Rpb24gcmVkdWNlQ3VycmVudERhdGUoY3VycmVudERhdGUsIGFjdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnQ0hBTkdFX0RBVEUnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5kYXRlTWFya2VyO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREYXRlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEluaXRpYWxEYXRlKG9wdGlvbnMsIGRhdGVFbnYpIHtcbiAgICBsZXQgaW5pdGlhbERhdGVJbnB1dCA9IG9wdGlvbnMuaW5pdGlhbERhdGU7XG4gICAgLy8gY29tcHV0ZSB0aGUgaW5pdGlhbCBhbWJpZy10aW1lem9uZSBkYXRlXG4gICAgaWYgKGluaXRpYWxEYXRlSW5wdXQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5jcmVhdGVNYXJrZXIoaW5pdGlhbERhdGVJbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBnZXROb3cob3B0aW9ucy5ub3csIGRhdGVFbnYpOyAvLyBnZXROb3cgYWxyZWFkeSByZXR1cm5zIHVuem9uZWRcbn1cbmZ1bmN0aW9uIGdldE5vdyhub3dJbnB1dCwgZGF0ZUVudikge1xuICAgIGlmICh0eXBlb2Ygbm93SW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbm93SW5wdXQgPSBub3dJbnB1dCgpO1xuICAgIH1cbiAgICBpZiAobm93SW5wdXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5jcmVhdGVOb3dNYXJrZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVFbnYuY3JlYXRlTWFya2VyKG5vd0lucHV0KTtcbn1cblxuY2xhc3MgRGF0ZVByb2ZpbGVHZW5lcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5ub3dEYXRlID0gZ2V0Tm93KHByb3BzLm5vd0lucHV0LCBwcm9wcy5kYXRlRW52KTtcbiAgICAgICAgdGhpcy5pbml0SGlkZGVuRGF5cygpO1xuICAgIH1cbiAgICAvKiBEYXRlIFJhbmdlIENvbXB1dGF0aW9uXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHdoYXQgdGhlIGRhdGVzL3JhbmdlcyB3aWxsIGJlIGZvciB0aGUgXCJwcmV2XCIgdmlldy5cbiAgICBidWlsZFByZXYoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZm9yY2VUb1ZhbGlkKSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBwcmV2RGF0ZSA9IGRhdGVFbnYuc3VidHJhY3QoZGF0ZUVudi5zdGFydE9mKGN1cnJlbnREYXRlLCBjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksIC8vIGltcG9ydGFudCBmb3Igc3RhcnQtb2YtbW9udGhcbiAgICAgICAgY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZChwcmV2RGF0ZSwgLTEsIGZvcmNlVG9WYWxpZCk7XG4gICAgfVxuICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcIm5leHRcIiB2aWV3LlxuICAgIGJ1aWxkTmV4dChjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmb3JjZVRvVmFsaWQpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IG5leHREYXRlID0gZGF0ZUVudi5hZGQoZGF0ZUVudi5zdGFydE9mKGN1cnJlbnREYXRlLCBjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksIC8vIGltcG9ydGFudCBmb3Igc3RhcnQtb2YtbW9udGhcbiAgICAgICAgY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZChuZXh0RGF0ZSwgMSwgZm9yY2VUb1ZhbGlkKTtcbiAgICB9XG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIGhvbGRpbmcgZGF0ZXMvcmFuZ2VzIGZvciByZW5kZXJpbmcgYXJvdW5kIHRoZSBnaXZlbiBkYXRlLlxuICAgIC8vIE9wdGlvbmFsIGRpcmVjdGlvbiBwYXJhbSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgZGF0ZSBpcyBiZWluZyBpbmNyZW1lbnRlZC9kZWNyZW1lbnRlZFxuICAgIC8vIGZyb20gaXRzIHByZXZpb3VzIHZhbHVlLiBkZWNyZW1lbnRlZCA9IC0xLCBpbmNyZW1lbnRlZCA9IDEgKGRlZmF1bHQpLlxuICAgIGJ1aWxkKGN1cnJlbnREYXRlLCBkaXJlY3Rpb24sIGZvcmNlVG9WYWxpZCA9IHRydWUpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB2YWxpZFJhbmdlO1xuICAgICAgICBsZXQgY3VycmVudEluZm87XG4gICAgICAgIGxldCBpc1JhbmdlQWxsRGF5O1xuICAgICAgICBsZXQgcmVuZGVyUmFuZ2U7XG4gICAgICAgIGxldCBhY3RpdmVSYW5nZTtcbiAgICAgICAgbGV0IGlzVmFsaWQ7XG4gICAgICAgIHZhbGlkUmFuZ2UgPSB0aGlzLmJ1aWxkVmFsaWRSYW5nZSgpO1xuICAgICAgICB2YWxpZFJhbmdlID0gdGhpcy50cmltSGlkZGVuRGF5cyh2YWxpZFJhbmdlKTtcbiAgICAgICAgaWYgKGZvcmNlVG9WYWxpZCkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSBjb25zdHJhaW5NYXJrZXJUb1JhbmdlKGN1cnJlbnREYXRlLCB2YWxpZFJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50SW5mbyA9IHRoaXMuYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGN1cnJlbnREYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgICBpc1JhbmdlQWxsRGF5ID0gL14oeWVhcnxtb250aHx3ZWVrfGRheSkkLy50ZXN0KGN1cnJlbnRJbmZvLnVuaXQpO1xuICAgICAgICByZW5kZXJSYW5nZSA9IHRoaXMuYnVpbGRSZW5kZXJSYW5nZSh0aGlzLnRyaW1IaWRkZW5EYXlzKGN1cnJlbnRJbmZvLnJhbmdlKSwgY3VycmVudEluZm8udW5pdCwgaXNSYW5nZUFsbERheSk7XG4gICAgICAgIHJlbmRlclJhbmdlID0gdGhpcy50cmltSGlkZGVuRGF5cyhyZW5kZXJSYW5nZSk7XG4gICAgICAgIGFjdGl2ZVJhbmdlID0gcmVuZGVyUmFuZ2U7XG4gICAgICAgIGlmICghcHJvcHMuc2hvd05vbkN1cnJlbnREYXRlcykge1xuICAgICAgICAgICAgYWN0aXZlUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoYWN0aXZlUmFuZ2UsIGN1cnJlbnRJbmZvLnJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVSYW5nZSA9IHRoaXMuYWRqdXN0QWN0aXZlUmFuZ2UoYWN0aXZlUmFuZ2UpO1xuICAgICAgICBhY3RpdmVSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhhY3RpdmVSYW5nZSwgdmFsaWRSYW5nZSk7IC8vIG1pZ2h0IHJldHVybiBudWxsXG4gICAgICAgIC8vIGl0J3MgaW52YWxpZCBpZiB0aGUgb3JpZ2luYWxseSByZXF1ZXN0ZWQgZGF0ZSBpcyBub3QgY29udGFpbmVkLFxuICAgICAgICAvLyBvciBpZiB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSBvdXRzaWRlIG9mIHRoZSB2YWxpZCByYW5nZS5cbiAgICAgICAgaXNWYWxpZCA9IHJhbmdlc0ludGVyc2VjdChjdXJyZW50SW5mby5yYW5nZSwgdmFsaWRSYW5nZSk7XG4gICAgICAgIC8vIEhBQ0s6IGNvbnN0cmFpbiB0byByZW5kZXItcmFuZ2Ugc28gYGN1cnJlbnREYXRlYCBpcyBtb3JlIHVzZWZ1bCB0byB2aWV3IHJlbmRlcmluZ1xuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNNYXJrZXIocmVuZGVyUmFuZ2UsIGN1cnJlbnREYXRlKSkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSByZW5kZXJSYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgICAgICAvLyBjb25zdHJhaW50IGZvciB3aGVyZSBwcmV2L25leHQgb3BlcmF0aW9ucyBjYW4gZ28gYW5kIHdoZXJlIGV2ZW50cyBjYW4gYmUgZHJhZ2dlZC9yZXNpemVkIHRvLlxuICAgICAgICAgICAgLy8gYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQgYW5kIGVuZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFsaWRSYW5nZSxcbiAgICAgICAgICAgIC8vIHJhbmdlIHRoZSB2aWV3IGlzIGZvcm1hbGx5IHJlc3BvbnNpYmxlIGZvci5cbiAgICAgICAgICAgIC8vIGZvciBleGFtcGxlLCBhIG1vbnRoIHZpZXcgbWlnaHQgaGF2ZSAxc3QtMzFzdCwgZXhjbHVkaW5nIHBhZGRlZCBkYXRlc1xuICAgICAgICAgICAgY3VycmVudFJhbmdlOiBjdXJyZW50SW5mby5yYW5nZSxcbiAgICAgICAgICAgIC8vIG5hbWUgb2YgbGFyZ2VzdCB1bml0IGJlaW5nIGRpc3BsYXllZCwgbGlrZSBcIm1vbnRoXCIgb3IgXCJ3ZWVrXCJcbiAgICAgICAgICAgIGN1cnJlbnRSYW5nZVVuaXQ6IGN1cnJlbnRJbmZvLnVuaXQsXG4gICAgICAgICAgICBpc1JhbmdlQWxsRGF5LFxuICAgICAgICAgICAgLy8gZGF0ZXMgdGhhdCBkaXNwbGF5IGV2ZW50cyBhbmQgYWNjZXB0IGRyYWctbi1kcm9wXG4gICAgICAgICAgICAvLyB3aWxsIGJlIGBudWxsYCBpZiBubyBkYXRlcyBhY2NlcHQgZXZlbnRzXG4gICAgICAgICAgICBhY3RpdmVSYW5nZSxcbiAgICAgICAgICAgIC8vIGRhdGUgcmFuZ2Ugd2l0aCBhIHJlbmRlcmVkIHNrZWxldG9uXG4gICAgICAgICAgICAvLyBpbmNsdWRlcyBub3QtYWN0aXZlIGRheXMgdGhhdCBuZWVkIHNvbWUgc29ydCBvZiBET01cbiAgICAgICAgICAgIHJlbmRlclJhbmdlLFxuICAgICAgICAgICAgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZmlyc3QgdmlzaWJsZSB0aW1lIG9mIGFueSBnaXZlbiBkYXlcbiAgICAgICAgICAgIHNsb3RNaW5UaW1lOiBwcm9wcy5zbG90TWluVGltZSxcbiAgICAgICAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGV4Y2x1c2l2ZSB2aXNpYmxlIGVuZCB0aW1lIG9mIGFueSBnaXZlbiBkYXlcbiAgICAgICAgICAgIHNsb3RNYXhUaW1lOiBwcm9wcy5zbG90TWF4VGltZSxcbiAgICAgICAgICAgIGlzVmFsaWQsXG4gICAgICAgICAgICAvLyBob3cgZmFyIHRoZSBjdXJyZW50IGRhdGUgd2lsbCBtb3ZlIGZvciBhIHByZXYvbmV4dCBvcGVyYXRpb25cbiAgICAgICAgICAgIGRhdGVJbmNyZW1lbnQ6IHRoaXMuYnVpbGREYXRlSW5jcmVtZW50KGN1cnJlbnRJbmZvLmR1cmF0aW9uKSxcbiAgICAgICAgICAgIC8vIHBhc3MgYSBmYWxsYmFjayAobWlnaHQgYmUgbnVsbCkgXlxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBCdWlsZHMgYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQvZW5kIHByb3BlcnRpZXMuXG4gICAgLy8gSW5kaWNhdGVzIHRoZSBtaW5pbXVtL21heGltdW0gZGF0ZXMgdG8gZGlzcGxheS5cbiAgICAvLyBub3QgcmVzcG9uc2libGUgZm9yIHRyaW1taW5nIGhpZGRlbiBkYXlzLlxuICAgIGJ1aWxkVmFsaWRSYW5nZSgpIHtcbiAgICAgICAgbGV0IGlucHV0ID0gdGhpcy5wcm9wcy52YWxpZFJhbmdlSW5wdXQ7XG4gICAgICAgIGxldCBzaW1wbGVJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBpbnB1dC5jYWxsKHRoaXMucHJvcHMuY2FsZW5kYXJBcGksIHRoaXMubm93RGF0ZSlcbiAgICAgICAgICAgIDogaW5wdXQ7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmluZVJhbmdlKHNpbXBsZUlucHV0KSB8fFxuICAgICAgICAgICAgeyBzdGFydDogbnVsbCwgZW5kOiBudWxsIH07IC8vIGNvbXBsZXRlbHkgb3Blbi1lbmRlZFxuICAgIH1cbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHRoZSBcImN1cnJlbnRcIiByYW5nZSwgdGhlIHJhbmdlIHRoYXQgaXNcbiAgICAvLyBoaWdobGlnaHRlZCBhcyBiZWluZyB0aGUgY3VycmVudCBtb250aCBmb3IgZXhhbXBsZS5cbiAgICAvLyBTZWUgYnVpbGQoKSBmb3IgYSBkZXNjcmlwdGlvbiBvZiBgZGlyZWN0aW9uYC5cbiAgICAvLyBHdWFyYW50ZWVkIHRvIGhhdmUgYHJhbmdlYCBhbmQgYHVuaXRgIHByb3BlcnRpZXMuIGBkdXJhdGlvbmAgaXMgb3B0aW9uYWwuXG4gICAgYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGRhdGUsIGRpcmVjdGlvbikge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgbGV0IHVuaXQgPSBudWxsO1xuICAgICAgICBsZXQgcmFuZ2UgPSBudWxsO1xuICAgICAgICBsZXQgZGF5Q291bnQ7XG4gICAgICAgIGlmIChwcm9wcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBwcm9wcy5kdXJhdGlvbjtcbiAgICAgICAgICAgIHVuaXQgPSBwcm9wcy5kdXJhdGlvblVuaXQ7XG4gICAgICAgICAgICByYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoZGF5Q291bnQgPSB0aGlzLnByb3BzLmRheUNvdW50KSkge1xuICAgICAgICAgICAgdW5pdCA9ICdkYXknO1xuICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQoZGF0ZSwgZGlyZWN0aW9uLCBkYXlDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHJhbmdlID0gdGhpcy5idWlsZEN1c3RvbVZpc2libGVSYW5nZShkYXRlKSkpIHtcbiAgICAgICAgICAgIHVuaXQgPSBwcm9wcy5kYXRlRW52LmdyZWF0ZXN0V2hvbGVVbml0KHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpLnVuaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZ2V0RmFsbGJhY2tEdXJhdGlvbigpO1xuICAgICAgICAgICAgdW5pdCA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXJhdGlvbikudW5pdDtcbiAgICAgICAgICAgIHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGR1cmF0aW9uLCB1bml0LCByYW5nZSB9O1xuICAgIH1cbiAgICBnZXRGYWxsYmFja0R1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oeyBkYXk6IDEgfSk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBuZXcgYWN0aXZlUmFuZ2UgdG8gaGF2ZSB0aW1lIHZhbHVlcyAodW4tYW1iaWd1YXRlKVxuICAgIC8vIHNsb3RNaW5UaW1lIG9yIHNsb3RNYXhUaW1lIGNhdXNlcyB0aGUgcmFuZ2UgdG8gZXhwYW5kLlxuICAgIGFkanVzdEFjdGl2ZVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIHVzZXNNaW5NYXhUaW1lLCBzbG90TWluVGltZSwgc2xvdE1heFRpbWUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IHJhbmdlO1xuICAgICAgICBpZiAodXNlc01pbk1heFRpbWUpIHtcbiAgICAgICAgICAgIC8vIGV4cGFuZCBhY3RpdmUgcmFuZ2UgaWYgc2xvdE1pblRpbWUgaXMgbmVnYXRpdmUgKHdoeSBub3Qgd2hlbiBwb3NpdGl2ZT8pXG4gICAgICAgICAgICBpZiAoYXNSb3VnaERheXMoc2xvdE1pblRpbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7IC8vIG5lY2Vzc2FyeT9cbiAgICAgICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBzbG90TWluVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBleHBhbmQgYWN0aXZlIHJhbmdlIGlmIHNsb3RNYXhUaW1lIGlzIGJleW9uZCBvbmUgZGF5ICh3aHkgbm90IHdoZW4gbmVnYXRpdmU/KVxuICAgICAgICAgICAgaWYgKGFzUm91Z2hEYXlzKHNsb3RNYXhUaW1lKSA+IDEpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBzdGFydE9mRGF5KGVuZCk7IC8vIG5lY2Vzc2FyeT9cbiAgICAgICAgICAgICAgICBlbmQgPSBhZGREYXlzKGVuZCwgLTEpO1xuICAgICAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgc2xvdE1heFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbiAgICB9XG4gICAgLy8gQnVpbGRzIHRoZSBcImN1cnJlbnRcIiByYW5nZSB3aGVuIGl0IGlzIHNwZWNpZmllZCBhcyBhbiBleHBsaWNpdCBkdXJhdGlvbi5cbiAgICAvLyBgdW5pdGAgaXMgdGhlIGFscmVhZHktY29tcHV0ZWQgZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yIHVuaXQgb2YgZHVyYXRpb24uXG4gICAgYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIGRhdGVBbGlnbm1lbnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBzdGFydDtcbiAgICAgICAgbGV0IGVuZDtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgLy8gY29tcHV0ZSB3aGF0IHRoZSBhbGlnbm1lbnQgc2hvdWxkIGJlXG4gICAgICAgIGlmICghZGF0ZUFsaWdubWVudCkge1xuICAgICAgICAgICAgbGV0IHsgZGF0ZUluY3JlbWVudCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmIChkYXRlSW5jcmVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gdW5pdHNcbiAgICAgICAgICAgICAgICBpZiAoYXNSb3VnaE1zKGRhdGVJbmNyZW1lbnQpIDwgYXNSb3VnaE1zKGR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGRhdGVJbmNyZW1lbnQpLnVuaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgdmlldyBkaXNwbGF5cyBhIHNpbmdsZSBkYXkgb3Igc21hbGxlclxuICAgICAgICBpZiAoYXNSb3VnaERheXMoZHVyYXRpb24pIDw9IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSGlkZGVuRGF5KHN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0T2ZEYXkoc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVSZXMoKSB7XG4gICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuc3RhcnRPZihkYXRlLCBkYXRlQWxpZ25tZW50KTtcbiAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBkdXJhdGlvbik7XG4gICAgICAgICAgICByZXMgPSB7IHN0YXJ0LCBlbmQgfTtcbiAgICAgICAgfVxuICAgICAgICBjb21wdXRlUmVzKCk7XG4gICAgICAgIC8vIGlmIHJhbmdlIGlzIGNvbXBsZXRlbHkgZW52ZWxvcGVkIGJ5IGhpZGRlbiBkYXlzLCBnbyBwYXN0IHRoZSBoaWRkZW4gZGF5c1xuICAgICAgICBpZiAoIXRoaXMudHJpbUhpZGRlbkRheXMocmVzKSkge1xuICAgICAgICAgICAgZGF0ZSA9IHRoaXMuc2tpcEhpZGRlbkRheXMoZGF0ZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGNvbXB1dGVSZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvLyBCdWlsZHMgdGhlIFwiY3VycmVudFwiIHJhbmdlIHdoZW4gYSBkYXlDb3VudCBpcyBzcGVjaWZpZWQuXG4gICAgYnVpbGRSYW5nZUZyb21EYXlDb3VudChkYXRlLCBkaXJlY3Rpb24sIGRheUNvdW50KSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIGRhdGVBbGlnbm1lbnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBydW5uaW5nQ291bnQgPSAwO1xuICAgICAgICBsZXQgc3RhcnQgPSBkYXRlO1xuICAgICAgICBsZXQgZW5kO1xuICAgICAgICBpZiAoZGF0ZUFsaWdubWVudCkge1xuICAgICAgICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2Yoc3RhcnQsIGRhdGVBbGlnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVuZCA9IGFkZERheXMoZW5kLCAxKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0hpZGRlbkRheShlbmQpKSB7XG4gICAgICAgICAgICAgICAgcnVubmluZ0NvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHJ1bm5pbmdDb3VudCA8IGRheUNvdW50KTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xuICAgIH1cbiAgICAvLyBCdWlsZHMgYSBub3JtYWxpemVkIHJhbmdlIG9iamVjdCBmb3IgdGhlIFwidmlzaWJsZVwiIHJhbmdlLFxuICAgIC8vIHdoaWNoIGlzIGEgd2F5IHRvIGRlZmluZSB0aGUgY3VycmVudFJhbmdlIGFuZCBhY3RpdmVSYW5nZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIGJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlKGRhdGUpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBpbnB1dCA9IHByb3BzLnZpc2libGVSYW5nZUlucHV0O1xuICAgICAgICBsZXQgc2ltcGxlSW5wdXQgPSB0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gaW5wdXQuY2FsbChwcm9wcy5jYWxlbmRhckFwaSwgcHJvcHMuZGF0ZUVudi50b0RhdGUoZGF0ZSkpXG4gICAgICAgICAgICA6IGlucHV0O1xuICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJlZmluZVJhbmdlKHNpbXBsZUlucHV0KTtcbiAgICAgICAgaWYgKHJhbmdlICYmIChyYW5nZS5zdGFydCA9PSBudWxsIHx8IHJhbmdlLmVuZCA9PSBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyB0aGUgcmFuZ2UgdGhhdCB3aWxsIHJlcHJlc2VudCB0aGUgZWxlbWVudC9jZWxscyBmb3IgKnJlbmRlcmluZyosXG4gICAgLy8gYnV0IHdoaWNoIG1heSBoYXZlIHZvaWRlZCBkYXlzL3RpbWVzLlxuICAgIC8vIG5vdCByZXNwb25zaWJsZSBmb3IgdHJpbW1pbmcgaGlkZGVuIGRheXMuXG4gICAgYnVpbGRSZW5kZXJSYW5nZShjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSYW5nZTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSB0aGUgZHVyYXRpb24gdmFsdWUgdGhhdCBzaG91bGQgYmUgYWRkZWQvc3Vic3RyYWN0ZWQgdG8gdGhlIGN1cnJlbnQgZGF0ZVxuICAgIC8vIHdoZW4gYSBwcmV2L25leHQgb3BlcmF0aW9uIGhhcHBlbnMuXG4gICAgYnVpbGREYXRlSW5jcmVtZW50KGZhbGxiYWNrKSB7XG4gICAgICAgIGxldCB7IGRhdGVJbmNyZW1lbnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBjdXN0b21BbGlnbm1lbnQ7XG4gICAgICAgIGlmIChkYXRlSW5jcmVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZUluY3JlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGN1c3RvbUFsaWdubWVudCA9IHRoaXMucHJvcHMuZGF0ZUFsaWdubWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbigxLCBjdXN0b21BbGlnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGRheXM6IDEgfSk7XG4gICAgfVxuICAgIHJlZmluZVJhbmdlKHJhbmdlSW5wdXQpIHtcbiAgICAgICAgaWYgKHJhbmdlSW5wdXQpIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHBhcnNlUmFuZ2UocmFuZ2VJbnB1dCwgdGhpcy5wcm9wcy5kYXRlRW52KTtcbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlID0gY29tcHV0ZVZpc2libGVEYXlSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qIEhpZGRlbiBEYXlzXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAvLyBJbml0aWFsaXplcyBpbnRlcm5hbCB2YXJpYWJsZXMgcmVsYXRlZCB0byBjYWxjdWxhdGluZyBoaWRkZW4gZGF5cy1vZi13ZWVrXG4gICAgaW5pdEhpZGRlbkRheXMoKSB7XG4gICAgICAgIGxldCBoaWRkZW5EYXlzID0gdGhpcy5wcm9wcy5oaWRkZW5EYXlzIHx8IFtdOyAvLyBhcnJheSBvZiBkYXktb2Ytd2VlayBpbmRpY2VzIHRoYXQgYXJlIGhpZGRlblxuICAgICAgICBsZXQgaXNIaWRkZW5EYXlIYXNoID0gW107IC8vIGlzIHRoZSBkYXktb2Ytd2VlayBoaWRkZW4/IChoYXNoIHdpdGggZGF5LW9mLXdlZWstaW5kZXggLT4gYm9vbClcbiAgICAgICAgbGV0IGRheUNudCA9IDA7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy53ZWVrZW5kcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGhpZGRlbkRheXMucHVzaCgwLCA2KTsgLy8gMD1zdW5kYXksIDY9c2F0dXJkYXlcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoIShpc0hpZGRlbkRheUhhc2hbaV0gPSBoaWRkZW5EYXlzLmluZGV4T2YoaSkgIT09IC0xKSkge1xuICAgICAgICAgICAgICAgIGRheUNudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZGF5Q250KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaGlkZGVuRGF5cycpOyAvLyBhbGwgZGF5cyB3ZXJlIGhpZGRlbj8gYmFkLlxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNIaWRkZW5EYXlIYXNoID0gaXNIaWRkZW5EYXlIYXNoO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgZGF5cyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgcmFuZ2UgdGhhdCBhcmUgY29tcHV0ZWQgYXMgaGlkZGVuLlxuICAgIC8vIElmIHRoZSB3aG9sZSByYW5nZSBpcyB0cmltbWVkIG9mZiwgcmV0dXJucyBudWxsXG4gICAgdHJpbUhpZGRlbkRheXMocmFuZ2UpIHtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gcmFuZ2U7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKGVuZCwgLTEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsIHx8IHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIElzIHRoZSBjdXJyZW50IGRheSBoaWRkZW4/XG4gICAgLy8gYGRheWAgaXMgYSBkYXktb2Ytd2VlayBpbmRleCAoMC02KSwgb3IgYSBEYXRlICh1c2VkIGZvciBVVEMpXG4gICAgaXNIaWRkZW5EYXkoZGF5KSB7XG4gICAgICAgIGlmIChkYXkgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICBkYXkgPSBkYXkuZ2V0VVRDRGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNIaWRkZW5EYXlIYXNoW2RheV07XG4gICAgfVxuICAgIC8vIEluY3JlbWVudGluZyB0aGUgY3VycmVudCBkYXkgdW50aWwgaXQgaXMgbm8gbG9uZ2VyIGEgaGlkZGVuIGRheSwgcmV0dXJuaW5nIGEgY29weS5cbiAgICAvLyBET0VTIE5PVCBDT05TSURFUiB2YWxpZFJhbmdlIVxuICAgIC8vIElmIHRoZSBpbml0aWFsIHZhbHVlIG9mIGBkYXRlYCBpcyBub3QgYSBoaWRkZW4gZGF5LCBkb24ndCBkbyBhbnl0aGluZy5cbiAgICAvLyBQYXNzIGBpc0V4Y2x1c2l2ZWAgYXMgYHRydWVgIGlmIHlvdSBhcmUgZGVhbGluZyB3aXRoIGFuIGVuZCBkYXRlLlxuICAgIC8vIGBpbmNgIGRlZmF1bHRzIHRvIGAxYCAoaW5jcmVtZW50IG9uZSBkYXkgZm9yd2FyZCBlYWNoIHRpbWUpXG4gICAgc2tpcEhpZGRlbkRheXMoZGF0ZSwgaW5jID0gMSwgaXNFeGNsdXNpdmUgPSBmYWxzZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5pc0hpZGRlbkRheUhhc2hbKGRhdGUuZ2V0VVRDRGF5KCkgKyAoaXNFeGNsdXNpdmUgPyBpbmMgOiAwKSArIDcpICUgN10pIHtcbiAgICAgICAgICAgIGRhdGUgPSBhZGREYXlzKGRhdGUsIGluYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFdmVudEluc3RhbmNlKGRlZklkLCByYW5nZSwgZm9yY2VkU3RhcnRUem8sIGZvcmNlZEVuZFR6bykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGluc3RhbmNlSWQ6IGd1aWQoKSxcbiAgICAgICAgZGVmSWQsXG4gICAgICAgIHJhbmdlLFxuICAgICAgICBmb3JjZWRTdGFydFR6bzogZm9yY2VkU3RhcnRUem8gPT0gbnVsbCA/IG51bGwgOiBmb3JjZWRTdGFydFR6byxcbiAgICAgICAgZm9yY2VkRW5kVHpvOiBmb3JjZWRFbmRUem8gPT0gbnVsbCA/IG51bGwgOiBmb3JjZWRFbmRUem8sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VSZWN1cnJpbmcocmVmaW5lZCwgZGVmYXVsdEFsbERheSwgZGF0ZUVudiwgcmVjdXJyaW5nVHlwZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3VycmluZ1R5cGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBwYXJzZWQgPSByZWN1cnJpbmdUeXBlc1tpXS5wYXJzZShyZWZpbmVkLCBkYXRlRW52KTtcbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgbGV0IHsgYWxsRGF5IH0gPSByZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGFsbERheSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWxsRGF5ID0gZGVmYXVsdEFsbERheTtcbiAgICAgICAgICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsRGF5ID0gcGFyc2VkLmFsbERheUd1ZXNzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbERheSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhbGxEYXksXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHBhcnNlZC5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICB0eXBlRGF0YTogcGFyc2VkLnR5cGVEYXRhLFxuICAgICAgICAgICAgICAgIHR5cGVJZDogaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBleHBhbmRSZWN1cnJpbmcoZXZlbnRTdG9yZSwgZnJhbWluZ1JhbmdlLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgZGF0ZUVudiwgcGx1Z2luSG9va3MsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlO1xuICAgIC8vIHJlbW92ZSBleGlzdGluZyByZWN1cnJpbmcgaW5zdGFuY2VzXG4gICAgLy8gVE9ETzogYmFkLiBhbHdheXMgZXhwYW5kIGV2ZW50cyBhcyBhIHNlY29uZCBzdGVwXG4gICAgaW5zdGFuY2VzID0gZmlsdGVySGFzaChpbnN0YW5jZXMsIChpbnN0YW5jZSkgPT4gIWRlZnNbaW5zdGFuY2UuZGVmSWRdLnJlY3VycmluZ0RlZik7XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICBsZXQgZGVmID0gZGVmc1tkZWZJZF07XG4gICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XG4gICAgICAgICAgICBsZXQgeyBkdXJhdGlvbiB9ID0gZGVmLnJlY3VycmluZ0RlZjtcbiAgICAgICAgICAgIGlmICghZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IGRlZi5hbGxEYXkgP1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uIDpcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0cyA9IGV4cGFuZFJlY3VycmluZ1JhbmdlcyhkZWYsIGR1cmF0aW9uLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYsIHBsdWdpbkhvb2tzLnJlY3VycmluZ1R5cGVzKTtcbiAgICAgICAgICAgIGZvciAobGV0IHN0YXJ0IG9mIHN0YXJ0cykge1xuICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmSWQsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoc3RhcnQsIGR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkZWZzLCBpbnN0YW5jZXMgfTtcbn1cbi8qXG5FdmVudCBNVVNUIGhhdmUgYSByZWN1cnJpbmdEZWZcbiovXG5mdW5jdGlvbiBleHBhbmRSZWN1cnJpbmdSYW5nZXMoZXZlbnREZWYsIGR1cmF0aW9uLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYsIHJlY3VycmluZ1R5cGVzKSB7XG4gICAgbGV0IHR5cGVEZWYgPSByZWN1cnJpbmdUeXBlc1tldmVudERlZi5yZWN1cnJpbmdEZWYudHlwZUlkXTtcbiAgICBsZXQgbWFya2VycyA9IHR5cGVEZWYuZXhwYW5kKGV2ZW50RGVmLnJlY3VycmluZ0RlZi50eXBlRGF0YSwge1xuICAgICAgICBzdGFydDogZGF0ZUVudi5zdWJ0cmFjdChmcmFtaW5nUmFuZ2Uuc3RhcnQsIGR1cmF0aW9uKSxcbiAgICAgICAgZW5kOiBmcmFtaW5nUmFuZ2UuZW5kLFxuICAgIH0sIGRhdGVFbnYpO1xuICAgIC8vIHRoZSByZWN1cnJlbmNlIHBsdWdpbnMgZG9uJ3QgZ3VhcmFudGVlIHRoYXQgYWxsLWRheSBldmVudHMgYXJlIHN0YXJ0LW9mLWRheSwgc28gd2UgaGF2ZSB0b1xuICAgIGlmIChldmVudERlZi5hbGxEYXkpIHtcbiAgICAgICAgbWFya2VycyA9IG1hcmtlcnMubWFwKHN0YXJ0T2ZEYXkpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya2Vycztcbn1cblxuY29uc3QgRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMgPSB7XG4gICAgaWQ6IFN0cmluZyxcbiAgICBncm91cElkOiBTdHJpbmcsXG4gICAgdGl0bGU6IFN0cmluZyxcbiAgICB1cmw6IFN0cmluZyxcbiAgICBpbnRlcmFjdGl2ZTogQm9vbGVhbixcbn07XG5jb25zdCBFVkVOVF9EQVRFX1JFRklORVJTID0ge1xuICAgIHN0YXJ0OiBpZGVudGl0eSxcbiAgICBlbmQ6IGlkZW50aXR5LFxuICAgIGRhdGU6IGlkZW50aXR5LFxuICAgIGFsbERheTogQm9vbGVhbixcbn07XG5jb25zdCBFVkVOVF9SRUZJTkVSUyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBFVkVOVF9OT05fREFURV9SRUZJTkVSUyksIEVWRU5UX0RBVEVfUkVGSU5FUlMpLCB7IGV4dGVuZGVkUHJvcHM6IGlkZW50aXR5IH0pO1xuZnVuY3Rpb24gcGFyc2VFdmVudChyYXcsIGV2ZW50U291cmNlLCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSwgcmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCksIGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwKSB7XG4gICAgbGV0IHsgcmVmaW5lZCwgZXh0cmEgfSA9IHJlZmluZUV2ZW50RGVmKHJhdywgY29udGV4dCwgcmVmaW5lcnMpO1xuICAgIGxldCBkZWZhdWx0QWxsRGF5ID0gY29tcHV0ZUlzRGVmYXVsdEFsbERheShldmVudFNvdXJjZSwgY29udGV4dCk7XG4gICAgbGV0IHJlY3VycmluZ1JlcyA9IHBhcnNlUmVjdXJyaW5nKHJlZmluZWQsIGRlZmF1bHRBbGxEYXksIGNvbnRleHQuZGF0ZUVudiwgY29udGV4dC5wbHVnaW5Ib29rcy5yZWN1cnJpbmdUeXBlcyk7XG4gICAgaWYgKHJlY3VycmluZ1Jlcykge1xuICAgICAgICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5zb3VyY2VJZCA6ICcnLCByZWN1cnJpbmdSZXMuYWxsRGF5LCBCb29sZWFuKHJlY3VycmluZ1Jlcy5kdXJhdGlvbiksIGNvbnRleHQsIGRlZklkTWFwKTtcbiAgICAgICAgZGVmLnJlY3VycmluZ0RlZiA9IHtcbiAgICAgICAgICAgIHR5cGVJZDogcmVjdXJyaW5nUmVzLnR5cGVJZCxcbiAgICAgICAgICAgIHR5cGVEYXRhOiByZWN1cnJpbmdSZXMudHlwZURhdGEsXG4gICAgICAgICAgICBkdXJhdGlvbjogcmVjdXJyaW5nUmVzLmR1cmF0aW9uLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBkZWYsIGluc3RhbmNlOiBudWxsIH07XG4gICAgfVxuICAgIGxldCBzaW5nbGVSZXMgPSBwYXJzZVNpbmdsZShyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSk7XG4gICAgaWYgKHNpbmdsZVJlcykge1xuICAgICAgICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5zb3VyY2VJZCA6ICcnLCBzaW5nbGVSZXMuYWxsRGF5LCBzaW5nbGVSZXMuaGFzRW5kLCBjb250ZXh0LCBkZWZJZE1hcCk7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmLmRlZklkLCBzaW5nbGVSZXMucmFuZ2UsIHNpbmdsZVJlcy5mb3JjZWRTdGFydFR6bywgc2luZ2xlUmVzLmZvcmNlZEVuZFR6byk7XG4gICAgICAgIGlmIChpbnN0YW5jZUlkTWFwICYmIGRlZi5wdWJsaWNJZCAmJiBpbnN0YW5jZUlkTWFwW2RlZi5wdWJsaWNJZF0pIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmluc3RhbmNlSWQgPSBpbnN0YW5jZUlkTWFwW2RlZi5wdWJsaWNJZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGVmLCBpbnN0YW5jZSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlZmluZUV2ZW50RGVmKHJhdywgY29udGV4dCwgcmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCkpIHtcbiAgICByZXR1cm4gcmVmaW5lUHJvcHMocmF3LCByZWZpbmVycyk7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgRVZFTlRfVUlfUkVGSU5FUlMpLCBFVkVOVF9SRUZJTkVSUyksIGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRSZWZpbmVycyk7XG59XG4vKlxuV2lsbCBOT1QgcG9wdWxhdGUgZXh0ZW5kZWRQcm9wcyB3aXRoIHRoZSBsZWZ0b3ZlciBwcm9wZXJ0aWVzLlxuV2lsbCBOT1QgcG9wdWxhdGUgZGF0ZS1yZWxhdGVkIHByb3BzLlxuKi9cbmZ1bmN0aW9uIHBhcnNlRXZlbnREZWYocmVmaW5lZCwgZXh0cmEsIHNvdXJjZUlkLCBhbGxEYXksIGhhc0VuZCwgY29udGV4dCwgZGVmSWRNYXApIHtcbiAgICBsZXQgZGVmID0ge1xuICAgICAgICB0aXRsZTogcmVmaW5lZC50aXRsZSB8fCAnJyxcbiAgICAgICAgZ3JvdXBJZDogcmVmaW5lZC5ncm91cElkIHx8ICcnLFxuICAgICAgICBwdWJsaWNJZDogcmVmaW5lZC5pZCB8fCAnJyxcbiAgICAgICAgdXJsOiByZWZpbmVkLnVybCB8fCAnJyxcbiAgICAgICAgcmVjdXJyaW5nRGVmOiBudWxsLFxuICAgICAgICBkZWZJZDogKChkZWZJZE1hcCAmJiByZWZpbmVkLmlkKSA/IGRlZklkTWFwW3JlZmluZWQuaWRdIDogJycpIHx8IGd1aWQoKSxcbiAgICAgICAgc291cmNlSWQsXG4gICAgICAgIGFsbERheSxcbiAgICAgICAgaGFzRW5kLFxuICAgICAgICBpbnRlcmFjdGl2ZTogcmVmaW5lZC5pbnRlcmFjdGl2ZSxcbiAgICAgICAgdWk6IGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCksXG4gICAgICAgIGV4dGVuZGVkUHJvcHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHJlZmluZWQuZXh0ZW5kZWRQcm9wcyB8fCB7fSkpLCBleHRyYSksXG4gICAgfTtcbiAgICBmb3IgKGxldCBtZW1iZXJBZGRlciBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50RGVmTWVtYmVyQWRkZXJzKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZGVmLCBtZW1iZXJBZGRlcihyZWZpbmVkKSk7XG4gICAgfVxuICAgIC8vIGhlbHAgb3V0IEV2ZW50SW1wbCBmcm9tIGhhdmluZyB1c2VyIG1vZGlmeSBwcm9wc1xuICAgIE9iamVjdC5mcmVlemUoZGVmLnVpLmNsYXNzTmFtZXMpO1xuICAgIE9iamVjdC5mcmVlemUoZGVmLmV4dGVuZGVkUHJvcHMpO1xuICAgIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBwYXJzZVNpbmdsZShyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSkge1xuICAgIGxldCB7IGFsbERheSB9ID0gcmVmaW5lZDtcbiAgICBsZXQgc3RhcnRNZXRhO1xuICAgIGxldCBzdGFydE1hcmtlciA9IG51bGw7XG4gICAgbGV0IGhhc0VuZCA9IGZhbHNlO1xuICAgIGxldCBlbmRNZXRhO1xuICAgIGxldCBlbmRNYXJrZXIgPSBudWxsO1xuICAgIGxldCBzdGFydElucHV0ID0gcmVmaW5lZC5zdGFydCAhPSBudWxsID8gcmVmaW5lZC5zdGFydCA6IHJlZmluZWQuZGF0ZTtcbiAgICBzdGFydE1ldGEgPSBjb250ZXh0LmRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFydElucHV0KTtcbiAgICBpZiAoc3RhcnRNZXRhKSB7XG4gICAgICAgIHN0YXJ0TWFya2VyID0gc3RhcnRNZXRhLm1hcmtlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWFsbG93T3BlblJhbmdlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocmVmaW5lZC5lbmQgIT0gbnVsbCkge1xuICAgICAgICBlbmRNZXRhID0gY29udGV4dC5kYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEocmVmaW5lZC5lbmQpO1xuICAgIH1cbiAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRBbGxEYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgYWxsRGF5ID0gZGVmYXVsdEFsbERheTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZhbGwgYmFjayB0byB0aGUgZGF0ZSBwcm9wcyBMQVNUXG4gICAgICAgICAgICBhbGxEYXkgPSAoIXN0YXJ0TWV0YSB8fCBzdGFydE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpICYmXG4gICAgICAgICAgICAgICAgKCFlbmRNZXRhIHx8IGVuZE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhbGxEYXkgJiYgc3RhcnRNYXJrZXIpIHtcbiAgICAgICAgc3RhcnRNYXJrZXIgPSBzdGFydE9mRGF5KHN0YXJ0TWFya2VyKTtcbiAgICB9XG4gICAgaWYgKGVuZE1ldGEpIHtcbiAgICAgICAgZW5kTWFya2VyID0gZW5kTWV0YS5tYXJrZXI7XG4gICAgICAgIGlmIChhbGxEYXkpIHtcbiAgICAgICAgICAgIGVuZE1hcmtlciA9IHN0YXJ0T2ZEYXkoZW5kTWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyIDw9IHN0YXJ0TWFya2VyKSB7XG4gICAgICAgICAgICBlbmRNYXJrZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbmRNYXJrZXIpIHtcbiAgICAgICAgaGFzRW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWFsbG93T3BlblJhbmdlKSB7XG4gICAgICAgIGhhc0VuZCA9IGNvbnRleHQub3B0aW9ucy5mb3JjZUV2ZW50RHVyYXRpb24gfHwgZmFsc2U7XG4gICAgICAgIGVuZE1hcmtlciA9IGNvbnRleHQuZGF0ZUVudi5hZGQoc3RhcnRNYXJrZXIsIGFsbERheSA/XG4gICAgICAgICAgICBjb250ZXh0Lm9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gOlxuICAgICAgICAgICAgY29udGV4dC5vcHRpb25zLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhbGxEYXksXG4gICAgICAgIGhhc0VuZCxcbiAgICAgICAgcmFuZ2U6IHsgc3RhcnQ6IHN0YXJ0TWFya2VyLCBlbmQ6IGVuZE1hcmtlciB9LFxuICAgICAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRNZXRhID8gc3RhcnRNZXRhLmZvcmNlZFR6byA6IG51bGwsXG4gICAgICAgIGZvcmNlZEVuZFR6bzogZW5kTWV0YSA/IGVuZE1ldGEuZm9yY2VkVHpvIDogbnVsbCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUlzRGVmYXVsdEFsbERheShldmVudFNvdXJjZSwgY29udGV4dCkge1xuICAgIGxldCByZXMgPSBudWxsO1xuICAgIGlmIChldmVudFNvdXJjZSkge1xuICAgICAgICByZXMgPSBldmVudFNvdXJjZS5kZWZhdWx0QWxsRGF5O1xuICAgIH1cbiAgICBpZiAocmVzID09IG51bGwpIHtcbiAgICAgICAgcmVzID0gY29udGV4dC5vcHRpb25zLmRlZmF1bHRBbGxEYXk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRXZlbnRzKHJhd0V2ZW50cywgZXZlbnRTb3VyY2UsIGNvbnRleHQsIGFsbG93T3BlblJhbmdlLCBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCkge1xuICAgIGxldCBldmVudFN0b3JlID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgbGV0IGV2ZW50UmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCk7XG4gICAgZm9yIChsZXQgcmF3RXZlbnQgb2YgcmF3RXZlbnRzKSB7XG4gICAgICAgIGxldCB0dXBsZSA9IHBhcnNlRXZlbnQocmF3RXZlbnQsIGV2ZW50U291cmNlLCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSwgZXZlbnRSZWZpbmVycywgZGVmSWRNYXAsIGluc3RhbmNlSWRNYXApO1xuICAgICAgICBpZiAodHVwbGUpIHtcbiAgICAgICAgICAgIGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlLCBldmVudFN0b3JlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRTdG9yZTtcbn1cbmZ1bmN0aW9uIGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlLCBldmVudFN0b3JlID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCkpIHtcbiAgICBldmVudFN0b3JlLmRlZnNbdHVwbGUuZGVmLmRlZklkXSA9IHR1cGxlLmRlZjtcbiAgICBpZiAodHVwbGUuaW5zdGFuY2UpIHtcbiAgICAgICAgZXZlbnRTdG9yZS5pbnN0YW5jZXNbdHVwbGUuaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSB0dXBsZS5pbnN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50U3RvcmU7XG59XG4vLyByZXRyaWV2ZXMgZXZlbnRzIHRoYXQgaGF2ZSB0aGUgc2FtZSBncm91cElkIGFzIHRoZSBpbnN0YW5jZSBzcGVjaWZpZWQgYnkgYGluc3RhbmNlSWRgXG4vLyBvciB0aGV5IGFyZSB0aGUgc2FtZSBhcyB0aGUgaW5zdGFuY2UuXG4vLyB3aHkgbWlnaHQgaW5zdGFuY2VJZCBub3QgYmUgaW4gdGhlIHN0b3JlPyBhbiBldmVudCBmcm9tIGFub3RoZXIgY2FsZW5kYXI/XG5mdW5jdGlvbiBnZXRSZWxldmFudEV2ZW50cyhldmVudFN0b3JlLCBpbnN0YW5jZUlkKSB7XG4gICAgbGV0IGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIGxldCBkZWYgPSBldmVudFN0b3JlLmRlZnNbaW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICAvLyBnZXQgZXZlbnRzL2luc3RhbmNlcyB3aXRoIHNhbWUgZ3JvdXBcbiAgICAgICAgbGV0IG5ld1N0b3JlID0gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgKGxvb2tEZWYpID0+IGlzRXZlbnREZWZzR3JvdXBlZChkZWYsIGxvb2tEZWYpKTtcbiAgICAgICAgLy8gYWRkIHRoZSBvcmlnaW5hbFxuICAgICAgICAvLyBUT0RPOiB3aXNoIHdlIGNvdWxkIHVzZSBldmVudFR1cGxlVG9TdG9yZSBvciBzb21ldGhpbmcgbGlrZSBpdFxuICAgICAgICBuZXdTdG9yZS5kZWZzW2RlZi5kZWZJZF0gPSBkZWY7XG4gICAgICAgIG5ld1N0b3JlLmluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXSA9IGluc3RhbmNlO1xuICAgICAgICByZXR1cm4gbmV3U3RvcmU7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGlzRXZlbnREZWZzR3JvdXBlZChkZWYwLCBkZWYxKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oZGVmMC5ncm91cElkICYmIGRlZjAuZ3JvdXBJZCA9PT0gZGVmMS5ncm91cElkKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpIHtcbiAgICByZXR1cm4geyBkZWZzOiB7fSwgaW5zdGFuY2VzOiB7fSB9O1xufVxuZnVuY3Rpb24gbWVyZ2VFdmVudFN0b3JlcyhzdG9yZTAsIHN0b3JlMSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlZnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RvcmUwLmRlZnMpLCBzdG9yZTEuZGVmcyksXG4gICAgICAgIGluc3RhbmNlczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdG9yZTAuaW5zdGFuY2VzKSwgc3RvcmUxLmluc3RhbmNlcyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIGZpbHRlckZ1bmMpIHtcbiAgICBsZXQgZGVmcyA9IGZpbHRlckhhc2goZXZlbnRTdG9yZS5kZWZzLCBmaWx0ZXJGdW5jKTtcbiAgICBsZXQgaW5zdGFuY2VzID0gZmlsdGVySGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgKGluc3RhbmNlKSA9PiAoZGVmc1tpbnN0YW5jZS5kZWZJZF0gLy8gc3RpbGwgZXhpc3RzP1xuICAgICkpO1xuICAgIHJldHVybiB7IGRlZnMsIGluc3RhbmNlcyB9O1xufVxuZnVuY3Rpb24gZXhjbHVkZVN1YkV2ZW50U3RvcmUobWFzdGVyLCBzdWIpIHtcbiAgICBsZXQgeyBkZWZzLCBpbnN0YW5jZXMgfSA9IG1hc3RlcjtcbiAgICBsZXQgZmlsdGVyZWREZWZzID0ge307XG4gICAgbGV0IGZpbHRlcmVkSW5zdGFuY2VzID0ge307XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICBpZiAoIXN1Yi5kZWZzW2RlZklkXSkgeyAvLyBub3QgZXhwbGljaXRseSBleGNsdWRlZFxuICAgICAgICAgICAgZmlsdGVyZWREZWZzW2RlZklkXSA9IGRlZnNbZGVmSWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgIGlmICghc3ViLmluc3RhbmNlc1tpbnN0YW5jZUlkXSAmJiAvLyBub3QgZXhwbGljaXRseSBleGNsdWRlZFxuICAgICAgICAgICAgZmlsdGVyZWREZWZzW2luc3RhbmNlc1tpbnN0YW5jZUlkXS5kZWZJZF0gLy8gZGVmIHdhc24ndCBmaWx0ZXJlZCBhd2F5XG4gICAgICAgICkge1xuICAgICAgICAgICAgZmlsdGVyZWRJbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmczogZmlsdGVyZWREZWZzLFxuICAgICAgICBpbnN0YW5jZXM6IGZpbHRlcmVkSW5zdGFuY2VzLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnN0cmFpbnQoaW5wdXQsIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRXZlbnRzKGlucHV0LCBudWxsLCBjb250ZXh0LCB0cnVlKTsgLy8gYWxsb3dPcGVuUmFuZ2U9dHJ1ZVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIHBhcnNlRXZlbnRzKFtpbnB1dF0sIG51bGwsIGNvbnRleHQsIHRydWUpOyAvLyBhbGxvd09wZW5SYW5nZT10cnVlXG4gICAgfVxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGFyc2VDbGFzc05hbWVzKHJhdykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJhdykpIHtcbiAgICAgICAgcmV0dXJuIHJhdztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiByYXcuc3BsaXQoL1xccysvKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuXG4vLyBUT0RPOiBiZXR0ZXIgY2FsbGVkIFwiRXZlbnRTZXR0aW5nc1wiIG9yIFwiRXZlbnRDb25maWdcIlxuLy8gVE9ETzogbW92ZSB0aGlzIGZpbGUgaW50byBzdHJ1Y3RzXG4vLyBUT0RPOiBzZXBhcmF0ZSBjb25zdHJhaW50L292ZXJsYXAvYWxsb3csIGJlY2F1c2Ugc2VsZWN0aW9uIHVzZXMgb25seSB0aGF0LCBub3Qgb3RoZXIgcHJvcHNcbmNvbnN0IEVWRU5UX1VJX1JFRklORVJTID0ge1xuICAgIGRpc3BsYXk6IFN0cmluZyxcbiAgICBlZGl0YWJsZTogQm9vbGVhbixcbiAgICBzdGFydEVkaXRhYmxlOiBCb29sZWFuLFxuICAgIGR1cmF0aW9uRWRpdGFibGU6IEJvb2xlYW4sXG4gICAgY29uc3RyYWludDogaWRlbnRpdHksXG4gICAgb3ZlcmxhcDogaWRlbnRpdHksXG4gICAgYWxsb3c6IGlkZW50aXR5LFxuICAgIGNsYXNzTmFtZTogcGFyc2VDbGFzc05hbWVzLFxuICAgIGNsYXNzTmFtZXM6IHBhcnNlQ2xhc3NOYW1lcyxcbiAgICBjb2xvcjogU3RyaW5nLFxuICAgIGJhY2tncm91bmRDb2xvcjogU3RyaW5nLFxuICAgIGJvcmRlckNvbG9yOiBTdHJpbmcsXG4gICAgdGV4dENvbG9yOiBTdHJpbmcsXG59O1xuY29uc3QgRU1QVFlfRVZFTlRfVUkgPSB7XG4gICAgZGlzcGxheTogbnVsbCxcbiAgICBzdGFydEVkaXRhYmxlOiBudWxsLFxuICAgIGR1cmF0aW9uRWRpdGFibGU6IG51bGwsXG4gICAgY29uc3RyYWludHM6IFtdLFxuICAgIG92ZXJsYXA6IG51bGwsXG4gICAgYWxsb3dzOiBbXSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICAgIGJvcmRlckNvbG9yOiAnJyxcbiAgICB0ZXh0Q29sb3I6ICcnLFxuICAgIGNsYXNzTmFtZXM6IFtdLFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCkge1xuICAgIGxldCBjb25zdHJhaW50ID0gbm9ybWFsaXplQ29uc3RyYWludChyZWZpbmVkLmNvbnN0cmFpbnQsIGNvbnRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3BsYXk6IHJlZmluZWQuZGlzcGxheSB8fCBudWxsLFxuICAgICAgICBzdGFydEVkaXRhYmxlOiByZWZpbmVkLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCA/IHJlZmluZWQuc3RhcnRFZGl0YWJsZSA6IHJlZmluZWQuZWRpdGFibGUsXG4gICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IHJlZmluZWQuZHVyYXRpb25FZGl0YWJsZSAhPSBudWxsID8gcmVmaW5lZC5kdXJhdGlvbkVkaXRhYmxlIDogcmVmaW5lZC5lZGl0YWJsZSxcbiAgICAgICAgY29uc3RyYWludHM6IGNvbnN0cmFpbnQgIT0gbnVsbCA/IFtjb25zdHJhaW50XSA6IFtdLFxuICAgICAgICBvdmVybGFwOiByZWZpbmVkLm92ZXJsYXAgIT0gbnVsbCA/IHJlZmluZWQub3ZlcmxhcCA6IG51bGwsXG4gICAgICAgIGFsbG93czogcmVmaW5lZC5hbGxvdyAhPSBudWxsID8gW3JlZmluZWQuYWxsb3ddIDogW10sXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogcmVmaW5lZC5iYWNrZ3JvdW5kQ29sb3IgfHwgcmVmaW5lZC5jb2xvciB8fCAnJyxcbiAgICAgICAgYm9yZGVyQ29sb3I6IHJlZmluZWQuYm9yZGVyQ29sb3IgfHwgcmVmaW5lZC5jb2xvciB8fCAnJyxcbiAgICAgICAgdGV4dENvbG9yOiByZWZpbmVkLnRleHRDb2xvciB8fCAnJyxcbiAgICAgICAgY2xhc3NOYW1lczogKHJlZmluZWQuY2xhc3NOYW1lIHx8IFtdKS5jb25jYXQocmVmaW5lZC5jbGFzc05hbWVzIHx8IFtdKSwgLy8gam9pbiBzaW5ndWxhciBhbmQgcGx1cmFsXG4gICAgfTtcbn1cbi8vIFRPRE86IHByZXZlbnQgYWdhaW5zdCBwcm9ibGVtcyB3aXRoIDwyIGFyZ3MhXG5mdW5jdGlvbiBjb21iaW5lRXZlbnRVaXModWlzKSB7XG4gICAgcmV0dXJuIHVpcy5yZWR1Y2UoY29tYmluZVR3b0V2ZW50VWlzLCBFTVBUWV9FVkVOVF9VSSk7XG59XG5mdW5jdGlvbiBjb21iaW5lVHdvRXZlbnRVaXMoaXRlbTAsIGl0ZW0xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcGxheTogaXRlbTEuZGlzcGxheSAhPSBudWxsID8gaXRlbTEuZGlzcGxheSA6IGl0ZW0wLmRpc3BsYXksXG4gICAgICAgIHN0YXJ0RWRpdGFibGU6IGl0ZW0xLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCA/IGl0ZW0xLnN0YXJ0RWRpdGFibGUgOiBpdGVtMC5zdGFydEVkaXRhYmxlLFxuICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiBpdGVtMS5kdXJhdGlvbkVkaXRhYmxlICE9IG51bGwgPyBpdGVtMS5kdXJhdGlvbkVkaXRhYmxlIDogaXRlbTAuZHVyYXRpb25FZGl0YWJsZSxcbiAgICAgICAgY29uc3RyYWludHM6IGl0ZW0wLmNvbnN0cmFpbnRzLmNvbmNhdChpdGVtMS5jb25zdHJhaW50cyksXG4gICAgICAgIG92ZXJsYXA6IHR5cGVvZiBpdGVtMS5vdmVybGFwID09PSAnYm9vbGVhbicgPyBpdGVtMS5vdmVybGFwIDogaXRlbTAub3ZlcmxhcCxcbiAgICAgICAgYWxsb3dzOiBpdGVtMC5hbGxvd3MuY29uY2F0KGl0ZW0xLmFsbG93cyksXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaXRlbTEuYmFja2dyb3VuZENvbG9yIHx8IGl0ZW0wLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgYm9yZGVyQ29sb3I6IGl0ZW0xLmJvcmRlckNvbG9yIHx8IGl0ZW0wLmJvcmRlckNvbG9yLFxuICAgICAgICB0ZXh0Q29sb3I6IGl0ZW0xLnRleHRDb2xvciB8fCBpdGVtMC50ZXh0Q29sb3IsXG4gICAgICAgIGNsYXNzTmFtZXM6IGl0ZW0wLmNsYXNzTmFtZXMuY29uY2F0KGl0ZW0xLmNsYXNzTmFtZXMpLFxuICAgIH07XG59XG5cbmNvbnN0IEVWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHtcbiAgICBpZDogU3RyaW5nLFxuICAgIGRlZmF1bHRBbGxEYXk6IEJvb2xlYW4sXG4gICAgdXJsOiBTdHJpbmcsXG4gICAgZm9ybWF0OiBTdHJpbmcsXG4gICAgZXZlbnRzOiBpZGVudGl0eSxcbiAgICBldmVudERhdGFUcmFuc2Zvcm06IGlkZW50aXR5LFxuICAgIC8vIGZvciBhbnkgbmV0d29yay1yZWxhdGVkIHNvdXJjZXNcbiAgICBzdWNjZXNzOiBpZGVudGl0eSxcbiAgICBmYWlsdXJlOiBpZGVudGl0eSxcbn07XG5mdW5jdGlvbiBwYXJzZUV2ZW50U291cmNlKHJhdywgY29udGV4dCwgcmVmaW5lcnMgPSBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMoY29udGV4dCkpIHtcbiAgICBsZXQgcmF3T2JqO1xuICAgIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgICAgICByYXdPYmogPSB7IHVybDogcmF3IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiByYXcgPT09ICdmdW5jdGlvbicgfHwgQXJyYXkuaXNBcnJheShyYXcpKSB7XG4gICAgICAgIHJhd09iaiA9IHsgZXZlbnRzOiByYXcgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHJhdyA9PT0gJ29iamVjdCcgJiYgcmF3KSB7IC8vIG5vdCBudWxsXG4gICAgICAgIHJhd09iaiA9IHJhdztcbiAgICB9XG4gICAgaWYgKHJhd09iaikge1xuICAgICAgICBsZXQgeyByZWZpbmVkLCBleHRyYSB9ID0gcmVmaW5lUHJvcHMocmF3T2JqLCByZWZpbmVycyk7XG4gICAgICAgIGxldCBtZXRhUmVzID0gYnVpbGRFdmVudFNvdXJjZU1ldGEocmVmaW5lZCwgY29udGV4dCk7XG4gICAgICAgIGlmIChtZXRhUmVzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIF9yYXc6IHJhdyxcbiAgICAgICAgICAgICAgICBpc0ZldGNoaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsYXRlc3RGZXRjaElkOiAnJyxcbiAgICAgICAgICAgICAgICBmZXRjaFJhbmdlOiBudWxsLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRBbGxEYXk6IHJlZmluZWQuZGVmYXVsdEFsbERheSxcbiAgICAgICAgICAgICAgICBldmVudERhdGFUcmFuc2Zvcm06IHJlZmluZWQuZXZlbnREYXRhVHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHJlZmluZWQuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBmYWlsdXJlOiByZWZpbmVkLmZhaWx1cmUsXG4gICAgICAgICAgICAgICAgcHVibGljSWQ6IHJlZmluZWQuaWQgfHwgJycsXG4gICAgICAgICAgICAgICAgc291cmNlSWQ6IGd1aWQoKSxcbiAgICAgICAgICAgICAgICBzb3VyY2VEZWZJZDogbWV0YVJlcy5zb3VyY2VEZWZJZCxcbiAgICAgICAgICAgICAgICBtZXRhOiBtZXRhUmVzLm1ldGEsXG4gICAgICAgICAgICAgICAgdWk6IGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCksXG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRQcm9wczogZXh0cmEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzKGNvbnRleHQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEVWRU5UX1VJX1JFRklORVJTKSwgRVZFTlRfU09VUkNFX1JFRklORVJTKSwgY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZVJlZmluZXJzKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRTb3VyY2VNZXRhKHJhdywgY29udGV4dCkge1xuICAgIGxldCBkZWZzID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZURlZnM7XG4gICAgZm9yIChsZXQgaSA9IGRlZnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHsgLy8gbGF0ZXItYWRkZWQgcGx1Z2lucyB0YWtlIHByZWNlZGVuY2VcbiAgICAgICAgbGV0IGRlZiA9IGRlZnNbaV07XG4gICAgICAgIGxldCBtZXRhID0gZGVmLnBhcnNlTWV0YShyYXcpO1xuICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc291cmNlRGVmSWQ6IGksIG1ldGEgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVkdWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBhY3Rpb24sIGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1JFQ0VJVkVfRVZFTlRTJzogLy8gcmF3XG4gICAgICAgICAgICByZXR1cm4gcmVjZWl2ZVJhd0V2ZW50cyhldmVudFN0b3JlLCBldmVudFNvdXJjZXNbYWN0aW9uLnNvdXJjZUlkXSwgYWN0aW9uLmZldGNoSWQsIGFjdGlvbi5mZXRjaFJhbmdlLCBhY3Rpb24ucmF3RXZlbnRzLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnUkVTRVRfUkFXX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gcmVzZXRSYXdFdmVudHMoZXZlbnRTdG9yZSwgZXZlbnRTb3VyY2VzW2FjdGlvbi5zb3VyY2VJZF0sIGFjdGlvbi5yYXdFdmVudHMsIGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnQUREX0VWRU5UUyc6IC8vIGFscmVhZHkgcGFyc2VkLCBidXQgbm90IGV4cGFuZGVkXG4gICAgICAgICAgICByZXR1cm4gYWRkRXZlbnQoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUsIC8vIG5ldyBvbmVzXG4gICAgICAgICAgICBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbCwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ1JFU0VUX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLmV2ZW50U3RvcmU7XG4gICAgICAgIGNhc2UgJ01FUkdFX0VWRU5UUyc6IC8vIGFscmVhZHkgcGFyc2VkIGFuZCBleHBhbmRlZFxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUpO1xuICAgICAgICBjYXNlICdQUkVWJzogLy8gVE9ETzogaG93IGRvIHdlIHRyYWNrIGFsbCBhY3Rpb25zIHRoYXQgYWZmZWN0IGRhdGVQcm9maWxlIDooXG4gICAgICAgIGNhc2UgJ05FWFQnOlxuICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgaWYgKGRhdGVQcm9maWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cGFuZFJlY3VycmluZyhldmVudFN0b3JlLCBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTdG9yZTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gZXhjbHVkZVN1YkV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUpO1xuICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRfU09VUkNFJzpcbiAgICAgICAgICAgIHJldHVybiBleGNsdWRlRXZlbnRzQnlTb3VyY2VJZChldmVudFN0b3JlLCBhY3Rpb24uc291cmNlSWQpO1xuICAgICAgICBjYXNlICdSRU1PVkVfQUxMX0VWRU5UX1NPVVJDRVMnOlxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIChldmVudERlZikgPT4gKCFldmVudERlZi5zb3VyY2VJZCAvLyBvbmx5IGtlZXAgZXZlbnRzIHdpdGggbm8gc291cmNlIGlkXG4gICAgICAgICAgICApKTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0FMTF9FVkVOVFMnOlxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmU7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVjZWl2ZVJhd0V2ZW50cyhldmVudFN0b3JlLCBldmVudFNvdXJjZSwgZmV0Y2hJZCwgZmV0Y2hSYW5nZSwgcmF3RXZlbnRzLCBjb250ZXh0KSB7XG4gICAgaWYgKGV2ZW50U291cmNlICYmIC8vIG5vdCBhbHJlYWR5IHJlbW92ZWRcbiAgICAgICAgZmV0Y2hJZCA9PT0gZXZlbnRTb3VyY2UubGF0ZXN0RmV0Y2hJZCAvLyBUT0RPOiB3aXNoIHRoaXMgbG9naWMgd2FzIGFsd2F5cyBpbiBldmVudC1zb3VyY2VzXG4gICAgKSB7XG4gICAgICAgIGxldCBzdWJzZXQgPSBwYXJzZUV2ZW50cyh0cmFuc2Zvcm1SYXdFdmVudHMocmF3RXZlbnRzLCBldmVudFNvdXJjZSwgY29udGV4dCksIGV2ZW50U291cmNlLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGZldGNoUmFuZ2UpIHtcbiAgICAgICAgICAgIHN1YnNldCA9IGV4cGFuZFJlY3VycmluZyhzdWJzZXQsIGZldGNoUmFuZ2UsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZUV2ZW50U3RvcmVzKGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlLnNvdXJjZUlkKSwgc3Vic2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50U3RvcmU7XG59XG5mdW5jdGlvbiByZXNldFJhd0V2ZW50cyhleGlzdGluZ0V2ZW50U3RvcmUsIGV2ZW50U291cmNlLCByYXdFdmVudHMsIGFjdGl2ZVJhbmdlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCB9ID0gYnVpbGRQdWJsaWNJZE1hcHMoZXhpc3RpbmdFdmVudFN0b3JlKTtcbiAgICBsZXQgbmV3RXZlbnRTdG9yZSA9IHBhcnNlRXZlbnRzKHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0KSwgZXZlbnRTb3VyY2UsIGNvbnRleHQsIGZhbHNlLCBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCk7XG4gICAgcmV0dXJuIGV4cGFuZFJlY3VycmluZyhuZXdFdmVudFN0b3JlLCBhY3RpdmVSYW5nZSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1SYXdFdmVudHMocmF3RXZlbnRzLCBldmVudFNvdXJjZSwgY29udGV4dCkge1xuICAgIGxldCBjYWxFYWNoVHJhbnNmb3JtID0gY29udGV4dC5vcHRpb25zLmV2ZW50RGF0YVRyYW5zZm9ybTtcbiAgICBsZXQgc291cmNlRWFjaFRyYW5zZm9ybSA9IGV2ZW50U291cmNlID8gZXZlbnRTb3VyY2UuZXZlbnREYXRhVHJhbnNmb3JtIDogbnVsbDtcbiAgICBpZiAoc291cmNlRWFjaFRyYW5zZm9ybSkge1xuICAgICAgICByYXdFdmVudHMgPSB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBzb3VyY2VFYWNoVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgaWYgKGNhbEVhY2hUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmF3RXZlbnRzID0gdHJhbnNmb3JtRWFjaFJhd0V2ZW50KHJhd0V2ZW50cywgY2FsRWFjaFRyYW5zZm9ybSk7XG4gICAgfVxuICAgIHJldHVybiByYXdFdmVudHM7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBmdW5jKSB7XG4gICAgbGV0IHJlZmluZWRFdmVudHM7XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICAgIHJlZmluZWRFdmVudHMgPSByYXdFdmVudHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZWZpbmVkRXZlbnRzID0gW107XG4gICAgICAgIGZvciAobGV0IHJhd0V2ZW50IG9mIHJhd0V2ZW50cykge1xuICAgICAgICAgICAgbGV0IHJlZmluZWRFdmVudCA9IGZ1bmMocmF3RXZlbnQpO1xuICAgICAgICAgICAgaWYgKHJlZmluZWRFdmVudCkge1xuICAgICAgICAgICAgICAgIHJlZmluZWRFdmVudHMucHVzaChyZWZpbmVkRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVmaW5lZEV2ZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkRXZlbnRzLnB1c2gocmF3RXZlbnQpO1xuICAgICAgICAgICAgfSAvLyBpZiBhIGRpZmZlcmVudCBmYWxzeSB2YWx1ZSwgZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWZpbmVkRXZlbnRzO1xufVxuZnVuY3Rpb24gYWRkRXZlbnQoZXZlbnRTdG9yZSwgc3Vic2V0LCBleHBhbmRSYW5nZSwgY29udGV4dCkge1xuICAgIGlmIChleHBhbmRSYW5nZSkge1xuICAgICAgICBzdWJzZXQgPSBleHBhbmRSZWN1cnJpbmcoc3Vic2V0LCBleHBhbmRSYW5nZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZUV2ZW50U3RvcmVzKGV2ZW50U3RvcmUsIHN1YnNldCk7XG59XG5mdW5jdGlvbiByZXpvbmVFdmVudFN0b3JlRGF0ZXMoZXZlbnRTdG9yZSwgb2xkRGF0ZUVudiwgbmV3RGF0ZUVudikge1xuICAgIGxldCB7IGRlZnMgfSA9IGV2ZW50U3RvcmU7XG4gICAgbGV0IGluc3RhbmNlcyA9IG1hcEhhc2goZXZlbnRTdG9yZS5pbnN0YW5jZXMsIChpbnN0YW5jZSkgPT4ge1xuICAgICAgICBsZXQgZGVmID0gZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGlmIChkZWYuYWxsRGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7IC8vIGlzbid0IGRlcGVuZGVudCBvbiB0aW1lem9uZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluc3RhbmNlKSwgeyByYW5nZToge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBuZXdEYXRlRW52LmNyZWF0ZU1hcmtlcihvbGREYXRlRW52LnRvRGF0ZShpbnN0YW5jZS5yYW5nZS5zdGFydCwgaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8pKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG5ld0RhdGVFbnYuY3JlYXRlTWFya2VyKG9sZERhdGVFbnYudG9EYXRlKGluc3RhbmNlLnJhbmdlLmVuZCwgaW5zdGFuY2UuZm9yY2VkRW5kVHpvKSksXG4gICAgICAgICAgICB9LCBmb3JjZWRTdGFydFR6bzogbmV3RGF0ZUVudi5jYW5Db21wdXRlT2Zmc2V0ID8gbnVsbCA6IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLCBmb3JjZWRFbmRUem86IG5ld0RhdGVFbnYuY2FuQ29tcHV0ZU9mZnNldCA/IG51bGwgOiBpbnN0YW5jZS5mb3JjZWRFbmRUem8gfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgZGVmcywgaW5zdGFuY2VzIH07XG59XG5mdW5jdGlvbiBleGNsdWRlRXZlbnRzQnlTb3VyY2VJZChldmVudFN0b3JlLCBzb3VyY2VJZCkge1xuICAgIHJldHVybiBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCAoZXZlbnREZWYpID0+IGV2ZW50RGVmLnNvdXJjZUlkICE9PSBzb3VyY2VJZCk7XG59XG4vLyBRVUVTVElPTjogd2h5IG5vdCBqdXN0IHJldHVybiBpbnN0YW5jZXM/IGRvIGEgZ2VuZXJhbCBvYmplY3QtcHJvcGVydHktZXhjbHVzaW9uIHV0aWxcbmZ1bmN0aW9uIGV4Y2x1ZGVJbnN0YW5jZXMoZXZlbnRTdG9yZSwgcmVtb3ZhbHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZzOiBldmVudFN0b3JlLmRlZnMsXG4gICAgICAgIGluc3RhbmNlczogZmlsdGVySGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgKGluc3RhbmNlKSA9PiAhcmVtb3ZhbHNbaW5zdGFuY2UuaW5zdGFuY2VJZF0pLFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZFB1YmxpY0lkTWFwcyhldmVudFN0b3JlKSB7XG4gICAgY29uc3QgeyBkZWZzLCBpbnN0YW5jZXMgfSA9IGV2ZW50U3RvcmU7XG4gICAgY29uc3QgZGVmSWRNYXAgPSB7fTtcbiAgICBjb25zdCBpbnN0YW5jZUlkTWFwID0ge307XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICBjb25zdCBkZWYgPSBkZWZzW2RlZklkXTtcbiAgICAgICAgY29uc3QgeyBwdWJsaWNJZCB9ID0gZGVmO1xuICAgICAgICBpZiAocHVibGljSWQpIHtcbiAgICAgICAgICAgIGRlZklkTWFwW3B1YmxpY0lkXSA9IGRlZklkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICBjb25zdCBkZWYgPSBkZWZzW2luc3RhbmNlLmRlZklkXTtcbiAgICAgICAgY29uc3QgeyBwdWJsaWNJZCB9ID0gZGVmO1xuICAgICAgICBpZiAocHVibGljSWQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlSWRNYXBbcHVibGljSWRdID0gaW5zdGFuY2VJZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCB9O1xufVxuXG5jbGFzcyBFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLnRoaXNDb250ZXh0ID0gbnVsbDtcbiAgICB9XG4gICAgc2V0VGhpc0NvbnRleHQodGhpc0NvbnRleHQpIHtcbiAgICAgICAgdGhpcy50aGlzQ29udGV4dCA9IHRoaXNDb250ZXh0O1xuICAgIH1cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgb24odHlwZSwgaGFuZGxlcikge1xuICAgICAgICBhZGRUb0hhc2godGhpcy5oYW5kbGVycywgdHlwZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIG9mZih0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHJlbW92ZUZyb21IYXNoKHRoaXMuaGFuZGxlcnMsIHR5cGUsIGhhbmRsZXIpO1xuICAgIH1cbiAgICB0cmlnZ2VyKHR5cGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IGF0dGFjaGVkSGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW3R5cGVdIHx8IFtdO1xuICAgICAgICBsZXQgb3B0aW9uSGFuZGxlciA9IHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNbdHlwZV07XG4gICAgICAgIGxldCBoYW5kbGVycyA9IFtdLmNvbmNhdChvcHRpb25IYW5kbGVyIHx8IFtdLCBhdHRhY2hlZEhhbmRsZXJzKTtcbiAgICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiBoYW5kbGVycykge1xuICAgICAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLnRoaXNDb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNIYW5kbGVycyh0eXBlKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKCh0aGlzLmhhbmRsZXJzW3R5cGVdICYmIHRoaXMuaGFuZGxlcnNbdHlwZV0ubGVuZ3RoKSB8fFxuICAgICAgICAgICAgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNbdHlwZV0pKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRUb0hhc2goaGFzaCwgdHlwZSwgaGFuZGxlcikge1xuICAgIChoYXNoW3R5cGVdIHx8IChoYXNoW3R5cGVdID0gW10pKVxuICAgICAgICAucHVzaChoYW5kbGVyKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUZyb21IYXNoKGhhc2gsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICBpZiAoaGFzaFt0eXBlXSkge1xuICAgICAgICAgICAgaGFzaFt0eXBlXSA9IGhhc2hbdHlwZV0uZmlsdGVyKChmdW5jKSA9PiBmdW5jICE9PSBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbdHlwZV07IC8vIHJlbW92ZSBhbGwgaGFuZGxlciBmdW5jcyBmb3IgdGhpcyB0eXBlXG4gICAgfVxufVxuXG5jb25zdCBERUZfREVGQVVMVFMgPSB7XG4gICAgc3RhcnRUaW1lOiAnMDk6MDAnLFxuICAgIGVuZFRpbWU6ICcxNzowMCcsXG4gICAgZGF5c09mV2VlazogWzEsIDIsIDMsIDQsIDVdLFxuICAgIGRpc3BsYXk6ICdpbnZlcnNlLWJhY2tncm91bmQnLFxuICAgIGNsYXNzTmFtZXM6ICdmYy1ub24tYnVzaW5lc3MnLFxuICAgIGdyb3VwSWQ6ICdfYnVzaW5lc3NIb3VycycsIC8vIHNvIG11bHRpcGxlIGRlZnMgZ2V0IGdyb3VwZWRcbn07XG4vKlxuVE9ETzogcGFzcyBhcm91bmQgYXMgRXZlbnREZWZIYXNoISEhXG4qL1xuZnVuY3Rpb24gcGFyc2VCdXNpbmVzc0hvdXJzKGlucHV0LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHBhcnNlRXZlbnRzKHJlZmluZUlucHV0cyhpbnB1dCksIG51bGwsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gcmVmaW5lSW5wdXRzKGlucHV0KSB7XG4gICAgbGV0IHJhd0RlZnM7XG4gICAgaWYgKGlucHV0ID09PSB0cnVlKSB7XG4gICAgICAgIHJhd0RlZnMgPSBbe31dOyAvLyB3aWxsIGdldCBERUZfREVGQVVMVFMgdmVyYmF0aW1cbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgLy8gaWYgc3BlY2lmeWluZyBhbiBhcnJheSwgZXZlcnkgc3ViLWRlZmluaXRpb24gTkVFRFMgYSBkYXktb2Ytd2Vla1xuICAgICAgICByYXdEZWZzID0gaW5wdXQuZmlsdGVyKChyYXdEZWYpID0+IHJhd0RlZi5kYXlzT2ZXZWVrKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmF3RGVmcyA9IFtpbnB1dF07XG4gICAgfVxuICAgIGVsc2UgeyAvLyBpcyBwcm9iYWJseSBmYWxzZVxuICAgICAgICByYXdEZWZzID0gW107XG4gICAgfVxuICAgIHJhd0RlZnMgPSByYXdEZWZzLm1hcCgocmF3RGVmKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZfREVGQVVMVFMpLCByYXdEZWYpKSk7XG4gICAgcmV0dXJuIHJhd0RlZnM7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXJEYXRlU2VsZWN0KHNlbGVjdGlvbiwgcGV2LCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ3NlbGVjdCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0KHNlbGVjdGlvbiwgY29udGV4dCkpLCB7IGpzRXZlbnQ6IHBldiA/IHBldi5vcmlnRXZlbnQgOiBudWxsLCB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfHwgY29udGV4dC5jYWxlbmRhckFwaS52aWV3IH0pKTtcbn1cbmZ1bmN0aW9uIHRyaWdnZXJEYXRlVW5zZWxlY3QocGV2LCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ3Vuc2VsZWN0Jywge1xuICAgICAgICBqc0V2ZW50OiBwZXYgPyBwZXYub3JpZ0V2ZW50IDogbnVsbCxcbiAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpIHx8IGNvbnRleHQuY2FsZW5kYXJBcGkudmlldyxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChkYXRlU3BhbiwgY29udGV4dCkge1xuICAgIGxldCBwcm9wcyA9IHt9O1xuICAgIGZvciAobGV0IHRyYW5zZm9ybSBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmRhdGVTcGFuVHJhbnNmb3Jtcykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIGNvbnRleHQpKTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihwcm9wcywgYnVpbGREYXRlU3BhbkFwaShkYXRlU3BhbiwgY29udGV4dC5kYXRlRW52KSk7XG4gICAgcmV0dXJuIHByb3BzO1xufVxuLy8gR2l2ZW4gYW4gZXZlbnQncyBhbGxEYXkgc3RhdHVzIGFuZCBzdGFydCBkYXRlLCByZXR1cm4gd2hhdCBpdHMgZmFsbGJhY2sgZW5kIGRhdGUgc2hvdWxkIGJlLlxuLy8gVE9ETzogcmVuYW1lIHRvIGNvbXB1dGVEZWZhdWx0RXZlbnRFbmRcbmZ1bmN0aW9uIGdldERlZmF1bHRFdmVudEVuZChhbGxEYXksIG1hcmtlciwgY29udGV4dCkge1xuICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IGVuZCA9IG1hcmtlcjtcbiAgICBpZiAoYWxsRGF5KSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0T2ZEYXkoZW5kKTtcbiAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoZW5kLCBvcHRpb25zLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgb3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuZDtcbn1cblxuLy8gYXBwbGllcyB0aGUgbXV0YXRpb24gdG8gQUxMIGRlZnMvaW5zdGFuY2VzIHdpdGhpbiB0aGUgZXZlbnQgc3RvcmVcbmZ1bmN0aW9uIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRDb25maWdCYXNlLCBtdXRhdGlvbiwgY29udGV4dCkge1xuICAgIGxldCBldmVudENvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMoZXZlbnRTdG9yZS5kZWZzLCBldmVudENvbmZpZ0Jhc2UpO1xuICAgIGxldCBkZXN0ID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnRTdG9yZS5kZWZzKSB7XG4gICAgICAgIGxldCBkZWYgPSBldmVudFN0b3JlLmRlZnNbZGVmSWRdO1xuICAgICAgICBkZXN0LmRlZnNbZGVmSWRdID0gYXBwbHlNdXRhdGlvblRvRXZlbnREZWYoZGVmLCBldmVudENvbmZpZ3NbZGVmSWRdLCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gZXZlbnRTdG9yZS5pbnN0YW5jZXMpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgIGxldCBkZWYgPSBkZXN0LmRlZnNbaW5zdGFuY2UuZGVmSWRdOyAvLyBpbXBvcnRhbnQgdG8gZ3JhYiB0aGUgbmV3bHkgbW9kaWZpZWQgZGVmXG4gICAgICAgIGRlc3QuaW5zdGFuY2VzW2luc3RhbmNlSWRdID0gYXBwbHlNdXRhdGlvblRvRXZlbnRJbnN0YW5jZShpbnN0YW5jZSwgZGVmLCBldmVudENvbmZpZ3NbaW5zdGFuY2UuZGVmSWRdLCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnREZWYoZXZlbnREZWYsIGV2ZW50Q29uZmlnLCBtdXRhdGlvbiwgY29udGV4dCkge1xuICAgIGxldCBzdGFuZGFyZFByb3BzID0gbXV0YXRpb24uc3RhbmRhcmRQcm9wcyB8fCB7fTtcbiAgICAvLyBpZiBoYXNFbmQgaGFzIG5vdCBiZWVuIHNwZWNpZmllZCwgZ3Vlc3MgYSBnb29kIHZhbHVlIGJhc2VkIG9uIGRlbHRhcy5cbiAgICAvLyBpZiBkdXJhdGlvbiB3aWxsIGNoYW5nZSwgdGhlcmUncyBubyB3YXkgdGhlIGRlZmF1bHQgZHVyYXRpb24gd2lsbCBwZXJzaXN0LFxuICAgIC8vIGFuZCB0aHVzLCB3ZSBuZWVkIHRvIG1hcmsgdGhlIGV2ZW50IGFzIGhhdmluZyBhIHJlYWwgZW5kXG4gICAgaWYgKHN0YW5kYXJkUHJvcHMuaGFzRW5kID09IG51bGwgJiZcbiAgICAgICAgZXZlbnRDb25maWcuZHVyYXRpb25FZGl0YWJsZSAmJlxuICAgICAgICAobXV0YXRpb24uc3RhcnREZWx0YSB8fCBtdXRhdGlvbi5lbmREZWx0YSkpIHtcbiAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSB0cnVlOyAvLyBUT0RPOiBpcyB0aGlzIG11dGF0aW9uIG9rYXk/XG4gICAgfVxuICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50RGVmKSwgc3RhbmRhcmRQcm9wcyksIHsgdWk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnREZWYudWkpLCBzdGFuZGFyZFByb3BzLnVpKSB9KTtcbiAgICBpZiAobXV0YXRpb24uZXh0ZW5kZWRQcm9wcykge1xuICAgICAgICBjb3B5LmV4dGVuZGVkUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvcHkuZXh0ZW5kZWRQcm9wcyksIG11dGF0aW9uLmV4dGVuZGVkUHJvcHMpO1xuICAgIH1cbiAgICBmb3IgKGxldCBhcHBsaWVyIG9mIGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzKSB7XG4gICAgICAgIGFwcGxpZXIoY29weSwgbXV0YXRpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoIWNvcHkuaGFzRW5kICYmIGNvbnRleHQub3B0aW9ucy5mb3JjZUV2ZW50RHVyYXRpb24pIHtcbiAgICAgICAgY29weS5oYXNFbmQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn1cbmZ1bmN0aW9uIGFwcGx5TXV0YXRpb25Ub0V2ZW50SW5zdGFuY2UoZXZlbnRJbnN0YW5jZSwgZXZlbnREZWYsIC8vIG11c3QgZmlyc3QgYmUgbW9kaWZpZWQgYnkgYXBwbHlNdXRhdGlvblRvRXZlbnREZWZcbmV2ZW50Q29uZmlnLCBtdXRhdGlvbiwgY29udGV4dCkge1xuICAgIGxldCB7IGRhdGVFbnYgfSA9IGNvbnRleHQ7XG4gICAgbGV0IGZvcmNlQWxsRGF5ID0gbXV0YXRpb24uc3RhbmRhcmRQcm9wcyAmJiBtdXRhdGlvbi5zdGFuZGFyZFByb3BzLmFsbERheSA9PT0gdHJ1ZTtcbiAgICBsZXQgY2xlYXJFbmQgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzICYmIG11dGF0aW9uLnN0YW5kYXJkUHJvcHMuaGFzRW5kID09PSBmYWxzZTtcbiAgICBsZXQgY29weSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50SW5zdGFuY2UpO1xuICAgIGlmIChmb3JjZUFsbERheSkge1xuICAgICAgICBjb3B5LnJhbmdlID0gY29tcHV0ZUFsaWduZWREYXlSYW5nZShjb3B5LnJhbmdlKTtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9uLmRhdGVzRGVsdGEgJiYgZXZlbnRDb25maWcuc3RhcnRFZGl0YWJsZSkge1xuICAgICAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2Uuc3RhcnQsIG11dGF0aW9uLmRhdGVzRGVsdGEpLFxuICAgICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLmVuZCwgbXV0YXRpb24uZGF0ZXNEZWx0YSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi5zdGFydERlbHRhICYmIGV2ZW50Q29uZmlnLmR1cmF0aW9uRWRpdGFibGUpIHtcbiAgICAgICAgY29weS5yYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLnN0YXJ0LCBtdXRhdGlvbi5zdGFydERlbHRhKSxcbiAgICAgICAgICAgIGVuZDogY29weS5yYW5nZS5lbmQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi5lbmREZWx0YSAmJiBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlKSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogY29weS5yYW5nZS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5lbmQsIG11dGF0aW9uLmVuZERlbHRhKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNsZWFyRW5kKSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogY29weS5yYW5nZS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZ2V0RGVmYXVsdEV2ZW50RW5kKGV2ZW50RGVmLmFsbERheSwgY29weS5yYW5nZS5zdGFydCwgY29udGV4dCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGluIGNhc2UgZXZlbnQgd2FzIGFsbC1kYXkgYnV0IHRoZSBzdXBwbGllZCBkZWx0YXMgd2VyZSBub3RcbiAgICAvLyBiZXR0ZXIgdXRpbCBmb3IgdGhpcz9cbiAgICBpZiAoZXZlbnREZWYuYWxsRGF5KSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnRPZkRheShjb3B5LnJhbmdlLnN0YXJ0KSxcbiAgICAgICAgICAgIGVuZDogc3RhcnRPZkRheShjb3B5LnJhbmdlLmVuZCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGhhbmRsZSBpbnZhbGlkIGR1cmF0aW9uc1xuICAgIGlmIChjb3B5LnJhbmdlLmVuZCA8IGNvcHkucmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgY29weS5yYW5nZS5lbmQgPSBnZXREZWZhdWx0RXZlbnRFbmQoZXZlbnREZWYuYWxsRGF5LCBjb3B5LnJhbmdlLnN0YXJ0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59XG5cbmNsYXNzIEV2ZW50U291cmNlSW1wbCB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgaW50ZXJuYWxFdmVudFNvdXJjZSkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UgPSBpbnRlcm5hbEV2ZW50U291cmNlO1xuICAgIH1cbiAgICByZW1vdmUoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UX1NPVVJDRScsXG4gICAgICAgICAgICBzb3VyY2VJZDogdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLnNvdXJjZUlkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVmZXRjaCgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdGRVRDSF9FVkVOVF9TT1VSQ0VTJyxcbiAgICAgICAgICAgIHNvdXJjZUlkczogW3RoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5zb3VyY2VJZF0sXG4gICAgICAgICAgICBpc1JlZmV0Y2g6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UucHVibGljSWQ7XG4gICAgfVxuICAgIGdldCB1cmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UubWV0YS51cmw7XG4gICAgfVxuICAgIGdldCBmb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UubWV0YS5mb3JtYXQ7IC8vIFRPRE86IGJhZC4gbm90IGd1YXJhbnRlZWRcbiAgICB9XG59XG5cbmNsYXNzIEV2ZW50SW1wbCB7XG4gICAgLy8gaW5zdGFuY2Ugd2lsbCBiZSBudWxsIGlmIGV4cHJlc3NpbmcgYSByZWN1cnJpbmcgZXZlbnQgdGhhdCBoYXMgbm8gY3VycmVudCBpbnN0YW5jZXMsXG4gICAgLy8gT1IgaWYgdHJ5aW5nIHRvIHZhbGlkYXRlIGFuIGluY29taW5nIGV4dGVybmFsIGV2ZW50IHRoYXQgaGFzIG5vIGRhdGVzIGFzc2lnbmVkXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgZGVmLCBpbnN0YW5jZSkge1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fZGVmID0gZGVmO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlIHx8IG51bGw7XG4gICAgfVxuICAgIC8qXG4gICAgVE9ETzogbWFrZSBldmVudCBzdHJ1Y3QgbW9yZSByZXNwb25zaWJsZSBmb3IgdGhpc1xuICAgICovXG4gICAgc2V0UHJvcChuYW1lLCB2YWwpIHtcbiAgICAgICAgaWYgKG5hbWUgaW4gRVZFTlRfREFURV9SRUZJTkVSUykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3Qgc2V0IGRhdGUtcmVsYXRlZCBwcm9wIFxcJ25hbWVcXCcuIFVzZSBvbmUgb2YgdGhlIGRhdGUtcmVsYXRlZCBtZXRob2RzIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYWtlIHByb3BlciBhbGlhc2luZyBzeXN0ZW0/XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2lkJykge1xuICAgICAgICAgICAgdmFsID0gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlNbbmFtZV0odmFsKTtcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzOiB7IHB1YmxpY0lkOiB2YWwgfSwgLy8gaGFyZGNvZGVkIGludGVybmFsIG5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgaW4gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMpIHtcbiAgICAgICAgICAgIHZhbCA9IEVWRU5UX05PTl9EQVRFX1JFRklORVJTW25hbWVdKHZhbCk7XG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wczogeyBbbmFtZV06IHZhbCB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSBpbiBFVkVOVF9VSV9SRUZJTkVSUykge1xuICAgICAgICAgICAgbGV0IHVpID0gRVZFTlRfVUlfUkVGSU5FUlNbbmFtZV0odmFsKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnY29sb3InKSB7XG4gICAgICAgICAgICAgICAgdWkgPSB7IGJhY2tncm91bmRDb2xvcjogdmFsLCBib3JkZXJDb2xvcjogdmFsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnZWRpdGFibGUnKSB7XG4gICAgICAgICAgICAgICAgdWkgPSB7IHN0YXJ0RWRpdGFibGU6IHZhbCwgZHVyYXRpb25FZGl0YWJsZTogdmFsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1aSA9IHsgW25hbWVdOiB2YWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzOiB7IHVpIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IHNldCBwcm9wICcke25hbWV9Jy4gVXNlIHNldEV4dGVuZGVkUHJvcCBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEV4dGVuZGVkUHJvcChuYW1lLCB2YWwpIHtcbiAgICAgICAgdGhpcy5tdXRhdGUoe1xuICAgICAgICAgICAgZXh0ZW5kZWRQcm9wczogeyBbbmFtZV06IHZhbCB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0U3RhcnQoc3RhcnRJbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIGxldCBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKHN0YXJ0SW5wdXQpO1xuICAgICAgICBpZiAoc3RhcnQgJiYgdGhpcy5faW5zdGFuY2UpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICBsZXQgaW5zdGFuY2VSYW5nZSA9IHRoaXMuX2luc3RhbmNlLnJhbmdlO1xuICAgICAgICAgICAgbGV0IHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpOyAvLyB3aGF0IGlmIHBhcnNlZCBiYWQhP1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWFpbnRhaW5EdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRFbmQoZW5kSW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBsZXQgZW5kO1xuICAgICAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpO1xuICAgICAgICAgICAgaWYgKCFlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmREZWx0YSA9IGRpZmZEYXRlcyh0aGlzLl9pbnN0YW5jZS5yYW5nZS5lbmQsIGVuZCwgZGF0ZUVudiwgb3B0aW9ucy5ncmFudWxhcml0eSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBlbmREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhbmRhcmRQcm9wczogeyBoYXNFbmQ6IGZhbHNlIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0RGF0ZXMoc3RhcnRJbnB1dCwgZW5kSW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBsZXQgc3RhbmRhcmRQcm9wcyA9IHsgYWxsRGF5OiBvcHRpb25zLmFsbERheSB9O1xuICAgICAgICBsZXQgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihzdGFydElucHV0KTtcbiAgICAgICAgbGV0IGVuZDtcbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpO1xuICAgICAgICAgICAgaWYgKCFlbmQpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgbGV0IGluc3RhbmNlUmFuZ2UgPSB0aGlzLl9pbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgICAgIC8vIHdoZW4gY29tcHV0aW5nIHRoZSBkaWZmIGZvciBhbiBldmVudCBiZWluZyBjb252ZXJ0ZWQgdG8gYWxsLWRheSxcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgZGlmZiBvZmYgb2YgdGhlIGFsbC1kYXkgdmFsdWVzIHRoZSB3YXkgZXZlbnQtbXV0YXRpb24gZG9lcy5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFsbERheSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlUmFuZ2UgPSBjb21wdXRlQWxpZ25lZERheVJhbmdlKGluc3RhbmNlUmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpO1xuICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmREZWx0YSA9IGRpZmZEYXRlcyhpbnN0YW5jZVJhbmdlLmVuZCwgZW5kLCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTtcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb25zRXF1YWwoc3RhcnREZWx0YSwgZW5kRGVsdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSwgc3RhbmRhcmRQcm9wcyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YSwgZW5kRGVsdGEsIHN0YW5kYXJkUHJvcHMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIG1lYW5zIFwiY2xlYXIgdGhlIGVuZFwiXG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IHN0YXJ0RGVsdGEsIHN0YW5kYXJkUHJvcHMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZVN0YXJ0KGRlbHRhSW5wdXQpIHtcbiAgICAgICAgbGV0IGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YTogZGVsdGEgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZUVuZChkZWx0YUlucHV0KSB7XG4gICAgICAgIGxldCBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpO1xuICAgICAgICBpZiAoZGVsdGEpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGVuZERlbHRhOiBkZWx0YSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlRGF0ZXMoZGVsdGFJbnB1dCkge1xuICAgICAgICBsZXQgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KTtcbiAgICAgICAgaWYgKGRlbHRhKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBkYXRlc0RlbHRhOiBkZWx0YSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRBbGxEYXkoYWxsRGF5LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IHN0YW5kYXJkUHJvcHMgPSB7IGFsbERheSB9O1xuICAgICAgICBsZXQgeyBtYWludGFpbkR1cmF0aW9uIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAobWFpbnRhaW5EdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBtYWludGFpbkR1cmF0aW9uID0gdGhpcy5fY29udGV4dC5vcHRpb25zLmFsbERheU1haW50YWluRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlZi5hbGxEYXkgIT09IGFsbERheSkge1xuICAgICAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBtYWludGFpbkR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubXV0YXRlKHsgc3RhbmRhcmRQcm9wcyB9KTtcbiAgICB9XG4gICAgZm9ybWF0UmFuZ2UoZm9ybWF0SW5wdXQpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIoZm9ybWF0SW5wdXQpO1xuICAgICAgICBpZiAodGhpcy5fZGVmLmhhc0VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2UoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGluc3RhbmNlLnJhbmdlLmVuZCwgZm9ybWF0dGVyLCB7XG4gICAgICAgICAgICAgICAgZm9yY2VkU3RhcnRUem86IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICAgICAgICAgIGZvcmNlZEVuZFR6bzogaW5zdGFuY2UuZm9yY2VkRW5kVHpvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0KGluc3RhbmNlLnJhbmdlLnN0YXJ0LCBmb3JtYXR0ZXIsIHtcbiAgICAgICAgICAgIGZvcmNlZFR6bzogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdXRhdGUobXV0YXRpb24pIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgbGV0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgICAgIGxldCBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgICAgIGxldCB7IGV2ZW50U3RvcmUgfSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IGdldFJlbGV2YW50RXZlbnRzKGV2ZW50U3RvcmUsIGluc3RhbmNlLmluc3RhbmNlSWQpO1xuICAgICAgICAgICAgbGV0IGV2ZW50Q29uZmlnQmFzZSA9IHtcbiAgICAgICAgICAgICAgICAnJzoge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRFZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd3M6IFtdLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJycsXG4gICAgICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJycsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM6IFtdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCBldmVudENvbmZpZ0Jhc2UsIG11dGF0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGxldCBvbGRFdmVudCA9IG5ldyBFdmVudEltcGwoY29udGV4dCwgZGVmLCBpbnN0YW5jZSk7IC8vIHNuYXBzaG90XG4gICAgICAgICAgICB0aGlzLl9kZWYgPSByZWxldmFudEV2ZW50cy5kZWZzW2RlZi5kZWZJZF07XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IHJlbGV2YW50RXZlbnRzLmluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgb2xkRXZlbnQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMocmVsZXZhbnRFdmVudHMsIGNvbnRleHQsIGluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICByZXZlcnQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFU0VUX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlLCAvLyB0aGUgT1JJR0lOQUwgc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSgpIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBsZXQgYXNTdG9yZSA9IGV2ZW50QXBpVG9TdG9yZSh0aGlzKTtcbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXG4gICAgICAgICAgICBldmVudFN0b3JlOiBhc1N0b3JlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVtb3ZlJywge1xuICAgICAgICAgICAgZXZlbnQ6IHRoaXMsXG4gICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBbXSxcbiAgICAgICAgICAgIHJldmVydCgpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGFzU3RvcmUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHNvdXJjZSgpIHtcbiAgICAgICAgbGV0IHsgc291cmNlSWQgfSA9IHRoaXMuX2RlZjtcbiAgICAgICAgaWYgKHNvdXJjZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlSW1wbCh0aGlzLl9jb250ZXh0LCB0aGlzLl9jb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTb3VyY2VzW3NvdXJjZUlkXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBzdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlID9cbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZGF0ZUVudi50b0RhdGUodGhpcy5faW5zdGFuY2UucmFuZ2Uuc3RhcnQpIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfVxuICAgIGdldCBlbmQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5faW5zdGFuY2UgJiYgdGhpcy5fZGVmLmhhc0VuZCkgP1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5lbmQpIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfVxuICAgIGdldCBzdGFydFN0cigpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZGF0ZUVudi5mb3JtYXRJc28oaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIHtcbiAgICAgICAgICAgICAgICBvbWl0VGltZTogdGhpcy5fZGVmLmFsbERheSxcbiAgICAgICAgICAgICAgICBmb3JjZWRUem86IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBnZXQgZW5kU3RyKCkge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIHRoaXMuX2RlZi5oYXNFbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmRhdGVFbnYuZm9ybWF0SXNvKGluc3RhbmNlLnJhbmdlLmVuZCwge1xuICAgICAgICAgICAgICAgIG9taXRUaW1lOiB0aGlzLl9kZWYuYWxsRGF5LFxuICAgICAgICAgICAgICAgIGZvcmNlZFR6bzogaW5zdGFuY2UuZm9yY2VkRW5kVHpvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICAvLyBjb21wdXRhYmxlIHByb3BzIHRoYXQgYWxsIGFjY2VzcyB0aGUgZGVmXG4gICAgLy8gVE9ETzogZmluZCBhIFR5cGVTY3JpcHQtY29tcGF0aWJsZSB3YXkgdG8gZG8gdGhpcyBhdCBzY2FsZVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuX2RlZi5wdWJsaWNJZDsgfVxuICAgIGdldCBncm91cElkKCkgeyByZXR1cm4gdGhpcy5fZGVmLmdyb3VwSWQ7IH1cbiAgICBnZXQgYWxsRGF5KCkgeyByZXR1cm4gdGhpcy5fZGVmLmFsbERheTsgfVxuICAgIGdldCB0aXRsZSgpIHsgcmV0dXJuIHRoaXMuX2RlZi50aXRsZTsgfVxuICAgIGdldCB1cmwoKSB7IHJldHVybiB0aGlzLl9kZWYudXJsOyB9XG4gICAgZ2V0IGRpc3BsYXkoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuZGlzcGxheSB8fCAnYXV0byc7IH0gLy8gYmFkLiBqdXN0IG5vcm1hbGl6ZSB0aGUgdHlwZSBlYXJsaWVyXG4gICAgZ2V0IHN0YXJ0RWRpdGFibGUoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuc3RhcnRFZGl0YWJsZTsgfVxuICAgIGdldCBkdXJhdGlvbkVkaXRhYmxlKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmR1cmF0aW9uRWRpdGFibGU7IH1cbiAgICBnZXQgY29uc3RyYWludCgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5jb25zdHJhaW50c1swXSB8fCBudWxsOyB9XG4gICAgZ2V0IG92ZXJsYXAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkub3ZlcmxhcDsgfVxuICAgIGdldCBhbGxvdygpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5hbGxvd3NbMF0gfHwgbnVsbDsgfVxuICAgIGdldCBiYWNrZ3JvdW5kQ29sb3IoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuYmFja2dyb3VuZENvbG9yOyB9XG4gICAgZ2V0IGJvcmRlckNvbG9yKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmJvcmRlckNvbG9yOyB9XG4gICAgZ2V0IHRleHRDb2xvcigpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS50ZXh0Q29sb3I7IH1cbiAgICAvLyBOT1RFOiB1c2VyIGNhbid0IG1vZGlmeSB0aGVzZSBiZWNhdXNlIE9iamVjdC5mcmVlemUgd2FzIGNhbGxlZCBpbiBldmVudC1kZWYgcGFyc2luZ1xuICAgIGdldCBjbGFzc05hbWVzKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmNsYXNzTmFtZXM7IH1cbiAgICBnZXQgZXh0ZW5kZWRQcm9wcygpIHsgcmV0dXJuIHRoaXMuX2RlZi5leHRlbmRlZFByb3BzOyB9XG4gICAgdG9QbGFpbk9iamVjdChzZXR0aW5ncyA9IHt9KSB7XG4gICAgICAgIGxldCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgIGxldCB7IHVpIH0gPSBkZWY7XG4gICAgICAgIGxldCB7IHN0YXJ0U3RyLCBlbmRTdHIgfSA9IHRoaXM7XG4gICAgICAgIGxldCByZXMgPSB7XG4gICAgICAgICAgICBhbGxEYXk6IGRlZi5hbGxEYXksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZWYudGl0bGUpIHtcbiAgICAgICAgICAgIHJlcy50aXRsZSA9IGRlZi50aXRsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRTdHIpIHtcbiAgICAgICAgICAgIHJlcy5zdGFydCA9IHN0YXJ0U3RyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRTdHIpIHtcbiAgICAgICAgICAgIHJlcy5lbmQgPSBlbmRTdHI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5wdWJsaWNJZCkge1xuICAgICAgICAgICAgcmVzLmlkID0gZGVmLnB1YmxpY0lkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYuZ3JvdXBJZCkge1xuICAgICAgICAgICAgcmVzLmdyb3VwSWQgPSBkZWYuZ3JvdXBJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLnVybCkge1xuICAgICAgICAgICAgcmVzLnVybCA9IGRlZi51cmw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpLmRpc3BsYXkgJiYgdWkuZGlzcGxheSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICByZXMuZGlzcGxheSA9IHVpLmRpc3BsYXk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogd2hhdCBhYm91dCByZWN1cnJpbmctZXZlbnQgcHJvcGVydGllcz8/P1xuICAgICAgICAvLyBUT0RPOiBpbmNsdWRlIHN0YXJ0RWRpdGFibGUvZHVyYXRpb25FZGl0YWJsZS9jb25zdHJhaW50L292ZXJsYXAvYWxsb3dcbiAgICAgICAgaWYgKHNldHRpbmdzLmNvbGxhcHNlQ29sb3IgJiYgdWkuYmFja2dyb3VuZENvbG9yICYmIHVpLmJhY2tncm91bmRDb2xvciA9PT0gdWkuYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgIHJlcy5jb2xvciA9IHVpLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh1aS5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICAgICAgICByZXMuYmFja2dyb3VuZENvbG9yID0gdWkuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVpLmJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgcmVzLmJvcmRlckNvbG9yID0gdWkuYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpLnRleHRDb2xvcikge1xuICAgICAgICAgICAgcmVzLnRleHRDb2xvciA9IHVpLnRleHRDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodWkuY2xhc3NOYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlcy5jbGFzc05hbWVzID0gdWkuY2xhc3NOYW1lcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGVmLmV4dGVuZGVkUHJvcHMpLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmNvbGxhcHNlRXh0ZW5kZWRQcm9wcykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzLCBkZWYuZXh0ZW5kZWRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMuZXh0ZW5kZWRQcm9wcyA9IGRlZi5leHRlbmRlZFByb3BzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9QbGFpbk9iamVjdCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV2ZW50QXBpVG9TdG9yZShldmVudEFwaSkge1xuICAgIGxldCBkZWYgPSBldmVudEFwaS5fZGVmO1xuICAgIGxldCBpbnN0YW5jZSA9IGV2ZW50QXBpLl9pbnN0YW5jZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZzOiB7IFtkZWYuZGVmSWRdOiBkZWYgfSxcbiAgICAgICAgaW5zdGFuY2VzOiBpbnN0YW5jZVxuICAgICAgICAgICAgPyB7IFtpbnN0YW5jZS5pbnN0YW5jZUlkXTogaW5zdGFuY2UgfVxuICAgICAgICAgICAgOiB7fSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudEFwaXMoZXZlbnRTdG9yZSwgY29udGV4dCwgZXhjbHVkZUluc3RhbmNlKSB7XG4gICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlO1xuICAgIGxldCBldmVudEFwaXMgPSBbXTtcbiAgICBsZXQgZXhjbHVkZUluc3RhbmNlSWQgPSBleGNsdWRlSW5zdGFuY2UgPyBleGNsdWRlSW5zdGFuY2UuaW5zdGFuY2VJZCA6ICcnO1xuICAgIGZvciAobGV0IGlkIGluIGluc3RhbmNlcykge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaWRdO1xuICAgICAgICBsZXQgZGVmID0gZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGlmIChpbnN0YW5jZS5pbnN0YW5jZUlkICE9PSBleGNsdWRlSW5zdGFuY2VJZCkge1xuICAgICAgICAgICAgZXZlbnRBcGlzLnB1c2gobmV3IEV2ZW50SW1wbChjb250ZXh0LCBkZWYsIGluc3RhbmNlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50QXBpcztcbn1cblxuLypcblNwZWNpZnlpbmcgbmV4dERheVRocmVzaG9sZCBzaWduYWxzIHRoYXQgYWxsLWRheSByYW5nZXMgc2hvdWxkIGJlIHNsaWNlZC5cbiovXG5mdW5jdGlvbiBzbGljZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBmcmFtaW5nUmFuZ2UsIG5leHREYXlUaHJlc2hvbGQpIHtcbiAgICBsZXQgaW52ZXJzZUJnQnlHcm91cElkID0ge307XG4gICAgbGV0IGludmVyc2VCZ0J5RGVmSWQgPSB7fTtcbiAgICBsZXQgZGVmQnlHcm91cElkID0ge307XG4gICAgbGV0IGJnUmFuZ2VzID0gW107XG4gICAgbGV0IGZnUmFuZ2VzID0gW107XG4gICAgbGV0IGV2ZW50VWlzID0gY29tcGlsZUV2ZW50VWlzKGV2ZW50U3RvcmUuZGVmcywgZXZlbnRVaUJhc2VzKTtcbiAgICBmb3IgKGxldCBkZWZJZCBpbiBldmVudFN0b3JlLmRlZnMpIHtcbiAgICAgICAgbGV0IGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF07XG4gICAgICAgIGxldCB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF07XG4gICAgICAgIGlmICh1aS5kaXNwbGF5ID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJykge1xuICAgICAgICAgICAgaWYgKGRlZi5ncm91cElkKSB7XG4gICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlHcm91cElkW2RlZi5ncm91cElkXSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmICghZGVmQnlHcm91cElkW2RlZi5ncm91cElkXSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZCeUdyb3VwSWRbZGVmLmdyb3VwSWRdID0gZGVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5RGVmSWRbZGVmSWRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBldmVudFN0b3JlLmluc3RhbmNlcykge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgbGV0IGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGxldCB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF07XG4gICAgICAgIGxldCBvcmlnUmFuZ2UgPSBpbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgbGV0IG5vcm1hbFJhbmdlID0gKCFkZWYuYWxsRGF5ICYmIG5leHREYXlUaHJlc2hvbGQpID9cbiAgICAgICAgICAgIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2Uob3JpZ1JhbmdlLCBuZXh0RGF5VGhyZXNob2xkKSA6XG4gICAgICAgICAgICBvcmlnUmFuZ2U7XG4gICAgICAgIGxldCBzbGljZWRSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhub3JtYWxSYW5nZSwgZnJhbWluZ1JhbmdlKTtcbiAgICAgICAgaWYgKHNsaWNlZFJhbmdlKSB7XG4gICAgICAgICAgICBpZiAodWkuZGlzcGxheSA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmLmdyb3VwSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlHcm91cElkW2RlZi5ncm91cElkXS5wdXNoKHNsaWNlZFJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5RGVmSWRbaW5zdGFuY2UuZGVmSWRdLnB1c2goc2xpY2VkUmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVpLmRpc3BsYXkgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICh1aS5kaXNwbGF5ID09PSAnYmFja2dyb3VuZCcgPyBiZ1JhbmdlcyA6IGZnUmFuZ2VzKS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZGVmLFxuICAgICAgICAgICAgICAgICAgICB1aSxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBzbGljZWRSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogbm9ybWFsUmFuZ2Uuc3RhcnQgJiYgbm9ybWFsUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSBzbGljZWRSYW5nZS5zdGFydC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBub3JtYWxSYW5nZS5lbmQgJiYgbm9ybWFsUmFuZ2UuZW5kLnZhbHVlT2YoKSA9PT0gc2xpY2VkUmFuZ2UuZW5kLnZhbHVlT2YoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBncm91cElkIGluIGludmVyc2VCZ0J5R3JvdXBJZCkgeyAvLyBCWSBHUk9VUFxuICAgICAgICBsZXQgcmFuZ2VzID0gaW52ZXJzZUJnQnlHcm91cElkW2dyb3VwSWRdO1xuICAgICAgICBsZXQgaW52ZXJ0ZWRSYW5nZXMgPSBpbnZlcnRSYW5nZXMocmFuZ2VzLCBmcmFtaW5nUmFuZ2UpO1xuICAgICAgICBmb3IgKGxldCBpbnZlcnRlZFJhbmdlIG9mIGludmVydGVkUmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgZGVmID0gZGVmQnlHcm91cElkW2dyb3VwSWRdO1xuICAgICAgICAgICAgbGV0IHVpID0gZXZlbnRVaXNbZGVmLmRlZklkXTtcbiAgICAgICAgICAgIGJnUmFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIGRlZixcbiAgICAgICAgICAgICAgICB1aSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICByYW5nZTogaW52ZXJ0ZWRSYW5nZSxcbiAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0VuZDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBkZWZJZCBpbiBpbnZlcnNlQmdCeURlZklkKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBpbnZlcnNlQmdCeURlZklkW2RlZklkXTtcbiAgICAgICAgbGV0IGludmVydGVkUmFuZ2VzID0gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgZnJhbWluZ1JhbmdlKTtcbiAgICAgICAgZm9yIChsZXQgaW52ZXJ0ZWRSYW5nZSBvZiBpbnZlcnRlZFJhbmdlcykge1xuICAgICAgICAgICAgYmdSYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGVmOiBldmVudFN0b3JlLmRlZnNbZGVmSWRdLFxuICAgICAgICAgICAgICAgIHVpOiBldmVudFVpc1tkZWZJZF0sXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IGludmVydGVkUmFuZ2UsXG4gICAgICAgICAgICAgICAgaXNTdGFydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNFbmQ6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYmc6IGJnUmFuZ2VzLCBmZzogZmdSYW5nZXMgfTtcbn1cbmZ1bmN0aW9uIGhhc0JnUmVuZGVyaW5nKGRlZikge1xuICAgIHJldHVybiBkZWYudWkuZGlzcGxheSA9PT0gJ2JhY2tncm91bmQnIHx8IGRlZi51aS5kaXNwbGF5ID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJztcbn1cbmZ1bmN0aW9uIHNldEVsU2VnKGVsLCBzZWcpIHtcbiAgICBlbC5mY1NlZyA9IHNlZztcbn1cbmZ1bmN0aW9uIGdldEVsU2VnKGVsKSB7XG4gICAgcmV0dXJuIGVsLmZjU2VnIHx8XG4gICAgICAgIGVsLnBhcmVudE5vZGUuZmNTZWcgfHwgLy8gZm9yIHRoZSBoYXJuZXNzXG4gICAgICAgIG51bGw7XG59XG4vLyBldmVudCB1aSBjb21wdXRhdGlvblxuZnVuY3Rpb24gY29tcGlsZUV2ZW50VWlzKGV2ZW50RGVmcywgZXZlbnRVaUJhc2VzKSB7XG4gICAgcmV0dXJuIG1hcEhhc2goZXZlbnREZWZzLCAoZXZlbnREZWYpID0+IGNvbXBpbGVFdmVudFVpKGV2ZW50RGVmLCBldmVudFVpQmFzZXMpKTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVFdmVudFVpKGV2ZW50RGVmLCBldmVudFVpQmFzZXMpIHtcbiAgICBsZXQgdWlzID0gW107XG4gICAgaWYgKGV2ZW50VWlCYXNlc1snJ10pIHtcbiAgICAgICAgdWlzLnB1c2goZXZlbnRVaUJhc2VzWycnXSk7XG4gICAgfVxuICAgIGlmIChldmVudFVpQmFzZXNbZXZlbnREZWYuZGVmSWRdKSB7XG4gICAgICAgIHVpcy5wdXNoKGV2ZW50VWlCYXNlc1tldmVudERlZi5kZWZJZF0pO1xuICAgIH1cbiAgICB1aXMucHVzaChldmVudERlZi51aSk7XG4gICAgcmV0dXJuIGNvbWJpbmVFdmVudFVpcyh1aXMpO1xufVxuZnVuY3Rpb24gc29ydEV2ZW50U2VncyhzZWdzLCBldmVudE9yZGVyU3BlY3MpIHtcbiAgICBsZXQgb2JqcyA9IHNlZ3MubWFwKGJ1aWxkU2VnQ29tcGFyZU9iaik7XG4gICAgb2Jqcy5zb3J0KChvYmowLCBvYmoxKSA9PiBjb21wYXJlQnlGaWVsZFNwZWNzKG9iajAsIG9iajEsIGV2ZW50T3JkZXJTcGVjcykpO1xuICAgIHJldHVybiBvYmpzLm1hcCgoYykgPT4gYy5fc2VnKTtcbn1cbi8vIHJldHVybnMgYSBvYmplY3Qgd2l0aCBhbGwgcHJpbWl0aXZlIHByb3BzIHRoYXQgY2FuIGJlIGNvbXBhcmVkXG5mdW5jdGlvbiBidWlsZFNlZ0NvbXBhcmVPYmooc2VnKSB7XG4gICAgbGV0IHsgZXZlbnRSYW5nZSB9ID0gc2VnO1xuICAgIGxldCBldmVudERlZiA9IGV2ZW50UmFuZ2UuZGVmO1xuICAgIGxldCByYW5nZSA9IGV2ZW50UmFuZ2UuaW5zdGFuY2UgPyBldmVudFJhbmdlLmluc3RhbmNlLnJhbmdlIDogZXZlbnRSYW5nZS5yYW5nZTtcbiAgICBsZXQgc3RhcnQgPSByYW5nZS5zdGFydCA/IHJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA6IDA7IC8vIFRPRE86IGJldHRlciBzdXBwb3J0IGZvciBvcGVuLXJhbmdlIGV2ZW50c1xuICAgIGxldCBlbmQgPSByYW5nZS5lbmQgPyByYW5nZS5lbmQudmFsdWVPZigpIDogMDsgLy8gXCJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50RGVmLmV4dGVuZGVkUHJvcHMpLCBldmVudERlZiksIHsgaWQ6IGV2ZW50RGVmLnB1YmxpY0lkLCBzdGFydCxcbiAgICAgICAgZW5kLCBkdXJhdGlvbjogZW5kIC0gc3RhcnQsIGFsbERheTogTnVtYmVyKGV2ZW50RGVmLmFsbERheSksIF9zZWc6IHNlZyB9KTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTZWdEcmFnZ2FibGUoc2VnLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgcGx1Z2luSG9va3MgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHRyYW5zZm9ybWVycyA9IHBsdWdpbkhvb2tzLmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzO1xuICAgIGxldCB7IGRlZiwgdWkgfSA9IHNlZy5ldmVudFJhbmdlO1xuICAgIGxldCB2YWwgPSB1aS5zdGFydEVkaXRhYmxlO1xuICAgIGZvciAobGV0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycykge1xuICAgICAgICB2YWwgPSB0cmFuc2Zvcm1lcih2YWwsIGRlZiwgdWksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlKHNlZywgY29udGV4dCkge1xuICAgIHJldHVybiBzZWcuaXNTdGFydCAmJiBzZWcuZXZlbnRSYW5nZS51aS5kdXJhdGlvbkVkaXRhYmxlICYmIGNvbnRleHQub3B0aW9ucy5ldmVudFJlc2l6YWJsZUZyb21TdGFydDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTZWdFbmRSZXNpemFibGUoc2VnLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHNlZy5pc0VuZCAmJiBzZWcuZXZlbnRSYW5nZS51aS5kdXJhdGlvbkVkaXRhYmxlO1xufVxuZnVuY3Rpb24gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIGRlZmF1bHREaXNwbGF5RXZlbnRUaW1lLCAvLyBkZWZhdWx0cyB0byB0cnVlXG5kZWZhdWx0RGlzcGxheUV2ZW50RW5kLCAvLyBkZWZhdWx0cyB0byB0cnVlXG5zdGFydE92ZXJyaWRlLCBlbmRPdmVycmlkZSkge1xuICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHsgZGlzcGxheUV2ZW50VGltZSwgZGlzcGxheUV2ZW50RW5kIH0gPSBvcHRpb25zO1xuICAgIGxldCBldmVudERlZiA9IHNlZy5ldmVudFJhbmdlLmRlZjtcbiAgICBsZXQgZXZlbnRJbnN0YW5jZSA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlO1xuICAgIGlmIChkaXNwbGF5RXZlbnRUaW1lID09IG51bGwpIHtcbiAgICAgICAgZGlzcGxheUV2ZW50VGltZSA9IGRlZmF1bHREaXNwbGF5RXZlbnRUaW1lICE9PSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXlFdmVudEVuZCA9PSBudWxsKSB7XG4gICAgICAgIGRpc3BsYXlFdmVudEVuZCA9IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgIT09IGZhbHNlO1xuICAgIH1cbiAgICBsZXQgd2hvbGVFdmVudFN0YXJ0ID0gZXZlbnRJbnN0YW5jZS5yYW5nZS5zdGFydDtcbiAgICBsZXQgd2hvbGVFdmVudEVuZCA9IGV2ZW50SW5zdGFuY2UucmFuZ2UuZW5kO1xuICAgIGxldCBzZWdTdGFydCA9IHN0YXJ0T3ZlcnJpZGUgfHwgc2VnLnN0YXJ0IHx8IHNlZy5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0O1xuICAgIGxldCBzZWdFbmQgPSBlbmRPdmVycmlkZSB8fCBzZWcuZW5kIHx8IHNlZy5ldmVudFJhbmdlLnJhbmdlLmVuZDtcbiAgICBsZXQgaXNTdGFydERheSA9IHN0YXJ0T2ZEYXkod2hvbGVFdmVudFN0YXJ0KS52YWx1ZU9mKCkgPT09IHN0YXJ0T2ZEYXkoc2VnU3RhcnQpLnZhbHVlT2YoKTtcbiAgICBsZXQgaXNFbmREYXkgPSBzdGFydE9mRGF5KGFkZE1zKHdob2xlRXZlbnRFbmQsIC0xKSkudmFsdWVPZigpID09PSBzdGFydE9mRGF5KGFkZE1zKHNlZ0VuZCwgLTEpKS52YWx1ZU9mKCk7XG4gICAgaWYgKGRpc3BsYXlFdmVudFRpbWUgJiYgIWV2ZW50RGVmLmFsbERheSAmJiAoaXNTdGFydERheSB8fCBpc0VuZERheSkpIHtcbiAgICAgICAgc2VnU3RhcnQgPSBpc1N0YXJ0RGF5ID8gd2hvbGVFdmVudFN0YXJ0IDogc2VnU3RhcnQ7XG4gICAgICAgIHNlZ0VuZCA9IGlzRW5kRGF5ID8gd2hvbGVFdmVudEVuZCA6IHNlZ0VuZDtcbiAgICAgICAgaWYgKGRpc3BsYXlFdmVudEVuZCAmJiBldmVudERlZi5oYXNFbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKHNlZ1N0YXJ0LCBzZWdFbmQsIHRpbWVGb3JtYXQsIHtcbiAgICAgICAgICAgICAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICAgICAgICAgIGZvcmNlZEVuZFR6bzogZW5kT3ZlcnJpZGUgPyBudWxsIDogZXZlbnRJbnN0YW5jZS5mb3JjZWRFbmRUem8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoc2VnU3RhcnQsIHRpbWVGb3JtYXQsIHtcbiAgICAgICAgICAgIGZvcmNlZFR6bzogc3RhcnRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLCAvLyBub29vb28sIHNhbWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlLCBub3dEYXRlKSB7XG4gICAgbGV0IHNlZ1JhbmdlID0gc2VnLmV2ZW50UmFuZ2UucmFuZ2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNQYXN0OiBzZWdSYW5nZS5lbmQgPCAobm93RGF0ZSB8fCB0b2RheVJhbmdlLnN0YXJ0KSxcbiAgICAgICAgaXNGdXR1cmU6IHNlZ1JhbmdlLnN0YXJ0ID49IChub3dEYXRlIHx8IHRvZGF5UmFuZ2UuZW5kKSxcbiAgICAgICAgaXNUb2RheTogdG9kYXlSYW5nZSAmJiByYW5nZUNvbnRhaW5zTWFya2VyKHRvZGF5UmFuZ2UsIHNlZ1JhbmdlLnN0YXJ0KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRDbGFzc05hbWVzKHByb3BzKSB7XG4gICAgbGV0IGNsYXNzTmFtZXMgPSBbJ2ZjLWV2ZW50J107XG4gICAgaWYgKHByb3BzLmlzTWlycm9yKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtbWlycm9yJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc0RyYWdnYWJsZSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWRyYWdnYWJsZScpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNTdGFydFJlc2l6YWJsZSB8fCBwcm9wcy5pc0VuZFJlc2l6YWJsZSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXJlc2l6YWJsZScpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNEcmFnZ2luZykge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWRyYWdnaW5nJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc1Jlc2l6aW5nKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtcmVzaXppbmcnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1zZWxlY3RlZCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNTdGFydCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXN0YXJ0Jyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc0VuZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWVuZCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNQYXN0KSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtcGFzdCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNUb2RheSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXRvZGF5Jyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc0Z1dHVyZSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWZ1dHVyZScpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRSYW5nZUtleShldmVudFJhbmdlKSB7XG4gICAgcmV0dXJuIGV2ZW50UmFuZ2UuaW5zdGFuY2VcbiAgICAgICAgPyBldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWRcbiAgICAgICAgOiBgJHtldmVudFJhbmdlLmRlZi5kZWZJZH06JHtldmVudFJhbmdlLnJhbmdlLnN0YXJ0LnRvSVNPU3RyaW5nKCl9YDtcbiAgICAvLyBpbnZlcnNlLWJhY2tncm91bmQgZXZlbnRzIGRvbid0IGhhdmUgc3BlY2lmaWMgaW5zdGFuY2VzLiBUT0RPOiBiZXR0ZXIgc29sdXRpb25cbn1cbmZ1bmN0aW9uIGdldFNlZ0FuY2hvckF0dHJzKHNlZywgY29udGV4dCkge1xuICAgIGxldCB7IGRlZiwgaW5zdGFuY2UgfSA9IHNlZy5ldmVudFJhbmdlO1xuICAgIGxldCB7IHVybCB9ID0gZGVmO1xuICAgIGlmICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHsgaHJlZjogdXJsIH07XG4gICAgfVxuICAgIGxldCB7IGVtaXR0ZXIsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHsgZXZlbnRJbnRlcmFjdGl2ZSB9ID0gb3B0aW9ucztcbiAgICBpZiAoZXZlbnRJbnRlcmFjdGl2ZSA9PSBudWxsKSB7XG4gICAgICAgIGV2ZW50SW50ZXJhY3RpdmUgPSBkZWYuaW50ZXJhY3RpdmU7XG4gICAgICAgIGlmIChldmVudEludGVyYWN0aXZlID09IG51bGwpIHtcbiAgICAgICAgICAgIGV2ZW50SW50ZXJhY3RpdmUgPSBCb29sZWFuKGVtaXR0ZXIuaGFzSGFuZGxlcnMoJ2V2ZW50Q2xpY2snKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbW9jayB3aGF0IGhhcHBlbnMgaW4gRXZlbnRDbGlja2luZ1xuICAgIGlmIChldmVudEludGVyYWN0aXZlKSB7XG4gICAgICAgIC8vIG9ubHkgYXR0YWNoIGtleWJvYXJkLXJlbGF0ZWQgaGFuZGxlcnMgYmVjYXVzZSBjbGljayBoYW5kbGVyIGlzIGFscmVhZHkgZG9uZSBpbiBFdmVudENsaWNraW5nXG4gICAgICAgIHJldHVybiBjcmVhdGVBcmlhS2V5Ym9hcmRBdHRycygoZXYpID0+IHtcbiAgICAgICAgICAgIGVtaXR0ZXIudHJpZ2dlcignZXZlbnRDbGljaycsIHtcbiAgICAgICAgICAgICAgICBlbDogZXYudGFyZ2V0LFxuICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIGRlZiwgaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xufVxuXG5jb25zdCBTVEFOREFSRF9QUk9QUyA9IHtcbiAgICBzdGFydDogaWRlbnRpdHksXG4gICAgZW5kOiBpZGVudGl0eSxcbiAgICBhbGxEYXk6IEJvb2xlYW4sXG59O1xuZnVuY3Rpb24gcGFyc2VEYXRlU3BhbihyYXcsIGRhdGVFbnYsIGRlZmF1bHREdXJhdGlvbikge1xuICAgIGxldCBzcGFuID0gcGFyc2VPcGVuRGF0ZVNwYW4ocmF3LCBkYXRlRW52KTtcbiAgICBsZXQgeyByYW5nZSB9ID0gc3BhbjtcbiAgICBpZiAoIXJhbmdlLnN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXJhbmdlLmVuZCkge1xuICAgICAgICBpZiAoZGVmYXVsdER1cmF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJhbmdlLmVuZCA9IGRhdGVFbnYuYWRkKHJhbmdlLnN0YXJ0LCBkZWZhdWx0RHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gc3Bhbjtcbn1cbi8qXG5UT0RPOiBzb21laG93IGNvbWJpbmUgd2l0aCBwYXJzZVJhbmdlP1xuV2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgc3RhcnQvZW5kIHByb3BzIHdlcmUgcHJlc2VudCBidXQgcGFyc2VkIGludmFsaWRseS5cbiovXG5mdW5jdGlvbiBwYXJzZU9wZW5EYXRlU3BhbihyYXcsIGRhdGVFbnYpIHtcbiAgICBsZXQgeyByZWZpbmVkOiBzdGFuZGFyZFByb3BzLCBleHRyYSB9ID0gcmVmaW5lUHJvcHMocmF3LCBTVEFOREFSRF9QUk9QUyk7XG4gICAgbGV0IHN0YXJ0TWV0YSA9IHN0YW5kYXJkUHJvcHMuc3RhcnQgPyBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoc3RhbmRhcmRQcm9wcy5zdGFydCkgOiBudWxsO1xuICAgIGxldCBlbmRNZXRhID0gc3RhbmRhcmRQcm9wcy5lbmQgPyBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoc3RhbmRhcmRQcm9wcy5lbmQpIDogbnVsbDtcbiAgICBsZXQgeyBhbGxEYXkgfSA9IHN0YW5kYXJkUHJvcHM7XG4gICAgaWYgKGFsbERheSA9PSBudWxsKSB7XG4gICAgICAgIGFsbERheSA9IChzdGFydE1ldGEgJiYgc3RhcnRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKSAmJlxuICAgICAgICAgICAgKCFlbmRNZXRhIHx8IGVuZE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHJhbmdlOiB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnRNZXRhID8gc3RhcnRNZXRhLm1hcmtlciA6IG51bGwsXG4gICAgICAgICAgICBlbmQ6IGVuZE1ldGEgPyBlbmRNZXRhLm1hcmtlciA6IG51bGwsXG4gICAgICAgIH0sIGFsbERheSB9LCBleHRyYSk7XG59XG5mdW5jdGlvbiBpc0RhdGVTcGFuc0VxdWFsKHNwYW4wLCBzcGFuMSkge1xuICAgIHJldHVybiByYW5nZXNFcXVhbChzcGFuMC5yYW5nZSwgc3BhbjEucmFuZ2UpICYmXG4gICAgICAgIHNwYW4wLmFsbERheSA9PT0gc3BhbjEuYWxsRGF5ICYmXG4gICAgICAgIGlzU3BhblByb3BzRXF1YWwoc3BhbjAsIHNwYW4xKTtcbn1cbi8vIHRoZSBOT04tREFURS1SRUxBVEVEIHByb3BzXG5mdW5jdGlvbiBpc1NwYW5Qcm9wc0VxdWFsKHNwYW4wLCBzcGFuMSkge1xuICAgIGZvciAobGV0IHByb3BOYW1lIGluIHNwYW4xKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZSAhPT0gJ3JhbmdlJyAmJiBwcm9wTmFtZSAhPT0gJ2FsbERheScpIHtcbiAgICAgICAgICAgIGlmIChzcGFuMFtwcm9wTmFtZV0gIT09IHNwYW4xW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhcmUgdGhlcmUgYW55IHByb3BzIHRoYXQgc3BhbjAgaGFzIHRoYXQgc3BhbjEgRE9FU04nVCBoYXZlP1xuICAgIC8vIGJvdGggaGF2ZSByYW5nZS9hbGxEYXksIHNvIG5vIG5lZWQgdG8gc3BlY2lhbC1jYXNlLlxuICAgIGZvciAobGV0IHByb3BOYW1lIGluIHNwYW4wKSB7XG4gICAgICAgIGlmICghKHByb3BOYW1lIGluIHNwYW4xKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYnVpbGREYXRlU3BhbkFwaShzcGFuLCBkYXRlRW52KSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGRSYW5nZUFwaShzcGFuLnJhbmdlLCBkYXRlRW52LCBzcGFuLmFsbERheSkpLCB7IGFsbERheTogc3Bhbi5hbGxEYXkgfSk7XG59XG5mdW5jdGlvbiBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lKHJhbmdlLCBkYXRlRW52LCBvbWl0VGltZSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkUmFuZ2VBcGkocmFuZ2UsIGRhdGVFbnYsIG9taXRUaW1lKSksIHsgdGltZVpvbmU6IGRhdGVFbnYudGltZVpvbmUgfSk7XG59XG5mdW5jdGlvbiBidWlsZFJhbmdlQXBpKHJhbmdlLCBkYXRlRW52LCBvbWl0VGltZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBkYXRlRW52LnRvRGF0ZShyYW5nZS5zdGFydCksXG4gICAgICAgIGVuZDogZGF0ZUVudi50b0RhdGUocmFuZ2UuZW5kKSxcbiAgICAgICAgc3RhcnRTdHI6IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLnN0YXJ0LCB7IG9taXRUaW1lIH0pLFxuICAgICAgICBlbmRTdHI6IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLmVuZCwgeyBvbWl0VGltZSB9KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZmFicmljYXRlRXZlbnRSYW5nZShkYXRlU3BhbiwgZXZlbnRVaUJhc2VzLCBjb250ZXh0KSB7XG4gICAgbGV0IHJlcyA9IHJlZmluZUV2ZW50RGVmKHsgZWRpdGFibGU6IGZhbHNlIH0sIGNvbnRleHQpO1xuICAgIGxldCBkZWYgPSBwYXJzZUV2ZW50RGVmKHJlcy5yZWZpbmVkLCByZXMuZXh0cmEsICcnLCAvLyBzb3VyY2VJZFxuICAgIGRhdGVTcGFuLmFsbERheSwgdHJ1ZSwgLy8gaGFzRW5kXG4gICAgY29udGV4dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmLFxuICAgICAgICB1aTogY29tcGlsZUV2ZW50VWkoZGVmLCBldmVudFVpQmFzZXMpLFxuICAgICAgICBpbnN0YW5jZTogY3JlYXRlRXZlbnRJbnN0YW5jZShkZWYuZGVmSWQsIGRhdGVTcGFuLnJhbmdlKSxcbiAgICAgICAgcmFuZ2U6IGRhdGVTcGFuLnJhbmdlLFxuICAgICAgICBpc1N0YXJ0OiB0cnVlLFxuICAgICAgICBpc0VuZDogdHJ1ZSxcbiAgICB9O1xufVxuXG4vKlxuZ2l2ZW4gYSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIGEgcmVzdWx0IGFzeW5jaHJvbm91c2x5LlxudGhlIGZ1bmN0aW9uIGNhbiBlaXRoZXIgY2FsbCBwYXNzZWQtaW4gc3VjY2VzcyBhbmQgZmFpbHVyZSBjYWxsYmFja3MsXG5vciBpdCBjYW4gcmV0dXJuIGEgcHJvbWlzZS5cbmlmIHlvdSBuZWVkIHRvIHBhc3MgYWRkaXRpb25hbCBwYXJhbXMgdG8gZnVuYywgYmluZCB0aGVtIGZpcnN0LlxuKi9cbmZ1bmN0aW9uIHVucHJvbWlzaWZ5KGZ1bmMsIG5vcm1hbGl6ZWRTdWNjZXNzQ2FsbGJhY2ssIG5vcm1hbGl6ZWRGYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAvLyBndWFyZCBhZ2FpbnN0IHN1Y2Nlc3MvZmFpbHVyZSBjYWxsYmFja3MgYmVpbmcgY2FsbGVkIG1vcmUgdGhhbiBvbmNlXG4gICAgLy8gYW5kIGd1YXJkIGFnYWluc3QgYSBwcm9taXNlIEFORCBjYWxsYmFjayBiZWluZyB1c2VkIHRvZ2V0aGVyLlxuICAgIGxldCBpc1Jlc29sdmVkID0gZmFsc2U7XG4gICAgbGV0IHdyYXBwZWRTdWNjZXNzID0gZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBpZiAoIWlzUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbm9ybWFsaXplZFN1Y2Nlc3NDYWxsYmFjayhyZXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgd3JhcHBlZEZhaWx1cmUgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRGYWlsdXJlQ2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgcmVzID0gZnVuYyh3cmFwcGVkU3VjY2Vzcywgd3JhcHBlZEZhaWx1cmUpO1xuICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlcy50aGVuKHdyYXBwZWRTdWNjZXNzLCB3cmFwcGVkRmFpbHVyZSk7XG4gICAgfVxufVxuXG5jbGFzcyBKc29uUmVxdWVzdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHJlc3BvbnNlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWVzdEpzb24obWV0aG9kLCB1cmwsIHBhcmFtcykge1xuICAgIG1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IGZldGNoT3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kLFxuICAgIH07XG4gICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgK1xuICAgICAgICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZmV0Y2hPcHRpb25zLmJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcyk7XG4gICAgICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzID0ge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZmV0Y2godXJsLCBmZXRjaE9wdGlvbnMpLnRoZW4oKGZldGNoUmVzKSA9PiB7XG4gICAgICAgIGlmIChmZXRjaFJlcy5vaykge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoUmVzLmpzb24oKS50aGVuKChwYXJzZWRSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBbcGFyc2VkUmVzcG9uc2UsIGZldGNoUmVzXTtcbiAgICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblJlcXVlc3RFcnJvcignRmFpbHVyZSBwYXJzaW5nIEpTT04nLCBmZXRjaFJlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBKc29uUmVxdWVzdEVycm9yKCdSZXF1ZXN0IGZhaWxlZCcsIGZldGNoUmVzKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5sZXQgY2FuVkdyb3dXaXRoaW5DZWxsO1xuZnVuY3Rpb24gZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsKCkge1xuICAgIGlmIChjYW5WR3Jvd1dpdGhpbkNlbGwgPT0gbnVsbCkge1xuICAgICAgICBjYW5WR3Jvd1dpdGhpbkNlbGwgPSBjb21wdXRlQ2FuVkdyb3dXaXRoaW5DZWxsKCk7XG4gICAgfVxuICAgIHJldHVybiBjYW5WR3Jvd1dpdGhpbkNlbGw7XG59XG5mdW5jdGlvbiBjb21wdXRlQ2FuVkdyb3dXaXRoaW5DZWxsKCkge1xuICAgIC8vIGZvciBTU1IsIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBjYWxsIGltbWVkaWF0ZWx5IGF0IHRvcC1sZXZlbFxuICAgIC8vIFRPRE86IGp1c3QgbWFrZSB0aGlzIGxvZ2ljIGV4ZWN1dGUgdG9wLWxldmVsLCBpbW1lZGlhdGVseSwgaW5zdGVhZCBvZiBkb2luZyBsYXppbHlcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGVsLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIGVsLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICBlbC5pbm5lckhUTUwgPSAnPHRhYmxlPjx0cj48dGQ+PGRpdj48L2Rpdj48L3RkPjwvdHI+PC90YWJsZT4nO1xuICAgIGVsLnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJykuc3R5bGUuaGVpZ2h0ID0gJzEwMHB4JztcbiAgICBlbC5xdWVyeVNlbGVjdG9yKCdkaXYnKS5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gICAgbGV0IGRpdiA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2RpdicpO1xuICAgIGxldCBwb3NzaWJsZSA9IGRpdi5vZmZzZXRIZWlnaHQgPiAwO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuICAgIHJldHVybiBwb3NzaWJsZTtcbn1cblxuY2xhc3MgQ2FsZW5kYXJSb290IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBmb3JQcmludDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlQmVmb3JlUHJpbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgZm9yUHJpbnQ6IHRydWUgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlQWZ0ZXJQcmludCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBmb3JQcmludDogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IHByb3BzO1xuICAgICAgICBsZXQgeyBmb3JQcmludCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgbGV0IGlzSGVpZ2h0QXV0byA9IGZvclByaW50IHx8IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy5jb250ZW50SGVpZ2h0ID09PSAnYXV0byc7XG4gICAgICAgIGxldCBoZWlnaHQgPSAoIWlzSGVpZ2h0QXV0byAmJiBvcHRpb25zLmhlaWdodCAhPSBudWxsKSA/IG9wdGlvbnMuaGVpZ2h0IDogJyc7XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgJ2ZjJyxcbiAgICAgICAgICAgIGZvclByaW50ID8gJ2ZjLW1lZGlhLXByaW50JyA6ICdmYy1tZWRpYS1zY3JlZW4nLFxuICAgICAgICAgICAgYGZjLWRpcmVjdGlvbi0ke29wdGlvbnMuZGlyZWN0aW9ufWAsXG4gICAgICAgICAgICBwcm9wcy50aGVtZS5nZXRDbGFzcygncm9vdCcpLFxuICAgICAgICBdO1xuICAgICAgICBpZiAoIWdldENhblZHcm93V2l0aGluQ2VsbCgpKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWxpcXVpZC1oYWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuKGNsYXNzTmFtZXMsIGhlaWdodCwgaXNIZWlnaHRBdXRvLCBmb3JQcmludCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBsZXQgeyBlbWl0dGVyIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBlbWl0dGVyLm9uKCdfYmVmb3JlcHJpbnQnLCB0aGlzLmhhbmRsZUJlZm9yZVByaW50KTtcbiAgICAgICAgZW1pdHRlci5vbignX2FmdGVycHJpbnQnLCB0aGlzLmhhbmRsZUFmdGVyUHJpbnQpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgbGV0IHsgZW1pdHRlciB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgZW1pdHRlci5vZmYoJ19iZWZvcmVwcmludCcsIHRoaXMuaGFuZGxlQmVmb3JlUHJpbnQpO1xuICAgICAgICBlbWl0dGVyLm9mZignX2FmdGVycHJpbnQnLCB0aGlzLmhhbmRsZUFmdGVyUHJpbnQpO1xuICAgIH1cbn1cblxuY2xhc3MgSW50ZXJhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gc2V0dGluZ3MuY29tcG9uZW50O1xuICAgICAgICB0aGlzLmlzSGl0Q29tYm9BbGxvd2VkID0gc2V0dGluZ3MuaXNIaXRDb21ib0FsbG93ZWQgfHwgbnVsbDtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUludGVyYWN0aW9uU2V0dGluZ3MoY29tcG9uZW50LCBpbnB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgZWw6IGlucHV0LmVsLFxuICAgICAgICB1c2VFdmVudENlbnRlcjogaW5wdXQudXNlRXZlbnRDZW50ZXIgIT0gbnVsbCA/IGlucHV0LnVzZUV2ZW50Q2VudGVyIDogdHJ1ZSxcbiAgICAgICAgaXNIaXRDb21ib0FsbG93ZWQ6IGlucHV0LmlzSGl0Q29tYm9BbGxvd2VkIHx8IG51bGwsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW3NldHRpbmdzLmNvbXBvbmVudC51aWRdOiBzZXR0aW5ncyxcbiAgICB9O1xufVxuLy8gZ2xvYmFsIHN0YXRlXG5jb25zdCBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUgPSB7fTtcblxuY2xhc3MgQ2FsZW5kYXJJbXBsIHtcbiAgICBnZXRDdXJyZW50RGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmdldEN1cnJlbnREYXRhKCk7XG4gICAgfVxuICAgIGRpc3BhdGNoKGFjdGlvbikge1xuICAgICAgICB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5kaXNwYXRjaChhY3Rpb24pO1xuICAgIH1cbiAgICBnZXQgdmlldygpIHsgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS52aWV3QXBpOyB9XG4gICAgYmF0Y2hSZW5kZXJpbmcoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgdXBkYXRlU2l6ZSgpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdfcmVzaXplJywgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIE9wdGlvbnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHNldE9wdGlvbihuYW1lLCB2YWwpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnU0VUX09QVElPTicsXG4gICAgICAgICAgICBvcHRpb25OYW1lOiBuYW1lLFxuICAgICAgICAgICAgcmF3T3B0aW9uVmFsdWU6IHZhbCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldE9wdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXRbbmFtZV07XG4gICAgfVxuICAgIGdldEF2YWlsYWJsZUxvY2FsZUNvZGVzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5nZXRDdXJyZW50RGF0YSgpLmF2YWlsYWJsZVJhd0xvY2FsZXMpO1xuICAgIH1cbiAgICAvLyBUcmlnZ2VyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBvbihoYW5kbGVyTmFtZSwgaGFuZGxlcikge1xuICAgICAgICBsZXQgeyBjdXJyZW50RGF0YU1hbmFnZXIgfSA9IHRoaXM7XG4gICAgICAgIGlmIChjdXJyZW50RGF0YU1hbmFnZXIuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzW2hhbmRsZXJOYW1lXSkge1xuICAgICAgICAgICAgY3VycmVudERhdGFNYW5hZ2VyLmVtaXR0ZXIub24oaGFuZGxlck5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmtub3duIGxpc3RlbmVyIG5hbWUgJyR7aGFuZGxlck5hbWV9J2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9mZihoYW5kbGVyTmFtZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5lbWl0dGVyLm9mZihoYW5kbGVyTmFtZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8vIG5vdCBtZWFudCBmb3IgcHVibGljIHVzZVxuICAgIHRyaWdnZXIoaGFuZGxlck5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIuZW1pdHRlci50cmlnZ2VyKGhhbmRsZXJOYW1lLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLy8gVmlld1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY2hhbmdlVmlldyh2aWV3VHlwZSwgZGF0ZU9yUmFuZ2UpIHtcbiAgICAgICAgdGhpcy5iYXRjaFJlbmRlcmluZygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICBpZiAoZGF0ZU9yUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZU9yUmFuZ2Uuc3RhcnQgJiYgZGF0ZU9yUmFuZ2UuZW5kKSB7IC8vIGEgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFVF9PUFRJT04nLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uTmFtZTogJ3Zpc2libGVSYW5nZScsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdPcHRpb25WYWx1ZTogZGF0ZU9yUmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZU1hcmtlcjogZGF0ZUVudi5jcmVhdGVNYXJrZXIoZGF0ZU9yUmFuZ2UpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxuICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEZvcmNlcyBuYXZpZ2F0aW9uIHRvIGEgdmlldyBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gICAgLy8gYHZpZXdUeXBlYCBjYW4gYmUgYSBzcGVjaWZpYyB2aWV3IG5hbWUgb3IgYSBnZW5lcmljIG9uZSBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCIuXG4gICAgLy8gbmVlZHMgdG8gY2hhbmdlXG4gICAgem9vbVRvKGRhdGVNYXJrZXIsIHZpZXdUeXBlKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgbGV0IHNwZWM7XG4gICAgICAgIHZpZXdUeXBlID0gdmlld1R5cGUgfHwgJ2RheSc7IC8vIGRheSBpcyBkZWZhdWx0IHpvb21cbiAgICAgICAgc3BlYyA9IHN0YXRlLnZpZXdTcGVjc1t2aWV3VHlwZV0gfHwgdGhpcy5nZXRVbml0Vmlld1NwZWModmlld1R5cGUpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIGlmIChzcGVjKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgdmlld1R5cGU6IHNwZWMudHlwZSxcbiAgICAgICAgICAgICAgICBkYXRlTWFya2VyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHaXZlbiBhIGR1cmF0aW9uIHNpbmd1bGFyIHVuaXQsIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIiwgZmluZHMgYSBtYXRjaGluZyB2aWV3IHNwZWMuXG4gICAgLy8gUHJlZmVyZW5jZSBpcyBnaXZlbiB0byB2aWV3cyB0aGF0IGhhdmUgY29ycmVzcG9uZGluZyBidXR0b25zLlxuICAgIGdldFVuaXRWaWV3U3BlYyh1bml0KSB7XG4gICAgICAgIGxldCB7IHZpZXdTcGVjcywgdG9vbGJhckNvbmZpZyB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgdmlld1R5cGVzID0gW10uY29uY2F0KHRvb2xiYXJDb25maWcuaGVhZGVyID8gdG9vbGJhckNvbmZpZy5oZWFkZXIudmlld3NXaXRoQnV0dG9ucyA6IFtdLCB0b29sYmFyQ29uZmlnLmZvb3RlciA/IHRvb2xiYXJDb25maWcuZm9vdGVyLnZpZXdzV2l0aEJ1dHRvbnMgOiBbXSk7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgc3BlYztcbiAgICAgICAgZm9yIChsZXQgdmlld1R5cGUgaW4gdmlld1NwZWNzKSB7XG4gICAgICAgICAgICB2aWV3VHlwZXMucHVzaCh2aWV3VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZpZXdUeXBlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgc3BlYyA9IHZpZXdTcGVjc1t2aWV3VHlwZXNbaV1dO1xuICAgICAgICAgICAgaWYgKHNwZWMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BlYy5zaW5nbGVVbml0ID09PSB1bml0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gQ3VycmVudCBEYXRlXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBwcmV2KCkge1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUFJFVicgfSk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdORVhUJyB9KTtcbiAgICB9XG4gICAgcHJldlllYXIoKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICBkYXRlTWFya2VyOiBzdGF0ZS5kYXRlRW52LmFkZFllYXJzKHN0YXRlLmN1cnJlbnREYXRlLCAtMSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZXh0WWVhcigpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkWWVhcnMoc3RhdGUuY3VycmVudERhdGUsIDEpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9kYXkoKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICBkYXRlTWFya2VyOiBnZXROb3coc3RhdGUuY2FsZW5kYXJPcHRpb25zLm5vdywgc3RhdGUuZGF0ZUVudiksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnb3RvRGF0ZSh6b25lZERhdGVJbnB1dCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5jcmVhdGVNYXJrZXIoem9uZWREYXRlSW5wdXQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5jcmVtZW50RGF0ZShkZWx0YUlucHV0KSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgbGV0IGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBlbHNlLCB3YXJuIGFib3V0IGludmFsaWQgaW5wdXQ/XG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkKHN0YXRlLmN1cnJlbnREYXRlLCBkZWx0YSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREYXRlKCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZS5kYXRlRW52LnRvRGF0ZShzdGF0ZS5jdXJyZW50RGF0ZSk7XG4gICAgfVxuICAgIC8vIERhdGUgRm9ybWF0dGluZyBVdGlsc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZm9ybWF0RGF0ZShkLCBmb3JtYXR0ZXIpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoZGF0ZUVudi5jcmVhdGVNYXJrZXIoZCksIGNyZWF0ZUZvcm1hdHRlcihmb3JtYXR0ZXIpKTtcbiAgICB9XG4gICAgLy8gYHNldHRpbmdzYCBpcyBmb3IgZm9ybWF0dGVyIEFORCBpc0VuZEV4Y2x1c2l2ZVxuICAgIGZvcm1hdFJhbmdlKGQwLCBkMSwgc2V0dGluZ3MpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShkYXRlRW52LmNyZWF0ZU1hcmtlcihkMCksIGRhdGVFbnYuY3JlYXRlTWFya2VyKGQxKSwgY3JlYXRlRm9ybWF0dGVyKHNldHRpbmdzKSwgc2V0dGluZ3MpO1xuICAgIH1cbiAgICBmb3JtYXRJc28oZCwgb21pdFRpbWUpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRJc28oZGF0ZUVudi5jcmVhdGVNYXJrZXIoZCksIHsgb21pdFRpbWUgfSk7XG4gICAgfVxuICAgIC8vIERhdGUgU2VsZWN0aW9uIC8gRXZlbnQgU2VsZWN0aW9uIC8gRGF5Q2xpY2tcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHNlbGVjdChkYXRlT3JPYmosIGVuZERhdGUpIHtcbiAgICAgICAgbGV0IHNlbGVjdGlvbklucHV0O1xuICAgICAgICBpZiAoZW5kRGF0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZGF0ZU9yT2JqLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25JbnB1dCA9IGRhdGVPck9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbklucHV0ID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogZGF0ZU9yT2JqLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbklucHV0ID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlT3JPYmosXG4gICAgICAgICAgICAgICAgZW5kOiBlbmREYXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBwYXJzZURhdGVTcGFuKHNlbGVjdGlvbklucHV0LCBzdGF0ZS5kYXRlRW52LCBjcmVhdGVEdXJhdGlvbih7IGRheXM6IDEgfSkpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7IC8vIHRocm93IHBhcnNlIGVycm9yIG90aGVyd2lzZT9cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnU0VMRUNUX0RBVEVTJywgc2VsZWN0aW9uIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckRhdGVTZWxlY3Qoc2VsZWN0aW9uLCBudWxsLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zZWxlY3QocGV2KSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgaWYgKHN0YXRlLmRhdGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfREFURVMnIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckRhdGVVbnNlbGVjdChwZXYsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQdWJsaWMgRXZlbnRzIEFQSVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYWRkRXZlbnQoZXZlbnRJbnB1dCwgc291cmNlSW5wdXQpIHtcbiAgICAgICAgaWYgKGV2ZW50SW5wdXQgaW5zdGFuY2VvZiBFdmVudEltcGwpIHtcbiAgICAgICAgICAgIGxldCBkZWYgPSBldmVudElucHV0Ll9kZWY7XG4gICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBldmVudElucHV0Ll9pbnN0YW5jZTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50RGF0YSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgICAgIC8vIG5vdCBhbHJlYWR5IHByZXNlbnQ/IGRvbid0IHdhbnQgdG8gYWRkIGFuIG9sZCBzbmFwc2hvdFxuICAgICAgICAgICAgaWYgKCFjdXJyZW50RGF0YS5ldmVudFN0b3JlLmRlZnNbZGVmLmRlZklkXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQUREX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50VHVwbGVUb1N0b3JlKHsgZGVmLCBpbnN0YW5jZSB9KSwgLy8gVE9ETzogYmV0dGVyIHV0aWwgZm9yIHR3byBhcmdzP1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50QWRkKGV2ZW50SW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50SW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgZXZlbnRTb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2VJbnB1dCBpbnN0YW5jZW9mIEV2ZW50U291cmNlSW1wbCkge1xuICAgICAgICAgICAgZXZlbnRTb3VyY2UgPSBzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2VJbnB1dCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlSW5wdXQpIHsgLy8gdHJ1ZS4gcGFydCBvZiB0aGUgZmlyc3QgZXZlbnQgc291cmNlXG4gICAgICAgICAgICAgICAgW2V2ZW50U291cmNlXSA9IGhhc2hWYWx1ZXNUb0FycmF5KHN0YXRlLmV2ZW50U291cmNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc291cmNlSW5wdXQgIT0gbnVsbCkgeyAvLyBhbiBJRC4gYWNjZXB0cyBhIG51bWJlciB0b29cbiAgICAgICAgICAgIGxldCBzb3VyY2VBcGkgPSB0aGlzLmdldEV2ZW50U291cmNlQnlJZChzb3VyY2VJbnB1dCk7IC8vIFRPRE86IHVzZSBhbiBpbnRlcm5hbCBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKCFzb3VyY2VBcGkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIGFuIGV2ZW50IHNvdXJjZSB3aXRoIElEIFwiJHtzb3VyY2VJbnB1dH1cImApOyAvLyBUT0RPOiB0ZXN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudFNvdXJjZSA9IHNvdXJjZUFwaS5pbnRlcm5hbEV2ZW50U291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0dXBsZSA9IHBhcnNlRXZlbnQoZXZlbnRJbnB1dCwgZXZlbnRTb3VyY2UsIHN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmICh0dXBsZSkge1xuICAgICAgICAgICAgbGV0IG5ld0V2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChzdGF0ZSwgdHVwbGUuZGVmLCB0dXBsZS5kZWYucmVjdXJyaW5nRGVmID8gbnVsbCA6IHR1cGxlLmluc3RhbmNlKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdBRERfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudFR1cGxlVG9TdG9yZSh0dXBsZSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50QWRkKG5ld0V2ZW50QXBpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdFdmVudEFwaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJpZ2dlckV2ZW50QWRkKGV2ZW50QXBpKSB7XG4gICAgICAgIGxldCB7IGVtaXR0ZXIgfSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdldmVudEFkZCcsIHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudEFwaSxcbiAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IFtdLFxuICAgICAgICAgICAgcmV2ZXJ0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRBcGlUb1N0b3JlKGV2ZW50QXBpKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUT0RPOiBvcHRpbWl6ZVxuICAgIGdldEV2ZW50QnlJZChpZCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gc3RhdGUuZXZlbnRTdG9yZTtcbiAgICAgICAgaWQgPSBTdHJpbmcoaWQpO1xuICAgICAgICBmb3IgKGxldCBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgICAgICBsZXQgZGVmID0gZGVmc1tkZWZJZF07XG4gICAgICAgICAgICBpZiAoZGVmLnB1YmxpY0lkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRJbXBsKHN0YXRlLCBkZWYsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5kZWZJZCA9PT0gZGVmLmRlZklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50SW1wbChzdGF0ZSwgZGVmLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldEV2ZW50cygpIHtcbiAgICAgICAgbGV0IGN1cnJlbnREYXRhID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gYnVpbGRFdmVudEFwaXMoY3VycmVudERhdGEuZXZlbnRTdG9yZSwgY3VycmVudERhdGEpO1xuICAgIH1cbiAgICByZW1vdmVBbGxFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUkVNT1ZFX0FMTF9FVkVOVFMnIH0pO1xuICAgIH1cbiAgICAvLyBQdWJsaWMgRXZlbnQgU291cmNlcyBBUElcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGdldEV2ZW50U291cmNlcygpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgc291cmNlSGFzaCA9IHN0YXRlLmV2ZW50U291cmNlcztcbiAgICAgICAgbGV0IHNvdXJjZUFwaXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW50ZXJuYWxJZCBpbiBzb3VyY2VIYXNoKSB7XG4gICAgICAgICAgICBzb3VyY2VBcGlzLnB1c2gobmV3IEV2ZW50U291cmNlSW1wbChzdGF0ZSwgc291cmNlSGFzaFtpbnRlcm5hbElkXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2VBcGlzO1xuICAgIH1cbiAgICBnZXRFdmVudFNvdXJjZUJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgc291cmNlSGFzaCA9IHN0YXRlLmV2ZW50U291cmNlcztcbiAgICAgICAgaWQgPSBTdHJpbmcoaWQpO1xuICAgICAgICBmb3IgKGxldCBzb3VyY2VJZCBpbiBzb3VyY2VIYXNoKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlSGFzaFtzb3VyY2VJZF0ucHVibGljSWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUltcGwoc3RhdGUsIHNvdXJjZUhhc2hbc291cmNlSWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYWRkRXZlbnRTb3VyY2Uoc291cmNlSW5wdXQpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBpZiAoc291cmNlSW5wdXQgaW5zdGFuY2VvZiBFdmVudFNvdXJjZUltcGwpIHtcbiAgICAgICAgICAgIC8vIG5vdCBhbHJlYWR5IHByZXNlbnQ/IGRvbid0IHdhbnQgdG8gYWRkIGFuIG9sZCBzbmFwc2hvdFxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5ldmVudFNvdXJjZXNbc291cmNlSW5wdXQuaW50ZXJuYWxFdmVudFNvdXJjZS5zb3VyY2VJZF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0FERF9FVkVOVF9TT1VSQ0VTJyxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlczogW3NvdXJjZUlucHV0LmludGVybmFsRXZlbnRTb3VyY2VdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZUlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBldmVudFNvdXJjZSA9IHBhcnNlRXZlbnRTb3VyY2Uoc291cmNlSW5wdXQsIHN0YXRlKTtcbiAgICAgICAgaWYgKGV2ZW50U291cmNlKSB7IC8vIFRPRE86IGVycm9yIG90aGVyd2lzZT9cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnQUREX0VWRU5UX1NPVVJDRVMnLCBzb3VyY2VzOiBbZXZlbnRTb3VyY2VdIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUltcGwoc3RhdGUsIGV2ZW50U291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmVtb3ZlQWxsRXZlbnRTb3VyY2VzKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUycgfSk7XG4gICAgfVxuICAgIHJlZmV0Y2hFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnRkVUQ0hfRVZFTlRfU09VUkNFUycsIGlzUmVmZXRjaDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLy8gU2Nyb2xsXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBzY3JvbGxUb1RpbWUodGltZUlucHV0KSB7XG4gICAgICAgIGxldCB0aW1lID0gY3JlYXRlRHVyYXRpb24odGltZUlucHV0KTtcbiAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignX3Njcm9sbFJlcXVlc3QnLCB7IHRpbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBvaW50SW5zaWRlUmVjdChwb2ludCwgcmVjdCkge1xuICAgIHJldHVybiBwb2ludC5sZWZ0ID49IHJlY3QubGVmdCAmJlxuICAgICAgICBwb2ludC5sZWZ0IDwgcmVjdC5yaWdodCAmJlxuICAgICAgICBwb2ludC50b3AgPj0gcmVjdC50b3AgJiZcbiAgICAgICAgcG9pbnQudG9wIDwgcmVjdC5ib3R0b207XG59XG4vLyBSZXR1cm5zIGEgbmV3IHJlY3RhbmdsZSB0aGF0IGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byByZWN0YW5nbGVzLiBJZiB0aGV5IGRvbid0IGludGVyc2VjdCwgcmV0dXJucyBmYWxzZVxuZnVuY3Rpb24gaW50ZXJzZWN0UmVjdHMocmVjdDEsIHJlY3QyKSB7XG4gICAgbGV0IHJlcyA9IHtcbiAgICAgICAgbGVmdDogTWF0aC5tYXgocmVjdDEubGVmdCwgcmVjdDIubGVmdCksXG4gICAgICAgIHJpZ2h0OiBNYXRoLm1pbihyZWN0MS5yaWdodCwgcmVjdDIucmlnaHQpLFxuICAgICAgICB0b3A6IE1hdGgubWF4KHJlY3QxLnRvcCwgcmVjdDIudG9wKSxcbiAgICAgICAgYm90dG9tOiBNYXRoLm1pbihyZWN0MS5ib3R0b20sIHJlY3QyLmJvdHRvbSksXG4gICAgfTtcbiAgICBpZiAocmVzLmxlZnQgPCByZXMucmlnaHQgJiYgcmVzLnRvcCA8IHJlcy5ib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdHJhbnNsYXRlUmVjdChyZWN0LCBkZWx0YVgsIGRlbHRhWSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIGRlbHRhWCxcbiAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgKyBkZWx0YVgsXG4gICAgICAgIHRvcDogcmVjdC50b3AgKyBkZWx0YVksXG4gICAgICAgIGJvdHRvbTogcmVjdC5ib3R0b20gKyBkZWx0YVksXG4gICAgfTtcbn1cbi8vIFJldHVybnMgYSBuZXcgcG9pbnQgdGhhdCB3aWxsIGhhdmUgYmVlbiBtb3ZlZCB0byByZXNpZGUgd2l0aGluIHRoZSBnaXZlbiByZWN0YW5nbGVcbmZ1bmN0aW9uIGNvbnN0cmFpblBvaW50KHBvaW50LCByZWN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQubGVmdCwgcmVjdC5sZWZ0KSwgcmVjdC5yaWdodCksXG4gICAgICAgIHRvcDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQudG9wLCByZWN0LnRvcCksIHJlY3QuYm90dG9tKSxcbiAgICB9O1xufVxuLy8gUmV0dXJucyBhIHBvaW50IHRoYXQgaXMgdGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlXG5mdW5jdGlvbiBnZXRSZWN0Q2VudGVyKHJlY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLFxuICAgICAgICB0b3A6IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDIsXG4gICAgfTtcbn1cbi8vIFN1YnRyYWN0cyBwb2ludDIncyBjb29yZGluYXRlcyBmcm9tIHBvaW50MSdzIGNvb3JkaW5hdGVzLCByZXR1cm5pbmcgYSBkZWx0YVxuZnVuY3Rpb24gZGlmZlBvaW50cyhwb2ludDEsIHBvaW50Mikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHBvaW50MS5sZWZ0IC0gcG9pbnQyLmxlZnQsXG4gICAgICAgIHRvcDogcG9pbnQxLnRvcCAtIHBvaW50Mi50b3AsXG4gICAgfTtcbn1cblxuY29uc3QgRU1QVFlfRVZFTlRfU1RPUkUgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTsgLy8gZm9yIHB1cmVjb21wb25lbnRzLiBUT0RPOiBrZWVwIGVsc2V3aGVyZVxuY2xhc3MgU3BsaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmdldEtleXNGb3JFdmVudERlZnMgPSBtZW1vaXplKHRoaXMuX2dldEtleXNGb3JFdmVudERlZnMpO1xuICAgICAgICB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvbiA9IG1lbW9pemUodGhpcy5fc3BsaXREYXRlU3Bhbik7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudFN0b3JlID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEV2ZW50U3RvcmUpO1xuICAgICAgICB0aGlzLnNwbGl0SW5kaXZpZHVhbFVpID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEluZGl2aWR1YWxVaSk7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudERyYWcgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW50ZXJhY3Rpb24pO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnRSZXNpemUgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW50ZXJhY3Rpb24pO1xuICAgICAgICB0aGlzLmV2ZW50VWlCdWlsZGVycyA9IHt9OyAvLyBUT0RPOiB0eXBlc2NyaXB0IHByb3RlY3Rpb25cbiAgICB9XG4gICAgc3BsaXRQcm9wcyhwcm9wcykge1xuICAgICAgICBsZXQga2V5SW5mb3MgPSB0aGlzLmdldEtleUluZm8ocHJvcHMpO1xuICAgICAgICBsZXQgZGVmS2V5cyA9IHRoaXMuZ2V0S2V5c0ZvckV2ZW50RGVmcyhwcm9wcy5ldmVudFN0b3JlKTtcbiAgICAgICAgbGV0IGRhdGVTZWxlY3Rpb25zID0gdGhpcy5zcGxpdERhdGVTZWxlY3Rpb24ocHJvcHMuZGF0ZVNlbGVjdGlvbik7XG4gICAgICAgIGxldCBpbmRpdmlkdWFsVWkgPSB0aGlzLnNwbGl0SW5kaXZpZHVhbFVpKHByb3BzLmV2ZW50VWlCYXNlcywgZGVmS2V5cyk7IC8vIHRoZSBpbmRpdmlkdWFsICpiYXNlcypcbiAgICAgICAgbGV0IGV2ZW50U3RvcmVzID0gdGhpcy5zcGxpdEV2ZW50U3RvcmUocHJvcHMuZXZlbnRTdG9yZSwgZGVmS2V5cyk7XG4gICAgICAgIGxldCBldmVudERyYWdzID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcpO1xuICAgICAgICBsZXQgZXZlbnRSZXNpemVzID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplKTtcbiAgICAgICAgbGV0IHNwbGl0UHJvcHMgPSB7fTtcbiAgICAgICAgdGhpcy5ldmVudFVpQnVpbGRlcnMgPSBtYXBIYXNoKGtleUluZm9zLCAoaW5mbywga2V5KSA9PiB0aGlzLmV2ZW50VWlCdWlsZGVyc1trZXldIHx8IG1lbW9pemUoYnVpbGRFdmVudFVpRm9yS2V5KSk7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBrZXlJbmZvcykge1xuICAgICAgICAgICAgbGV0IGtleUluZm8gPSBrZXlJbmZvc1trZXldO1xuICAgICAgICAgICAgbGV0IGV2ZW50U3RvcmUgPSBldmVudFN0b3Jlc1trZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFO1xuICAgICAgICAgICAgbGV0IGJ1aWxkRXZlbnRVaSA9IHRoaXMuZXZlbnRVaUJ1aWxkZXJzW2tleV07XG4gICAgICAgICAgICBzcGxpdFByb3BzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgYnVzaW5lc3NIb3Vyczoga2V5SW5mby5idXNpbmVzc0hvdXJzIHx8IHByb3BzLmJ1c2luZXNzSG91cnMsXG4gICAgICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogZGF0ZVNlbGVjdGlvbnNba2V5XSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmUsXG4gICAgICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiBidWlsZEV2ZW50VWkocHJvcHMuZXZlbnRVaUJhc2VzWycnXSwga2V5SW5mby51aSwgaW5kaXZpZHVhbFVpW2tleV0pLFxuICAgICAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBldmVudFN0b3JlLmluc3RhbmNlc1twcm9wcy5ldmVudFNlbGVjdGlvbl0gPyBwcm9wcy5ldmVudFNlbGVjdGlvbiA6ICcnLFxuICAgICAgICAgICAgICAgIGV2ZW50RHJhZzogZXZlbnREcmFnc1trZXldIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplc1trZXldIHx8IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdFByb3BzO1xuICAgIH1cbiAgICBfc3BsaXREYXRlU3BhbihkYXRlU3Bhbikge1xuICAgICAgICBsZXQgZGF0ZVNwYW5zID0ge307XG4gICAgICAgIGlmIChkYXRlU3Bhbikge1xuICAgICAgICAgICAgbGV0IGtleXMgPSB0aGlzLmdldEtleXNGb3JEYXRlU3BhbihkYXRlU3Bhbik7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuICAgICAgICAgICAgICAgIGRhdGVTcGFuc1trZXldID0gZGF0ZVNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVTcGFucztcbiAgICB9XG4gICAgX2dldEtleXNGb3JFdmVudERlZnMoZXZlbnRTdG9yZSkge1xuICAgICAgICByZXR1cm4gbWFwSGFzaChldmVudFN0b3JlLmRlZnMsIChldmVudERlZikgPT4gdGhpcy5nZXRLZXlzRm9yRXZlbnREZWYoZXZlbnREZWYpKTtcbiAgICB9XG4gICAgX3NwbGl0RXZlbnRTdG9yZShldmVudFN0b3JlLCBkZWZLZXlzKSB7XG4gICAgICAgIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gZXZlbnRTdG9yZTtcbiAgICAgICAgbGV0IHNwbGl0U3RvcmVzID0ge307XG4gICAgICAgIGZvciAobGV0IGRlZklkIGluIGRlZnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBkZWZLZXlzW2RlZklkXSkge1xuICAgICAgICAgICAgICAgIGlmICghc3BsaXRTdG9yZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBzcGxpdFN0b3Jlc1trZXldID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0uZGVmc1tkZWZJZF0gPSBkZWZzW2RlZklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIGRlZktleXNbaW5zdGFuY2UuZGVmSWRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0U3RvcmVzW2tleV0pIHsgLy8gbXVzdCBoYXZlIGFscmVhZHkgYmVlbiBjcmVhdGVkXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0uaW5zdGFuY2VzW2luc3RhbmNlSWRdID0gaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdFN0b3JlcztcbiAgICB9XG4gICAgX3NwbGl0SW5kaXZpZHVhbFVpKGV2ZW50VWlCYXNlcywgZGVmS2V5cykge1xuICAgICAgICBsZXQgc3BsaXRIYXNoZXMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnRVaUJhc2VzKSB7XG4gICAgICAgICAgICBpZiAoZGVmSWQpIHsgLy8gbm90IHRoZSAnJyBrZXlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgb2YgZGVmS2V5c1tkZWZJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzcGxpdEhhc2hlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpdEhhc2hlc1trZXldID0ge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3BsaXRIYXNoZXNba2V5XVtkZWZJZF0gPSBldmVudFVpQmFzZXNbZGVmSWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXRIYXNoZXM7XG4gICAgfVxuICAgIF9zcGxpdEludGVyYWN0aW9uKGludGVyYWN0aW9uKSB7XG4gICAgICAgIGxldCBzcGxpdFN0YXRlcyA9IHt9O1xuICAgICAgICBpZiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBhZmZlY3RlZFN0b3JlcyA9IHRoaXMuX3NwbGl0RXZlbnRTdG9yZShpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cywgdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cykpO1xuICAgICAgICAgICAgLy8gY2FuJ3QgcmVseSBvbiBkZWZLZXlzIGJlY2F1c2UgZXZlbnQgZGF0YSBpcyBtdXRhdGVkXG4gICAgICAgICAgICBsZXQgbXV0YXRlZEtleXNCeURlZklkID0gdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzKTtcbiAgICAgICAgICAgIGxldCBtdXRhdGVkU3RvcmVzID0gdGhpcy5fc3BsaXRFdmVudFN0b3JlKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMsIG11dGF0ZWRLZXlzQnlEZWZJZCk7XG4gICAgICAgICAgICBsZXQgcG9wdWxhdGUgPSAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzcGxpdFN0YXRlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0U3RhdGVzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogYWZmZWN0ZWRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IG11dGF0ZWRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRXZlbnQ6IGludGVyYWN0aW9uLmlzRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBhZmZlY3RlZFN0b3Jlcykge1xuICAgICAgICAgICAgICAgIHBvcHVsYXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gbXV0YXRlZFN0b3Jlcykge1xuICAgICAgICAgICAgICAgIHBvcHVsYXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0U3RhdGVzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUZvcktleShhbGxVaSwgZXZlbnRVaUZvcktleSwgaW5kaXZpZHVhbFVpKSB7XG4gICAgbGV0IGJhc2VQYXJ0cyA9IFtdO1xuICAgIGlmIChhbGxVaSkge1xuICAgICAgICBiYXNlUGFydHMucHVzaChhbGxVaSk7XG4gICAgfVxuICAgIGlmIChldmVudFVpRm9yS2V5KSB7XG4gICAgICAgIGJhc2VQYXJ0cy5wdXNoKGV2ZW50VWlGb3JLZXkpO1xuICAgIH1cbiAgICBsZXQgc3R1ZmYgPSB7XG4gICAgICAgICcnOiBjb21iaW5lRXZlbnRVaXMoYmFzZVBhcnRzKSxcbiAgICB9O1xuICAgIGlmIChpbmRpdmlkdWFsVWkpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdHVmZiwgaW5kaXZpZHVhbFVpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0dWZmO1xufVxuXG5mdW5jdGlvbiBnZXREYXRlTWV0YShkYXRlLCB0b2RheVJhbmdlLCBub3dEYXRlLCBkYXRlUHJvZmlsZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRvdzogZGF0ZS5nZXRVVENEYXkoKSxcbiAgICAgICAgaXNEaXNhYmxlZDogQm9vbGVhbihkYXRlUHJvZmlsZSAmJiAhcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgZGF0ZSkpLFxuICAgICAgICBpc090aGVyOiBCb29sZWFuKGRhdGVQcm9maWxlICYmICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgZGF0ZSkpLFxuICAgICAgICBpc1RvZGF5OiBCb29sZWFuKHRvZGF5UmFuZ2UgJiYgcmFuZ2VDb250YWluc01hcmtlcih0b2RheVJhbmdlLCBkYXRlKSksXG4gICAgICAgIGlzUGFzdDogQm9vbGVhbihub3dEYXRlID8gKGRhdGUgPCBub3dEYXRlKSA6IHRvZGF5UmFuZ2UgPyAoZGF0ZSA8IHRvZGF5UmFuZ2Uuc3RhcnQpIDogZmFsc2UpLFxuICAgICAgICBpc0Z1dHVyZTogQm9vbGVhbihub3dEYXRlID8gKGRhdGUgPiBub3dEYXRlKSA6IHRvZGF5UmFuZ2UgPyAoZGF0ZSA+PSB0b2RheVJhbmdlLmVuZCkgOiBmYWxzZSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldERheUNsYXNzTmFtZXMobWV0YSwgdGhlbWUpIHtcbiAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgJ2ZjLWRheScsXG4gICAgICAgIGBmYy1kYXktJHtEQVlfSURTW21ldGEuZG93XX1gLFxuICAgIF07XG4gICAgaWYgKG1ldGEuaXNEaXNhYmxlZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1kaXNhYmxlZCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG1ldGEuaXNUb2RheSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktdG9kYXknKTtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCh0aGVtZS5nZXRDbGFzcygndG9kYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNQYXN0KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1wYXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNGdXR1cmUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LWZ1dHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmlzT3RoZXIpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LW90aGVyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiBnZXRTbG90Q2xhc3NOYW1lcyhtZXRhLCB0aGVtZSkge1xuICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtc2xvdCcsXG4gICAgICAgIGBmYy1zbG90LSR7REFZX0lEU1ttZXRhLmRvd119YCxcbiAgICBdO1xuICAgIGlmIChtZXRhLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zbG90LWRpc2FibGVkJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobWV0YS5pc1RvZGF5KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtdG9kYXknKTtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCh0aGVtZS5nZXRDbGFzcygndG9kYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNQYXN0KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtcGFzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmlzRnV0dXJlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtZnV0dXJlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5cbmNvbnN0IERBWV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH0pO1xuY29uc3QgV0VFS19GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnbG9uZycgfSk7XG5mdW5jdGlvbiBidWlsZE5hdkxpbmtBdHRycyhjb250ZXh0LCBkYXRlTWFya2VyLCB2aWV3VHlwZSA9ICdkYXknLCBpc1RhYmJhYmxlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgZGF0ZUVudiwgb3B0aW9ucywgY2FsZW5kYXJBcGkgfSA9IGNvbnRleHQ7XG4gICAgbGV0IGRhdGVTdHIgPSBkYXRlRW52LmZvcm1hdChkYXRlTWFya2VyLCB2aWV3VHlwZSA9PT0gJ3dlZWsnID8gV0VFS19GT1JNQVQgOiBEQVlfRk9STUFUKTtcbiAgICBpZiAob3B0aW9ucy5uYXZMaW5rcykge1xuICAgICAgICBsZXQgem9uZWREYXRlID0gZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlcik7XG4gICAgICAgIGNvbnN0IGhhbmRsZUludGVyYWN0aW9uID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgY3VzdG9tQWN0aW9uID0gdmlld1R5cGUgPT09ICdkYXknID8gb3B0aW9ucy5uYXZMaW5rRGF5Q2xpY2sgOlxuICAgICAgICAgICAgICAgIHZpZXdUeXBlID09PSAnd2VlaycgPyBvcHRpb25zLm5hdkxpbmtXZWVrQ2xpY2sgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjdXN0b21BY3Rpb24uY2FsbChjYWxlbmRhckFwaSwgZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlciksIGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSA9IGN1c3RvbUFjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJBcGkuem9vbVRvKGRhdGVNYXJrZXIsIHZpZXdUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB0aXRsZTogZm9ybWF0V2l0aE9yZGluYWxzKG9wdGlvbnMubmF2TGlua0hpbnQsIFtkYXRlU3RyLCB6b25lZERhdGVdLCBkYXRlU3RyKSwgJ2RhdGEtbmF2bGluayc6ICcnIH0sIChpc1RhYmJhYmxlXG4gICAgICAgICAgICA/IGNyZWF0ZUFyaWFDbGlja0F0dHJzKGhhbmRsZUludGVyYWN0aW9uKVxuICAgICAgICAgICAgOiB7IG9uQ2xpY2s6IGhhbmRsZUludGVyYWN0aW9uIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgJ2FyaWEtbGFiZWwnOiBkYXRlU3RyIH07XG59XG5cbmxldCBfaXNSdGxTY3JvbGxiYXJPbkxlZnQgPSBudWxsO1xuZnVuY3Rpb24gZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQoKSB7XG4gICAgaWYgKF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9PT0gbnVsbCkge1xuICAgICAgICBfaXNSdGxTY3JvbGxiYXJPbkxlZnQgPSBjb21wdXRlSXNSdGxTY3JvbGxiYXJPbkxlZnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9pc1J0bFNjcm9sbGJhck9uTGVmdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJc1J0bFNjcm9sbGJhck9uTGVmdCgpIHtcbiAgICBsZXQgb3V0ZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGFwcGx5U3R5bGUob3V0ZXJFbCwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdG9wOiAtMTAwMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBvdmVyZmxvdzogJ3Njcm9sbCcsXG4gICAgICAgIGRpcmVjdGlvbjogJ3J0bCcsXG4gICAgfSk7XG4gICAgb3V0ZXJFbC5pbm5lckhUTUwgPSAnPGRpdj48L2Rpdj4nO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXJFbCk7XG4gICAgbGV0IGlubmVyRWwgPSBvdXRlckVsLmZpcnN0Q2hpbGQ7XG4gICAgbGV0IHJlcyA9IGlubmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCA+IG91dGVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICByZW1vdmVFbGVtZW50KG91dGVyRWwpO1xuICAgIHJldHVybiByZXM7XG59XG5cbmxldCBfc2Nyb2xsYmFyV2lkdGhzO1xuZnVuY3Rpb24gZ2V0U2Nyb2xsYmFyV2lkdGhzKCkge1xuICAgIGlmICghX3Njcm9sbGJhcldpZHRocykge1xuICAgICAgICBfc2Nyb2xsYmFyV2lkdGhzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRocygpO1xuICAgIH1cbiAgICByZXR1cm4gX3Njcm9sbGJhcldpZHRocztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTY3JvbGxiYXJXaWR0aHMoKSB7XG4gICAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJztcbiAgICBlbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZWwuc3R5bGUudG9wID0gJy05OTk5cHgnO1xuICAgIGVsLnN0eWxlLmxlZnQgPSAnLTk5OTlweCc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gICAgbGV0IHJlcyA9IGNvbXB1dGVTY3JvbGxiYXJXaWR0aHNGb3JFbChlbCk7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIFdBUk5JTkc6IHdpbGwgaW5jbHVkZSBib3JkZXJcbmZ1bmN0aW9uIGNvbXB1dGVTY3JvbGxiYXJXaWR0aHNGb3JFbChlbCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGVsLm9mZnNldEhlaWdodCAtIGVsLmNsaWVudEhlaWdodCxcbiAgICAgICAgeTogZWwub2Zmc2V0V2lkdGggLSBlbC5jbGllbnRXaWR0aCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRWRnZXMoZWwsIGdldFBhZGRpbmcgPSBmYWxzZSkge1xuICAgIGxldCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIGxldCBib3JkZXJMZWZ0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgsIDEwKSB8fCAwO1xuICAgIGxldCBib3JkZXJSaWdodCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCwgMTApIHx8IDA7XG4gICAgbGV0IGJvcmRlclRvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwKSB8fCAwO1xuICAgIGxldCBib3JkZXJCb3R0b20gPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCkgfHwgMDtcbiAgICBsZXQgYmFkU2Nyb2xsYmFyV2lkdGhzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKTsgLy8gaW5jbHVkZXMgYm9yZGVyIVxuICAgIGxldCBzY3JvbGxiYXJMZWZ0UmlnaHQgPSBiYWRTY3JvbGxiYXJXaWR0aHMueSAtIGJvcmRlckxlZnQgLSBib3JkZXJSaWdodDtcbiAgICBsZXQgc2Nyb2xsYmFyQm90dG9tID0gYmFkU2Nyb2xsYmFyV2lkdGhzLnggLSBib3JkZXJUb3AgLSBib3JkZXJCb3R0b207XG4gICAgbGV0IHJlcyA9IHtcbiAgICAgICAgYm9yZGVyTGVmdCxcbiAgICAgICAgYm9yZGVyUmlnaHQsXG4gICAgICAgIGJvcmRlclRvcCxcbiAgICAgICAgYm9yZGVyQm90dG9tLFxuICAgICAgICBzY3JvbGxiYXJCb3R0b20sXG4gICAgICAgIHNjcm9sbGJhckxlZnQ6IDAsXG4gICAgICAgIHNjcm9sbGJhclJpZ2h0OiAwLFxuICAgIH07XG4gICAgaWYgKGdldElzUnRsU2Nyb2xsYmFyT25MZWZ0KCkgJiYgY29tcHV0ZWRTdHlsZS5kaXJlY3Rpb24gPT09ICdydGwnKSB7IC8vIGlzIHRoZSBzY3JvbGxiYXIgb24gdGhlIGxlZnQgc2lkZT9cbiAgICAgICAgcmVzLnNjcm9sbGJhckxlZnQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXMuc2Nyb2xsYmFyUmlnaHQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XG4gICAgfVxuICAgIGlmIChnZXRQYWRkaW5nKSB7XG4gICAgICAgIHJlcy5wYWRkaW5nTGVmdCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQsIDEwKSB8fCAwO1xuICAgICAgICByZXMucGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQsIDEwKSB8fCAwO1xuICAgICAgICByZXMucGFkZGluZ1RvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ1RvcCwgMTApIHx8IDA7XG4gICAgICAgIHJlcy5wYWRkaW5nQm90dG9tID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nQm90dG9tLCAxMCkgfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJbm5lclJlY3QoZWwsIGdvV2l0aGluUGFkZGluZyA9IGZhbHNlLCBkb0Zyb21XaW5kb3dWaWV3cG9ydCkge1xuICAgIGxldCBvdXRlclJlY3QgPSBkb0Zyb21XaW5kb3dWaWV3cG9ydCA/IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogY29tcHV0ZVJlY3QoZWwpO1xuICAgIGxldCBlZGdlcyA9IGNvbXB1dGVFZGdlcyhlbCwgZ29XaXRoaW5QYWRkaW5nKTtcbiAgICBsZXQgcmVzID0ge1xuICAgICAgICBsZWZ0OiBvdXRlclJlY3QubGVmdCArIGVkZ2VzLmJvcmRlckxlZnQgKyBlZGdlcy5zY3JvbGxiYXJMZWZ0LFxuICAgICAgICByaWdodDogb3V0ZXJSZWN0LnJpZ2h0IC0gZWRnZXMuYm9yZGVyUmlnaHQgLSBlZGdlcy5zY3JvbGxiYXJSaWdodCxcbiAgICAgICAgdG9wOiBvdXRlclJlY3QudG9wICsgZWRnZXMuYm9yZGVyVG9wLFxuICAgICAgICBib3R0b206IG91dGVyUmVjdC5ib3R0b20gLSBlZGdlcy5ib3JkZXJCb3R0b20gLSBlZGdlcy5zY3JvbGxiYXJCb3R0b20sXG4gICAgfTtcbiAgICBpZiAoZ29XaXRoaW5QYWRkaW5nKSB7XG4gICAgICAgIHJlcy5sZWZ0ICs9IGVkZ2VzLnBhZGRpbmdMZWZ0O1xuICAgICAgICByZXMucmlnaHQgLT0gZWRnZXMucGFkZGluZ1JpZ2h0O1xuICAgICAgICByZXMudG9wICs9IGVkZ2VzLnBhZGRpbmdUb3A7XG4gICAgICAgIHJlcy5ib3R0b20gLT0gZWRnZXMucGFkZGluZ0JvdHRvbTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVSZWN0KGVsKSB7XG4gICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgICAgIHRvcDogcmVjdC50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQsXG4gICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0ICsgd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgICBib3R0b206IHJlY3QuYm90dG9tICsgd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wdXRlQ2xpcHBlZENsaWVudFJlY3QoZWwpIHtcbiAgICBsZXQgY2xpcHBpbmdQYXJlbnRzID0gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsKTtcbiAgICBsZXQgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGZvciAobGV0IGNsaXBwaW5nUGFyZW50IG9mIGNsaXBwaW5nUGFyZW50cykge1xuICAgICAgICBsZXQgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0UmVjdHMocmVjdCwgY2xpcHBpbmdQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uKSB7XG4gICAgICAgICAgICByZWN0ID0gaW50ZXJzZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlY3Q7XG59XG4vLyBkb2VzIG5vdCByZXR1cm4gd2luZG93XG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWwpIHtcbiAgICBsZXQgcGFyZW50cyA9IFtdO1xuICAgIHdoaWxlIChlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7IC8vIHdpbGwgc3RvcCB3aGVuIGdldHMgdG8gZG9jdW1lbnQgb3IgbnVsbFxuICAgICAgICBsZXQgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgICAgaWYgKGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoLyhhdXRvfHNjcm9sbCkvKS50ZXN0KGNvbXB1dGVkU3R5bGUub3ZlcmZsb3cgKyBjb21wdXRlZFN0eWxlLm92ZXJmbG93WSArIGNvbXB1dGVkU3R5bGUub3ZlcmZsb3dYKSkge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRzO1xufVxuXG4vKlxuUmVjb3JkcyBvZmZzZXQgaW5mb3JtYXRpb24gZm9yIGEgc2V0IG9mIGVsZW1lbnRzLCByZWxhdGl2ZSB0byBhbiBvcmlnaW4gZWxlbWVudC5cbkNhbiByZWNvcmQgdGhlIGxlZnQvcmlnaHQgT1IgdGhlIHRvcC9ib3R0b20gT1IgYm90aC5cblByb3ZpZGVzIG1ldGhvZHMgZm9yIHF1ZXJ5aW5nIHRoZSBjYWNoZSBieSBwb3NpdGlvbi5cbiovXG5jbGFzcyBQb3NpdGlvbkNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW5FbCwgZWxzLCBpc0hvcml6b250YWwsIGlzVmVydGljYWwpIHtcbiAgICAgICAgdGhpcy5lbHMgPSBlbHM7XG4gICAgICAgIGxldCBvcmlnaW5DbGllbnRSZWN0ID0gdGhpcy5vcmlnaW5DbGllbnRSZWN0ID0gb3JpZ2luRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIHJlbGF0aXZlIHRvIHZpZXdwb3J0IHRvcC1sZWZ0XG4gICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRFbEhvcml6b250YWxzKG9yaWdpbkNsaWVudFJlY3QubGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRFbFZlcnRpY2FscyhvcmlnaW5DbGllbnRSZWN0LnRvcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUG9wdWxhdGVzIHRoZSBsZWZ0L3JpZ2h0IGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXG4gICAgYnVpbGRFbEhvcml6b250YWxzKG9yaWdpbkNsaWVudExlZnQpIHtcbiAgICAgICAgbGV0IGxlZnRzID0gW107XG4gICAgICAgIGxldCByaWdodHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZWwgb2YgdGhpcy5lbHMpIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBsZWZ0cy5wdXNoKHJlY3QubGVmdCAtIG9yaWdpbkNsaWVudExlZnQpO1xuICAgICAgICAgICAgcmlnaHRzLnB1c2gocmVjdC5yaWdodCAtIG9yaWdpbkNsaWVudExlZnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVmdHMgPSBsZWZ0cztcbiAgICAgICAgdGhpcy5yaWdodHMgPSByaWdodHM7XG4gICAgfVxuICAgIC8vIFBvcHVsYXRlcyB0aGUgdG9wL2JvdHRvbSBpbnRlcm5hbCBjb29yZGluYXRlIGFycmF5c1xuICAgIGJ1aWxkRWxWZXJ0aWNhbHMob3JpZ2luQ2xpZW50VG9wKSB7XG4gICAgICAgIGxldCB0b3BzID0gW107XG4gICAgICAgIGxldCBib3R0b21zID0gW107XG4gICAgICAgIGZvciAobGV0IGVsIG9mIHRoaXMuZWxzKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdG9wcy5wdXNoKHJlY3QudG9wIC0gb3JpZ2luQ2xpZW50VG9wKTtcbiAgICAgICAgICAgIGJvdHRvbXMucHVzaChyZWN0LmJvdHRvbSAtIG9yaWdpbkNsaWVudFRvcCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3BzID0gdG9wcztcbiAgICAgICAgdGhpcy5ib3R0b21zID0gYm90dG9tcztcbiAgICB9XG4gICAgLy8gR2l2ZW4gYSBsZWZ0IG9mZnNldCAoZnJvbSBkb2N1bWVudCBsZWZ0KSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgaG9yaXpvbnRhbGx5IGludGVyc2VjdHMuXG4gICAgLy8gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIG1hZGUsIHJldHVybnMgdW5kZWZpbmVkLlxuICAgIGxlZnRUb0luZGV4KGxlZnRQb3NpdGlvbikge1xuICAgICAgICBsZXQgeyBsZWZ0cywgcmlnaHRzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgbGVuID0gbGVmdHMubGVuZ3RoO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAobGVmdFBvc2l0aW9uID49IGxlZnRzW2ldICYmIGxlZnRQb3NpdGlvbiA8IHJpZ2h0c1tpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIFRPRE86IGJldHRlclxuICAgIH1cbiAgICAvLyBHaXZlbiBhIHRvcCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgdG9wKSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgdmVydGljYWxseSBpbnRlcnNlY3RzLlxuICAgIC8vIElmIG5vIGludGVyc2VjdGlvbiBpcyBtYWRlLCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICB0b3BUb0luZGV4KHRvcFBvc2l0aW9uKSB7XG4gICAgICAgIGxldCB7IHRvcHMsIGJvdHRvbXMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBsZW4gPSB0b3BzLmxlbmd0aDtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHRvcFBvc2l0aW9uID49IHRvcHNbaV0gJiYgdG9wUG9zaXRpb24gPCBib3R0b21zW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gVE9ETzogYmV0dGVyXG4gICAgfVxuICAgIC8vIEdldHMgdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxuICAgIGdldFdpZHRoKGxlZnRJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yaWdodHNbbGVmdEluZGV4XSAtIHRoaXMubGVmdHNbbGVmdEluZGV4XTtcbiAgICB9XG4gICAgLy8gR2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxuICAgIGdldEhlaWdodCh0b3BJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3R0b21zW3RvcEluZGV4XSAtIHRoaXMudG9wc1t0b3BJbmRleF07XG4gICAgfVxuICAgIHNpbWlsYXJUbyhvdGhlckNhY2hlKSB7XG4gICAgICAgIHJldHVybiBzaW1pbGFyTnVtQXJyYXlzKHRoaXMudG9wcyB8fCBbXSwgb3RoZXJDYWNoZS50b3BzIHx8IFtdKSAmJlxuICAgICAgICAgICAgc2ltaWxhck51bUFycmF5cyh0aGlzLmJvdHRvbXMgfHwgW10sIG90aGVyQ2FjaGUuYm90dG9tcyB8fCBbXSkgJiZcbiAgICAgICAgICAgIHNpbWlsYXJOdW1BcnJheXModGhpcy5sZWZ0cyB8fCBbXSwgb3RoZXJDYWNoZS5sZWZ0cyB8fCBbXSkgJiZcbiAgICAgICAgICAgIHNpbWlsYXJOdW1BcnJheXModGhpcy5yaWdodHMgfHwgW10sIG90aGVyQ2FjaGUucmlnaHRzIHx8IFtdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzaW1pbGFyTnVtQXJyYXlzKGEsIGIpIHtcbiAgICBjb25zdCBsZW4gPSBhLmxlbmd0aDtcbiAgICBpZiAobGVuICE9PSBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKE1hdGgucm91bmQoYVtpXSkgIT09IE1hdGgucm91bmQoYltpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyogZXNsaW50IG1heC1jbGFzc2VzLXBlci1maWxlOiBcIm9mZlwiICovXG4vKlxuQW4gb2JqZWN0IGZvciBnZXR0aW5nL3NldHRpbmcgc2Nyb2xsLXJlbGF0ZWQgaW5mb3JtYXRpb24gZm9yIGFuIGVsZW1lbnQuXG5JbnRlcm5hbGx5LCB0aGlzIGlzIGRvbmUgdmVyeSBkaWZmZXJlbnRseSBmb3Igd2luZG93IHZlcnN1cyBET00gZWxlbWVudCxcbnNvIHRoaXMgb2JqZWN0IHNlcnZlcyBhcyBhIGNvbW1vbiBpbnRlcmZhY2UuXG4qL1xuY2xhc3MgU2Nyb2xsQ29udHJvbGxlciB7XG4gICAgZ2V0TWF4U2Nyb2xsVG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxIZWlnaHQoKSAtIHRoaXMuZ2V0Q2xpZW50SGVpZ2h0KCk7XG4gICAgfVxuICAgIGdldE1heFNjcm9sbExlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbFdpZHRoKCkgLSB0aGlzLmdldENsaWVudFdpZHRoKCk7XG4gICAgfVxuICAgIGNhblNjcm9sbFZlcnRpY2FsbHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1heFNjcm9sbFRvcCgpID4gMDtcbiAgICB9XG4gICAgY2FuU2Nyb2xsSG9yaXpvbnRhbGx5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXhTY3JvbGxMZWZ0KCkgPiAwO1xuICAgIH1cbiAgICBjYW5TY3JvbGxVcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsVG9wKCkgPiAwO1xuICAgIH1cbiAgICBjYW5TY3JvbGxEb3duKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxUb3AoKSA8IHRoaXMuZ2V0TWF4U2Nyb2xsVG9wKCk7XG4gICAgfVxuICAgIGNhblNjcm9sbExlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbExlZnQoKSA+IDA7XG4gICAgfVxuICAgIGNhblNjcm9sbFJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxMZWZ0KCkgPCB0aGlzLmdldE1heFNjcm9sbExlZnQoKTtcbiAgICB9XG59XG5jbGFzcyBFbGVtZW50U2Nyb2xsQ29udHJvbGxlciBleHRlbmRzIFNjcm9sbENvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKGVsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsVG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxUb3A7XG4gICAgfVxuICAgIGdldFNjcm9sbExlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbExlZnQ7XG4gICAgfVxuICAgIHNldFNjcm9sbFRvcCh0b3ApIHtcbiAgICAgICAgdGhpcy5lbC5zY3JvbGxUb3AgPSB0b3A7XG4gICAgfVxuICAgIHNldFNjcm9sbExlZnQobGVmdCkge1xuICAgICAgICB0aGlzLmVsLnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgIH1cbiAgICBnZXRTY3JvbGxXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsV2lkdGg7XG4gICAgfVxuICAgIGdldFNjcm9sbEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsSGVpZ2h0O1xuICAgIH1cbiAgICBnZXRDbGllbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLmNsaWVudEhlaWdodDtcbiAgICB9XG4gICAgZ2V0Q2xpZW50V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLmNsaWVudFdpZHRoO1xuICAgIH1cbn1cbmNsYXNzIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIgZXh0ZW5kcyBTY3JvbGxDb250cm9sbGVyIHtcbiAgICBnZXRTY3JvbGxUb3AoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgfVxuICAgIGdldFNjcm9sbExlZnQoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gICAgfVxuICAgIHNldFNjcm9sbFRvcChuKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGwod2luZG93LnBhZ2VYT2Zmc2V0LCBuKTtcbiAgICB9XG4gICAgc2V0U2Nyb2xsTGVmdChuKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGwobiwgd2luZG93LnBhZ2VZT2Zmc2V0KTtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGg7XG4gICAgfVxuICAgIGdldFNjcm9sbEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gICAgfVxuICAgIGdldENsaWVudEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgfVxuICAgIGdldENsaWVudFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIH1cbn1cblxuLypcbmFuIElOVEVSQUNUQUJMRSBkYXRlIGNvbXBvbmVudFxuXG5QVVJQT1NFUzpcbi0gaG9vayB1cCB0byBmZywgZmlsbCwgYW5kIG1pcnJvciByZW5kZXJlcnNcbi0gaW50ZXJmYWNlIGZvciBkcmFnZ2luZyBhbmQgaGl0c1xuKi9cbmNsYXNzIERhdGVDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy51aWQgPSBndWlkKCk7XG4gICAgfVxuICAgIC8vIEhpdCBTeXN0ZW1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHByZXBhcmVIaXRzKCkge1xuICAgIH1cbiAgICBxdWVyeUhpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wLCBlbFdpZHRoLCBlbEhlaWdodCkge1xuICAgICAgICByZXR1cm4gbnVsbDsgLy8gdGhpcyBzaG91bGQgYmUgYWJzdHJhY3RcbiAgICB9XG4gICAgLy8gUG9pbnRlciBJbnRlcmFjdGlvbiBVdGlsc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgaXNWYWxpZFNlZ0Rvd25FbChlbCkge1xuICAgICAgICByZXR1cm4gIXRoaXMucHJvcHMuZXZlbnREcmFnICYmIC8vIEhBQ0tcbiAgICAgICAgICAgICF0aGlzLnByb3BzLmV2ZW50UmVzaXplICYmIC8vIEhBQ0tcbiAgICAgICAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJy5mYy1ldmVudC1taXJyb3InKTtcbiAgICB9XG4gICAgaXNWYWxpZERhdGVEb3duRWwoZWwpIHtcbiAgICAgICAgcmV0dXJuICFlbGVtZW50Q2xvc2VzdChlbCwgJy5mYy1ldmVudDpub3QoLmZjLWJnLWV2ZW50KScpICYmXG4gICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtbW9yZS1saW5rJykgJiYgLy8gYSBcIm1vcmUuLlwiIGxpbmtcbiAgICAgICAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJ2FbZGF0YS1uYXZsaW5rXScpICYmIC8vIGEgY2xpY2thYmxlIG5hdiBsaW5rXG4gICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtcG9wb3ZlcicpOyAvLyBoYWNrXG4gICAgfVxufVxuXG5jbGFzcyBOYW1lZFRpbWVab25lSW1wbCB7XG4gICAgY29uc3RydWN0b3IodGltZVpvbmVOYW1lKSB7XG4gICAgICAgIHRoaXMudGltZVpvbmVOYW1lID0gdGltZVpvbmVOYW1lO1xuICAgIH1cbn1cblxuY2xhc3MgU2VnSGllcmFyY2h5IHtcbiAgICBjb25zdHJ1Y3RvcihnZXRFbnRyeVRoaWNrbmVzcyA9IChlbnRyeSkgPT4ge1xuICAgICAgICAvLyBzaG91bGQgcmV0dXJuIGFuIGludGVnZXJcbiAgICAgICAgcmV0dXJuIGVudHJ5LnRoaWNrbmVzcztcbiAgICB9KSB7XG4gICAgICAgIHRoaXMuZ2V0RW50cnlUaGlja25lc3MgPSBnZXRFbnRyeVRoaWNrbmVzcztcbiAgICAgICAgLy8gc2V0dGluZ3NcbiAgICAgICAgdGhpcy5zdHJpY3RPcmRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsbG93UmVzbGljaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF4Q29vcmQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XG4gICAgICAgIHRoaXMubWF4U3RhY2tDbnQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XG4gICAgICAgIHRoaXMubGV2ZWxDb29yZHMgPSBbXTsgLy8gb3JkZXJlZFxuICAgICAgICB0aGlzLmVudHJpZXNCeUxldmVsID0gW107IC8vIHBhcmFsbGVsIHdpdGggbGV2ZWxDb29yZHNcbiAgICAgICAgdGhpcy5zdGFja0NudHMgPSB7fTsgLy8gVE9ETzogdXNlIGJldHRlciB0ZWNobmlxdWUhP1xuICAgIH1cbiAgICBhZGRTZWdzKGlucHV0cykge1xuICAgICAgICBsZXQgaGlkZGVuRW50cmllcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0RW50cnkoaW5wdXQsIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWRkZW5FbnRyaWVzO1xuICAgIH1cbiAgICBpbnNlcnRFbnRyeShlbnRyeSwgaGlkZGVuRW50cmllcykge1xuICAgICAgICBsZXQgaW5zZXJ0aW9uID0gdGhpcy5maW5kSW5zZXJ0aW9uKGVudHJ5KTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbnNlcnRpb25WYWxpZChpbnNlcnRpb24sIGVudHJ5KSkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRFbnRyeUF0KGVudHJ5LCBpbnNlcnRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlSW52YWxpZEluc2VydGlvbihpbnNlcnRpb24sIGVudHJ5LCBoaWRkZW5FbnRyaWVzKTtcbiAgICB9XG4gICAgaXNJbnNlcnRpb25WYWxpZChpbnNlcnRpb24sIGVudHJ5KSB7XG4gICAgICAgIHJldHVybiAodGhpcy5tYXhDb29yZCA9PT0gLTEgfHwgaW5zZXJ0aW9uLmxldmVsQ29vcmQgKyB0aGlzLmdldEVudHJ5VGhpY2tuZXNzKGVudHJ5KSA8PSB0aGlzLm1heENvb3JkKSAmJlxuICAgICAgICAgICAgKHRoaXMubWF4U3RhY2tDbnQgPT09IC0xIHx8IGluc2VydGlvbi5zdGFja0NudCA8IHRoaXMubWF4U3RhY2tDbnQpO1xuICAgIH1cbiAgICAvLyByZXR1cm5zIG51bWJlciBvZiBuZXcgZW50cmllcyBpbnNlcnRlZFxuICAgIGhhbmRsZUludmFsaWRJbnNlcnRpb24oaW5zZXJ0aW9uLCBlbnRyeSwgaGlkZGVuRW50cmllcykge1xuICAgICAgICBpZiAodGhpcy5hbGxvd1Jlc2xpY2luZyAmJiBpbnNlcnRpb24udG91Y2hpbmdFbnRyeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXRFbnRyeShlbnRyeSwgaW5zZXJ0aW9uLnRvdWNoaW5nRW50cnksIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGhpZGRlbkVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBzcGxpdEVudHJ5KGVudHJ5LCBiYXJyaWVyLCBoaWRkZW5FbnRyaWVzKSB7XG4gICAgICAgIGxldCBwYXJ0Q250ID0gMDtcbiAgICAgICAgbGV0IHNwbGl0SGlkZGVuRW50cmllcyA9IFtdO1xuICAgICAgICBsZXQgZW50cnlTcGFuID0gZW50cnkuc3BhbjtcbiAgICAgICAgbGV0IGJhcnJpZXJTcGFuID0gYmFycmllci5zcGFuO1xuICAgICAgICBpZiAoZW50cnlTcGFuLnN0YXJ0IDwgYmFycmllclNwYW4uc3RhcnQpIHtcbiAgICAgICAgICAgIHBhcnRDbnQgKz0gdGhpcy5pbnNlcnRFbnRyeSh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGVudHJ5LmluZGV4LFxuICAgICAgICAgICAgICAgIHRoaWNrbmVzczogZW50cnkudGhpY2tuZXNzLFxuICAgICAgICAgICAgICAgIHNwYW46IHsgc3RhcnQ6IGVudHJ5U3Bhbi5zdGFydCwgZW5kOiBiYXJyaWVyU3Bhbi5zdGFydCB9LFxuICAgICAgICAgICAgfSwgc3BsaXRIaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW50cnlTcGFuLmVuZCA+IGJhcnJpZXJTcGFuLmVuZCkge1xuICAgICAgICAgICAgcGFydENudCArPSB0aGlzLmluc2VydEVudHJ5KHtcbiAgICAgICAgICAgICAgICBpbmRleDogZW50cnkuaW5kZXgsXG4gICAgICAgICAgICAgICAgdGhpY2tuZXNzOiBlbnRyeS50aGlja25lc3MsXG4gICAgICAgICAgICAgICAgc3BhbjogeyBzdGFydDogYmFycmllclNwYW4uZW5kLCBlbmQ6IGVudHJ5U3Bhbi5lbmQgfSxcbiAgICAgICAgICAgIH0sIHNwbGl0SGlkZGVuRW50cmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRDbnQpIHtcbiAgICAgICAgICAgIGhpZGRlbkVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGVudHJ5LmluZGV4LFxuICAgICAgICAgICAgICAgIHRoaWNrbmVzczogZW50cnkudGhpY2tuZXNzLFxuICAgICAgICAgICAgICAgIHNwYW46IGludGVyc2VjdFNwYW5zKGJhcnJpZXJTcGFuLCBlbnRyeVNwYW4pLCAvLyBndWFyYW50ZWVkIHRvIGludGVyc2VjdFxuICAgICAgICAgICAgfSwgLi4uc3BsaXRIaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0Q250O1xuICAgICAgICB9XG4gICAgICAgIGhpZGRlbkVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpbnNlcnRFbnRyeUF0KGVudHJ5LCBpbnNlcnRpb24pIHtcbiAgICAgICAgbGV0IHsgZW50cmllc0J5TGV2ZWwsIGxldmVsQ29vcmRzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoaW5zZXJ0aW9uLmxhdGVyYWwgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgbGV2ZWxcbiAgICAgICAgICAgIGluc2VydEF0KGxldmVsQ29vcmRzLCBpbnNlcnRpb24ubGV2ZWwsIGluc2VydGlvbi5sZXZlbENvb3JkKTtcbiAgICAgICAgICAgIGluc2VydEF0KGVudHJpZXNCeUxldmVsLCBpbnNlcnRpb24ubGV2ZWwsIFtlbnRyeV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGludG8gZXhpc3RpbmcgbGV2ZWxcbiAgICAgICAgICAgIGluc2VydEF0KGVudHJpZXNCeUxldmVsW2luc2VydGlvbi5sZXZlbF0sIGluc2VydGlvbi5sYXRlcmFsLCBlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFja0NudHNbYnVpbGRFbnRyeUtleShlbnRyeSldID0gaW5zZXJ0aW9uLnN0YWNrQ250O1xuICAgIH1cbiAgICBmaW5kSW5zZXJ0aW9uKG5ld0VudHJ5KSB7XG4gICAgICAgIGxldCB7IGxldmVsQ29vcmRzLCBlbnRyaWVzQnlMZXZlbCwgc3RyaWN0T3JkZXIsIHN0YWNrQ250cyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGxldmVsQ250ID0gbGV2ZWxDb29yZHMubGVuZ3RoO1xuICAgICAgICBsZXQgY2FuZGlkYXRlQ29vcmQgPSAwO1xuICAgICAgICBsZXQgdG91Y2hpbmdMZXZlbCA9IC0xO1xuICAgICAgICBsZXQgdG91Y2hpbmdMYXRlcmFsID0gLTE7XG4gICAgICAgIGxldCB0b3VjaGluZ0VudHJ5ID0gbnVsbDtcbiAgICAgICAgbGV0IHN0YWNrQ250ID0gMDtcbiAgICAgICAgZm9yIChsZXQgdHJhY2tpbmdMZXZlbCA9IDA7IHRyYWNraW5nTGV2ZWwgPCBsZXZlbENudDsgdHJhY2tpbmdMZXZlbCArPSAxKSB7XG4gICAgICAgICAgICBsZXQgdHJhY2tpbmdDb29yZCA9IGxldmVsQ29vcmRzW3RyYWNraW5nTGV2ZWxdO1xuICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgbGV2ZWwgaXMgcGFzdCB0aGUgcGxhY2VkIGVudHJ5LCB3ZSBoYXZlIGZvdW5kIGEgZ29vZCBlbXB0eSBzcGFjZSBhbmQgY2FuIHN0b3AuXG4gICAgICAgICAgICAvLyBpZiBzdHJpY3RPcmRlciwga2VlcCBmaW5kaW5nIG1vcmUgbGF0ZXJhbCBpbnRlcnNlY3Rpb25zLlxuICAgICAgICAgICAgaWYgKCFzdHJpY3RPcmRlciAmJiB0cmFja2luZ0Nvb3JkID49IGNhbmRpZGF0ZUNvb3JkICsgdGhpcy5nZXRFbnRyeVRoaWNrbmVzcyhuZXdFbnRyeSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0cmFja2luZ0VudHJpZXMgPSBlbnRyaWVzQnlMZXZlbFt0cmFja2luZ0xldmVsXTtcbiAgICAgICAgICAgIGxldCB0cmFja2luZ0VudHJ5O1xuICAgICAgICAgICAgbGV0IHNlYXJjaFJlcyA9IGJpbmFyeVNlYXJjaCh0cmFja2luZ0VudHJpZXMsIG5ld0VudHJ5LnNwYW4uc3RhcnQsIGdldEVudHJ5U3BhbkVuZCk7IC8vIGZpbmQgZmlyc3QgZW50cnkgYWZ0ZXIgbmV3RW50cnkncyBlbmRcbiAgICAgICAgICAgIGxldCBsYXRlcmFsSW5kZXggPSBzZWFyY2hSZXNbMF0gKyBzZWFyY2hSZXNbMV07IC8vIGlmIGV4YWN0IG1hdGNoICh3aGljaCBkb2Vzbid0IGNvbGxpZGUpLCBnbyB0byBuZXh0IG9uZVxuICAgICAgICAgICAgd2hpbGUgKCAvLyBsb29wIHRocm91Z2ggZW50cmllcyB0aGF0IGhvcml6b250YWxseSBpbnRlcnNlY3RcbiAgICAgICAgICAgICh0cmFja2luZ0VudHJ5ID0gdHJhY2tpbmdFbnRyaWVzW2xhdGVyYWxJbmRleF0pICYmIC8vIGJ1dCBub3QgcGFzdCB0aGUgd2hvbGUgZW50cnkgbGlzdFxuICAgICAgICAgICAgICAgIHRyYWNraW5nRW50cnkuc3Bhbi5zdGFydCA8IG5ld0VudHJ5LnNwYW4uZW5kIC8vIGFuZCBub3QgZW50aXJlbHkgcGFzdCBuZXdFbnRyeVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyYWNraW5nRW50cnlCb3R0b20gPSB0cmFja2luZ0Nvb3JkICsgdGhpcy5nZXRFbnRyeVRoaWNrbmVzcyh0cmFja2luZ0VudHJ5KTtcbiAgICAgICAgICAgICAgICAvLyBpbnRlcnNlY3RzIGludG8gdGhlIHRvcCBvZiB0aGUgY2FuZGlkYXRlP1xuICAgICAgICAgICAgICAgIGlmICh0cmFja2luZ0VudHJ5Qm90dG9tID4gY2FuZGlkYXRlQ29vcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlQ29vcmQgPSB0cmFja2luZ0VudHJ5Qm90dG9tO1xuICAgICAgICAgICAgICAgICAgICB0b3VjaGluZ0VudHJ5ID0gdHJhY2tpbmdFbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hpbmdMZXZlbCA9IHRyYWNraW5nTGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoaW5nTGF0ZXJhbCA9IGxhdGVyYWxJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYnV0dHMgdXAgYWdhaW5zdCB0b3Agb2YgY2FuZGlkYXRlPyAod2lsbCBoYXBwZW4gaWYganVzdCBpbnRlcnNlY3RlZCBhcyB3ZWxsKVxuICAgICAgICAgICAgICAgIGlmICh0cmFja2luZ0VudHJ5Qm90dG9tID09PSBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhY2N1bXVsYXRlIHRoZSBoaWdoZXN0IHBvc3NpYmxlIHN0YWNrQ250IG9mIHRoZSB0cmFja2luZ0VudHJpZXMgdGhhdCBidXR0IHVwXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrQ250ID0gTWF0aC5tYXgoc3RhY2tDbnQsIHN0YWNrQ250c1tidWlsZEVudHJ5S2V5KHRyYWNraW5nRW50cnkpXSArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXRlcmFsSW5kZXggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgZGVzdGluYXRpb24gbGV2ZWwgd2lsbCBiZSBhZnRlciB0b3VjaGluZ0VudHJ5J3MgbGV2ZWwuIGZpbmQgaXRcbiAgICAgICAgbGV0IGRlc3RMZXZlbCA9IDA7XG4gICAgICAgIGlmICh0b3VjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgICBkZXN0TGV2ZWwgPSB0b3VjaGluZ0xldmVsICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChkZXN0TGV2ZWwgPCBsZXZlbENudCAmJiBsZXZlbENvb3Jkc1tkZXN0TGV2ZWxdIDwgY2FuZGlkYXRlQ29vcmQpIHtcbiAgICAgICAgICAgICAgICBkZXN0TGV2ZWwgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBhZGRpbmcgdG8gYW4gZXhpc3RpbmcgbGV2ZWwsIGZpbmQgd2hlcmUgdG8gaW5zZXJ0XG4gICAgICAgIGxldCBkZXN0TGF0ZXJhbCA9IC0xO1xuICAgICAgICBpZiAoZGVzdExldmVsIDwgbGV2ZWxDbnQgJiYgbGV2ZWxDb29yZHNbZGVzdExldmVsXSA9PT0gY2FuZGlkYXRlQ29vcmQpIHtcbiAgICAgICAgICAgIGRlc3RMYXRlcmFsID0gYmluYXJ5U2VhcmNoKGVudHJpZXNCeUxldmVsW2Rlc3RMZXZlbF0sIG5ld0VudHJ5LnNwYW4uZW5kLCBnZXRFbnRyeVNwYW5FbmQpWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3VjaGluZ0xldmVsLFxuICAgICAgICAgICAgdG91Y2hpbmdMYXRlcmFsLFxuICAgICAgICAgICAgdG91Y2hpbmdFbnRyeSxcbiAgICAgICAgICAgIHN0YWNrQ250LFxuICAgICAgICAgICAgbGV2ZWxDb29yZDogY2FuZGlkYXRlQ29vcmQsXG4gICAgICAgICAgICBsZXZlbDogZGVzdExldmVsLFxuICAgICAgICAgICAgbGF0ZXJhbDogZGVzdExhdGVyYWwsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIHNvcnRlZCBieSBsZXZlbENvb3JkIChsb3dlc3QgdG8gaGlnaGVzdClcbiAgICB0b1JlY3RzKCkge1xuICAgICAgICBsZXQgeyBlbnRyaWVzQnlMZXZlbCwgbGV2ZWxDb29yZHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBsZXZlbENudCA9IGVudHJpZXNCeUxldmVsLmxlbmd0aDtcbiAgICAgICAgbGV0IHJlY3RzID0gW107XG4gICAgICAgIGZvciAobGV0IGxldmVsID0gMDsgbGV2ZWwgPCBsZXZlbENudDsgbGV2ZWwgKz0gMSkge1xuICAgICAgICAgICAgbGV0IGVudHJpZXMgPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF07XG4gICAgICAgICAgICBsZXQgbGV2ZWxDb29yZCA9IGxldmVsQ29vcmRzW2xldmVsXTtcbiAgICAgICAgICAgIGZvciAobGV0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICByZWN0cy5wdXNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZW50cnkpLCB7IHRoaWNrbmVzczogdGhpcy5nZXRFbnRyeVRoaWNrbmVzcyhlbnRyeSksIGxldmVsQ29vcmQgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWN0cztcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRFbnRyeVNwYW5FbmQoZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuc3Bhbi5lbmQ7XG59XG5mdW5jdGlvbiBidWlsZEVudHJ5S2V5KGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LmluZGV4ICsgJzonICsgZW50cnkuc3Bhbi5zdGFydDtcbn1cbi8vIHJldHVybnMgZ3JvdXBzIHdpdGggZW50cmllcyBzb3J0ZWQgYnkgaW5wdXQgb3JkZXJcbmZ1bmN0aW9uIGdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyhlbnRyaWVzKSB7XG4gICAgbGV0IG1lcmdlcyA9IFtdO1xuICAgIGZvciAobGV0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgbGV0IGZpbHRlcmVkTWVyZ2VzID0gW107XG4gICAgICAgIGxldCBodW5ncnlNZXJnZSA9IHtcbiAgICAgICAgICAgIHNwYW46IGVudHJ5LnNwYW4sXG4gICAgICAgICAgICBlbnRyaWVzOiBbZW50cnldLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBtZXJnZSBvZiBtZXJnZXMpIHtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3RTcGFucyhtZXJnZS5zcGFuLCBodW5ncnlNZXJnZS5zcGFuKSkge1xuICAgICAgICAgICAgICAgIGh1bmdyeU1lcmdlID0ge1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzOiBtZXJnZS5lbnRyaWVzLmNvbmNhdChodW5ncnlNZXJnZS5lbnRyaWVzKSxcbiAgICAgICAgICAgICAgICAgICAgc3Bhbjogam9pblNwYW5zKG1lcmdlLnNwYW4sIGh1bmdyeU1lcmdlLnNwYW4pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZE1lcmdlcy5wdXNoKG1lcmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaWx0ZXJlZE1lcmdlcy5wdXNoKGh1bmdyeU1lcmdlKTtcbiAgICAgICAgbWVyZ2VzID0gZmlsdGVyZWRNZXJnZXM7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZXM7XG59XG5mdW5jdGlvbiBqb2luU3BhbnMoc3BhbjAsIHNwYW4xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IE1hdGgubWluKHNwYW4wLnN0YXJ0LCBzcGFuMS5zdGFydCksXG4gICAgICAgIGVuZDogTWF0aC5tYXgoc3BhbjAuZW5kLCBzcGFuMS5lbmQpLFxuICAgIH07XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RTcGFucyhzcGFuMCwgc3BhbjEpIHtcbiAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChzcGFuMC5zdGFydCwgc3BhbjEuc3RhcnQpO1xuICAgIGxldCBlbmQgPSBNYXRoLm1pbihzcGFuMC5lbmQsIHNwYW4xLmVuZCk7XG4gICAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyBnZW5lcmFsIHV0aWxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gaW5zZXJ0QXQoYXJyLCBpbmRleCwgaXRlbSkge1xuICAgIGFyci5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pO1xufVxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGEsIHNlYXJjaFZhbCwgZ2V0SXRlbVZhbCkge1xuICAgIGxldCBzdGFydEluZGV4ID0gMDtcbiAgICBsZXQgZW5kSW5kZXggPSBhLmxlbmd0aDsgLy8gZXhjbHVzaXZlXG4gICAgaWYgKCFlbmRJbmRleCB8fCBzZWFyY2hWYWwgPCBnZXRJdGVtVmFsKGFbc3RhcnRJbmRleF0pKSB7IC8vIG5vIGl0ZW1zIE9SIGJlZm9yZSBmaXJzdCBpdGVtXG4gICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgfVxuICAgIGlmIChzZWFyY2hWYWwgPiBnZXRJdGVtVmFsKGFbZW5kSW5kZXggLSAxXSkpIHsgLy8gYWZ0ZXIgbGFzdCBpdGVtXG4gICAgICAgIHJldHVybiBbZW5kSW5kZXgsIDBdO1xuICAgIH1cbiAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGVuZEluZGV4KSB7XG4gICAgICAgIGxldCBtaWRkbGVJbmRleCA9IE1hdGguZmxvb3Ioc3RhcnRJbmRleCArIChlbmRJbmRleCAtIHN0YXJ0SW5kZXgpIC8gMik7XG4gICAgICAgIGxldCBtaWRkbGVWYWwgPSBnZXRJdGVtVmFsKGFbbWlkZGxlSW5kZXhdKTtcbiAgICAgICAgaWYgKHNlYXJjaFZhbCA8IG1pZGRsZVZhbCkge1xuICAgICAgICAgICAgZW5kSW5kZXggPSBtaWRkbGVJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWFyY2hWYWwgPiBtaWRkbGVWYWwpIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBtaWRkbGVJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIGVxdWFsIVxuICAgICAgICAgICAgcmV0dXJuIFttaWRkbGVJbmRleCwgMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtzdGFydEluZGV4LCAwXTtcbn1cblxuLypcbkFuIGFic3RyYWN0aW9uIGZvciBhIGRyYWdnaW5nIGludGVyYWN0aW9uIG9yaWdpbmF0aW5nIG9uIGFuIGV2ZW50LlxuRG9lcyBoaWdoZXItbGV2ZWwgdGhpbmdzIHRoYW4gUG9pbnRlckRyYWdnZXIsIHN1Y2ggYXMgcG9zc2libHk6XG4tIGEgXCJtaXJyb3JcIiB0aGF0IG1vdmVzIHdpdGggdGhlIHBvaW50ZXJcbi0gYSBtaW5pbXVtIG51bWJlciBvZiBwaXhlbHMgb3Igb3RoZXIgY3JpdGVyaWEgZm9yIGEgdHJ1ZSBkcmFnIHRvIGJlZ2luXG5cbnN1YmNsYXNzZXMgbXVzdCBlbWl0OlxuLSBwb2ludGVyZG93blxuLSBkcmFnc3RhcnRcbi0gZHJhZ21vdmVcbi0gcG9pbnRlcnVwXG4tIGRyYWdlbmRcbiovXG5jbGFzcyBFbGVtZW50RHJhZ2dpbmcge1xuICAgIGNvbnN0cnVjdG9yKGVsLCBzZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgIH1cbiAgICBzZXRNaXJyb3JJc1Zpc2libGUoYm9vbCkge1xuICAgICAgICAvLyBvcHRpb25hbCBpZiBzdWJjbGFzcyBkb2Vzbid0IHdhbnQgdG8gc3VwcG9ydCBhIG1pcnJvclxuICAgIH1cbiAgICBzZXRNaXJyb3JOZWVkc1JldmVydChib29sKSB7XG4gICAgICAgIC8vIG9wdGlvbmFsIGlmIHN1YmNsYXNzIGRvZXNuJ3Qgd2FudCB0byBzdXBwb3J0IGEgbWlycm9yXG4gICAgfVxuICAgIHNldEF1dG9TY3JvbGxFbmFibGVkKGJvb2wpIHtcbiAgICAgICAgLy8gb3B0aW9uYWxcbiAgICB9XG59XG5cbi8vIFRPRE86IGdldCByaWQgb2YgdGhpcyBpbiBmYXZvciBvZiBvcHRpb25zIHN5c3RlbSxcbi8vIHRobyBpdCdzIHJlYWxseSBlYXN5IHRvIGFjY2VzcyB0aGlzIGdsb2JhbGx5IHJhdGhlciB0aGFuIHBhc3MgdGhydSBvcHRpb25zLlxuY29uc3QgY29uZmlnID0ge307XG5cbi8qXG5JbmZvcm1hdGlvbiBhYm91dCB3aGF0IHdpbGwgaGFwcGVuIHdoZW4gYW4gZXh0ZXJuYWwgZWxlbWVudCBpcyBkcmFnZ2VkLWFuZC1kcm9wcGVkXG5vbnRvIGEgY2FsZW5kYXIuIENvbnRhaW5zIGluZm9ybWF0aW9uIGZvciBjcmVhdGluZyBhbiBldmVudC5cbiovXG5jb25zdCBEUkFHX01FVEFfUkVGSU5FUlMgPSB7XG4gICAgc3RhcnRUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gICAgY3JlYXRlOiBCb29sZWFuLFxuICAgIHNvdXJjZUlkOiBTdHJpbmcsXG59O1xuZnVuY3Rpb24gcGFyc2VEcmFnTWV0YShyYXcpIHtcbiAgICBsZXQgeyByZWZpbmVkLCBleHRyYSB9ID0gcmVmaW5lUHJvcHMocmF3LCBEUkFHX01FVEFfUkVGSU5FUlMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0VGltZTogcmVmaW5lZC5zdGFydFRpbWUgfHwgbnVsbCxcbiAgICAgICAgZHVyYXRpb246IHJlZmluZWQuZHVyYXRpb24gfHwgbnVsbCxcbiAgICAgICAgY3JlYXRlOiByZWZpbmVkLmNyZWF0ZSAhPSBudWxsID8gcmVmaW5lZC5jcmVhdGUgOiB0cnVlLFxuICAgICAgICBzb3VyY2VJZDogcmVmaW5lZC5zb3VyY2VJZCxcbiAgICAgICAgbGVmdG92ZXJQcm9wczogZXh0cmEsXG4gICAgfTtcbn1cblxuLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGNvbHVtbiBoZWFkZXIgZm9ybWF0dGluZyBzdHJpbmcgaWYgYGNvbEZvcm1hdGAgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZFxuZnVuY3Rpb24gY29tcHV0ZUZhbGxiYWNrSGVhZGVyRm9ybWF0KGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXlDbnQpIHtcbiAgICAvLyBpZiBtb3JlIHRoYW4gb25lIHdlZWsgcm93LCBvciBpZiB0aGVyZSBhcmUgYSBsb3Qgb2YgY29sdW1ucyB3aXRoIG5vdCBtdWNoIHNwYWNlLFxuICAgIC8vIHB1dCBqdXN0IHRoZSBkYXkgbnVtYmVycyB3aWxsIGJlIGluIGVhY2ggY2VsbFxuICAgIGlmICghZGF0ZXNSZXBEaXN0aW5jdERheXMgfHwgZGF5Q250ID4gMTApIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdzaG9ydCcgfSk7IC8vIFwiU2F0XCJcbiAgICB9XG4gICAgaWYgKGRheUNudCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdzaG9ydCcsIG1vbnRoOiAnbnVtZXJpYycsIGRheTogJ251bWVyaWMnLCBvbWl0Q29tbWFzOiB0cnVlIH0pOyAvLyBcIlNhdCAxMS8xMlwiXG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrZGF5OiAnbG9uZycgfSk7IC8vIFwiU2F0dXJkYXlcIlxufVxuXG5jb25zdCBDTEFTU19OQU1FID0gJ2ZjLWNvbC1oZWFkZXItY2VsbCc7IC8vIGRvIHRoZSBjdXNoaW9uIHRvbz8gbm9cbmZ1bmN0aW9uIHJlbmRlcklubmVyJDEocmVuZGVyUHJvcHMpIHtcbiAgICByZXR1cm4gcmVuZGVyUHJvcHMudGV4dDtcbn1cblxuLy8gQkFEIG5hbWUgZm9yIHRoaXMgY2xhc3Mgbm93LiB1c2VkIGluIHRoZSBIZWFkZXJcbmNsYXNzIFRhYmxlRGF0ZUNlbGwgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMsIHRoZW1lLCB2aWV3QXBpIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBkYXRlLCBkYXRlUHJvZmlsZSB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBkYXlNZXRhID0gZ2V0RGF0ZU1ldGEoZGF0ZSwgcHJvcHMudG9kYXlSYW5nZSwgbnVsbCwgZGF0ZVByb2ZpbGUpO1xuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtDTEFTU19OQU1FXS5jb25jYXQoZ2V0RGF5Q2xhc3NOYW1lcyhkYXlNZXRhLCB0aGVtZSkpO1xuICAgICAgICBsZXQgdGV4dCA9IGRhdGVFbnYuZm9ybWF0KGRhdGUsIHByb3BzLmRheUhlYWRlckZvcm1hdCk7XG4gICAgICAgIC8vIGlmIGNvbENudCBpcyAxLCB3ZSBhcmUgYWxyZWFkeSBpbiBhIGRheS12aWV3IGFuZCBkb24ndCBuZWVkIGEgbmF2bGlua1xuICAgICAgICBsZXQgbmF2TGlua0F0dHJzID0gKCFkYXlNZXRhLmlzRGlzYWJsZWQgJiYgcHJvcHMuY29sQ250ID4gMSlcbiAgICAgICAgICAgID8gYnVpbGROYXZMaW5rQXR0cnModGhpcy5jb250ZXh0LCBkYXRlKVxuICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgbGV0IHJlbmRlclByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBkYXRlOiBkYXRlRW52LnRvRGF0ZShkYXRlKSwgdmlldzogdmlld0FwaSB9LCBwcm9wcy5leHRyYVJlbmRlclByb3BzKSwgeyB0ZXh0IH0pLCBkYXlNZXRhKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwidGhcIiwgZWxDbGFzc2VzOiBjbGFzc05hbWVzLCBlbEF0dHJzOiBPYmplY3QuYXNzaWduKHsgcm9sZTogJ2NvbHVtbmhlYWRlcicsIGNvbFNwYW46IHByb3BzLmNvbFNwYW4sICdkYXRhLWRhdGUnOiAhZGF5TWV0YS5pc0Rpc2FibGVkID8gZm9ybWF0RGF5U3RyaW5nKGRhdGUpIDogdW5kZWZpbmVkIH0sIHByb3BzLmV4dHJhRGF0YUF0dHJzKSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImRheUhlYWRlckNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmRheUhlYWRlckNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyJDEsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5kYXlIZWFkZXJDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5kYXlIZWFkZXJEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyV2lsbFVubW91bnQgfSwgKElubmVyQ29udGFpbmVyKSA9PiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXJcIiB9LCAhZGF5TWV0YS5pc0Rpc2FibGVkICYmIChjcmVhdGVFbGVtZW50KElubmVyQ29udGFpbmVyLCB7IGVsVGFnOiBcImFcIiwgZWxBdHRyczogbmF2TGlua0F0dHJzLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAnZmMtY29sLWhlYWRlci1jZWxsLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgIHByb3BzLmlzU3RpY2t5ICYmICdmYy1zdGlja3knLFxuICAgICAgICAgICAgXSB9KSkpKSkpO1xuICAgIH1cbn1cblxuY29uc3QgV0VFS0RBWV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrZGF5OiAnbG9uZycgfSk7XG5jbGFzcyBUYWJsZURvd0NlbGwgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBkYXRlRW52LCB0aGVtZSwgdmlld0FwaSwgb3B0aW9ucyB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgZGF0ZSA9IGFkZERheXMobmV3IERhdGUoMjU5MjAwMDAwKSwgcHJvcHMuZG93KTsgLy8gc3RhcnQgd2l0aCBTdW4sIDA0IEphbiAxOTcwIDAwOjAwOjAwIEdNVFxuICAgICAgICBsZXQgZGF0ZU1ldGEgPSB7XG4gICAgICAgICAgICBkb3c6IHByb3BzLmRvdyxcbiAgICAgICAgICAgIGlzRGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNGdXR1cmU6IGZhbHNlLFxuICAgICAgICAgICAgaXNQYXN0OiBmYWxzZSxcbiAgICAgICAgICAgIGlzVG9kYXk6IGZhbHNlLFxuICAgICAgICAgICAgaXNPdGhlcjogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIGxldCB0ZXh0ID0gZGF0ZUVudi5mb3JtYXQoZGF0ZSwgcHJvcHMuZGF5SGVhZGVyRm9ybWF0KTtcbiAgICAgICAgbGV0IHJlbmRlclByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IC8vIFRPRE86IG1ha2UgdGhpcyBwdWJsaWM/XG4gICAgICAgICAgICBkYXRlIH0sIGRhdGVNZXRhKSwgeyB2aWV3OiB2aWV3QXBpIH0pLCBwcm9wcy5leHRyYVJlbmRlclByb3BzKSwgeyB0ZXh0IH0pO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJ0aFwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICBDTEFTU19OQU1FLFxuICAgICAgICAgICAgICAgIC4uLmdldERheUNsYXNzTmFtZXMoZGF0ZU1ldGEsIHRoZW1lKSxcbiAgICAgICAgICAgICAgICAuLi4ocHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKSxcbiAgICAgICAgICAgIF0sIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oeyByb2xlOiAnY29sdW1uaGVhZGVyJywgY29sU3BhbjogcHJvcHMuY29sU3BhbiB9LCBwcm9wcy5leHRyYURhdGFBdHRycyksIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJkYXlIZWFkZXJDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5kYXlIZWFkZXJDb250ZW50LCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lciQxLCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMuZGF5SGVhZGVyQ2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmRheUhlYWRlcldpbGxVbm1vdW50IH0sIChJbm5lckNvbnRlbnQpID0+IChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc3luYy1pbm5lclwiIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJhXCIsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICAgICAnZmMtY29sLWhlYWRlci1jZWxsLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5pc1N0aWNreSAmJiAnZmMtc3RpY2t5JyxcbiAgICAgICAgICAgICAgICBdLCBlbEF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdhcmlhLWxhYmVsJzogZGF0ZUVudi5mb3JtYXQoZGF0ZSwgV0VFS0RBWV9GT1JNQVQpLFxuICAgICAgICAgICAgICAgIH0gfSkpKSkpO1xuICAgIH1cbn1cblxuY2xhc3MgTm93VGltZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy5pbml0aWFsTm93RGF0ZSA9IGdldE5vdyhjb250ZXh0Lm9wdGlvbnMubm93LCBjb250ZXh0LmRhdGVFbnYpO1xuICAgICAgICB0aGlzLmluaXRpYWxOb3dRdWVyaWVkTXMgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuY29tcHV0ZVRpbWluZygpLmN1cnJlbnRTdGF0ZTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbihzdGF0ZS5ub3dEYXRlLCBzdGF0ZS50b2RheVJhbmdlKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuc2V0VGltZW91dCgpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGlmIChwcmV2UHJvcHMudW5pdCAhPT0gdGhpcy5wcm9wcy51bml0KSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgfVxuICAgIGNvbXB1dGVUaW1pbmcoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgdW5yb3VuZGVkTm93ID0gYWRkTXModGhpcy5pbml0aWFsTm93RGF0ZSwgbmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLmluaXRpYWxOb3dRdWVyaWVkTXMpO1xuICAgICAgICBsZXQgY3VycmVudFVuaXRTdGFydCA9IGNvbnRleHQuZGF0ZUVudi5zdGFydE9mKHVucm91bmRlZE5vdywgcHJvcHMudW5pdCk7XG4gICAgICAgIGxldCBuZXh0VW5pdFN0YXJ0ID0gY29udGV4dC5kYXRlRW52LmFkZChjdXJyZW50VW5pdFN0YXJ0LCBjcmVhdGVEdXJhdGlvbigxLCBwcm9wcy51bml0KSk7XG4gICAgICAgIGxldCB3YWl0TXMgPSBuZXh0VW5pdFN0YXJ0LnZhbHVlT2YoKSAtIHVucm91bmRlZE5vdy52YWx1ZU9mKCk7XG4gICAgICAgIC8vIHRoZXJlIGlzIGEgbWF4IHNldFRpbWVvdXQgbXMgdmFsdWUgKGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNDY4NjUwLzk2MzQyKVxuICAgICAgICAvLyBlbnN1cmUgbm8gbG9uZ2VyIHRoYW4gYSBkYXlcbiAgICAgICAgd2FpdE1zID0gTWF0aC5taW4oMTAwMCAqIDYwICogNjAgKiAyNCwgd2FpdE1zKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZTogeyBub3dEYXRlOiBjdXJyZW50VW5pdFN0YXJ0LCB0b2RheVJhbmdlOiBidWlsZERheVJhbmdlKGN1cnJlbnRVbml0U3RhcnQpIH0sXG4gICAgICAgICAgICBuZXh0U3RhdGU6IHsgbm93RGF0ZTogbmV4dFVuaXRTdGFydCwgdG9kYXlSYW5nZTogYnVpbGREYXlSYW5nZShuZXh0VW5pdFN0YXJ0KSB9LFxuICAgICAgICAgICAgd2FpdE1zLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KCkge1xuICAgICAgICBsZXQgeyBuZXh0U3RhdGUsIHdhaXRNcyB9ID0gdGhpcy5jb21wdXRlVGltaW5nKCk7XG4gICAgICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKG5leHRTdGF0ZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VGltZW91dCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHdhaXRNcyk7XG4gICAgfVxuICAgIGNsZWFyVGltZW91dCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuTm93VGltZXIuY29udGV4dFR5cGUgPSBWaWV3Q29udGV4dFR5cGU7XG5mdW5jdGlvbiBidWlsZERheVJhbmdlKGRhdGUpIHtcbiAgICBsZXQgc3RhcnQgPSBzdGFydE9mRGF5KGRhdGUpO1xuICAgIGxldCBlbmQgPSBhZGREYXlzKHN0YXJ0LCAxKTtcbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG59XG5cbmNsYXNzIERheUhlYWRlciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNyZWF0ZURheUhlYWRlckZvcm1hdHRlciA9IG1lbW9pemUoY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBkYXRlcywgZGF0ZVByb2ZpbGUsIGRhdGVzUmVwRGlzdGluY3REYXlzLCByZW5kZXJJbnRybyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IGRheUhlYWRlckZvcm1hdCA9IHRoaXMuY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKGNvbnRleHQub3B0aW9ucy5kYXlIZWFkZXJGb3JtYXQsIGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXRlcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTm93VGltZXIsIHsgdW5pdDogXCJkYXlcIiB9LCAobm93RGF0ZSwgdG9kYXlSYW5nZSkgPT4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJvbGU6IFwicm93XCIgfSxcbiAgICAgICAgICAgIHJlbmRlckludHJvICYmIHJlbmRlckludHJvKCdkYXknKSxcbiAgICAgICAgICAgIGRhdGVzLm1hcCgoZGF0ZSkgPT4gKGRhdGVzUmVwRGlzdGluY3REYXlzID8gKGNyZWF0ZUVsZW1lbnQoVGFibGVEYXRlQ2VsbCwgeyBrZXk6IGRhdGUudG9JU09TdHJpbmcoKSwgZGF0ZTogZGF0ZSwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlLCBjb2xDbnQ6IGRhdGVzLmxlbmd0aCwgZGF5SGVhZGVyRm9ybWF0OiBkYXlIZWFkZXJGb3JtYXQgfSkpIDogKGNyZWF0ZUVsZW1lbnQoVGFibGVEb3dDZWxsLCB7IGtleTogZGF0ZS5nZXRVVENEYXkoKSwgZG93OiBkYXRlLmdldFVUQ0RheSgpLCBkYXlIZWFkZXJGb3JtYXQ6IGRheUhlYWRlckZvcm1hdCB9KSkpKSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKGV4cGxpY2l0Rm9ybWF0LCBkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF0ZUNudCkge1xuICAgIHJldHVybiBleHBsaWNpdEZvcm1hdCB8fCBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQoZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRhdGVDbnQpO1xufVxuXG5jbGFzcyBEYXlTZXJpZXNNb2RlbCB7XG4gICAgY29uc3RydWN0b3IocmFuZ2UsIGRhdGVQcm9maWxlR2VuZXJhdG9yKSB7XG4gICAgICAgIGxldCBkYXRlID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIGxldCB7IGVuZCB9ID0gcmFuZ2U7XG4gICAgICAgIGxldCBpbmRpY2VzID0gW107XG4gICAgICAgIGxldCBkYXRlcyA9IFtdO1xuICAgICAgICBsZXQgZGF5SW5kZXggPSAtMTtcbiAgICAgICAgd2hpbGUgKGRhdGUgPCBlbmQpIHsgLy8gbG9vcCBlYWNoIGRheSBmcm9tIHN0YXJ0IHRvIGVuZFxuICAgICAgICAgICAgaWYgKGRhdGVQcm9maWxlR2VuZXJhdG9yLmlzSGlkZGVuRGF5KGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGRheUluZGV4ICsgMC41KTsgLy8gbWFyayB0aGF0IGl0J3MgYmV0d2VlbiBpbmRpY2VzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXlJbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChkYXlJbmRleCk7XG4gICAgICAgICAgICAgICAgZGF0ZXMucHVzaChkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGUgPSBhZGREYXlzKGRhdGUsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0ZXMgPSBkYXRlcztcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gaW5kaWNlcztcbiAgICAgICAgdGhpcy5jbnQgPSBkYXRlcy5sZW5ndGg7XG4gICAgfVxuICAgIHNsaWNlUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgbGV0IGZpcnN0SW5kZXggPSB0aGlzLmdldERhdGVEYXlJbmRleChyYW5nZS5zdGFydCk7IC8vIGluY2x1c2l2ZSBmaXJzdCBpbmRleFxuICAgICAgICBsZXQgbGFzdEluZGV4ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgoYWRkRGF5cyhyYW5nZS5lbmQsIC0xKSk7IC8vIGluY2x1c2l2ZSBsYXN0IGluZGV4XG4gICAgICAgIGxldCBjbGlwcGVkRmlyc3RJbmRleCA9IE1hdGgubWF4KDAsIGZpcnN0SW5kZXgpO1xuICAgICAgICBsZXQgY2xpcHBlZExhc3RJbmRleCA9IE1hdGgubWluKHRoaXMuY250IC0gMSwgbGFzdEluZGV4KTtcbiAgICAgICAgLy8gZGVhbCB3aXRoIGluLWJldHdlZW4gaW5kaWNlc1xuICAgICAgICBjbGlwcGVkRmlyc3RJbmRleCA9IE1hdGguY2VpbChjbGlwcGVkRmlyc3RJbmRleCk7IC8vIGluLWJldHdlZW4gc3RhcnRzIHJvdW5kIHRvIG5leHQgY2VsbFxuICAgICAgICBjbGlwcGVkTGFzdEluZGV4ID0gTWF0aC5mbG9vcihjbGlwcGVkTGFzdEluZGV4KTsgLy8gaW4tYmV0d2VlbiBlbmRzIHJvdW5kIHRvIHByZXYgY2VsbFxuICAgICAgICBpZiAoY2xpcHBlZEZpcnN0SW5kZXggPD0gY2xpcHBlZExhc3RJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmaXJzdEluZGV4OiBjbGlwcGVkRmlyc3RJbmRleCxcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXg6IGNsaXBwZWRMYXN0SW5kZXgsXG4gICAgICAgICAgICAgICAgaXNTdGFydDogZmlyc3RJbmRleCA9PT0gY2xpcHBlZEZpcnN0SW5kZXgsXG4gICAgICAgICAgICAgICAgaXNFbmQ6IGxhc3RJbmRleCA9PT0gY2xpcHBlZExhc3RJbmRleCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEdpdmVuIGEgZGF0ZSwgcmV0dXJucyBpdHMgY2hyb25vbG9jaWFsIGNlbGwtaW5kZXggZnJvbSB0aGUgZmlyc3QgY2VsbCBvZiB0aGUgZ3JpZC5cbiAgICAvLyBJZiB0aGUgZGF0ZSBsaWVzIGJldHdlZW4gY2VsbHMgKGJlY2F1c2Ugb2YgaGlkZGVuRGF5cyksIHJldHVybnMgYSBmbG9hdGluZy1wb2ludCB2YWx1ZSBiZXR3ZWVuIG9mZnNldHMuXG4gICAgLy8gSWYgYmVmb3JlIHRoZSBmaXJzdCBvZmZzZXQsIHJldHVybnMgYSBuZWdhdGl2ZSBudW1iZXIuXG4gICAgLy8gSWYgYWZ0ZXIgdGhlIGxhc3Qgb2Zmc2V0LCByZXR1cm5zIGFuIG9mZnNldCBwYXN0IHRoZSBsYXN0IGNlbGwgb2Zmc2V0LlxuICAgIC8vIE9ubHkgd29ya3MgZm9yICpzdGFydCogZGF0ZXMgb2YgY2VsbHMuIFdpbGwgbm90IHdvcmsgZm9yIGV4Y2x1c2l2ZSBlbmQgZGF0ZXMgZm9yIGNlbGxzLlxuICAgIGdldERhdGVEYXlJbmRleChkYXRlKSB7XG4gICAgICAgIGxldCB7IGluZGljZXMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBkYXlPZmZzZXQgPSBNYXRoLmZsb29yKGRpZmZEYXlzKHRoaXMuZGF0ZXNbMF0sIGRhdGUpKTtcbiAgICAgICAgaWYgKGRheU9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRpY2VzWzBdIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5T2Zmc2V0ID49IGluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kaWNlc1tkYXlPZmZzZXRdO1xuICAgIH1cbn1cblxuY2xhc3MgRGF5VGFibGVNb2RlbCB7XG4gICAgY29uc3RydWN0b3IoZGF5U2VyaWVzLCBicmVha09uV2Vla3MpIHtcbiAgICAgICAgbGV0IHsgZGF0ZXMgfSA9IGRheVNlcmllcztcbiAgICAgICAgbGV0IGRheXNQZXJSb3c7XG4gICAgICAgIGxldCBmaXJzdERheTtcbiAgICAgICAgbGV0IHJvd0NudDtcbiAgICAgICAgaWYgKGJyZWFrT25XZWVrcykge1xuICAgICAgICAgICAgLy8gY291bnQgY29sdW1ucyB1bnRpbCB0aGUgZGF5LW9mLXdlZWsgcmVwZWF0c1xuICAgICAgICAgICAgZmlyc3REYXkgPSBkYXRlc1swXS5nZXRVVENEYXkoKTtcbiAgICAgICAgICAgIGZvciAoZGF5c1BlclJvdyA9IDE7IGRheXNQZXJSb3cgPCBkYXRlcy5sZW5ndGg7IGRheXNQZXJSb3cgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRlc1tkYXlzUGVyUm93XS5nZXRVVENEYXkoKSA9PT0gZmlyc3REYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93Q250ID0gTWF0aC5jZWlsKGRhdGVzLmxlbmd0aCAvIGRheXNQZXJSb3cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcm93Q250ID0gMTtcbiAgICAgICAgICAgIGRheXNQZXJSb3cgPSBkYXRlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3dDbnQgPSByb3dDbnQ7XG4gICAgICAgIHRoaXMuY29sQ250ID0gZGF5c1BlclJvdztcbiAgICAgICAgdGhpcy5kYXlTZXJpZXMgPSBkYXlTZXJpZXM7XG4gICAgICAgIHRoaXMuY2VsbHMgPSB0aGlzLmJ1aWxkQ2VsbHMoKTtcbiAgICAgICAgdGhpcy5oZWFkZXJEYXRlcyA9IHRoaXMuYnVpbGRIZWFkZXJEYXRlcygpO1xuICAgIH1cbiAgICBidWlsZENlbGxzKCkge1xuICAgICAgICBsZXQgcm93cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0aGlzLnJvd0NudDsgcm93ICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBjZWxscyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICAgICAgY2VsbHMucHVzaCh0aGlzLmJ1aWxkQ2VsbChyb3csIGNvbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93cy5wdXNoKGNlbGxzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93cztcbiAgICB9XG4gICAgYnVpbGRDZWxsKHJvdywgY29sKSB7XG4gICAgICAgIGxldCBkYXRlID0gdGhpcy5kYXlTZXJpZXMuZGF0ZXNbcm93ICogdGhpcy5jb2xDbnQgKyBjb2xdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiBkYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBidWlsZEhlYWRlckRhdGVzKCkge1xuICAgICAgICBsZXQgZGF0ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBkYXRlcy5wdXNoKHRoaXMuY2VsbHNbMF1bY29sXS5kYXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZXM7XG4gICAgfVxuICAgIHNsaWNlUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgbGV0IHsgY29sQ250IH0gPSB0aGlzO1xuICAgICAgICBsZXQgc2VyaWVzU2VnID0gdGhpcy5kYXlTZXJpZXMuc2xpY2VSYW5nZShyYW5nZSk7XG4gICAgICAgIGxldCBzZWdzID0gW107XG4gICAgICAgIGlmIChzZXJpZXNTZWcpIHtcbiAgICAgICAgICAgIGxldCB7IGZpcnN0SW5kZXgsIGxhc3RJbmRleCB9ID0gc2VyaWVzU2VnO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gZmlyc3RJbmRleDtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsZXQgcm93ID0gTWF0aC5mbG9vcihpbmRleCAvIGNvbENudCk7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRJbmRleCA9IE1hdGgubWluKChyb3cgKyAxKSAqIGNvbENudCwgbGFzdEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgICAgICAgICBmaXJzdENvbDogaW5kZXggJSBjb2xDbnQsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb2w6IChuZXh0SW5kZXggLSAxKSAlIGNvbENudCxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VyaWVzU2VnLmlzU3RhcnQgJiYgaW5kZXggPT09IGZpcnN0SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZXJpZXNTZWcuaXNFbmQgJiYgKG5leHRJbmRleCAtIDEpID09PSBsYXN0SW5kZXgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfVxufVxuXG5jbGFzcyBTbGljZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNsaWNlQnVzaW5lc3NIb3VycyA9IG1lbW9pemUodGhpcy5fc2xpY2VCdXNpbmVzc0hvdXJzKTtcbiAgICAgICAgdGhpcy5zbGljZURhdGVTZWxlY3Rpb24gPSBtZW1vaXplKHRoaXMuX3NsaWNlRGF0ZVNwYW4pO1xuICAgICAgICB0aGlzLnNsaWNlRXZlbnRTdG9yZSA9IG1lbW9pemUodGhpcy5fc2xpY2VFdmVudFN0b3JlKTtcbiAgICAgICAgdGhpcy5zbGljZUV2ZW50RHJhZyA9IG1lbW9pemUodGhpcy5fc2xpY2VJbnRlcmFjdGlvbik7XG4gICAgICAgIHRoaXMuc2xpY2VFdmVudFJlc2l6ZSA9IG1lbW9pemUodGhpcy5fc2xpY2VJbnRlcmFjdGlvbik7XG4gICAgICAgIHRoaXMuZm9yY2VEYXlJZkxpc3RJdGVtID0gZmFsc2U7IC8vIGhhY2tcbiAgICB9XG4gICAgc2xpY2VQcm9wcyhwcm9wcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIC4uLmV4dHJhQXJncykge1xuICAgICAgICBsZXQgeyBldmVudFVpQmFzZXMgfSA9IHByb3BzO1xuICAgICAgICBsZXQgZXZlbnRTZWdzID0gdGhpcy5zbGljZUV2ZW50U3RvcmUocHJvcHMuZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgLi4uZXh0cmFBcmdzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb25TZWdzOiB0aGlzLnNsaWNlRGF0ZVNlbGVjdGlvbihwcm9wcy5kYXRlU2VsZWN0aW9uLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgZXZlbnRVaUJhc2VzLCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpLFxuICAgICAgICAgICAgYnVzaW5lc3NIb3VyU2VnczogdGhpcy5zbGljZUJ1c2luZXNzSG91cnMocHJvcHMuYnVzaW5lc3NIb3VycywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIC4uLmV4dHJhQXJncyksXG4gICAgICAgICAgICBmZ0V2ZW50U2VnczogZXZlbnRTZWdzLmZnLFxuICAgICAgICAgICAgYmdFdmVudFNlZ3M6IGV2ZW50U2Vncy5iZyxcbiAgICAgICAgICAgIGV2ZW50RHJhZzogdGhpcy5zbGljZUV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncyksXG4gICAgICAgICAgICBldmVudFJlc2l6ZTogdGhpcy5zbGljZUV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpLFxuICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLFxuICAgICAgICB9OyAvLyBUT0RPOiBnaXZlIGludGVyYWN0aW9uU2Vncz9cbiAgICB9XG4gICAgc2xpY2VOb3dEYXRlKC8vIGRvZXMgbm90IG1lbW9pemVcbiAgICBkYXRlLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgLi4uZXh0cmFBcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zbGljZURhdGVTcGFuKHsgcmFuZ2U6IHsgc3RhcnQ6IGRhdGUsIGVuZDogYWRkTXMoZGF0ZSwgMSkgfSwgYWxsRGF5OiBmYWxzZSB9LCAvLyBhZGQgMSBtcywgcHJvdGVjdCBhZ2FpbnN0IG51bGwgcmFuZ2VcbiAgICAgICAgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIHt9LCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpO1xuICAgIH1cbiAgICBfc2xpY2VCdXNpbmVzc0hvdXJzKGJ1c2luZXNzSG91cnMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpIHtcbiAgICAgICAgaWYgKCFidXNpbmVzc0hvdXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NsaWNlRXZlbnRTdG9yZShleHBhbmRSZWN1cnJpbmcoYnVzaW5lc3NIb3VycywgY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKSwgY29udGV4dCksIHt9LCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgLi4uZXh0cmFBcmdzKS5iZztcbiAgICB9XG4gICAgX3NsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpIHtcbiAgICAgICAgaWYgKGV2ZW50U3RvcmUpIHtcbiAgICAgICAgICAgIGxldCByYW5nZVJlcyA9IHNsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgQm9vbGVhbihuZXh0RGF5VGhyZXNob2xkKSksIG5leHREYXlUaHJlc2hvbGQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBiZzogdGhpcy5zbGljZUV2ZW50UmFuZ2VzKHJhbmdlUmVzLmJnLCBleHRyYUFyZ3MpLFxuICAgICAgICAgICAgICAgIGZnOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuZmcsIGV4dHJhQXJncyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGJnOiBbXSwgZmc6IFtdIH07XG4gICAgfVxuICAgIF9zbGljZUludGVyYWN0aW9uKGludGVyYWN0aW9uLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpIHtcbiAgICAgICAgaWYgKCFpbnRlcmFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJhbmdlUmVzID0gc2xpY2VFdmVudFN0b3JlKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMsIGV2ZW50VWlCYXNlcywgY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKSwgbmV4dERheVRocmVzaG9sZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZWdzOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuZmcsIGV4dHJhQXJncyksXG4gICAgICAgICAgICBhZmZlY3RlZEluc3RhbmNlczogaW50ZXJhY3Rpb24uYWZmZWN0ZWRFdmVudHMuaW5zdGFuY2VzLFxuICAgICAgICAgICAgaXNFdmVudDogaW50ZXJhY3Rpb24uaXNFdmVudCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3NsaWNlRGF0ZVNwYW4oZGF0ZVNwYW4sIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBldmVudFVpQmFzZXMsIGNvbnRleHQsIC4uLmV4dHJhQXJncykge1xuICAgICAgICBpZiAoIWRhdGVTcGFuKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFjdGl2ZVJhbmdlID0gY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKTtcbiAgICAgICAgbGV0IGFjdGl2ZURhdGVTcGFuUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoZGF0ZVNwYW4ucmFuZ2UsIGFjdGl2ZVJhbmdlKTtcbiAgICAgICAgaWYgKGFjdGl2ZURhdGVTcGFuUmFuZ2UpIHtcbiAgICAgICAgICAgIGRhdGVTcGFuID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRlU3BhbiksIHsgcmFuZ2U6IGFjdGl2ZURhdGVTcGFuUmFuZ2UgfSk7XG4gICAgICAgICAgICBsZXQgZXZlbnRSYW5nZSA9IGZhYnJpY2F0ZUV2ZW50UmFuZ2UoZGF0ZVNwYW4sIGV2ZW50VWlCYXNlcywgY29udGV4dCk7XG4gICAgICAgICAgICBsZXQgc2VncyA9IHRoaXMuc2xpY2VSYW5nZShkYXRlU3Bhbi5yYW5nZSwgLi4uZXh0cmFBcmdzKTtcbiAgICAgICAgICAgIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XG4gICAgICAgICAgICAgICAgc2VnLmV2ZW50UmFuZ2UgPSBldmVudFJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvKlxuICAgIFwiY29tcGxldGVcIiBzZWcgbWVhbnMgaXQgaGFzIGNvbXBvbmVudCBhbmQgZXZlbnRSYW5nZVxuICAgICovXG4gICAgc2xpY2VFdmVudFJhbmdlcyhldmVudFJhbmdlcywgZXh0cmFBcmdzKSB7XG4gICAgICAgIGxldCBzZWdzID0gW107XG4gICAgICAgIGZvciAobGV0IGV2ZW50UmFuZ2Ugb2YgZXZlbnRSYW5nZXMpIHtcbiAgICAgICAgICAgIHNlZ3MucHVzaCguLi50aGlzLnNsaWNlRXZlbnRSYW5nZShldmVudFJhbmdlLCBleHRyYUFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VncztcbiAgICB9XG4gICAgLypcbiAgICBcImNvbXBsZXRlXCIgc2VnIG1lYW5zIGl0IGhhcyBjb21wb25lbnQgYW5kIGV2ZW50UmFuZ2VcbiAgICAqL1xuICAgIHNsaWNlRXZlbnRSYW5nZShldmVudFJhbmdlLCBleHRyYUFyZ3MpIHtcbiAgICAgICAgbGV0IGRhdGVSYW5nZSA9IGV2ZW50UmFuZ2UucmFuZ2U7XG4gICAgICAgIC8vIGhhY2sgdG8gbWFrZSBtdWx0aS1kYXkgZXZlbnRzIHRoYXQgYXJlIGJlaW5nIGZvcmNlLWRpc3BsYXllZCBhcyBsaXN0LWl0ZW1zIHRvIHRha2UgdXAgb25seSBvbmUgZGF5XG4gICAgICAgIGlmICh0aGlzLmZvcmNlRGF5SWZMaXN0SXRlbSAmJiBldmVudFJhbmdlLnVpLmRpc3BsYXkgPT09ICdsaXN0LWl0ZW0nKSB7XG4gICAgICAgICAgICBkYXRlUmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGRhdGVSYW5nZS5zdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IGFkZERheXMoZGF0ZVJhbmdlLnN0YXJ0LCAxKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlZ3MgPSB0aGlzLnNsaWNlUmFuZ2UoZGF0ZVJhbmdlLCAuLi5leHRyYUFyZ3MpO1xuICAgICAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xuICAgICAgICAgICAgc2VnLmV2ZW50UmFuZ2UgPSBldmVudFJhbmdlO1xuICAgICAgICAgICAgc2VnLmlzU3RhcnQgPSBldmVudFJhbmdlLmlzU3RhcnQgJiYgc2VnLmlzU3RhcnQ7XG4gICAgICAgICAgICBzZWcuaXNFbmQgPSBldmVudFJhbmdlLmlzRW5kICYmIHNlZy5pc0VuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VncztcbiAgICB9XG59XG4vKlxuZm9yIGluY29ycG9yYXRpbmcgc2xvdE1pblRpbWUvc2xvdE1heFRpbWUgaWYgYXBwcm9wcmlhdGVcblRPRE86IHNob3VsZCBiZSBwYXJ0IG9mIERhdGVQcm9maWxlIVxuVGltZWxpbmVEYXRlUHJvZmlsZSBhbHJlYWR5IGRvZXMgdGhpcyBidHdcbiovXG5mdW5jdGlvbiBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIGlzQ29tcG9uZW50QWxsRGF5KSB7XG4gICAgbGV0IHJhbmdlID0gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2U7XG4gICAgaWYgKGlzQ29tcG9uZW50QWxsRGF5KSB7XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IGFkZE1zKHJhbmdlLnN0YXJ0LCBkYXRlUHJvZmlsZS5zbG90TWluVGltZS5taWxsaXNlY29uZHMpLFxuICAgICAgICBlbmQ6IGFkZE1zKHJhbmdlLmVuZCwgZGF0ZVByb2ZpbGUuc2xvdE1heFRpbWUubWlsbGlzZWNvbmRzIC0gODY0ZTUpLCAvLyA4NjRlNSA9IG1zIGluIGEgZGF5XG4gICAgfTtcbn1cblxuLy8gaGlnaC1sZXZlbCBzZWdtZW50aW5nLWF3YXJlIHRlc3RlciBmdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIGxldCB7IGluc3RhbmNlcyB9ID0gaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cztcbiAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNSYW5nZShkYXRlUHJvZmlsZS52YWxpZFJhbmdlLCBpbnN0YW5jZXNbaW5zdGFuY2VJZF0ucmFuZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzTmV3UHJvcHNWYWxpZCh7IGV2ZW50RHJhZzogaW50ZXJhY3Rpb24gfSwgY29udGV4dCk7IC8vIEhBQ0s6IHRoZSBldmVudERyYWcgcHJvcHMgaXMgdXNlZCBmb3IgQUxMIGludGVyYWN0aW9uc1xufVxuZnVuY3Rpb24gaXNEYXRlU2VsZWN0aW9uVmFsaWQoZGF0ZVNlbGVjdGlvbiwgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBpZiAoIXJhbmdlQ29udGFpbnNSYW5nZShkYXRlUHJvZmlsZS52YWxpZFJhbmdlLCBkYXRlU2VsZWN0aW9uLnJhbmdlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc05ld1Byb3BzVmFsaWQoeyBkYXRlU2VsZWN0aW9uIH0sIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gaXNOZXdQcm9wc1ZhbGlkKG5ld1Byb3BzLCBjb250ZXh0KSB7XG4gICAgbGV0IGNhbGVuZGFyU3RhdGUgPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCk7XG4gICAgbGV0IHByb3BzID0gT2JqZWN0LmFzc2lnbih7IGJ1c2luZXNzSG91cnM6IGNhbGVuZGFyU3RhdGUuYnVzaW5lc3NIb3VycywgZGF0ZVNlbGVjdGlvbjogJycsIGV2ZW50U3RvcmU6IGNhbGVuZGFyU3RhdGUuZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzOiBjYWxlbmRhclN0YXRlLmV2ZW50VWlCYXNlcywgZXZlbnRTZWxlY3Rpb246ICcnLCBldmVudERyYWc6IG51bGwsIGV2ZW50UmVzaXplOiBudWxsIH0sIG5ld1Byb3BzKTtcbiAgICByZXR1cm4gKGNvbnRleHQucGx1Z2luSG9va3MuaXNQcm9wc1ZhbGlkIHx8IGlzUHJvcHNWYWxpZCkocHJvcHMsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gaXNQcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEgPSB7fSwgZmlsdGVyQ29uZmlnKSB7XG4gICAgaWYgKHN0YXRlLmV2ZW50RHJhZyAmJiAhaXNJbnRlcmFjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5kYXRlU2VsZWN0aW9uICYmICFpc0RhdGVTZWxlY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIE1vdmluZyBFdmVudCBWYWxpZGF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGlzSW50ZXJhY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykge1xuICAgIGxldCBjdXJyZW50U3RhdGUgPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCk7XG4gICAgbGV0IGludGVyYWN0aW9uID0gc3RhdGUuZXZlbnREcmFnOyAvLyBIQUNLOiB0aGUgZXZlbnREcmFnIHByb3BzIGlzIHVzZWQgZm9yIEFMTCBpbnRlcmFjdGlvbnNcbiAgICBsZXQgc3ViamVjdEV2ZW50U3RvcmUgPSBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzO1xuICAgIGxldCBzdWJqZWN0RGVmcyA9IHN1YmplY3RFdmVudFN0b3JlLmRlZnM7XG4gICAgbGV0IHN1YmplY3RJbnN0YW5jZXMgPSBzdWJqZWN0RXZlbnRTdG9yZS5pbnN0YW5jZXM7XG4gICAgbGV0IHN1YmplY3RDb25maWdzID0gY29tcGlsZUV2ZW50VWlzKHN1YmplY3REZWZzLCBpbnRlcmFjdGlvbi5pc0V2ZW50ID9cbiAgICAgICAgc3RhdGUuZXZlbnRVaUJhc2VzIDpcbiAgICAgICAgeyAnJzogY3VycmVudFN0YXRlLnNlbGVjdGlvbkNvbmZpZyB9KTtcbiAgICBpZiAoZmlsdGVyQ29uZmlnKSB7XG4gICAgICAgIHN1YmplY3RDb25maWdzID0gbWFwSGFzaChzdWJqZWN0Q29uZmlncywgZmlsdGVyQ29uZmlnKTtcbiAgICB9XG4gICAgLy8gZXhjbHVkZSB0aGUgc3ViamVjdCBldmVudHMuIFRPRE86IGV4Y2x1ZGUgZGVmcyB0b28/XG4gICAgbGV0IG90aGVyRXZlbnRTdG9yZSA9IGV4Y2x1ZGVJbnN0YW5jZXMoc3RhdGUuZXZlbnRTdG9yZSwgaW50ZXJhY3Rpb24uYWZmZWN0ZWRFdmVudHMuaW5zdGFuY2VzKTtcbiAgICBsZXQgb3RoZXJEZWZzID0gb3RoZXJFdmVudFN0b3JlLmRlZnM7XG4gICAgbGV0IG90aGVySW5zdGFuY2VzID0gb3RoZXJFdmVudFN0b3JlLmluc3RhbmNlcztcbiAgICBsZXQgb3RoZXJDb25maWdzID0gY29tcGlsZUV2ZW50VWlzKG90aGVyRGVmcywgc3RhdGUuZXZlbnRVaUJhc2VzKTtcbiAgICBmb3IgKGxldCBzdWJqZWN0SW5zdGFuY2VJZCBpbiBzdWJqZWN0SW5zdGFuY2VzKSB7XG4gICAgICAgIGxldCBzdWJqZWN0SW5zdGFuY2UgPSBzdWJqZWN0SW5zdGFuY2VzW3N1YmplY3RJbnN0YW5jZUlkXTtcbiAgICAgICAgbGV0IHN1YmplY3RSYW5nZSA9IHN1YmplY3RJbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgbGV0IHN1YmplY3RDb25maWcgPSBzdWJqZWN0Q29uZmlnc1tzdWJqZWN0SW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICBsZXQgc3ViamVjdERlZiA9IHN1YmplY3REZWZzW3N1YmplY3RJbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIC8vIGNvbnN0cmFpbnRcbiAgICAgICAgaWYgKCFhbGxDb25zdHJhaW50c1Bhc3Moc3ViamVjdENvbmZpZy5jb25zdHJhaW50cywgc3ViamVjdFJhbmdlLCBvdGhlckV2ZW50U3RvcmUsIHN0YXRlLmJ1c2luZXNzSG91cnMsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3ZlcmxhcFxuICAgICAgICBsZXQgeyBldmVudE92ZXJsYXAgfSA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgICAgbGV0IGV2ZW50T3ZlcmxhcEZ1bmMgPSB0eXBlb2YgZXZlbnRPdmVybGFwID09PSAnZnVuY3Rpb24nID8gZXZlbnRPdmVybGFwIDogbnVsbDtcbiAgICAgICAgZm9yIChsZXQgb3RoZXJJbnN0YW5jZUlkIGluIG90aGVySW5zdGFuY2VzKSB7XG4gICAgICAgICAgICBsZXQgb3RoZXJJbnN0YW5jZSA9IG90aGVySW5zdGFuY2VzW290aGVySW5zdGFuY2VJZF07XG4gICAgICAgICAgICAvLyBpbnRlcnNlY3QhIGV2YWx1YXRlXG4gICAgICAgICAgICBpZiAocmFuZ2VzSW50ZXJzZWN0KHN1YmplY3RSYW5nZSwgb3RoZXJJbnN0YW5jZS5yYW5nZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgb3RoZXJPdmVybGFwID0gb3RoZXJDb25maWdzW290aGVySW5zdGFuY2UuZGVmSWRdLm92ZXJsYXA7XG4gICAgICAgICAgICAgICAgLy8gY29uc2lkZXIgdGhlIG90aGVyIGV2ZW50J3Mgb3ZlcmxhcC4gb25seSBkbyB0aGlzIGlmIHRoZSBzdWJqZWN0IGV2ZW50IGlzIGEgXCJyZWFsXCIgZXZlbnRcbiAgICAgICAgICAgICAgICBpZiAob3RoZXJPdmVybGFwID09PSBmYWxzZSAmJiBpbnRlcmFjdGlvbi5pc0V2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN1YmplY3RDb25maWcub3ZlcmxhcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRPdmVybGFwRnVuYyAmJiAhZXZlbnRPdmVybGFwRnVuYyhuZXcgRXZlbnRJbXBsKGNvbnRleHQsIG90aGVyRGVmc1tvdGhlckluc3RhbmNlLmRlZklkXSwgb3RoZXJJbnN0YW5jZSksIC8vIHN0aWxsIGV2ZW50XG4gICAgICAgICAgICAgICAgbmV3IEV2ZW50SW1wbChjb250ZXh0LCBzdWJqZWN0RGVmLCBzdWJqZWN0SW5zdGFuY2UpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFsbG93IChhIGZ1bmN0aW9uKVxuICAgICAgICBsZXQgY2FsZW5kYXJFdmVudFN0b3JlID0gY3VycmVudFN0YXRlLmV2ZW50U3RvcmU7IC8vIG5lZWQgZ2xvYmFsLXRvLWNhbGVuZGFyLCBub3QgbG9jYWwgdG8gY29tcG9uZW50IChzcGxpdHRhYmxlKXN0YXRlXG4gICAgICAgIGZvciAobGV0IHN1YmplY3RBbGxvdyBvZiBzdWJqZWN0Q29uZmlnLmFsbG93cykge1xuICAgICAgICAgICAgbGV0IHN1YmplY3REYXRlU3BhbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0ZVNwYW5NZXRhKSwgeyByYW5nZTogc3ViamVjdEluc3RhbmNlLnJhbmdlLCBhbGxEYXk6IHN1YmplY3REZWYuYWxsRGF5IH0pO1xuICAgICAgICAgICAgbGV0IG9yaWdEZWYgPSBjYWxlbmRhckV2ZW50U3RvcmUuZGVmc1tzdWJqZWN0RGVmLmRlZklkXTtcbiAgICAgICAgICAgIGxldCBvcmlnSW5zdGFuY2UgPSBjYWxlbmRhckV2ZW50U3RvcmUuaW5zdGFuY2VzW3N1YmplY3RJbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIGxldCBldmVudEFwaTtcbiAgICAgICAgICAgIGlmIChvcmlnRGVmKSB7IC8vIHdhcyBwcmV2aW91c2x5IGluIHRoZSBjYWxlbmRhclxuICAgICAgICAgICAgICAgIGV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChjb250ZXh0LCBvcmlnRGVmLCBvcmlnSW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIHdhcyBhbiBleHRlcm5hbCBldmVudFxuICAgICAgICAgICAgICAgIGV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChjb250ZXh0LCBzdWJqZWN0RGVmKTsgLy8gbm8gaW5zdGFuY2UsIGJlY2F1c2UgaGFkIG5vIGRhdGVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN1YmplY3RBbGxvdyhidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoc3ViamVjdERhdGVTcGFuLCBjb250ZXh0KSwgZXZlbnRBcGkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gRGF0ZSBTZWxlY3Rpb24gVmFsaWRhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBpc0RhdGVTZWxlY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykge1xuICAgIGxldCByZWxldmFudEV2ZW50U3RvcmUgPSBzdGF0ZS5ldmVudFN0b3JlO1xuICAgIGxldCByZWxldmFudERlZnMgPSByZWxldmFudEV2ZW50U3RvcmUuZGVmcztcbiAgICBsZXQgcmVsZXZhbnRJbnN0YW5jZXMgPSByZWxldmFudEV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIGxldCBzZWxlY3Rpb24gPSBzdGF0ZS5kYXRlU2VsZWN0aW9uO1xuICAgIGxldCBzZWxlY3Rpb25SYW5nZSA9IHNlbGVjdGlvbi5yYW5nZTtcbiAgICBsZXQgeyBzZWxlY3Rpb25Db25maWcgfSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcbiAgICBpZiAoZmlsdGVyQ29uZmlnKSB7XG4gICAgICAgIHNlbGVjdGlvbkNvbmZpZyA9IGZpbHRlckNvbmZpZyhzZWxlY3Rpb25Db25maWcpO1xuICAgIH1cbiAgICAvLyBjb25zdHJhaW50XG4gICAgaWYgKCFhbGxDb25zdHJhaW50c1Bhc3Moc2VsZWN0aW9uQ29uZmlnLmNvbnN0cmFpbnRzLCBzZWxlY3Rpb25SYW5nZSwgcmVsZXZhbnRFdmVudFN0b3JlLCBzdGF0ZS5idXNpbmVzc0hvdXJzLCBjb250ZXh0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIG92ZXJsYXBcbiAgICBsZXQgeyBzZWxlY3RPdmVybGFwIH0gPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgbGV0IHNlbGVjdE92ZXJsYXBGdW5jID0gdHlwZW9mIHNlbGVjdE92ZXJsYXAgPT09ICdmdW5jdGlvbicgPyBzZWxlY3RPdmVybGFwIDogbnVsbDtcbiAgICBmb3IgKGxldCByZWxldmFudEluc3RhbmNlSWQgaW4gcmVsZXZhbnRJbnN0YW5jZXMpIHtcbiAgICAgICAgbGV0IHJlbGV2YW50SW5zdGFuY2UgPSByZWxldmFudEluc3RhbmNlc1tyZWxldmFudEluc3RhbmNlSWRdO1xuICAgICAgICAvLyBpbnRlcnNlY3QhIGV2YWx1YXRlXG4gICAgICAgIGlmIChyYW5nZXNJbnRlcnNlY3Qoc2VsZWN0aW9uUmFuZ2UsIHJlbGV2YW50SW5zdGFuY2UucmFuZ2UpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uQ29uZmlnLm92ZXJsYXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdE92ZXJsYXBGdW5jICYmICFzZWxlY3RPdmVybGFwRnVuYyhuZXcgRXZlbnRJbXBsKGNvbnRleHQsIHJlbGV2YW50RGVmc1tyZWxldmFudEluc3RhbmNlLmRlZklkXSwgcmVsZXZhbnRJbnN0YW5jZSksIG51bGwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFsbG93IChhIGZ1bmN0aW9uKVxuICAgIGZvciAobGV0IHNlbGVjdGlvbkFsbG93IG9mIHNlbGVjdGlvbkNvbmZpZy5hbGxvd3MpIHtcbiAgICAgICAgbGV0IGZ1bGxEYXRlU3BhbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0ZVNwYW5NZXRhKSwgc2VsZWN0aW9uKTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb25BbGxvdyhidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoZnVsbERhdGVTcGFuLCBjb250ZXh0KSwgbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIENvbnN0cmFpbnQgVXRpbHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gYWxsQ29uc3RyYWludHNQYXNzKGNvbnN0cmFpbnRzLCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIGNvbnRleHQpIHtcbiAgICBmb3IgKGxldCBjb25zdHJhaW50IG9mIGNvbnN0cmFpbnRzKSB7XG4gICAgICAgIGlmICghYW55UmFuZ2VzQ29udGFpblJhbmdlKGNvbnN0cmFpbnRUb1Jhbmdlcyhjb25zdHJhaW50LCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIGNvbnRleHQpLCBzdWJqZWN0UmFuZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb25zdHJhaW50VG9SYW5nZXMoY29uc3RyYWludCwgc3ViamVjdFJhbmdlLCAvLyBmb3IgZXhwYW5kaW5nIGEgcmVjdXJyaW5nIGNvbnN0cmFpbnQsIG9yIGV4cGFuZGluZyBidXNpbmVzcyBob3Vyc1xub3RoZXJFdmVudFN0b3JlLCAvLyBmb3IgaWYgY29uc3RyYWludCBpcyBhbiBldmVuIGdyb3VwIElEXG5idXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgLy8gZm9yIGlmIGNvbnN0cmFpbnQgaXMgJ2J1c2luZXNzSG91cnMnXG5jb250ZXh0KSB7XG4gICAgaWYgKGNvbnN0cmFpbnQgPT09ICdidXNpbmVzc0hvdXJzJykge1xuICAgICAgICByZXR1cm4gZXZlbnRTdG9yZVRvUmFuZ2VzKGV4cGFuZFJlY3VycmluZyhidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgc3ViamVjdFJhbmdlLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uc3RyYWludCA9PT0gJ3N0cmluZycpIHsgLy8gYW4gZ3JvdXAgSURcbiAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmVUb1JhbmdlcyhmaWx0ZXJFdmVudFN0b3JlRGVmcyhvdGhlckV2ZW50U3RvcmUsIChldmVudERlZikgPT4gZXZlbnREZWYuZ3JvdXBJZCA9PT0gY29uc3RyYWludCkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnN0cmFpbnQgPT09ICdvYmplY3QnICYmIGNvbnN0cmFpbnQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoZXhwYW5kUmVjdXJyaW5nKGNvbnN0cmFpbnQsIHN1YmplY3RSYW5nZSwgY29udGV4dCkpO1xuICAgIH1cbiAgICByZXR1cm4gW107IC8vIGlmIGl0J3MgZmFsc2Vcbn1cbi8vIFRPRE86IG1vdmUgdG8gZXZlbnQtc3RvcmUgZmlsZT9cbmZ1bmN0aW9uIGV2ZW50U3RvcmVUb1JhbmdlcyhldmVudFN0b3JlKSB7XG4gICAgbGV0IHsgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlO1xuICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICByYW5nZXMucHVzaChpbnN0YW5jZXNbaW5zdGFuY2VJZF0ucmFuZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuLy8gVE9ETzogbW92ZSB0byBnZW9tIGZpbGU/XG5mdW5jdGlvbiBhbnlSYW5nZXNDb250YWluUmFuZ2Uob3V0ZXJSYW5nZXMsIGlubmVyUmFuZ2UpIHtcbiAgICBmb3IgKGxldCBvdXRlclJhbmdlIG9mIG91dGVyUmFuZ2VzKSB7XG4gICAgICAgIGlmIChyYW5nZUNvbnRhaW5zUmFuZ2Uob3V0ZXJSYW5nZSwgaW5uZXJSYW5nZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3QgVklTSUJMRV9ISURERU5fUkUgPSAvXih2aXNpYmxlfGhpZGRlbikkLztcbmNsYXNzIFNjcm9sbGVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaGFuZGxlRWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGxpcXVpZCwgbGlxdWlkSXNBYnNvbHV0ZSB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBpc0Fic29sdXRlID0gbGlxdWlkICYmIGxpcXVpZElzQWJzb2x1dGU7XG4gICAgICAgIGxldCBjbGFzc05hbWUgPSBbJ2ZjLXNjcm9sbGVyJ107XG4gICAgICAgIGlmIChsaXF1aWQpIHtcbiAgICAgICAgICAgIGlmIChsaXF1aWRJc0Fic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lLnB1c2goJ2ZjLXNjcm9sbGVyLWxpcXVpZC1hYnNvbHV0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lLnB1c2goJ2ZjLXNjcm9sbGVyLWxpcXVpZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5oYW5kbGVFbCwgY2xhc3NOYW1lOiBjbGFzc05hbWUuam9pbignICcpLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93WDogcHJvcHMub3ZlcmZsb3dYLFxuICAgICAgICAgICAgICAgIG92ZXJmbG93WTogcHJvcHMub3ZlcmZsb3dZLFxuICAgICAgICAgICAgICAgIGxlZnQ6IChpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVMZWZ0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICByaWdodDogKGlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZVJpZ2h0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBib3R0b206IChpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVCb3R0b20gfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lTGVmdCB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lUmlnaHQgfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogKCFpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVCb3R0b20gfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIG1heEhlaWdodDogcHJvcHMubWF4SGVpZ2h0IHx8ICcnLFxuICAgICAgICAgICAgfSB9LCBwcm9wcy5jaGlsZHJlbikpO1xuICAgIH1cbiAgICBuZWVkc1hTY3JvbGxpbmcoKSB7XG4gICAgICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dYKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRlc3Rpbmcgc2Nyb2xsV2lkdGg+Y2xpZW50V2lkdGggaXMgdW5yZWxpYWJsZSBjcm9zcy1icm93c2VyIHdoZW4gcGl4ZWwgaGVpZ2h0cyBhcmVuJ3QgaW50ZWdlcnMuXG4gICAgICAgIC8vIG11Y2ggbW9yZSByZWxpYWJsZSB0byBzZWUgaWYgY2hpbGRyZW4gYXJlIHRhbGxlciB0aGFuIHRoZSBzY3JvbGxlciwgZXZlbiB0aG8gZG9lc24ndCBhY2NvdW50IGZvclxuICAgICAgICAvLyBpbm5lci1jaGlsZCBtYXJnaW5zIGFuZCBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuICAgICAgICBsZXQgeyBlbCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHJlYWxDbGllbnRXaWR0aCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSB0aGlzLmdldFlTY3JvbGxiYXJXaWR0aCgpO1xuICAgICAgICBsZXQgeyBjaGlsZHJlbiB9ID0gZWw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZEVsID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCA+IHJlYWxDbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbmVlZHNZU2Nyb2xsaW5nKCkge1xuICAgICAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0ZXN0aW5nIHNjcm9sbEhlaWdodD5jbGllbnRIZWlnaHQgaXMgdW5yZWxpYWJsZSBjcm9zcy1icm93c2VyIHdoZW4gcGl4ZWwgaGVpZ2h0cyBhcmVuJ3QgaW50ZWdlcnMuXG4gICAgICAgIC8vIG11Y2ggbW9yZSByZWxpYWJsZSB0byBzZWUgaWYgY2hpbGRyZW4gYXJlIHRhbGxlciB0aGFuIHRoZSBzY3JvbGxlciwgZXZlbiB0aG8gZG9lc24ndCBhY2NvdW50IGZvclxuICAgICAgICAvLyBpbm5lci1jaGlsZCBtYXJnaW5zIGFuZCBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuICAgICAgICBsZXQgeyBlbCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHJlYWxDbGllbnRIZWlnaHQgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCAtIHRoaXMuZ2V0WFNjcm9sbGJhcldpZHRoKCk7XG4gICAgICAgIGxldCB7IGNoaWxkcmVuIH0gPSBlbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkRWwgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCA+IHJlYWxDbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldFhTY3JvbGxiYXJXaWR0aCgpIHtcbiAgICAgICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1gpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbC5vZmZzZXRIZWlnaHQgLSB0aGlzLmVsLmNsaWVudEhlaWdodDsgLy8gb25seSB3b3JrcyBiZWNhdXNlIHdlIGd1YXJhbnRlZSBubyBib3JkZXJzLiBUT0RPOiBhZGQgdG8gQ1NTIHdpdGggaW1wb3J0YW50P1xuICAgIH1cbiAgICBnZXRZU2Nyb2xsYmFyV2lkdGgoKSB7XG4gICAgICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dZKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwub2Zmc2V0V2lkdGggLSB0aGlzLmVsLmNsaWVudFdpZHRoOyAvLyBvbmx5IHdvcmtzIGJlY2F1c2Ugd2UgZ3VhcmFudGVlIG5vIGJvcmRlcnMuIFRPRE86IGFkZCB0byBDU1Mgd2l0aCBpbXBvcnRhbnQ/XG4gICAgfVxufVxuXG4vKlxuVE9ETzogc29tZWhvdyBpbmZlciBPdGhlckFyZ3MgZnJvbSBtYXN0ZXJDYWxsYmFjaz9cblRPRE86IGluZmVyIFJlZlR5cGUgZnJvbSBtYXN0ZXJDYWxsYmFjayBpZiBwcm92aWRlZFxuKi9cbmNsYXNzIFJlZk1hcCB7XG4gICAgY29uc3RydWN0b3IobWFzdGVyQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5tYXN0ZXJDYWxsYmFjayA9IG1hc3RlckNhbGxiYWNrO1xuICAgICAgICB0aGlzLmN1cnJlbnRNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5kZXB0aHMgPSB7fTtcbiAgICAgICAgdGhpcy5jYWxsYmFja01hcCA9IHt9O1xuICAgICAgICB0aGlzLmhhbmRsZVZhbHVlID0gKHZhbCwga2V5KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBkZXB0aHMsIGN1cnJlbnRNYXAgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgcmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGFkZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGJ1Zy4uLiBBQ1RVQUxMWTogY2FuIHByb2JhYmx5IGRvIGF3YXkgd2l0aCB0aGlzIG5vdyB0aGF0IGNhbGxlcnMgZG9uJ3Qgc2hhcmUgbnVtZXJpYyBpbmRpY2VzIGFueW1vcmVcbiAgICAgICAgICAgICAgICByZW1vdmVkID0gKGtleSBpbiBjdXJyZW50TWFwKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWFwW2tleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgZGVwdGhzW2tleV0gPSAoZGVwdGhzW2tleV0gfHwgMCkgKyAxO1xuICAgICAgICAgICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlcHRoc1trZXldIC09IDE7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXB0aHNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY3VycmVudE1hcFtrZXldO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFja01hcFtrZXldO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tYXN0ZXJDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFzdGVyQ2FsbGJhY2sobnVsbCwgU3RyaW5nKGtleSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWRkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXN0ZXJDYWxsYmFjayh2YWwsIFN0cmluZyhrZXkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNyZWF0ZVJlZihrZXkpIHtcbiAgICAgICAgbGV0IHJlZkNhbGxiYWNrID0gdGhpcy5jYWxsYmFja01hcFtrZXldO1xuICAgICAgICBpZiAoIXJlZkNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZWZDYWxsYmFjayA9IHRoaXMuY2FsbGJhY2tNYXBba2V5XSA9ICh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVZhbHVlKHZhbCwgU3RyaW5nKGtleSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmQ2FsbGJhY2s7XG4gICAgfVxuICAgIC8vIFRPRE86IGNoZWNrIGNhbGxlcnMgdGhhdCBkb24ndCBjYXJlIGFib3V0IG9yZGVyLiBzaG91bGQgdXNlIGdldEFsbCBpbnN0ZWFkXG4gICAgLy8gTk9URTogdGhpcyBtZXRob2QgaGFzIGJlY29tZSBsZXNzIHZhbHVhYmxlIG5vdyB0aGF0IHdlIGFyZSBlbmNvdXJhZ2VkIHRvIG1hcCBvcmRlciBieSBzb21lIG90aGVyIGluZGV4XG4gICAgLy8gVE9ETzogcHJvdmlkZSBPTkUgYXJyYXktZXhwb3J0IGZ1bmN0aW9uLCBidWlsZEFycmF5LCB3aGljaCBmYWlscyBvbiBub24tbnVtZXJpYyBpbmRleGVzLiBjYWxsZXIgY2FuIG1hbmlwdWxhdGUgYW5kIFwiY29sbGVjdFwiXG4gICAgY29sbGVjdChzdGFydEluZGV4LCBlbmRJbmRleCwgc3RlcCkge1xuICAgICAgICByZXR1cm4gY29sbGVjdEZyb21IYXNoKHRoaXMuY3VycmVudE1hcCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIHN0ZXApO1xuICAgIH1cbiAgICBnZXRBbGwoKSB7XG4gICAgICAgIHJldHVybiBoYXNoVmFsdWVzVG9BcnJheSh0aGlzLmN1cnJlbnRNYXApO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZVNocmlua1dpZHRoKGNodW5rRWxzKSB7XG4gICAgbGV0IHNocmlua0NlbGxzID0gZmluZEVsZW1lbnRzKGNodW5rRWxzLCAnLmZjLXNjcm9sbGdyaWQtc2hyaW5rJyk7XG4gICAgbGV0IGxhcmdlc3RXaWR0aCA9IDA7XG4gICAgZm9yIChsZXQgc2hyaW5rQ2VsbCBvZiBzaHJpbmtDZWxscykge1xuICAgICAgICBsYXJnZXN0V2lkdGggPSBNYXRoLm1heChsYXJnZXN0V2lkdGgsIGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aChzaHJpbmtDZWxsKSk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmNlaWwobGFyZ2VzdFdpZHRoKTsgLy8gPHRhYmxlPiBlbGVtZW50cyB3b3JrIGJlc3Qgd2l0aCBpbnRlZ2Vycy4gcm91bmQgdXAgdG8gZW5zdXJlIGNvbnRlbnRzIGZpdHNcbn1cbmZ1bmN0aW9uIGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQocHJvcHMsIHNlY3Rpb25Db25maWcpIHtcbiAgICByZXR1cm4gcHJvcHMubGlxdWlkICYmIHNlY3Rpb25Db25maWcubGlxdWlkOyAvLyBkb2VzIHRoZSBzZWN0aW9uIGRvIGxpcXVpZC1oZWlnaHQ/IChuZWVkIHRvIGhhdmUgd2hvbGUgc2Nyb2xsZ3JpZCBsaXF1aWQtaGVpZ2h0IGFzIHdlbGwpXG59XG5mdW5jdGlvbiBnZXRBbGxvd1lTY3JvbGxpbmcocHJvcHMsIHNlY3Rpb25Db25maWcpIHtcbiAgICByZXR1cm4gc2VjdGlvbkNvbmZpZy5tYXhIZWlnaHQgIT0gbnVsbCB8fCAvLyBpZiBpdHMgcG9zc2libGUgZm9yIHRoZSBoZWlnaHQgdG8gbWF4IG91dCwgd2UgbWlnaHQgbmVlZCBzY3JvbGxiYXJzXG4gICAgICAgIGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQocHJvcHMsIHNlY3Rpb25Db25maWcpOyAvLyBpZiB0aGUgc2VjdGlvbiBpcyBsaXF1aWQgaGVpZ2h0LCBpdCBtaWdodCBjb25kZW5zZSBlbm91Z2ggdG8gcmVxdWlyZSBzY3JvbGxiYXJzXG59XG4vLyBUT0RPOiBPTkxZIHVzZSBgYXJnYC4gZm9yY2Ugb3V0IGludGVybmFsIGZ1bmN0aW9uIHRvIHVzZSBzYW1lIEFQSVxuZnVuY3Rpb24gcmVuZGVyQ2h1bmtDb250ZW50KHNlY3Rpb25Db25maWcsIGNodW5rQ29uZmlnLCBhcmcsIGlzSGVhZGVyKSB7XG4gICAgbGV0IHsgZXhwYW5kUm93cyB9ID0gYXJnO1xuICAgIGxldCBjb250ZW50ID0gdHlwZW9mIGNodW5rQ29uZmlnLmNvbnRlbnQgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICBjaHVua0NvbmZpZy5jb250ZW50KGFyZykgOlxuICAgICAgICBjcmVhdGVFbGVtZW50KCd0YWJsZScsIHtcbiAgICAgICAgICAgIHJvbGU6ICdwcmVzZW50YXRpb24nLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgICAgY2h1bmtDb25maWcudGFibGVDbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgc2VjdGlvbkNvbmZpZy5zeW5jUm93SGVpZ2h0cyA/ICdmYy1zY3JvbGxncmlkLXN5bmMtdGFibGUnIDogJycsXG4gICAgICAgICAgICBdLmpvaW4oJyAnKSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IGFyZy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBhcmcuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBleHBhbmRSb3dzID8gYXJnLmNsaWVudEhlaWdodCA6ICcnLCAvLyBjc3MgYGhlaWdodGAgb24gYSA8dGFibGU+IHNlcnZlcyBhcyBhIG1pbi1oZWlnaHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIGFyZy50YWJsZUNvbEdyb3VwTm9kZSwgY3JlYXRlRWxlbWVudChpc0hlYWRlciA/ICd0aGVhZCcgOiAndGJvZHknLCB7XG4gICAgICAgICAgICByb2xlOiAncHJlc2VudGF0aW9uJyxcbiAgICAgICAgfSwgdHlwZW9mIGNodW5rQ29uZmlnLnJvd0NvbnRlbnQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gY2h1bmtDb25maWcucm93Q29udGVudChhcmcpXG4gICAgICAgICAgICA6IGNodW5rQ29uZmlnLnJvd0NvbnRlbnQpKTtcbiAgICByZXR1cm4gY29udGVudDtcbn1cbmZ1bmN0aW9uIGlzQ29sUHJvcHNFcXVhbChjb2xzMCwgY29sczEpIHtcbiAgICByZXR1cm4gaXNBcnJheXNFcXVhbChjb2xzMCwgY29sczEsIGlzUHJvcHNFcXVhbCk7XG59XG5mdW5jdGlvbiByZW5kZXJNaWNyb0NvbEdyb3VwKGNvbHMsIHNocmlua1dpZHRoKSB7XG4gICAgbGV0IGNvbE5vZGVzID0gW107XG4gICAgLypcbiAgICBmb3IgQ29sUHJvcHMgd2l0aCBzcGFucywgaXQgd291bGQgaGF2ZSBiZWVuIGdyZWF0IHRvIG1ha2UgYSBzaW5nbGUgPGNvbCBzcGFuPVwiXCI+XG4gICAgSE9XRVZFUiwgQ2hyb21lIHdhcyBnZXR0aW5nIG1lc3NpbmcgdXAgZGlzdHJpYnV0aW5nIHRoZSB3aWR0aCB0byA8dGQ+Lzx0aD4gZWxlbWVudHMgd2l0aCBjb2xzcGFucy5cbiAgICBTT0xVVElPTjogbWFraW5nIGluZGl2aWR1YWwgPGNvbD4gZWxlbWVudHMgbWFrZXMgQ2hyb21lIGJlaGF2ZS5cbiAgICAqL1xuICAgIGZvciAobGV0IGNvbFByb3BzIG9mIGNvbHMpIHtcbiAgICAgICAgbGV0IHNwYW4gPSBjb2xQcm9wcy5zcGFuIHx8IDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BhbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb2xOb2Rlcy5wdXNoKGNyZWF0ZUVsZW1lbnQoXCJjb2xcIiwgeyBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogY29sUHJvcHMud2lkdGggPT09ICdzaHJpbmsnID8gc2FuaXRpemVTaHJpbmtXaWR0aChzaHJpbmtXaWR0aCkgOiAoY29sUHJvcHMud2lkdGggfHwgJycpLFxuICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogY29sUHJvcHMubWluV2lkdGggfHwgJycsXG4gICAgICAgICAgICAgICAgfSB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2NvbGdyb3VwJywge30sIC4uLmNvbE5vZGVzKTtcbn1cbmZ1bmN0aW9uIHNhbml0aXplU2hyaW5rV2lkdGgoc2hyaW5rV2lkdGgpIHtcbiAgICAvKiB3aHkgND8gaWYgd2UgZG8gMCwgaXQgd2lsbCBraWxsIGFueSBib3JkZXIsIHdoaWNoIGFyZSBuZWVkZWQgZm9yIGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aFxuICAgIDQgYWNjb3VudHMgZm9yIDIgMi1waXhlbCBib3JkZXJzLiBUT0RPOiBiZXR0ZXIgc29sdXRpb24/ICovXG4gICAgcmV0dXJuIHNocmlua1dpZHRoID09IG51bGwgPyA0IDogc2hyaW5rV2lkdGg7XG59XG5mdW5jdGlvbiBoYXNTaHJpbmtXaWR0aChjb2xzKSB7XG4gICAgZm9yIChsZXQgY29sIG9mIGNvbHMpIHtcbiAgICAgICAgaWYgKGNvbC53aWR0aCA9PT0gJ3NocmluaycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFNjcm9sbEdyaWRDbGFzc05hbWVzKGxpcXVpZCwgY29udGV4dCkge1xuICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtc2Nyb2xsZ3JpZCcsXG4gICAgICAgIGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlJyksXG4gICAgXTtcbiAgICBpZiAobGlxdWlkKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1saXF1aWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiBnZXRTZWN0aW9uQ2xhc3NOYW1lcyhzZWN0aW9uQ29uZmlnLCB3aG9sZVRhYmxlVkdyb3cpIHtcbiAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2VjdGlvbicsXG4gICAgICAgIGBmYy1zY3JvbGxncmlkLXNlY3Rpb24tJHtzZWN0aW9uQ29uZmlnLnR5cGV9YCxcbiAgICAgICAgc2VjdGlvbkNvbmZpZy5jbGFzc05hbWUsIC8vIHVzZWQ/XG4gICAgXTtcbiAgICBpZiAod2hvbGVUYWJsZVZHcm93ICYmIHNlY3Rpb25Db25maWcubGlxdWlkICYmIHNlY3Rpb25Db25maWcubWF4SGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLXNlY3Rpb24tbGlxdWlkJyk7XG4gICAgfVxuICAgIGlmIChzZWN0aW9uQ29uZmlnLmlzU3RpY2t5KSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreScpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cbmZ1bmN0aW9uIHJlbmRlclNjcm9sbFNoaW0oYXJnKSB7XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc3RpY2t5LXNoaW1cIiwgc3R5bGU6IHtcbiAgICAgICAgICAgIHdpZHRoOiBhcmcuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICBtaW5XaWR0aDogYXJnLnRhYmxlTWluV2lkdGgsXG4gICAgICAgIH0gfSkpO1xufVxuZnVuY3Rpb24gZ2V0U3RpY2t5SGVhZGVyRGF0ZXMob3B0aW9ucykge1xuICAgIGxldCB7IHN0aWNreUhlYWRlckRhdGVzIH0gPSBvcHRpb25zO1xuICAgIGlmIChzdGlja3lIZWFkZXJEYXRlcyA9PSBudWxsIHx8IHN0aWNreUhlYWRlckRhdGVzID09PSAnYXV0bycpIHtcbiAgICAgICAgc3RpY2t5SGVhZGVyRGF0ZXMgPSBvcHRpb25zLmhlaWdodCA9PT0gJ2F1dG8nIHx8IG9wdGlvbnMudmlld0hlaWdodCA9PT0gJ2F1dG8nO1xuICAgIH1cbiAgICByZXR1cm4gc3RpY2t5SGVhZGVyRGF0ZXM7XG59XG5mdW5jdGlvbiBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIob3B0aW9ucykge1xuICAgIGxldCB7IHN0aWNreUZvb3RlclNjcm9sbGJhciB9ID0gb3B0aW9ucztcbiAgICBpZiAoc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID09IG51bGwgfHwgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID09PSAnYXV0bycpIHtcbiAgICAgICAgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID0gb3B0aW9ucy5oZWlnaHQgPT09ICdhdXRvJyB8fCBvcHRpb25zLnZpZXdIZWlnaHQgPT09ICdhdXRvJztcbiAgICB9XG4gICAgcmV0dXJuIHN0aWNreUZvb3RlclNjcm9sbGJhcjtcbn1cblxuY2xhc3MgU2ltcGxlU2Nyb2xsR3JpZCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnByb2Nlc3NDb2xzID0gbWVtb2l6ZSgoYSkgPT4gYSwgaXNDb2xQcm9wc0VxdWFsKTsgLy8gc28gd2UgZ2V0IHNhbWUgYGNvbHNgIHByb3BzIGV2ZXJ5IHRpbWVcbiAgICAgICAgLy8geXVja3kgdG8gbWVtb2l6ZSBWTm9kZXMsIGJ1dCBtdWNoIG1vcmUgZWZmaWNpZW50IGZvciBjb25zdW1lcnNcbiAgICAgICAgdGhpcy5yZW5kZXJNaWNyb0NvbEdyb3VwID0gbWVtb2l6ZShyZW5kZXJNaWNyb0NvbEdyb3VwKTtcbiAgICAgICAgdGhpcy5zY3JvbGxlclJlZnMgPSBuZXcgUmVmTWFwKCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsZXJFbFJlZnMgPSBuZXcgUmVmTWFwKHRoaXMuX2hhbmRsZVNjcm9sbGVyRWwuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzaHJpbmtXaWR0aDogbnVsbCxcbiAgICAgICAgICAgIGZvcmNlWVNjcm9sbGJhcnM6IGZhbHNlLFxuICAgICAgICAgICAgc2Nyb2xsZXJDbGllbnRXaWR0aHM6IHt9LFxuICAgICAgICAgICAgc2Nyb2xsZXJDbGllbnRIZWlnaHRzOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVE9ETzogY2FuIGRvIGEgcmVhbGx5IHNpbXBsZSBwcmludC12aWV3LiBkb250IG5lZWQgdG8gam9pbiByb3dzXG4gICAgICAgIHRoaXMuaGFuZGxlU2l6aW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zYWZlU2V0U3RhdGUoT2JqZWN0LmFzc2lnbih7IHNocmlua1dpZHRoOiB0aGlzLmNvbXB1dGVTaHJpbmtXaWR0aCgpIH0sIHRoaXMuY29tcHV0ZVNjcm9sbGVyRGltcygpKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgc2VjdGlvbkNvbmZpZ3MgPSBwcm9wcy5zZWN0aW9ucyB8fCBbXTtcbiAgICAgICAgbGV0IGNvbHMgPSB0aGlzLnByb2Nlc3NDb2xzKHByb3BzLmNvbHMpO1xuICAgICAgICBsZXQgbWljcm9Db2xHcm91cE5vZGUgPSB0aGlzLnJlbmRlck1pY3JvQ29sR3JvdXAoY29scywgc3RhdGUuc2hyaW5rV2lkdGgpO1xuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IGdldFNjcm9sbEdyaWRDbGFzc05hbWVzKHByb3BzLmxpcXVpZCwgY29udGV4dCk7XG4gICAgICAgIGlmIChwcm9wcy5jb2xsYXBzaWJsZVdpZHRoKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtY29sbGFwc2libGUnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBtYWtlIERSWVxuICAgICAgICBsZXQgY29uZmlnQ250ID0gc2VjdGlvbkNvbmZpZ3MubGVuZ3RoO1xuICAgICAgICBsZXQgY29uZmlnSSA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50Q29uZmlnO1xuICAgICAgICBsZXQgaGVhZFNlY3Rpb25Ob2RlcyA9IFtdO1xuICAgICAgICBsZXQgYm9keVNlY3Rpb25Ob2RlcyA9IFtdO1xuICAgICAgICBsZXQgZm9vdFNlY3Rpb25Ob2RlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoY29uZmlnSSA8IGNvbmZpZ0NudCAmJiAoY3VycmVudENvbmZpZyA9IHNlY3Rpb25Db25maWdzW2NvbmZpZ0ldKS50eXBlID09PSAnaGVhZGVyJykge1xuICAgICAgICAgICAgaGVhZFNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgdHJ1ZSkpO1xuICAgICAgICAgICAgY29uZmlnSSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdib2R5Jykge1xuICAgICAgICAgICAgYm9keVNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgZmFsc2UpKTtcbiAgICAgICAgICAgIGNvbmZpZ0kgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY29uZmlnSSA8IGNvbmZpZ0NudCAmJiAoY3VycmVudENvbmZpZyA9IHNlY3Rpb25Db25maWdzW2NvbmZpZ0ldKS50eXBlID09PSAnZm9vdGVyJykge1xuICAgICAgICAgICAgZm9vdFNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgdHJ1ZSkpO1xuICAgICAgICAgICAgY29uZmlnSSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpcmVmb3ggYnVnOiB3aGVuIHNldHRpbmcgaGVpZ2h0IG9uIHRhYmxlIGFuZCB0aGVyZSBpcyBhIHRoZWFkIG9yIHRmb290LFxuICAgICAgICAvLyB0aGUgbmVjZXNzYXJ5IGhlaWdodDoxMDAlIG9uIHRoZSBsaXF1aWQtaGVpZ2h0IGJvZHkgc2VjdGlvbiBmb3JjZXMgdGhlICp3aG9sZSogdGFibGUgdG8gYmUgdGFsbGVyLiAoYnVnICM1NTI0KVxuICAgICAgICAvLyB1c2UgZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsIGFzIGEgd2F5IHRvIGRldGVjdCB0YWJsZS1zdHVwaWQgZmlyZWZveC5cbiAgICAgICAgLy8gaWYgc28sIHVzZSBhIHNpbXBsZXIgZG9tIHN0cnVjdHVyZSwgamFtIGV2ZXJ5dGhpbmcgaW50byBhIGxvbmUgdGJvZHkuXG4gICAgICAgIGxldCBpc0J1Z2d5ID0gIWdldENhblZHcm93V2l0aGluQ2VsbCgpO1xuICAgICAgICBjb25zdCByb2xlQXR0cnMgPSB7IHJvbGU6ICdyb3dncm91cCcgfTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ3RhYmxlJywge1xuICAgICAgICAgICAgcm9sZTogJ2dyaWQnLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSxcbiAgICAgICAgICAgIHN0eWxlOiB7IGhlaWdodDogcHJvcHMuaGVpZ2h0IH0sXG4gICAgICAgIH0sIEJvb2xlYW4oIWlzQnVnZ3kgJiYgaGVhZFNlY3Rpb25Ob2Rlcy5sZW5ndGgpICYmIGNyZWF0ZUVsZW1lbnQoJ3RoZWFkJywgcm9sZUF0dHJzLCAuLi5oZWFkU2VjdGlvbk5vZGVzKSwgQm9vbGVhbighaXNCdWdneSAmJiBib2R5U2VjdGlvbk5vZGVzLmxlbmd0aCkgJiYgY3JlYXRlRWxlbWVudCgndGJvZHknLCByb2xlQXR0cnMsIC4uLmJvZHlTZWN0aW9uTm9kZXMpLCBCb29sZWFuKCFpc0J1Z2d5ICYmIGZvb3RTZWN0aW9uTm9kZXMubGVuZ3RoKSAmJiBjcmVhdGVFbGVtZW50KCd0Zm9vdCcsIHJvbGVBdHRycywgLi4uZm9vdFNlY3Rpb25Ob2RlcyksIGlzQnVnZ3kgJiYgY3JlYXRlRWxlbWVudCgndGJvZHknLCByb2xlQXR0cnMsIC4uLmhlYWRTZWN0aW9uTm9kZXMsIC4uLmJvZHlTZWN0aW9uTm9kZXMsIC4uLmZvb3RTZWN0aW9uTm9kZXMpKTtcbiAgICB9XG4gICAgcmVuZGVyU2VjdGlvbihzZWN0aW9uQ29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgaXNIZWFkZXIpIHtcbiAgICAgICAgaWYgKCdvdXRlckNvbnRlbnQnIGluIHNlY3Rpb25Db25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgeyBrZXk6IHNlY3Rpb25Db25maWcua2V5IH0sIHNlY3Rpb25Db25maWcub3V0ZXJDb250ZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyBrZXk6IHNlY3Rpb25Db25maWcua2V5LCByb2xlOiBcInByZXNlbnRhdGlvblwiLCBjbGFzc05hbWU6IGdldFNlY3Rpb25DbGFzc05hbWVzKHNlY3Rpb25Db25maWcsIHRoaXMucHJvcHMubGlxdWlkKS5qb2luKCcgJykgfSwgdGhpcy5yZW5kZXJDaHVua1RkKHNlY3Rpb25Db25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBzZWN0aW9uQ29uZmlnLmNodW5rLCBpc0hlYWRlcikpKTtcbiAgICB9XG4gICAgcmVuZGVyQ2h1bmtUZChzZWN0aW9uQ29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgY2h1bmtDb25maWcsIGlzSGVhZGVyKSB7XG4gICAgICAgIGlmICgnb3V0ZXJDb250ZW50JyBpbiBjaHVua0NvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIGNodW5rQ29uZmlnLm91dGVyQ29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgZm9yY2VZU2Nyb2xsYmFycywgc2Nyb2xsZXJDbGllbnRXaWR0aHMsIHNjcm9sbGVyQ2xpZW50SGVpZ2h0cyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgbGV0IG5lZWRzWVNjcm9sbGluZyA9IGdldEFsbG93WVNjcm9sbGluZyhwcm9wcywgc2VjdGlvbkNvbmZpZyk7IC8vIFRPRE86IGRvIGxhemlseS4gZG8gaW4gc2VjdGlvbiBjb25maWc/XG4gICAgICAgIGxldCBpc0xpcXVpZCA9IGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQocHJvcHMsIHNlY3Rpb25Db25maWcpO1xuICAgICAgICAvLyBmb3IgYCFwcm9wcy5saXF1aWRgIC0gaXMgV0hPTEUgc2Nyb2xsZ3JpZCBuYXR1cmFsIGhlaWdodD9cbiAgICAgICAgLy8gVE9ETzogZG8gc2FtZSB0aGluZyBpbiBhZHZhbmNlZCBzY3JvbGxncmlkPyBwcm9sbHkgbm90IGIvYyBhbHdheXMgaGFzIGhvcml6b250YWwgc2Nyb2xsYmFyc1xuICAgICAgICBsZXQgb3ZlcmZsb3dZID0gIXByb3BzLmxpcXVpZCA/ICd2aXNpYmxlJyA6XG4gICAgICAgICAgICBmb3JjZVlTY3JvbGxiYXJzID8gJ3Njcm9sbCcgOlxuICAgICAgICAgICAgICAgICFuZWVkc1lTY3JvbGxpbmcgPyAnaGlkZGVuJyA6XG4gICAgICAgICAgICAgICAgICAgICdhdXRvJztcbiAgICAgICAgbGV0IHNlY3Rpb25LZXkgPSBzZWN0aW9uQ29uZmlnLmtleTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSByZW5kZXJDaHVua0NvbnRlbnQoc2VjdGlvbkNvbmZpZywgY2h1bmtDb25maWcsIHtcbiAgICAgICAgICAgIHRhYmxlQ29sR3JvdXBOb2RlOiBtaWNyb0NvbEdyb3VwTm9kZSxcbiAgICAgICAgICAgIHRhYmxlTWluV2lkdGg6ICcnLFxuICAgICAgICAgICAgY2xpZW50V2lkdGg6ICghcHJvcHMuY29sbGFwc2libGVXaWR0aCAmJiBzY3JvbGxlckNsaWVudFdpZHRoc1tzZWN0aW9uS2V5XSAhPT0gdW5kZWZpbmVkKSA/IHNjcm9sbGVyQ2xpZW50V2lkdGhzW3NlY3Rpb25LZXldIDogbnVsbCxcbiAgICAgICAgICAgIGNsaWVudEhlaWdodDogc2Nyb2xsZXJDbGllbnRIZWlnaHRzW3NlY3Rpb25LZXldICE9PSB1bmRlZmluZWQgPyBzY3JvbGxlckNsaWVudEhlaWdodHNbc2VjdGlvbktleV0gOiBudWxsLFxuICAgICAgICAgICAgZXhwYW5kUm93czogc2VjdGlvbkNvbmZpZy5leHBhbmRSb3dzLFxuICAgICAgICAgICAgc3luY1Jvd0hlaWdodHM6IGZhbHNlLFxuICAgICAgICAgICAgcm93U3luY0hlaWdodHM6IFtdLFxuICAgICAgICAgICAgcmVwb3J0Um93SGVpZ2h0Q2hhbmdlOiAoKSA9PiB7IH0sXG4gICAgICAgIH0sIGlzSGVhZGVyKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoaXNIZWFkZXIgPyAndGgnIDogJ3RkJywge1xuICAgICAgICAgICAgcmVmOiBjaHVua0NvbmZpZy5lbFJlZixcbiAgICAgICAgICAgIHJvbGU6ICdwcmVzZW50YXRpb24nLFxuICAgICAgICB9LCBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBgZmMtc2Nyb2xsZXItaGFybmVzcyR7aXNMaXF1aWQgPyAnIGZjLXNjcm9sbGVyLWhhcm5lc3MtbGlxdWlkJyA6ICcnfWAgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoU2Nyb2xsZXIsIHsgcmVmOiB0aGlzLnNjcm9sbGVyUmVmcy5jcmVhdGVSZWYoc2VjdGlvbktleSksIGVsUmVmOiB0aGlzLnNjcm9sbGVyRWxSZWZzLmNyZWF0ZVJlZihzZWN0aW9uS2V5KSwgb3ZlcmZsb3dZOiBvdmVyZmxvd1ksIG92ZXJmbG93WDogIXByb3BzLmxpcXVpZCA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nIC8qIG5hdHVyYWwgaGVpZ2h0PyAqLywgbWF4SGVpZ2h0OiBzZWN0aW9uQ29uZmlnLm1heEhlaWdodCwgbGlxdWlkOiBpc0xpcXVpZCwgbGlxdWlkSXNBYnNvbHV0ZSAvLyBiZWNhdXNlIGl0cyB3aXRoaW4gYSBoYXJuZXNzXG4gICAgICAgICAgICAgICAgOiB0cnVlIH0sIGNvbnRlbnQpKSk7XG4gICAgfVxuICAgIF9oYW5kbGVTY3JvbGxlckVsKHNjcm9sbGVyRWwsIGtleSkge1xuICAgICAgICBsZXQgc2VjdGlvbiA9IGdldFNlY3Rpb25CeUtleSh0aGlzLnByb3BzLnNlY3Rpb25zLCBrZXkpO1xuICAgICAgICBpZiAoc2VjdGlvbikge1xuICAgICAgICAgICAgc2V0UmVmKHNlY3Rpb24uY2h1bmsuc2Nyb2xsZXJFbFJlZiwgc2Nyb2xsZXJFbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlU2l6aW5nKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5hZGRSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlU2l6aW5nKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICAvLyBUT0RPOiBuZWVkIGJldHRlciBzb2x1dGlvbiB3aGVuIHN0YXRlIGNvbnRhaW5zIG5vbi1zaXppbmcgdGhpbmdzXG4gICAgICAgIHRoaXMuaGFuZGxlU2l6aW5nKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLmNvbnRleHQucmVtb3ZlUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVNpemluZyk7XG4gICAgfVxuICAgIGNvbXB1dGVTaHJpbmtXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIGhhc1Nocmlua1dpZHRoKHRoaXMucHJvcHMuY29scylcbiAgICAgICAgICAgID8gY29tcHV0ZVNocmlua1dpZHRoKHRoaXMuc2Nyb2xsZXJFbFJlZnMuZ2V0QWxsKCkpXG4gICAgICAgICAgICA6IDA7XG4gICAgfVxuICAgIGNvbXB1dGVTY3JvbGxlckRpbXMoKSB7XG4gICAgICAgIGxldCBzY3JvbGxiYXJXaWR0aCA9IGdldFNjcm9sbGJhcldpZHRocygpO1xuICAgICAgICBsZXQgeyBzY3JvbGxlclJlZnMsIHNjcm9sbGVyRWxSZWZzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZm9yY2VZU2Nyb2xsYmFycyA9IGZhbHNlO1xuICAgICAgICBsZXQgc2Nyb2xsZXJDbGllbnRXaWR0aHMgPSB7fTtcbiAgICAgICAgbGV0IHNjcm9sbGVyQ2xpZW50SGVpZ2h0cyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBzZWN0aW9uS2V5IGluIHNjcm9sbGVyUmVmcy5jdXJyZW50TWFwKSB7XG4gICAgICAgICAgICBsZXQgc2Nyb2xsZXIgPSBzY3JvbGxlclJlZnMuY3VycmVudE1hcFtzZWN0aW9uS2V5XTtcbiAgICAgICAgICAgIGlmIChzY3JvbGxlciAmJiBzY3JvbGxlci5uZWVkc1lTY3JvbGxpbmcoKSkge1xuICAgICAgICAgICAgICAgIGZvcmNlWVNjcm9sbGJhcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHNlY3Rpb24gb2YgdGhpcy5wcm9wcy5zZWN0aW9ucykge1xuICAgICAgICAgICAgbGV0IHNlY3Rpb25LZXkgPSBzZWN0aW9uLmtleTtcbiAgICAgICAgICAgIGxldCBzY3JvbGxlckVsID0gc2Nyb2xsZXJFbFJlZnMuY3VycmVudE1hcFtzZWN0aW9uS2V5XTtcbiAgICAgICAgICAgIGlmIChzY3JvbGxlckVsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhhcm5lc3NFbCA9IHNjcm9sbGVyRWwucGFyZW50Tm9kZTsgLy8gVE9ETzogd2VpcmQgd2F5IHRvIGdldCB0aGlzLiBuZWVkIGhhcm5lc3MgYi9jIGRvZXNuJ3QgaW5jbHVkZSB0YWJsZSBib3JkZXJzXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJDbGllbnRXaWR0aHNbc2VjdGlvbktleV0gPSBNYXRoLmZsb29yKGhhcm5lc3NFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIChmb3JjZVlTY3JvbGxiYXJzXG4gICAgICAgICAgICAgICAgICAgID8gc2Nyb2xsYmFyV2lkdGgueSAvLyB1c2UgZ2xvYmFsIGJlY2F1c2Ugc2Nyb2xsZXIgbWlnaHQgbm90IGhhdmUgc2Nyb2xsYmFycyB5ZXQgYnV0IHdpbGwgbmVlZCB0aGVtIGluIGZ1dHVyZVxuICAgICAgICAgICAgICAgICAgICA6IDApKTtcbiAgICAgICAgICAgICAgICBzY3JvbGxlckNsaWVudEhlaWdodHNbc2VjdGlvbktleV0gPSBNYXRoLmZsb29yKGhhcm5lc3NFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZvcmNlWVNjcm9sbGJhcnMsIHNjcm9sbGVyQ2xpZW50V2lkdGhzLCBzY3JvbGxlckNsaWVudEhlaWdodHMgfTtcbiAgICB9XG59XG5TaW1wbGVTY3JvbGxHcmlkLmFkZFN0YXRlRXF1YWxpdHkoe1xuICAgIHNjcm9sbGVyQ2xpZW50V2lkdGhzOiBpc1Byb3BzRXF1YWwsXG4gICAgc2Nyb2xsZXJDbGllbnRIZWlnaHRzOiBpc1Byb3BzRXF1YWwsXG59KTtcbmZ1bmN0aW9uIGdldFNlY3Rpb25CeUtleShzZWN0aW9ucywga2V5KSB7XG4gICAgZm9yIChsZXQgc2VjdGlvbiBvZiBzZWN0aW9ucykge1xuICAgICAgICBpZiAoc2VjdGlvbi5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNsYXNzIEV2ZW50Q29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaGFuZGxlRWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIHNldEVsU2VnKGVsLCB0aGlzLnByb3BzLnNlZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBjb25zdCB7IHNlZyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHsgZXZlbnRSYW5nZSB9ID0gc2VnO1xuICAgICAgICBjb25zdCB7IHVpIH0gPSBldmVudFJhbmdlO1xuICAgICAgICBjb25zdCByZW5kZXJQcm9wcyA9IHtcbiAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIGV2ZW50UmFuZ2UuZGVmLCBldmVudFJhbmdlLmluc3RhbmNlKSxcbiAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIHRpbWVUZXh0OiBwcm9wcy50aW1lVGV4dCxcbiAgICAgICAgICAgIHRleHRDb2xvcjogdWkudGV4dENvbG9yLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB1aS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogdWkuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBpc0RyYWdnYWJsZTogIXByb3BzLmRpc2FibGVEcmFnZ2luZyAmJiBjb21wdXRlU2VnRHJhZ2dhYmxlKHNlZywgY29udGV4dCksXG4gICAgICAgICAgICBpc1N0YXJ0UmVzaXphYmxlOiAhcHJvcHMuZGlzYWJsZVJlc2l6aW5nICYmIGNvbXB1dGVTZWdTdGFydFJlc2l6YWJsZShzZWcsIGNvbnRleHQpLFxuICAgICAgICAgICAgaXNFbmRSZXNpemFibGU6ICFwcm9wcy5kaXNhYmxlUmVzaXppbmcgJiYgY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZShzZWcpLFxuICAgICAgICAgICAgaXNNaXJyb3I6IEJvb2xlYW4ocHJvcHMuaXNEcmFnZ2luZyB8fCBwcm9wcy5pc1Jlc2l6aW5nIHx8IHByb3BzLmlzRGF0ZVNlbGVjdGluZyksXG4gICAgICAgICAgICBpc1N0YXJ0OiBCb29sZWFuKHNlZy5pc1N0YXJ0KSxcbiAgICAgICAgICAgIGlzRW5kOiBCb29sZWFuKHNlZy5pc0VuZCksXG4gICAgICAgICAgICBpc1Bhc3Q6IEJvb2xlYW4ocHJvcHMuaXNQYXN0KSxcbiAgICAgICAgICAgIGlzRnV0dXJlOiBCb29sZWFuKHByb3BzLmlzRnV0dXJlKSxcbiAgICAgICAgICAgIGlzVG9kYXk6IEJvb2xlYW4ocHJvcHMuaXNUb2RheSksXG4gICAgICAgICAgICBpc1NlbGVjdGVkOiBCb29sZWFuKHByb3BzLmlzU2VsZWN0ZWQpLFxuICAgICAgICAgICAgaXNEcmFnZ2luZzogQm9vbGVhbihwcm9wcy5pc0RyYWdnaW5nKSxcbiAgICAgICAgICAgIGlzUmVzaXppbmc6IEJvb2xlYW4ocHJvcHMuaXNSZXNpemluZyksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcyAvKiBjb250YWlucyBjaGlsZHJlbiAqLywgeyBlbFJlZjogdGhpcy5oYW5kbGVFbCwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgLi4uZ2V0RXZlbnRDbGFzc05hbWVzKHJlbmRlclByb3BzKSxcbiAgICAgICAgICAgICAgICAuLi5zZWcuZXZlbnRSYW5nZS51aS5jbGFzc05hbWVzLFxuICAgICAgICAgICAgICAgIC4uLihwcm9wcy5lbENsYXNzZXMgfHwgW10pLFxuICAgICAgICAgICAgXSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImV2ZW50Q29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuZXZlbnRDb250ZW50LCBkZWZhdWx0R2VuZXJhdG9yOiBwcm9wcy5kZWZhdWx0R2VuZXJhdG9yLCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMuZXZlbnRDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5ldmVudERpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5ldmVudFdpbGxVbm1vdW50IH0pKSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuZWwgJiYgdGhpcy5wcm9wcy5zZWcgIT09IHByZXZQcm9wcy5zZWcpIHtcbiAgICAgICAgICAgIHNldEVsU2VnKHRoaXMuZWwsIHRoaXMucHJvcHMuc2VnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gc2hvdWxkIG5vdCBiZSBhIHB1cmVjb21wb25lbnRcbmNsYXNzIFN0YW5kYXJkRXZlbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgeyBzZWcgfSA9IHByb3BzO1xuICAgICAgICBsZXQgeyB1aSB9ID0gc2VnLmV2ZW50UmFuZ2U7XG4gICAgICAgIGxldCB0aW1lRm9ybWF0ID0gb3B0aW9ucy5ldmVudFRpbWVGb3JtYXQgfHwgcHJvcHMuZGVmYXVsdFRpbWVGb3JtYXQ7XG4gICAgICAgIGxldCB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQoc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50VGltZSwgcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudEVuZCk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChFdmVudENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMgLyogaW5jbHVkZXMgZWxSZWYgKi8sIHsgZWxUYWc6IFwiYVwiLCBlbFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHVpLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdWkuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgfSwgZWxBdHRyczogZ2V0U2VnQW5jaG9yQXR0cnMoc2VnLCBjb250ZXh0KSwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXJDb250ZW50JDEsIHRpbWVUZXh0OiB0aW1lVGV4dCB9KSwgKElubmVyQ29udGVudCwgZXZlbnRDb250ZW50QXJnKSA9PiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtZXZlbnQtbWFpbiddLCBlbFN0eWxlOiB7IGNvbG9yOiBldmVudENvbnRlbnRBcmcudGV4dENvbG9yIH0gfSksXG4gICAgICAgICAgICBCb29sZWFuKGV2ZW50Q29udGVudEFyZy5pc1N0YXJ0UmVzaXphYmxlKSAmJiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC1yZXNpemVyIGZjLWV2ZW50LXJlc2l6ZXItc3RhcnRcIiB9KSksXG4gICAgICAgICAgICBCb29sZWFuKGV2ZW50Q29udGVudEFyZy5pc0VuZFJlc2l6YWJsZSkgJiYgKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtcmVzaXplciBmYy1ldmVudC1yZXNpemVyLWVuZFwiIH0pKSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50JDEoaW5uZXJQcm9wcykge1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC1tYWluLWZyYW1lXCIgfSxcbiAgICAgICAgaW5uZXJQcm9wcy50aW1lVGV4dCAmJiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aW1lXCIgfSwgaW5uZXJQcm9wcy50aW1lVGV4dCkpLFxuICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlLWNvbnRhaW5lclwiIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlIGZjLXN0aWNreVwiIH0sIGlubmVyUHJvcHMuZXZlbnQudGl0bGUgfHwgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgXCJcXHUwMEEwXCIpKSkpKTtcbn1cblxuY29uc3QgTm93SW5kaWNhdG9yQ29udGFpbmVyID0gKHByb3BzKSA9PiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXIsIG51bGwsIChjb250ZXh0KSA9PiB7XG4gICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgIGlzQXhpczogcHJvcHMuaXNBeGlzLFxuICAgICAgICBkYXRlOiBjb250ZXh0LmRhdGVFbnYudG9EYXRlKHByb3BzLmRhdGUpLFxuICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgfTtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMgLyogaW5jbHVkZXMgY2hpbGRyZW4gKi8sIHsgZWxUYWc6IHByb3BzLmVsVGFnIHx8ICdkaXYnLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwibm93SW5kaWNhdG9yQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMubm93SW5kaWNhdG9yQ29udGVudCwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLm5vd0luZGljYXRvckNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLm5vd0luZGljYXRvckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5ub3dJbmRpY2F0b3JXaWxsVW5tb3VudCB9KSkpO1xufSkpO1xuXG5jb25zdCBEQVlfTlVNX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IGRheTogJ251bWVyaWMnIH0pO1xuY2xhc3MgRGF5Q2VsbENvbnRhaW5lciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnJlZmluZVJlbmRlclByb3BzID0gbWVtb2l6ZU9iakFyZyhyZWZpbmVSZW5kZXJQcm9wcyk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCByZW5kZXJQcm9wcyA9IHRoaXMucmVmaW5lUmVuZGVyUHJvcHMoe1xuICAgICAgICAgICAgZGF0ZTogcHJvcHMuZGF0ZSxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsXG4gICAgICAgICAgICBpc01vbnRoU3RhcnQ6IHByb3BzLmlzTW9udGhTdGFydCB8fCBmYWxzZSxcbiAgICAgICAgICAgIHNob3dEYXlOdW1iZXI6IHByb3BzLnNob3dEYXlOdW1iZXIsXG4gICAgICAgICAgICBleHRyYVJlbmRlclByb3BzOiBwcm9wcy5leHRyYVJlbmRlclByb3BzLFxuICAgICAgICAgICAgdmlld0FwaTogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgZGF0ZUVudjogY29udGV4dC5kYXRlRW52LFxuICAgICAgICAgICAgbW9udGhTdGFydEZvcm1hdDogb3B0aW9ucy5tb250aFN0YXJ0Rm9ybWF0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzIC8qIGluY2x1ZGVzIGNoaWxkcmVuICovLCB7IGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgIC4uLmdldERheUNsYXNzTmFtZXMocmVuZGVyUHJvcHMsIGNvbnRleHQudGhlbWUpLFxuICAgICAgICAgICAgICAgIC4uLihwcm9wcy5lbENsYXNzZXMgfHwgW10pLFxuICAgICAgICAgICAgXSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5lbEF0dHJzKSwgKHJlbmRlclByb3BzLmlzRGlzYWJsZWQgPyB7fSA6IHsgJ2RhdGEtZGF0ZSc6IGZvcm1hdERheVN0cmluZyhwcm9wcy5kYXRlKSB9KSksIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJkYXlDZWxsQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuZGF5Q2VsbENvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHByb3BzLmRlZmF1bHRHZW5lcmF0b3IsIGNsYXNzTmFtZUdlbmVyYXRvcjogXG4gICAgICAgICAgICAvLyBkb24ndCB1c2UgY3VzdG9tIGNsYXNzTmFtZXMgaWYgZGlzYWJsZWRcbiAgICAgICAgICAgIHJlbmRlclByb3BzLmlzRGlzYWJsZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLmRheUNlbGxDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5kYXlDZWxsRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmRheUNlbGxXaWxsVW5tb3VudCB9KSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0N1c3RvbURheUNlbGxDb250ZW50KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gQm9vbGVhbihvcHRpb25zLmRheUNlbGxDb250ZW50IHx8IGhhc0N1c3RvbVJlbmRlcmluZ0hhbmRsZXIoJ2RheUNlbGxDb250ZW50Jywgb3B0aW9ucykpO1xufVxuZnVuY3Rpb24gcmVmaW5lUmVuZGVyUHJvcHMocmF3KSB7XG4gICAgbGV0IHsgZGF0ZSwgZGF0ZUVudiwgZGF0ZVByb2ZpbGUsIGlzTW9udGhTdGFydCB9ID0gcmF3O1xuICAgIGxldCBkYXlNZXRhID0gZ2V0RGF0ZU1ldGEoZGF0ZSwgcmF3LnRvZGF5UmFuZ2UsIG51bGwsIGRhdGVQcm9maWxlKTtcbiAgICBsZXQgZGF5TnVtYmVyVGV4dCA9IHJhdy5zaG93RGF5TnVtYmVyID8gKGRhdGVFbnYuZm9ybWF0KGRhdGUsIGlzTW9udGhTdGFydCA/IHJhdy5tb250aFN0YXJ0Rm9ybWF0IDogREFZX05VTV9GT1JNQVQpKSA6ICcnO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGRhdGU6IGRhdGVFbnYudG9EYXRlKGRhdGUpLCB2aWV3OiByYXcudmlld0FwaSB9LCBkYXlNZXRhKSwgeyBpc01vbnRoU3RhcnQsXG4gICAgICAgIGRheU51bWJlclRleHQgfSksIHJhdy5leHRyYVJlbmRlclByb3BzKTtcbn1cblxuY2xhc3MgQmdFdmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHNlZyB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChFdmVudENvbnRhaW5lciwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbJ2ZjLWJnLWV2ZW50J10sIGVsU3R5bGU6IHsgYmFja2dyb3VuZENvbG9yOiBzZWcuZXZlbnRSYW5nZS51aS5iYWNrZ3JvdW5kQ29sb3IgfSwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXJDb250ZW50LCBzZWc6IHNlZywgdGltZVRleHQ6IFwiXCIsIGlzRHJhZ2dpbmc6IGZhbHNlLCBpc1Jlc2l6aW5nOiBmYWxzZSwgaXNEYXRlU2VsZWN0aW5nOiBmYWxzZSwgaXNTZWxlY3RlZDogZmFsc2UsIGlzUGFzdDogcHJvcHMuaXNQYXN0LCBpc0Z1dHVyZTogcHJvcHMuaXNGdXR1cmUsIGlzVG9kYXk6IHByb3BzLmlzVG9kYXksIGRpc2FibGVEcmFnZ2luZzogdHJ1ZSwgZGlzYWJsZVJlc2l6aW5nOiB0cnVlIH0pKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQocHJvcHMpIHtcbiAgICBsZXQgeyB0aXRsZSB9ID0gcHJvcHMuZXZlbnQ7XG4gICAgcmV0dXJuIHRpdGxlICYmIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlXCIgfSwgcHJvcHMuZXZlbnQudGl0bGUpKTtcbn1cbmZ1bmN0aW9uIHJlbmRlckZpbGwoZmlsbFR5cGUpIHtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGBmYy0ke2ZpbGxUeXBlfWAgfSkpO1xufVxuXG5jb25zdCBXZWVrTnVtYmVyQ29udGFpbmVyID0gKHByb3BzKSA9PiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXIsIG51bGwsIChjb250ZXh0KSA9PiB7XG4gICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICBsZXQgeyBkYXRlIH0gPSBwcm9wcztcbiAgICBsZXQgZm9ybWF0ID0gb3B0aW9ucy53ZWVrTnVtYmVyRm9ybWF0IHx8IHByb3BzLmRlZmF1bHRGb3JtYXQ7XG4gICAgbGV0IG51bSA9IGRhdGVFbnYuY29tcHV0ZVdlZWtOdW1iZXIoZGF0ZSk7IC8vIFRPRE86IHNvbWVob3cgdXNlIGZvciBmb3JtYXR0aW5nIGFzIHdlbGw/XG4gICAgbGV0IHRleHQgPSBkYXRlRW52LmZvcm1hdChkYXRlLCBmb3JtYXQpO1xuICAgIGxldCByZW5kZXJQcm9wcyA9IHsgbnVtLCB0ZXh0LCBkYXRlIH07XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIgLy8gd2h5IGlzbid0IFdlZWtOdW1iZXJDb250ZW50QXJnIGJlaW5nIGF1dG8tZGV0ZWN0ZWQ/XG4gICAgLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcyAvKiBpbmNsdWRlcyBjaGlsZHJlbiAqLywgeyByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwid2Vla051bWJlckNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLndlZWtOdW1iZXJDb250ZW50LCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lciwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLndlZWtOdW1iZXJDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy53ZWVrTnVtYmVyRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLndlZWtOdW1iZXJXaWxsVW5tb3VudCB9KSkpO1xufSkpO1xuZnVuY3Rpb24gcmVuZGVySW5uZXIoaW5uZXJQcm9wcykge1xuICAgIHJldHVybiBpbm5lclByb3BzLnRleHQ7XG59XG5cbmNvbnN0IFBBRERJTkdfRlJPTV9WSUVXUE9SVCA9IDEwO1xuY2xhc3MgUG9wb3ZlciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdGl0bGVJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb290RWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMucm9vdEVsID0gZWw7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5lbFJlZikge1xuICAgICAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyAqYW55d2hlcmUqIGluIHRoZSBkb2N1bWVudCwgZm9yIHRoZSBhdXRvSGlkZSBmZWF0dXJlXG4gICAgICAgIHRoaXMuaGFuZGxlRG9jdW1lbnRNb3VzZURvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIC8vIG9ubHkgaGlkZSB0aGUgcG9wb3ZlciBpZiB0aGUgY2xpY2sgaGFwcGVuZWQgb3V0c2lkZSB0aGUgcG9wb3ZlclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXRWaWFSb290KGV2KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yb290RWwuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xvc2VDbGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURvY3VtZW50S2V5RG93biA9IChldikgPT4ge1xuICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNsb3NlQ2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVDbG9zZUNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHsgb25DbG9zZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmIChvbkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHRoZW1lLCBvcHRpb25zIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICAnZmMtcG9wb3ZlcicsXG4gICAgICAgICAgICB0aGVtZS5nZXRDbGFzcygncG9wb3ZlcicpLFxuICAgICAgICBdLmNvbmNhdChwcm9wcy5leHRyYUNsYXNzTmFtZXMgfHwgW10pO1xuICAgICAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMuZXh0cmFBdHRycywgeyBpZDogcHJvcHMuaWQsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHN0YXRlLnRpdGxlSWQsIHJlZjogdGhpcy5oYW5kbGVSb290RWwgfSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnZmMtcG9wb3Zlci1oZWFkZXIgJyArIHRoZW1lLmdldENsYXNzKCdwb3BvdmVySGVhZGVyJykgfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJmYy1wb3BvdmVyLXRpdGxlXCIsIGlkOiBzdGF0ZS50aXRsZUlkIH0sIHByb3BzLnRpdGxlKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogJ2ZjLXBvcG92ZXItY2xvc2UgJyArIHRoZW1lLmdldEljb25DbGFzcygnY2xvc2UnKSwgdGl0bGU6IG9wdGlvbnMuY2xvc2VIaW50LCBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsb3NlQ2xpY2sgfSkpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2ZjLXBvcG92ZXItYm9keSAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXJDb250ZW50JykgfSwgcHJvcHMuY2hpbGRyZW4pKSwgcHJvcHMucGFyZW50RWwpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVEb2N1bWVudE1vdXNlRG93bik7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50S2V5RG93bik7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVEb2N1bWVudE1vdXNlRG93bik7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50S2V5RG93bik7XG4gICAgfVxuICAgIHVwZGF0ZVNpemUoKSB7XG4gICAgICAgIGxldCB7IGlzUnRsIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCB7IGFsaWdubWVudEVsLCBhbGlnbkdyaWRUb3AgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCB7IHJvb3RFbCB9ID0gdGhpcztcbiAgICAgICAgbGV0IGFsaWdubWVudFJlY3QgPSBjb21wdXRlQ2xpcHBlZENsaWVudFJlY3QoYWxpZ25tZW50RWwpO1xuICAgICAgICBpZiAoYWxpZ25tZW50UmVjdCkge1xuICAgICAgICAgICAgbGV0IHBvcG92ZXJEaW1zID0gcm9vdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgLy8gcG9zaXRpb24gcmVsYXRpdmUgdG8gdmlld3BvcnRcbiAgICAgICAgICAgIGxldCBwb3BvdmVyVG9wID0gYWxpZ25HcmlkVG9wXG4gICAgICAgICAgICAgICAgPyBlbGVtZW50Q2xvc2VzdChhbGlnbm1lbnRFbCwgJy5mYy1zY3JvbGxncmlkJykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG4gICAgICAgICAgICAgICAgOiBhbGlnbm1lbnRSZWN0LnRvcDtcbiAgICAgICAgICAgIGxldCBwb3BvdmVyTGVmdCA9IGlzUnRsID8gYWxpZ25tZW50UmVjdC5yaWdodCAtIHBvcG92ZXJEaW1zLndpZHRoIDogYWxpZ25tZW50UmVjdC5sZWZ0O1xuICAgICAgICAgICAgLy8gY29uc3RyYWluXG4gICAgICAgICAgICBwb3BvdmVyVG9wID0gTWF0aC5tYXgocG9wb3ZlclRvcCwgUEFERElOR19GUk9NX1ZJRVdQT1JUKTtcbiAgICAgICAgICAgIHBvcG92ZXJMZWZ0ID0gTWF0aC5taW4ocG9wb3ZlckxlZnQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCAtIFBBRERJTkdfRlJPTV9WSUVXUE9SVCAtIHBvcG92ZXJEaW1zLndpZHRoKTtcbiAgICAgICAgICAgIHBvcG92ZXJMZWZ0ID0gTWF0aC5tYXgocG9wb3ZlckxlZnQsIFBBRERJTkdfRlJPTV9WSUVXUE9SVCk7XG4gICAgICAgICAgICBsZXQgb3JpZ2luID0gcm9vdEVsLm9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGFwcGx5U3R5bGUocm9vdEVsLCB7XG4gICAgICAgICAgICAgICAgdG9wOiBwb3BvdmVyVG9wIC0gb3JpZ2luLnRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0OiBwb3BvdmVyTGVmdCAtIG9yaWdpbi5sZWZ0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIE1vcmVQb3BvdmVyIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaGFuZGxlUm9vdEVsID0gKHJvb3RFbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yb290RWwgPSByb290RWw7XG4gICAgICAgICAgICBpZiAocm9vdEVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcywge1xuICAgICAgICAgICAgICAgICAgICBlbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgICAgICB1c2VFdmVudENlbnRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IG9wdGlvbnMsIGRhdGVFbnYgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHN0YXJ0RGF0ZSwgdG9kYXlSYW5nZSwgZGF0ZVByb2ZpbGUgfSA9IHByb3BzO1xuICAgICAgICBsZXQgdGl0bGUgPSBkYXRlRW52LmZvcm1hdChzdGFydERhdGUsIG9wdGlvbnMuZGF5UG9wb3ZlckZvcm1hdCk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChEYXlDZWxsQ29udGFpbmVyLCB7IGVsUmVmOiB0aGlzLmhhbmRsZVJvb3RFbCwgZGF0ZTogc3RhcnREYXRlLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UgfSwgKElubmVyQ29udGVudCwgcmVuZGVyUHJvcHMsIGVsQXR0cnMpID0+IChjcmVhdGVFbGVtZW50KFBvcG92ZXIsIHsgZWxSZWY6IGVsQXR0cnMucmVmLCBpZDogcHJvcHMuaWQsIHRpdGxlOiB0aXRsZSwgZXh0cmFDbGFzc05hbWVzOiBbJ2ZjLW1vcmUtcG9wb3ZlciddLmNvbmNhdChlbEF0dHJzLmNsYXNzTmFtZSB8fCBbXSksIGV4dHJhQXR0cnM6IGVsQXR0cnMgLyogVE9ETzogbWFrZSB0aGVzZSB0aW1lLWJhc2VkIHdoZW4gbm90IHdob2xlLWRheT8gKi8sIHBhcmVudEVsOiBwcm9wcy5wYXJlbnRFbCwgYWxpZ25tZW50RWw6IHByb3BzLmFsaWdubWVudEVsLCBhbGlnbkdyaWRUb3A6IHByb3BzLmFsaWduR3JpZFRvcCwgb25DbG9zZTogcHJvcHMub25DbG9zZSB9LFxuICAgICAgICAgICAgaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQob3B0aW9ucykgJiYgKGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtbW9yZS1wb3BvdmVyLW1pc2MnXSB9KSksXG4gICAgICAgICAgICBwcm9wcy5jaGlsZHJlbikpKSk7XG4gICAgfVxuICAgIHF1ZXJ5SGl0KHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3AsIGVsV2lkdGgsIGVsSGVpZ2h0KSB7XG4gICAgICAgIGxldCB7IHJvb3RFbCwgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChwb3NpdGlvbkxlZnQgPj0gMCAmJiBwb3NpdGlvbkxlZnQgPCBlbFdpZHRoICYmXG4gICAgICAgICAgICBwb3NpdGlvblRvcCA+PSAwICYmIHBvc2l0aW9uVG9wIDwgZWxIZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICAgICAgICAgIGRhdGVTcGFuOiBPYmplY3QuYXNzaWduKHsgYWxsRGF5OiAhcHJvcHMuZm9yY2VUaW1lZCwgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwcm9wcy5zdGFydERhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHByb3BzLmVuZERhdGUsXG4gICAgICAgICAgICAgICAgICAgIH0gfSwgcHJvcHMuZXh0cmFEYXRlU3BhbiksXG4gICAgICAgICAgICAgICAgZGF5RWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGVsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogZWxIZWlnaHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsYXllcjogMSwgLy8gaW1wb3J0YW50IHdoZW4gY29tcGFyaW5nIHdpdGggaGl0cyBmcm9tIG90aGVyIGNvbXBvbmVudHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5jbGFzcyBNb3JlTGlua0NvbnRhaW5lciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgaXNQb3BvdmVyT3BlbjogZmFsc2UsXG4gICAgICAgICAgICBwb3BvdmVySWQ6IGdldFVuaXF1ZURvbUlkKCksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlTGlua0VsID0gKGxpbmtFbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5saW5rRWwgPSBsaW5rRWw7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5lbFJlZikge1xuICAgICAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBsaW5rRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUNsaWNrID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCB7IG1vcmVMaW5rQ2xpY2sgfSA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgICAgICAgIGxldCBkYXRlID0gY29tcHV0ZVJhbmdlKHByb3BzKS5zdGFydDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGJ1aWxkUHVibGljU2VnKHNlZykge1xuICAgICAgICAgICAgICAgIGxldCB7IGRlZiwgaW5zdGFuY2UsIHJhbmdlIH0gPSBzZWcuZXZlbnRSYW5nZTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb250ZXh0LCBkZWYsIGluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGNvbnRleHQuZGF0ZUVudi50b0RhdGUocmFuZ2Uuc3RhcnQpLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGNvbnRleHQuZGF0ZUVudi50b0RhdGUocmFuZ2UuZW5kKSxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VnLmlzU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZWcuaXNFbmQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbW9yZUxpbmtDbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG1vcmVMaW5rQ2xpY2sgPSBtb3JlTGlua0NsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsRGF5OiBCb29sZWFuKHByb3BzLmFsbERheURhdGUpLFxuICAgICAgICAgICAgICAgICAgICBhbGxTZWdzOiBwcm9wcy5hbGxTZWdzLm1hcChidWlsZFB1YmxpY1NlZyksXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlblNlZ3M6IHByb3BzLmhpZGRlblNlZ3MubWFwKGJ1aWxkUHVibGljU2VnKSxcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbW9yZUxpbmtDbGljayB8fCBtb3JlTGlua0NsaWNrID09PSAncG9wb3ZlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgaXNQb3BvdmVyT3BlbjogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtb3JlTGlua0NsaWNrID09PSAnc3RyaW5nJykgeyAvLyBhIHZpZXcgbmFtZVxuICAgICAgICAgICAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkuem9vbVRvKGRhdGUsIG1vcmVMaW5rQ2xpY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVBvcG92ZXJDbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc1BvcG92ZXJPcGVuOiBmYWxzZSB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXIsIG51bGwsIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyB2aWV3QXBpLCBvcHRpb25zLCBjYWxlbmRhckFwaSB9ID0gY29udGV4dDtcbiAgICAgICAgICAgIGxldCB7IG1vcmVMaW5rVGV4dCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGxldCB7IG1vcmVDbnQgfSA9IHByb3BzO1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gY29tcHV0ZVJhbmdlKHByb3BzKTtcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gdHlwZW9mIG1vcmVMaW5rVGV4dCA9PT0gJ2Z1bmN0aW9uJyAvLyBUT0RPOiBldmVudHVhbGx5IHVzZSBmb3JtYXRXaXRoT3JkaW5hbHNcbiAgICAgICAgICAgICAgICA/IG1vcmVMaW5rVGV4dC5jYWxsKGNhbGVuZGFyQXBpLCBtb3JlQ250KVxuICAgICAgICAgICAgICAgIDogYCske21vcmVDbnR9ICR7bW9yZUxpbmtUZXh0fWA7XG4gICAgICAgICAgICBsZXQgaGludCA9IGZvcm1hdFdpdGhPcmRpbmFscyhvcHRpb25zLm1vcmVMaW5rSGludCwgW21vcmVDbnRdLCB0ZXh0KTtcbiAgICAgICAgICAgIGxldCByZW5kZXJQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICBudW06IG1vcmVDbnQsXG4gICAgICAgICAgICAgICAgc2hvcnRUZXh0OiBgKyR7bW9yZUNudH1gLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgdmlldzogdmlld0FwaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgQm9vbGVhbihwcm9wcy5tb3JlQ250KSAmJiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBwcm9wcy5lbFRhZyB8fCAnYScsIGVsUmVmOiB0aGlzLmhhbmRsZUxpbmtFbCwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi4ocHJvcHMuZWxDbGFzc2VzIHx8IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy1tb3JlLWxpbmsnLFxuICAgICAgICAgICAgICAgICAgICBdLCBlbFN0eWxlOiBwcm9wcy5lbFN0eWxlLCBlbEF0dHJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMuZWxBdHRycyksIGNyZWF0ZUFyaWFDbGlja0F0dHJzKHRoaXMuaGFuZGxlQ2xpY2spKSwgeyB0aXRsZTogaGludCwgJ2FyaWEtZXhwYW5kZWQnOiBzdGF0ZS5pc1BvcG92ZXJPcGVuLCAnYXJpYS1jb250cm9scyc6IHN0YXRlLmlzUG9wb3Zlck9wZW4gPyBzdGF0ZS5wb3BvdmVySWQgOiAnJyB9KSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcIm1vcmVMaW5rQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMubW9yZUxpbmtDb250ZW50LCBkZWZhdWx0R2VuZXJhdG9yOiBwcm9wcy5kZWZhdWx0R2VuZXJhdG9yIHx8IHJlbmRlck1vcmVMaW5rSW5uZXIsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5tb3JlTGlua0NsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLm1vcmVMaW5rRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLm1vcmVMaW5rV2lsbFVubW91bnQgfSwgcHJvcHMuY2hpbGRyZW4pKSxcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc1BvcG92ZXJPcGVuICYmIChjcmVhdGVFbGVtZW50KE1vcmVQb3BvdmVyLCB7IGlkOiBzdGF0ZS5wb3BvdmVySWQsIHN0YXJ0RGF0ZTogcmFuZ2Uuc3RhcnQsIGVuZERhdGU6IHJhbmdlLmVuZCwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBleHRyYURhdGVTcGFuOiBwcm9wcy5leHRyYURhdGVTcGFuLCBwYXJlbnRFbDogdGhpcy5wYXJlbnRFbCwgYWxpZ25tZW50RWw6IHByb3BzLmFsaWdubWVudEVsUmVmID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmFsaWdubWVudEVsUmVmLmN1cnJlbnQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5rRWwsIGFsaWduR3JpZFRvcDogcHJvcHMuYWxpZ25HcmlkVG9wLCBmb3JjZVRpbWVkOiBwcm9wcy5mb3JjZVRpbWVkLCBvbkNsb3NlOiB0aGlzLmhhbmRsZVBvcG92ZXJDbG9zZSB9LCBwcm9wcy5wb3BvdmVyQ29udGVudCgpKSkpKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQYXJlbnRFbCgpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUGFyZW50RWwoKTtcbiAgICB9XG4gICAgdXBkYXRlUGFyZW50RWwoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmtFbCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRFbCA9IGVsZW1lbnRDbG9zZXN0KHRoaXMubGlua0VsLCAnLmZjLXZpZXctaGFybmVzcycpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVyTW9yZUxpbmtJbm5lcihwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50ZXh0O1xufVxuZnVuY3Rpb24gY29tcHV0ZVJhbmdlKHByb3BzKSB7XG4gICAgaWYgKHByb3BzLmFsbERheURhdGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiBwcm9wcy5hbGxEYXlEYXRlLFxuICAgICAgICAgICAgZW5kOiBhZGREYXlzKHByb3BzLmFsbERheURhdGUsIDEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBsZXQgeyBoaWRkZW5TZWdzIH0gPSBwcm9wcztcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQoaGlkZGVuU2VncyksXG4gICAgICAgIGVuZDogY29tcHV0ZUxhdGVzdFNlZ0VuZChoaWRkZW5TZWdzKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQoc2Vncykge1xuICAgIHJldHVybiBzZWdzLnJlZHVjZShwaWNrRWFybGllc3RTdGFydCkuZXZlbnRSYW5nZS5yYW5nZS5zdGFydDtcbn1cbmZ1bmN0aW9uIHBpY2tFYXJsaWVzdFN0YXJ0KHNlZzAsIHNlZzEpIHtcbiAgICByZXR1cm4gc2VnMC5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0IDwgc2VnMS5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0ID8gc2VnMCA6IHNlZzE7XG59XG5mdW5jdGlvbiBjb21wdXRlTGF0ZXN0U2VnRW5kKHNlZ3MpIHtcbiAgICByZXR1cm4gc2Vncy5yZWR1Y2UocGlja0xhdGVzdEVuZCkuZXZlbnRSYW5nZS5yYW5nZS5lbmQ7XG59XG5mdW5jdGlvbiBwaWNrTGF0ZXN0RW5kKHNlZzAsIHNlZzEpIHtcbiAgICByZXR1cm4gc2VnMC5ldmVudFJhbmdlLnJhbmdlLmVuZCA+IHNlZzEuZXZlbnRSYW5nZS5yYW5nZS5lbmQgPyBzZWcwIDogc2VnMTtcbn1cblxuY2xhc3MgU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgfVxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIHRoaXMuaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGhhbmRsZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjcmliZShoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhhbmRsZXIodGhpcy5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKlxuU3Vic2NyaWJlcnMgd2lsbCBnZXQgYSBMSVNUIG9mIEN1c3RvbVJlbmRlcmluZ3NcbiovXG5jbGFzcyBDdXN0b21SZW5kZXJpbmdTdG9yZSBleHRlbmRzIFN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8vIGZvciBjb25zaXN0ZW50IG9yZGVyXG4gICAgaGFuZGxlKGN1c3RvbVJlbmRlcmluZykge1xuICAgICAgICBjb25zdCB7IG1hcCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGN1c3RvbVJlbmRlcmluZy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgbWFwLnNldChjdXN0b21SZW5kZXJpbmcuaWQsIGN1c3RvbVJlbmRlcmluZyk7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXAuaGFzKGN1c3RvbVJlbmRlcmluZy5pZCkpIHtcbiAgICAgICAgICAgIG1hcC5kZWxldGUoY3VzdG9tUmVuZGVyaW5nLmlkKTtcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldChtYXApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBlbGVtZW50Q2xvc2VzdCBhcyAkLCBtZW1vaXplT2JqQXJnIGFzIEEsIEJhc2VDb21wb25lbnQgYXMgQiwgQ29udGVudENvbnRhaW5lciBhcyBDLCBEZWxheWVkUnVubmVyIGFzIEQsIGlzUHJvcHNFcXVhbCBhcyBFLCBFbWl0dGVyIGFzIEYsIGdldEluaXRpYWxEYXRlIGFzIEcsIHJhbmdlQ29udGFpbnNNYXJrZXIgYXMgSCwgY3JlYXRlRW1wdHlFdmVudFN0b3JlIGFzIEksIHJlZHVjZUN1cnJlbnREYXRlIGFzIEosIHJlZHVjZUV2ZW50U3RvcmUgYXMgSywgcmV6b25lRXZlbnRTdG9yZURhdGVzIGFzIEwsIG1lcmdlUmF3T3B0aW9ucyBhcyBNLCBCQVNFX09QVElPTl9SRUZJTkVSUyBhcyBOLCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyBhcyBPLCBDQUxFTkRBUl9PUFRJT05fUkVGSU5FUlMgYXMgUCwgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlMgYXMgUSwgVklFV19PUFRJT05fUkVGSU5FUlMgYXMgUiwgRGF0ZUVudiBhcyBTLCBUaGVtZSBhcyBULCBEYXRlUHJvZmlsZUdlbmVyYXRvciBhcyBVLCBWaWV3Q29udGV4dFR5cGUgYXMgViwgY3JlYXRlRXZlbnRVaSBhcyBXLCBwYXJzZUJ1c2luZXNzSG91cnMgYXMgWCwgc2V0UmVmIGFzIFksIEludGVyYWN0aW9uIGFzIFosIGdldEVsU2VnIGFzIF8sIG1hcEhhc2ggYXMgYSwgZ2V0U2xvdENsYXNzTmFtZXMgYXMgYSQsIEV2ZW50SW1wbCBhcyBhMCwgbGlzdGVuQnlTZWxlY3RvciBhcyBhMSwgbGlzdGVuVG9Ib3ZlckJ5U2VsZWN0b3IgYXMgYTIsIFB1cmVDb21wb25lbnQgYXMgYTMsIGJ1aWxkVmlld0NvbnRleHQgYXMgYTQsIGdldFVuaXF1ZURvbUlkIGFzIGE1LCBwYXJzZUludGVyYWN0aW9uU2V0dGluZ3MgYXMgYTYsIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSBhcyBhNywgZ2V0Tm93IGFzIGE4LCBDYWxlbmRhckltcGwgYXMgYTksIGRpZmZEYXRlcyBhcyBhQSwgcmVtb3ZlRXhhY3QgYXMgYUIsIG1lbW9pemVBcnJheWxpa2UgYXMgYUMsIG1lbW9pemVIYXNobGlrZSBhcyBhRCwgaW50ZXJzZWN0UmVjdHMgYXMgYUUsIHBvaW50SW5zaWRlUmVjdCBhcyBhRiwgY29uc3RyYWluUG9pbnQgYXMgYUcsIGdldFJlY3RDZW50ZXIgYXMgYUgsIGRpZmZQb2ludHMgYXMgYUksIHRyYW5zbGF0ZVJlY3QgYXMgYUosIGNvbXBhcmVPYmpzIGFzIGFLLCBjb2xsZWN0RnJvbUhhc2ggYXMgYUwsIGZpbmRFbGVtZW50cyBhcyBhTSwgZmluZERpcmVjdENoaWxkcmVuIGFzIGFOLCByZW1vdmVFbGVtZW50IGFzIGFPLCBhcHBseVN0eWxlIGFzIGFQLCBlbGVtZW50TWF0Y2hlcyBhcyBhUSwgZ2V0RXZlbnRUYXJnZXRWaWFSb290IGFzIGFSLCBwYXJzZUNsYXNzTmFtZXMgYXMgYVMsIGdldENhblZHcm93V2l0aGluQ2VsbCBhcyBhVCwgbWVyZ2VFdmVudFN0b3JlcyBhcyBhVSwgZ2V0UmVsZXZhbnRFdmVudHMgYXMgYVYsIGV2ZW50VHVwbGVUb1N0b3JlIGFzIGFXLCBjb21iaW5lRXZlbnRVaXMgYXMgYVgsIFNwbGl0dGVyIGFzIGFZLCBnZXREYXlDbGFzc05hbWVzIGFzIGFaLCBnZXREYXRlTWV0YSBhcyBhXywgZmx1c2hTeW5jIGFzIGFhLCBDYWxlbmRhclJvb3QgYXMgYWIsIFJlbmRlcklkIGFzIGFjLCBlbnN1cmVFbEhhc1N0eWxlcyBhcyBhZCwgYXBwbHlTdHlsZVByb3AgYXMgYWUsIHNsaWNlRXZlbnRTdG9yZSBhcyBhZiwgSnNvblJlcXVlc3RFcnJvciBhcyBhZywgY3JlYXRlQ29udGV4dCBhcyBhaCwgcmVmaW5lUHJvcHMgYXMgYWksIGNyZWF0ZUV2ZW50SW5zdGFuY2UgYXMgYWosIHBhcnNlRXZlbnREZWYgYXMgYWssIHJlZmluZUV2ZW50RGVmIGFzIGFsLCBwYWRTdGFydCBhcyBhbSwgaXNJbnQgYXMgYW4sIHBhcnNlRmllbGRTcGVjcyBhcyBhbywgY29tcGFyZUJ5RmllbGRTcGVjcyBhcyBhcCwgZmxleGlibGVDb21wYXJlIGFzIGFxLCBwcmV2ZW50U2VsZWN0aW9uIGFzIGFyLCBhbGxvd1NlbGVjdGlvbiBhcyBhcywgcHJldmVudENvbnRleHRNZW51IGFzIGF0LCBhbGxvd0NvbnRleHRNZW51IGFzIGF1LCBjb21wYXJlTnVtYmVycyBhcyBhdiwgZW5hYmxlQ3Vyc29yIGFzIGF3LCBkaXNhYmxlQ3Vyc29yIGFzIGF4LCBjb21wdXRlVmlzaWJsZURheVJhbmdlIGFzIGF5LCBpc011bHRpRGF5UmFuZ2UgYXMgYXosIGJ1aWxkVmlld0NsYXNzTmFtZXMgYXMgYiwgU2ltcGxlU2Nyb2xsR3JpZCBhcyBiJCwgYnVpbGROYXZMaW5rQXR0cnMgYXMgYjAsIHByZXZlbnREZWZhdWx0IGFzIGIxLCB3aGVuVHJhbnNpdGlvbkRvbmUgYXMgYjIsIGNvbXB1dGVJbm5lclJlY3QgYXMgYjMsIGNvbXB1dGVFZGdlcyBhcyBiNCwgZ2V0Q2xpcHBpbmdQYXJlbnRzIGFzIGI1LCBjb21wdXRlUmVjdCBhcyBiNiwgcmFuZ2VzRXF1YWwgYXMgYjcsIHJhbmdlc0ludGVyc2VjdCBhcyBiOCwgcmFuZ2VDb250YWluc1JhbmdlIGFzIGI5LCBTZWdIaWVyYXJjaHkgYXMgYkEsIGJ1aWxkRW50cnlLZXkgYXMgYkIsIGdldEVudHJ5U3BhbkVuZCBhcyBiQywgYmluYXJ5U2VhcmNoIGFzIGJELCBncm91cEludGVyc2VjdGluZ0VudHJpZXMgYXMgYkUsIGludGVyc2VjdFNwYW5zIGFzIGJGLCBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZSBhcyBiRywgRWxlbWVudERyYWdnaW5nIGFzIGJILCBjb25maWcgYXMgYkksIHBhcnNlRHJhZ01ldGEgYXMgYkosIERheUhlYWRlciBhcyBiSywgY29tcHV0ZUZhbGxiYWNrSGVhZGVyRm9ybWF0IGFzIGJMLCBUYWJsZURhdGVDZWxsIGFzIGJNLCBUYWJsZURvd0NlbGwgYXMgYk4sIERheVNlcmllc01vZGVsIGFzIGJPLCBoYXNCZ1JlbmRlcmluZyBhcyBiUCwgYnVpbGRTZWdUaW1lVGV4dCBhcyBiUSwgc29ydEV2ZW50U2VncyBhcyBiUiwgZ2V0U2VnTWV0YSBhcyBiUywgYnVpbGRFdmVudFJhbmdlS2V5IGFzIGJULCBnZXRTZWdBbmNob3JBdHRycyBhcyBiVSwgRGF5VGFibGVNb2RlbCBhcyBiViwgU2xpY2VyIGFzIGJXLCBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlIGFzIGJYLCBpc1Byb3BzVmFsaWQgYXMgYlksIGlzSW50ZXJhY3Rpb25WYWxpZCBhcyBiWiwgaXNEYXRlU2VsZWN0aW9uVmFsaWQgYXMgYl8sIFBvc2l0aW9uQ2FjaGUgYXMgYmEsIFNjcm9sbENvbnRyb2xsZXIgYXMgYmIsIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyIGFzIGJjLCBXaW5kb3dTY3JvbGxDb250cm9sbGVyIGFzIGJkLCBEYXRlQ29tcG9uZW50IGFzIGJlLCBpc0RhdGVTcGFuc0VxdWFsIGFzIGJmLCBhZGRNcyBhcyBiZywgYWRkV2Vla3MgYXMgYmgsIGRpZmZXZWVrcyBhcyBiaSwgZGlmZldob2xlV2Vla3MgYXMgYmosIGRpZmZEYXlBbmRUaW1lIGFzIGJrLCBkaWZmRGF5cyBhcyBibCwgaXNWYWxpZERhdGUgYXMgYm0sIGFzQ2xlYW5EYXlzIGFzIGJuLCBtdWx0aXBseUR1cmF0aW9uIGFzIGJvLCBhZGREdXJhdGlvbnMgYXMgYnAsIGFzUm91Z2hNaW51dGVzIGFzIGJxLCBhc1JvdWdoU2Vjb25kcyBhcyBiciwgYXNSb3VnaE1zIGFzIGJzLCB3aG9sZURpdmlkZUR1cmF0aW9ucyBhcyBidCwgZm9ybWF0SXNvVGltZVN0cmluZyBhcyBidSwgZm9ybWF0RGF5U3RyaW5nIGFzIGJ2LCBidWlsZElzb1N0cmluZyBhcyBidywgZm9ybWF0SXNvTW9udGhTdHIgYXMgYngsIE5hbWVkVGltZVpvbmVJbXBsIGFzIGJ5LCBwYXJzZSBhcyBieiwgZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yIGFzIGMsIGhhc1Nocmlua1dpZHRoIGFzIGMwLCByZW5kZXJNaWNyb0NvbEdyb3VwIGFzIGMxLCBnZXRTY3JvbGxHcmlkQ2xhc3NOYW1lcyBhcyBjMiwgZ2V0U2VjdGlvbkNsYXNzTmFtZXMgYXMgYzMsIGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQgYXMgYzQsIGdldEFsbG93WVNjcm9sbGluZyBhcyBjNSwgcmVuZGVyQ2h1bmtDb250ZW50IGFzIGM2LCBjb21wdXRlU2hyaW5rV2lkdGggYXMgYzcsIHNhbml0aXplU2hyaW5rV2lkdGggYXMgYzgsIGlzQ29sUHJvcHNFcXVhbCBhcyBjOSwgcmVuZGVyU2Nyb2xsU2hpbSBhcyBjYSwgZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyIGFzIGNiLCBnZXRTdGlja3lIZWFkZXJEYXRlcyBhcyBjYywgU2Nyb2xsZXIgYXMgY2QsIGdldFNjcm9sbGJhcldpZHRocyBhcyBjZSwgUmVmTWFwIGFzIGNmLCBnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCBhcyBjZywgTm93VGltZXIgYXMgY2gsIFNjcm9sbFJlc3BvbmRlciBhcyBjaSwgU3RhbmRhcmRFdmVudCBhcyBjaiwgTm93SW5kaWNhdG9yQ29udGFpbmVyIGFzIGNrLCBEYXlDZWxsQ29udGFpbmVyIGFzIGNsLCBoYXNDdXN0b21EYXlDZWxsQ29udGVudCBhcyBjbSwgRXZlbnRDb250YWluZXIgYXMgY24sIHJlbmRlckZpbGwgYXMgY28sIEJnRXZlbnQgYXMgY3AsIFdlZWtOdW1iZXJDb250YWluZXIgYXMgY3EsIE1vcmVMaW5rQ29udGFpbmVyIGFzIGNyLCBjb21wdXRlRWFybGllc3RTZWdTdGFydCBhcyBjcywgVmlld0NvbnRhaW5lciBhcyBjdCwgdHJpZ2dlckRhdGVTZWxlY3QgYXMgY3UsIGdldERlZmF1bHRFdmVudEVuZCBhcyBjdiwgaW5qZWN0U3R5bGVzIGFzIGN3LCBidWlsZEVsQXR0cnMgYXMgY3gsIEN1c3RvbVJlbmRlcmluZ1N0b3JlIGFzIGN5LCBjcmVhdGVEdXJhdGlvbiBhcyBkLCBCQVNFX09QVElPTl9ERUZBVUxUUyBhcyBlLCBhcnJheVRvSGFzaCBhcyBmLCBndWlkIGFzIGcsIGZpbHRlckhhc2ggYXMgaCwgaXNBcnJheXNFcXVhbCBhcyBpLCBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMgYXMgaiwgZm9ybWF0V2l0aE9yZGluYWxzIGFzIGssIGJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUgYXMgbCwgbWVyZ2VQcm9wcyBhcyBtLCBpZGVudGl0eSBhcyBuLCBpbnRlcnNlY3RSYW5nZXMgYXMgbywgcGFyc2VFdmVudFNvdXJjZSBhcyBwLCBzdGFydE9mRGF5IGFzIHEsIHJlcXVlc3RKc29uIGFzIHIsIHN1YnRyYWN0RHVyYXRpb25zIGFzIHMsIGFkZERheXMgYXMgdCwgdW5wcm9taXNpZnkgYXMgdSwgaGFzaFZhbHVlc1RvQXJyYXkgYXMgdiwgYnVpbGRFdmVudEFwaXMgYXMgdywgY3JlYXRlRm9ybWF0dGVyIGFzIHgsIGRpZmZXaG9sZURheXMgYXMgeSwgbWVtb2l6ZSBhcyB6IH07XG4iXSwibmFtZXMiOlsicHJlYWN0IiwiQ29tcG9uZW50IiwiY3JlYXRlRWxlbWVudCIsImlzVmFsaWRFbGVtZW50IiwiRnJhZ21lbnQiLCJjcmVhdGVQb3J0YWwiLCJzdHlsZVRleHRzIiwic3R5bGVFbHMiLCJNYXAiLCJpbmplY3RTdHlsZXMiLCJzdHlsZVRleHQiLCJwdXNoIiwiZm9yRWFjaCIsInN0eWxlRWwiLCJhcHBlbmRTdHlsZXNUbyIsImVuc3VyZUVsSGFzU3R5bGVzIiwiZWwiLCJpc0Nvbm5lY3RlZCIsInJlZ2lzdGVyU3R5bGVzUm9vdCIsImdldFJvb3ROb2RlIiwicm9vdE5vZGUiLCJnZXQiLCJxdWVyeVNlbGVjdG9yIiwiZG9jdW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJub25jZSIsImdldE5vbmNlVmFsdWUiLCJwYXJlbnRFbCIsImhlYWQiLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwic2V0IiwiaHlkcmF0ZVN0eWxlc1Jvb3QiLCJzaGVldCIsInJ1bGVDbnQiLCJjc3NSdWxlcyIsImxlbmd0aCIsInNwbGl0Iiwic3R5bGVTdHIiLCJpIiwidHJpbSIsImluc2VydFJ1bGUiLCJxdWVyaWVkTm9uY2VWYWx1ZSIsInVuZGVmaW5lZCIsInF1ZXJ5Tm9uY2VWYWx1ZSIsIm1ldGFXaXRoTm9uY2UiLCJoYXNBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJlbFdpdGhOb25jZSIsImNzc18yNDh6IiwiRGVsYXllZFJ1bm5lciIsImNvbnN0cnVjdG9yIiwiZHJhaW5lZE9wdGlvbiIsImlzUnVubmluZyIsImlzRGlydHkiLCJwYXVzZURlcHRocyIsInRpbWVvdXRJZCIsInJlcXVlc3QiLCJkZWxheSIsImlzUGF1c2VkIiwiY2xlYXJUaW1lb3V0IiwidHJ5RHJhaW4iLCJzZXRUaW1lb3V0IiwiYmluZCIsInBhdXNlIiwic2NvcGUiLCJyZXN1bWUiLCJmb3JjZSIsImRlcHRoIiwiT2JqZWN0Iiwia2V5cyIsImRyYWluZWQiLCJjbGVhciIsInJlbW92ZUVsZW1lbnQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJlbGVtZW50Q2xvc2VzdCIsInNlbGVjdG9yIiwiY2xvc2VzdCIsImRvY3VtZW50RWxlbWVudCIsImNvbnRhaW5zIiwiZWxlbWVudE1hdGNoZXMiLCJwYXJlbnRFbGVtZW50Iiwibm9kZVR5cGUiLCJtZXRob2QiLCJtYXRjaGVzIiwibWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJjYWxsIiwiZmluZEVsZW1lbnRzIiwiY29udGFpbmVyIiwiY29udGFpbmVycyIsIkhUTUxFbGVtZW50IiwiYWxsTWF0Y2hlcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJqIiwiZmluZERpcmVjdENoaWxkcmVuIiwicGFyZW50IiwicGFyZW50cyIsImNoaWxkTm9kZXMiLCJjaGlsZHJlbiIsImNoaWxkTm9kZSIsIlBJWEVMX1BST1BfUkUiLCJhcHBseVN0eWxlIiwicHJvcHMiLCJwcm9wTmFtZSIsImFwcGx5U3R5bGVQcm9wIiwibmFtZSIsInZhbCIsInN0eWxlIiwidGVzdCIsImdldEV2ZW50VGFyZ2V0VmlhUm9vdCIsImV2IiwiX2EiLCJfYiIsImNvbXBvc2VkUGF0aCIsInRhcmdldCIsImd1aWQkMSIsImdldFVuaXF1ZURvbUlkIiwicHJldmVudERlZmF1bHQiLCJidWlsZERlbGVnYXRpb25IYW5kbGVyIiwiaGFuZGxlciIsIm1hdGNoZWRDaGlsZCIsImxpc3RlbkJ5U2VsZWN0b3IiLCJldmVudFR5cGUiLCJhdHRhY2hlZEhhbmRsZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImxpc3RlblRvSG92ZXJCeVNlbGVjdG9yIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwiY3VycmVudE1hdGNoZWRDaGlsZCIsIm1vdXNlT3ZlckV2IiwicmVhbE9uTW91c2VMZWF2ZSIsIm1vdXNlTGVhdmVFdiIsInRyYW5zaXRpb25FdmVudE5hbWVzIiwid2hlblRyYW5zaXRpb25Eb25lIiwiY2FsbGJhY2siLCJyZWFsQ2FsbGJhY2siLCJldmVudE5hbWUiLCJjcmVhdGVBcmlhQ2xpY2tBdHRycyIsImFzc2lnbiIsIm9uQ2xpY2siLCJjcmVhdGVBcmlhS2V5Ym9hcmRBdHRycyIsInRhYkluZGV4Iiwib25LZXlEb3duIiwia2V5IiwiZ3VpZE51bWJlciIsImd1aWQiLCJTdHJpbmciLCJkaXNhYmxlQ3Vyc29yIiwiYm9keSIsImNsYXNzTGlzdCIsImFkZCIsImVuYWJsZUN1cnNvciIsInJlbW92ZSIsInByZXZlbnRTZWxlY3Rpb24iLCJ1c2VyU2VsZWN0Iiwid2Via2l0VXNlclNlbGVjdCIsImFsbG93U2VsZWN0aW9uIiwicHJldmVudENvbnRleHRNZW51IiwiYWxsb3dDb250ZXh0TWVudSIsInBhcnNlRmllbGRTcGVjcyIsImlucHV0Iiwic3BlY3MiLCJ0b2tlbnMiLCJ0b2tlbiIsIkFycmF5IiwiaXNBcnJheSIsImNoYXJBdCIsImZpZWxkIiwic3Vic3RyaW5nIiwib3JkZXIiLCJmdW5jIiwiY29tcGFyZUJ5RmllbGRTcGVjcyIsIm9iajAiLCJvYmoxIiwiZmllbGRTcGVjcyIsImNtcCIsImNvbXBhcmVCeUZpZWxkU3BlYyIsImZpZWxkU3BlYyIsImZsZXhpYmxlQ29tcGFyZSIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsInBhZFN0YXJ0IiwibGVuIiwicyIsInN1YnN0ciIsImZvcm1hdFdpdGhPcmRpbmFscyIsImZvcm1hdHRlciIsImFyZ3MiLCJmYWxsYmFja1RleHQiLCJyZWR1Y2UiLCJzdHIiLCJhcmciLCJpbmRleCIsInJlcGxhY2UiLCJjb21wYXJlTnVtYmVycyIsImlzSW50IiwibiIsImNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aCIsImNlbGxFbCIsImFsbFdpZHRoRWwiLCJjb250ZW50V2lkdGhFbCIsIkVycm9yIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJJTlRFUk5BTF9VTklUUyIsIlBBUlNFX1JFIiwiY3JlYXRlRHVyYXRpb24iLCJ1bml0IiwicGFyc2VTdHJpbmciLCJwYXJzZU9iamVjdCIsIm0iLCJleGVjIiwic2lnbiIsInllYXJzIiwibW9udGhzIiwiZGF5cyIsInBhcnNlSW50IiwibWlsbGlzZWNvbmRzIiwib2JqIiwiZHVyYXRpb24iLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJob3VycyIsImhvdXIiLCJtaW51dGVzIiwibWludXRlIiwic2Vjb25kcyIsInNlY29uZCIsIm1pbGxpc2Vjb25kIiwibXMiLCJ3ZWVrcyIsIndlZWsiLCJzcGVjaWZpZWRXZWVrcyIsImR1cmF0aW9uc0VxdWFsIiwiZDAiLCJkMSIsImFzQ2xlYW5EYXlzIiwiZHVyIiwiYWRkRHVyYXRpb25zIiwic3VidHJhY3REdXJhdGlvbnMiLCJtdWx0aXBseUR1cmF0aW9uIiwiZCIsImFzUm91Z2hZZWFycyIsImFzUm91Z2hEYXlzIiwiYXNSb3VnaE1vbnRocyIsImFzUm91Z2hNcyIsImFzUm91Z2hNaW51dGVzIiwiYXNSb3VnaFNlY29uZHMiLCJ3aG9sZURpdmlkZUR1cmF0aW9ucyIsIm51bWVyYXRvciIsImRlbm9taW5hdG9yIiwicmVzIiwibG9jYWxSZXMiLCJncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IiLCJ2YWx1ZSIsInJlbW92ZUV4YWN0IiwiYXJyYXkiLCJleGFjdFZhbCIsInJlbW92ZUNudCIsInNwbGljZSIsImlzQXJyYXlzRXF1YWwiLCJhMCIsImExIiwiZXF1YWxpdHlGdW5jIiwiREFZX0lEUyIsImFkZFdlZWtzIiwiZGF0ZVRvVXRjQXJyYXkiLCJhcnJheVRvVXRjRGF0ZSIsImFkZERheXMiLCJhZGRNcyIsImRpZmZXZWVrcyIsIm0wIiwibTEiLCJkaWZmRGF5cyIsInZhbHVlT2YiLCJkaWZmSG91cnMiLCJkaWZmTWludXRlcyIsImRpZmZTZWNvbmRzIiwiZGlmZkRheUFuZFRpbWUiLCJtMGRheSIsInN0YXJ0T2ZEYXkiLCJtMWRheSIsIk1hdGgiLCJyb3VuZCIsImRpZmZXaG9sZVdlZWtzIiwiZGlmZldob2xlRGF5cyIsInRpbWVBc01zIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJzdGFydE9mSG91ciIsImdldFVUQ0hvdXJzIiwic3RhcnRPZk1pbnV0ZSIsImdldFVUQ01pbnV0ZXMiLCJzdGFydE9mU2Vjb25kIiwiZ2V0VVRDU2Vjb25kcyIsIndlZWtPZlllYXIiLCJtYXJrZXIiLCJkb3ciLCJkb3kiLCJ5IiwidyIsIndlZWtPZkdpdmVuWWVhciIsIm5leHRXIiwibWluIiwiZmlyc3RXZWVrU3RhcnQiLCJmaXJzdFdlZWtPZmZzZXQiLCJkYXlTdGFydCIsImZsb29yIiwiZndkIiwiZndkbHciLCJnZXRVVENEYXkiLCJkYXRlVG9Mb2NhbEFycmF5IiwiZGF0ZSIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImdldE1pbGxpc2Vjb25kcyIsImFycmF5VG9Mb2NhbERhdGUiLCJEYXRlIiwiZ2V0VVRDTWlsbGlzZWNvbmRzIiwiY29uY2F0IiwiVVRDIiwiaXNWYWxpZERhdGUiLCJpc05hTiIsImJ1aWxkSXNvU3RyaW5nIiwidGltZVpvbmVPZmZzZXQiLCJzdHJpcFplcm9UaW1lIiwidG9JU09TdHJpbmciLCJmb3JtYXRUaW1lWm9uZU9mZnNldCIsImZvcm1hdERheVN0cmluZyIsImZvcm1hdElzb01vbnRoU3RyIiwibWF0Y2giLCJmb3JtYXRJc29UaW1lU3RyaW5nIiwiZG9Jc28iLCJhYnMiLCJtaW5zIiwibWVtb2l6ZSIsIndvcmtlckZ1bmMiLCJyZXNFcXVhbGl0eSIsInRlYXJkb3duRnVuYyIsImN1cnJlbnRBcmdzIiwiY3VycmVudFJlcyIsIm5ld0FyZ3MiLCJhcHBseSIsIm1lbW9pemVPYmpBcmciLCJjdXJyZW50QXJnIiwibmV3QXJnIiwiaXNQcm9wc0VxdWFsIiwibWVtb2l6ZUFycmF5bGlrZSIsImN1cnJlbnRBcmdTZXRzIiwiY3VycmVudFJlc3VsdHMiLCJuZXdBcmdTZXRzIiwiY3VycmVudExlbiIsIm5ld0xlbiIsIm1lbW9pemVIYXNobGlrZSIsImN1cnJlbnRBcmdIYXNoIiwiY3VycmVudFJlc0hhc2giLCJuZXdBcmdIYXNoIiwibmV3UmVzSGFzaCIsIkVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTIiwic2VwYXJhdG9yIiwib21pdFplcm9NaW51dGUiLCJtZXJpZGllbSIsIm9taXRDb21tYXMiLCJTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUyIsInRpbWVab25lTmFtZSIsImVyYSIsIndlZWtkYXkiLCJNRVJJRElFTV9SRSIsIkNPTU1BX1JFIiwiTVVMVElfU1BBQ0VfUkUiLCJMVFJfUkUiLCJVVENfUkUiLCJOYXRpdmVGb3JtYXR0ZXIiLCJmb3JtYXRTZXR0aW5ncyIsInN0YW5kYXJkRGF0ZVByb3BzIiwiZXh0ZW5kZWRTZXR0aW5ncyIsInNldmVyaXR5IiwibWF4IiwiYnVpbGRGb3JtYXR0aW5nRnVuYyIsImZvcm1hdCIsImNvbnRleHQiLCJmb3JtYXRSYW5nZSIsInN0YXJ0IiwiZW5kIiwiYmV0dGVyRGVmYXVsdFNlcGFyYXRvciIsImRpZmZTZXZlcml0eSIsImNvbXB1dGVNYXJrZXJEaWZmU2V2ZXJpdHkiLCJjYWxlbmRhclN5c3RlbSIsImJpZ2dlc3RVbml0Rm9yUGFydGlhbCIsImZ1bGwwIiwiZnVsbDEiLCJwYXJ0aWFsRGF0ZVByb3BzIiwiY29tcHV0ZVBhcnRpYWxGb3JtYXR0aW5nT3B0aW9ucyIsInBhcnRpYWxGb3JtYXR0aW5nRnVuYyIsInBhcnRpYWwwIiwicGFydGlhbDEiLCJpbnNlcnRpb24iLCJmaW5kQ29tbW9uSW5zZXJ0aW9uIiwiZGVmYXVsdFNlcGFyYXRvciIsImJlZm9yZSIsImFmdGVyIiwiZ2V0TGFyZ2VzdFVuaXQiLCJzdGFuZGFyZERhdGVQcm9wQ250IiwiZm9ybWF0V2Vla051bWJlciIsImNvbXB1dGVXZWVrTnVtYmVyIiwid2Vla1RleHQiLCJ3ZWVrVGV4dExvbmciLCJsb2NhbGUiLCJidWlsZE5hdGl2ZUZvcm1hdHRpbmdGdW5jIiwic2FuaXRpemVTZXR0aW5ncyIsInRpbWVab25lIiwibm9ybWFsRm9ybWF0IiwiSW50bCIsIkRhdGVUaW1lRm9ybWF0IiwiY29kZXMiLCJ6ZXJvRm9ybWF0IiwiemVyb1Byb3BzIiwicG9zdFByb2Nlc3MiLCJpbmplY3RUem9TdHIiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsInR6b1N0ciIsInJlcGxhY2VkIiwibnVtIiwiZGlzcGxheSIsInBhcnRzIiwic2ltcGxlTnVtYmVyRm9ybWF0Iiwib3B0aW9ucyIsImRpcmVjdGlvbiIsInJldmVyc2UiLCJqb2luIiwiY2EiLCJnZXRNYXJrZXJZZWFyIiwiZ2V0TWFya2VyTW9udGgiLCJnZXRNYXJrZXJEYXkiLCJiaWdnZXN0VW5pdCIsInBhcnRpYWxPcHRpb25zIiwiaTAiLCJmb3VuZDAiLCJpbmRleE9mIiwiYmVmb3JlMCIsImFmdGVyMCIsImkxIiwiZm91bmQxIiwiYmVmb3JlMSIsImFmdGVyMSIsImV4cGFuZFpvbmVkTWFya2VyIiwiZGF0ZUluZm8iLCJtYXJrZXJUb0FycmF5IiwiY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmciLCJzdGFydEluZm8iLCJlbmRJbmZvIiwibG9jYWxlQ29kZXMiLCJDbWRGb3JtYXR0ZXIiLCJjbWRTdHIiLCJjbWRGb3JtYXR0ZXIiLCJGdW5jRm9ybWF0dGVyIiwiY3JlYXRlRm9ybWF0dGVyIiwiQkFTRV9PUFRJT05fUkVGSU5FUlMiLCJuYXZMaW5rRGF5Q2xpY2siLCJpZGVudGl0eSIsIm5hdkxpbmtXZWVrQ2xpY2siLCJib290c3RyYXBGb250QXdlc29tZSIsImJ1dHRvbkljb25zIiwiY3VzdG9tQnV0dG9ucyIsImRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uIiwiZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbiIsIm5leHREYXlUaHJlc2hvbGQiLCJzY3JvbGxUaW1lIiwic2Nyb2xsVGltZVJlc2V0IiwiQm9vbGVhbiIsInNsb3RNaW5UaW1lIiwic2xvdE1heFRpbWUiLCJkYXlQb3BvdmVyRm9ybWF0Iiwic2xvdER1cmF0aW9uIiwic25hcER1cmF0aW9uIiwiaGVhZGVyVG9vbGJhciIsImZvb3RlclRvb2xiYXIiLCJkZWZhdWx0UmFuZ2VTZXBhcmF0b3IiLCJ0aXRsZVJhbmdlU2VwYXJhdG9yIiwiZm9yY2VFdmVudER1cmF0aW9uIiwiZGF5SGVhZGVycyIsImRheUhlYWRlckZvcm1hdCIsImRheUhlYWRlckNsYXNzTmFtZXMiLCJkYXlIZWFkZXJDb250ZW50IiwiZGF5SGVhZGVyRGlkTW91bnQiLCJkYXlIZWFkZXJXaWxsVW5tb3VudCIsImRheUNlbGxDbGFzc05hbWVzIiwiZGF5Q2VsbENvbnRlbnQiLCJkYXlDZWxsRGlkTW91bnQiLCJkYXlDZWxsV2lsbFVubW91bnQiLCJpbml0aWFsVmlldyIsImFzcGVjdFJhdGlvIiwiTnVtYmVyIiwid2Vla2VuZHMiLCJ3ZWVrTnVtYmVyQ2FsY3VsYXRpb24iLCJ3ZWVrTnVtYmVycyIsIndlZWtOdW1iZXJDbGFzc05hbWVzIiwid2Vla051bWJlckNvbnRlbnQiLCJ3ZWVrTnVtYmVyRGlkTW91bnQiLCJ3ZWVrTnVtYmVyV2lsbFVubW91bnQiLCJlZGl0YWJsZSIsInZpZXdDbGFzc05hbWVzIiwidmlld0RpZE1vdW50Iiwidmlld1dpbGxVbm1vdW50Iiwibm93SW5kaWNhdG9yIiwibm93SW5kaWNhdG9yQ2xhc3NOYW1lcyIsIm5vd0luZGljYXRvckNvbnRlbnQiLCJub3dJbmRpY2F0b3JEaWRNb3VudCIsIm5vd0luZGljYXRvcldpbGxVbm1vdW50Iiwic2hvd05vbkN1cnJlbnREYXRlcyIsImxhenlGZXRjaGluZyIsInN0YXJ0UGFyYW0iLCJlbmRQYXJhbSIsInRpbWVab25lUGFyYW0iLCJsb2NhbGVzIiwidGhlbWVTeXN0ZW0iLCJkcmFnUmV2ZXJ0RHVyYXRpb24iLCJkcmFnU2Nyb2xsIiwiYWxsRGF5TWFpbnRhaW5EdXJhdGlvbiIsInVuc2VsZWN0QXV0byIsImRyb3BBY2NlcHQiLCJldmVudE9yZGVyIiwiZXZlbnRPcmRlclN0cmljdCIsImhhbmRsZVdpbmRvd1Jlc2l6ZSIsIndpbmRvd1Jlc2l6ZURlbGF5IiwibG9uZ1ByZXNzRGVsYXkiLCJldmVudERyYWdNaW5EaXN0YW5jZSIsImV4cGFuZFJvd3MiLCJoZWlnaHQiLCJjb250ZW50SGVpZ2h0Iiwid2Vla051bWJlckZvcm1hdCIsImV2ZW50UmVzaXphYmxlRnJvbVN0YXJ0IiwiZGlzcGxheUV2ZW50VGltZSIsImRpc3BsYXlFdmVudEVuZCIsInByb2dyZXNzaXZlRXZlbnRSZW5kZXJpbmciLCJidXNpbmVzc0hvdXJzIiwiaW5pdGlhbERhdGUiLCJub3ciLCJldmVudERhdGFUcmFuc2Zvcm0iLCJzdGlja3lIZWFkZXJEYXRlcyIsInN0aWNreUZvb3RlclNjcm9sbGJhciIsInZpZXdIZWlnaHQiLCJkZWZhdWx0QWxsRGF5IiwiZXZlbnRTb3VyY2VGYWlsdXJlIiwiZXZlbnRTb3VyY2VTdWNjZXNzIiwiZXZlbnREaXNwbGF5IiwiZXZlbnRTdGFydEVkaXRhYmxlIiwiZXZlbnREdXJhdGlvbkVkaXRhYmxlIiwiZXZlbnRPdmVybGFwIiwiZXZlbnRDb25zdHJhaW50IiwiZXZlbnRBbGxvdyIsImV2ZW50QmFja2dyb3VuZENvbG9yIiwiZXZlbnRCb3JkZXJDb2xvciIsImV2ZW50VGV4dENvbG9yIiwiZXZlbnRDb2xvciIsImV2ZW50Q2xhc3NOYW1lcyIsImV2ZW50Q29udGVudCIsImV2ZW50RGlkTW91bnQiLCJldmVudFdpbGxVbm1vdW50Iiwic2VsZWN0Q29uc3RyYWludCIsInNlbGVjdE92ZXJsYXAiLCJzZWxlY3RBbGxvdyIsImRyb3BwYWJsZSIsInVuc2VsZWN0Q2FuY2VsIiwic2xvdExhYmVsRm9ybWF0Iiwic2xvdExhbmVDbGFzc05hbWVzIiwic2xvdExhbmVDb250ZW50Iiwic2xvdExhbmVEaWRNb3VudCIsInNsb3RMYW5lV2lsbFVubW91bnQiLCJzbG90TGFiZWxDbGFzc05hbWVzIiwic2xvdExhYmVsQ29udGVudCIsInNsb3RMYWJlbERpZE1vdW50Iiwic2xvdExhYmVsV2lsbFVubW91bnQiLCJkYXlNYXhFdmVudHMiLCJkYXlNYXhFdmVudFJvd3MiLCJkYXlNaW5XaWR0aCIsInNsb3RMYWJlbEludGVydmFsIiwiYWxsRGF5VGV4dCIsImFsbERheUNsYXNzTmFtZXMiLCJhbGxEYXlDb250ZW50IiwiYWxsRGF5RGlkTW91bnQiLCJhbGxEYXlXaWxsVW5tb3VudCIsInNsb3RNaW5XaWR0aCIsIm5hdkxpbmtzIiwiZXZlbnRUaW1lRm9ybWF0IiwicmVyZW5kZXJEZWxheSIsIm1vcmVMaW5rVGV4dCIsIm1vcmVMaW5rSGludCIsInNlbGVjdE1pbkRpc3RhbmNlIiwic2VsZWN0YWJsZSIsInNlbGVjdExvbmdQcmVzc0RlbGF5IiwiZXZlbnRMb25nUHJlc3NEZWxheSIsInNlbGVjdE1pcnJvciIsImV2ZW50TWF4U3RhY2siLCJldmVudE1pbkhlaWdodCIsImV2ZW50TWluV2lkdGgiLCJldmVudFNob3J0SGVpZ2h0Iiwic2xvdEV2ZW50T3ZlcmxhcCIsInBsdWdpbnMiLCJmaXJzdERheSIsImRheUNvdW50IiwiZGF0ZUFsaWdubWVudCIsImRhdGVJbmNyZW1lbnQiLCJoaWRkZW5EYXlzIiwiZml4ZWRXZWVrQ291bnQiLCJ2YWxpZFJhbmdlIiwidmlzaWJsZVJhbmdlIiwidGl0bGVGb3JtYXQiLCJldmVudEludGVyYWN0aXZlIiwibm9FdmVudHNUZXh0Iiwidmlld0hpbnQiLCJuYXZMaW5rSGludCIsImNsb3NlSGludCIsInRpbWVIaW50IiwiZXZlbnRIaW50IiwibW9yZUxpbmtDbGljayIsIm1vcmVMaW5rQ2xhc3NOYW1lcyIsIm1vcmVMaW5rQ29udGVudCIsIm1vcmVMaW5rRGlkTW91bnQiLCJtb3JlTGlua1dpbGxVbm1vdW50IiwibW9udGhTdGFydEZvcm1hdCIsImhhbmRsZUN1c3RvbVJlbmRlcmluZyIsImN1c3RvbVJlbmRlcmluZ01ldGFNYXAiLCJjdXN0b21SZW5kZXJpbmdSZXBsYWNlcyIsIkJBU0VfT1BUSU9OX0RFRkFVTFRTIiwiY2VudGVyIiwiQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlMiLCJkYXRlc1NldCIsImV2ZW50c1NldCIsImV2ZW50QWRkIiwiZXZlbnRDaGFuZ2UiLCJldmVudFJlbW92ZSIsIndpbmRvd1Jlc2l6ZSIsImV2ZW50Q2xpY2siLCJldmVudE1vdXNlRW50ZXIiLCJldmVudE1vdXNlTGVhdmUiLCJzZWxlY3QiLCJ1bnNlbGVjdCIsImxvYWRpbmciLCJfdW5tb3VudCIsIl9iZWZvcmVwcmludCIsIl9hZnRlcnByaW50IiwiX25vRXZlbnREcm9wIiwiX25vRXZlbnRSZXNpemUiLCJfcmVzaXplIiwiX3Njcm9sbFJlcXVlc3QiLCJDQUxFTkRBUl9PUFRJT05fUkVGSU5FUlMiLCJidXR0b25UZXh0IiwiYnV0dG9uSGludHMiLCJ2aWV3cyIsImluaXRpYWxFdmVudHMiLCJldmVudHMiLCJldmVudFNvdXJjZXMiLCJDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUyIsImlzTWF5YmVPYmplY3RzRXF1YWwiLCJpc01heWJlQXJyYXlzRXF1YWwiLCJWSUVXX09QVElPTl9SRUZJTkVSUyIsInR5cGUiLCJjb21wb25lbnQiLCJidXR0b25UZXh0S2V5IiwiZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyIsInVzZXNNaW5NYXhUaW1lIiwiY2xhc3NOYW1lcyIsImNvbnRlbnQiLCJkaWRNb3VudCIsIndpbGxVbm1vdW50IiwibWVyZ2VSYXdPcHRpb25zIiwib3B0aW9uU2V0cyIsIm1lcmdlUHJvcHMiLCJyZWZpbmVQcm9wcyIsInJlZmluZXJzIiwicmVmaW5lZCIsImV4dHJhIiwicmF3IiwiaGFzT3duUHJvcGVydHkiLCJwcm90b3R5cGUiLCJwcm9wT2JqcyIsImNvbXBsZXhQcm9wc01hcCIsImRlc3QiLCJjb21wbGV4T2JqcyIsInVuc2hpZnQiLCJmaWx0ZXJIYXNoIiwiaGFzaCIsImZpbHRlcmVkIiwibWFwSGFzaCIsIm5ld0hhc2giLCJhcnJheVRvSGFzaCIsIml0ZW0iLCJoYXNoVmFsdWVzVG9BcnJheSIsIkhBTkRMRVJfUkUiLCJpc05vbkhhbmRsZXJQcm9wc0VxdWFsIiwiZ2V0VW5lcXVhbFByb3BzIiwiY29tcGFyZU9ianMiLCJvbGRQcm9wcyIsIm5ld1Byb3BzIiwiZXF1YWxpdHlGdW5jcyIsImlzT2JqVmFsc0VxdWFsIiwidmFsMCIsInZhbDEiLCJjb21wYXJhdG9yIiwiY29sbGVjdEZyb21IYXNoIiwic3RhcnRJbmRleCIsImVuZEluZGV4Iiwic3RlcCIsImNhbGVuZGFyU3lzdGVtQ2xhc3NNYXAiLCJyZWdpc3RlckNhbGVuZGFyU3lzdGVtIiwidGhlQ2xhc3MiLCJjcmVhdGVDYWxlbmRhclN5c3RlbSIsIkdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtIiwiYXJyYXlUb01hcmtlciIsImFyciIsIklTT19SRSIsInBhcnNlIiwiaXNUaW1lVW5zcGVjaWZpZWQiLCJEYXRlRW52Iiwic2V0dGluZ3MiLCJpc05hbWVkVGltZVpvbmUiLCJuYW1lZFRpbWVab25lSW1wbCIsImNhbkNvbXB1dGVPZmZzZXQiLCJ3ZWVrRG93Iiwid2Vla0RveSIsIndlZWtOdW1iZXJGdW5jIiwiY3JlYXRlTWFya2VyIiwibWV0YSIsImNyZWF0ZU1hcmtlck1ldGEiLCJjcmVhdGVOb3dNYXJrZXIiLCJ0aW1lc3RhbXBUb01hcmtlciIsImZvcmNlZFR6byIsImdldFllYXIiLCJnZXREYXkiLCJzdWJ0cmFjdCIsImFkZFllYXJzIiwiYWRkTW9udGhzIiwiZGlmZldob2xlWWVhcnMiLCJkaWZmV2hvbGVNb250aHMiLCJncmVhdGVzdFdob2xlVW5pdCIsImNvdW50RHVyYXRpb25zQmV0d2VlbiIsImRpZmYiLCJzdGFydE9mIiwic3RhcnRPZlllYXIiLCJzdGFydE9mTW9udGgiLCJzdGFydE9mV2VlayIsInRvRGF0ZSIsImRhdGVPcHRpb25zIiwib2Zmc2V0Rm9yTWFya2VyIiwiaXNFbmRFeGNsdXNpdmUiLCJmb3JjZWRTdGFydFR6byIsImZvcmNlZEVuZFR6byIsImZvcm1hdElzbyIsImV4dHJhT3B0aW9ucyIsIm9taXRUaW1lWm9uZU9mZnNldCIsIm9taXRUaW1lIiwidGltZXN0YW1wVG9BcnJheSIsImdldFRpbWV6b25lT2Zmc2V0Iiwib2Zmc2V0Rm9yQXJyYXkiLCJUaGVtZSIsImNhbGVuZGFyT3B0aW9ucyIsImljb25PdmVycmlkZU9wdGlvbiIsInNldEljb25PdmVycmlkZSIsImljb25PdmVycmlkZUhhc2giLCJpY29uQ2xhc3Nlc0NvcHkiLCJidXR0b25OYW1lIiwiaWNvbkNsYXNzZXMiLCJhcHBseUljb25PdmVycmlkZVByZWZpeCIsImNsYXNzTmFtZSIsInByZWZpeCIsImljb25PdmVycmlkZVByZWZpeCIsImdldENsYXNzIiwiY2xhc3NlcyIsImdldEljb25DbGFzcyIsImlzUnRsIiwicnRsSWNvbkNsYXNzZXMiLCJiYXNlSWNvbkNsYXNzIiwiZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzIiwiY3VzdG9tQnV0dG9uUHJvcHMiLCJpY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24iLCJmbHVzaFN5bmMiLCJydW5CZWZvcmVGbHVzaCIsIm9sZERlYm91bmNlUmVuZGVyaW5nIiwiZGVib3VuY2VSZW5kZXJpbmciLCJjYWxsYmFja1EiLCJleGVjQ2FsbGJhY2tTeW5jIiwicmVuZGVyIiwiRmFrZUNvbXBvbmVudCIsInNoaWZ0IiwiY29tcG9uZW50RGlkTW91bnQiLCJzZXRTdGF0ZSIsImNyZWF0ZUNvbnRleHQiLCJkZWZhdWx0VmFsdWUiLCJDb250ZXh0VHlwZSIsIm9yaWdQcm92aWRlciIsIlByb3ZpZGVyIiwiaXNOZXciLCJnZXRDaGlsZENvbnRleHQiLCJhcmd1bWVudHMiLCJzdWJzIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiX3Byb3BzIiwiYyIsImZvcmNlVXBkYXRlIiwic3ViIiwib2xkIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJTY3JvbGxSZXNwb25kZXIiLCJleGVjRnVuYyIsImVtaXR0ZXIiLCJoYW5kbGVTY3JvbGxSZXF1ZXN0IiwicXVldWVkUmVxdWVzdCIsImRyYWluIiwib24iLCJmaXJlSW5pdGlhbFNjcm9sbCIsImRldGFjaCIsIm9mZiIsInVwZGF0ZSIsImlzRGF0ZXNOZXciLCJ0aW1lIiwiVmlld0NvbnRleHRUeXBlIiwiYnVpbGRWaWV3Q29udGV4dCIsInZpZXdTcGVjIiwidmlld0FwaSIsInZpZXdPcHRpb25zIiwiZGF0ZVByb2ZpbGVHZW5lcmF0b3IiLCJkYXRlRW52IiwidGhlbWUiLCJwbHVnaW5Ib29rcyIsImRpc3BhdGNoIiwiZ2V0Q3VycmVudERhdGEiLCJjYWxlbmRhckFwaSIsInJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQiLCJ1bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQiLCJhZGRSZXNpemVIYW5kbGVyIiwicmVtb3ZlUmVzaXplSGFuZGxlciIsImNyZWF0ZVNjcm9sbFJlc3BvbmRlciIsIlB1cmVDb21wb25lbnQiLCJuZXh0UHJvcHMiLCJuZXh0U3RhdGUiLCJkZWJ1ZyIsImNvbnNvbGUiLCJsb2ciLCJzdGF0ZSIsInByb3BFcXVhbGl0eSIsInN0YXRlRXF1YWxpdHkiLCJzYWZlU2V0U3RhdGUiLCJuZXdTdGF0ZSIsImFkZFByb3BzRXF1YWxpdHkiLCJhZGRTdGF0ZUVxdWFsaXR5IiwiY29udGV4dFR5cGUiLCJCYXNlQ29tcG9uZW50IiwiY3JlYXRlIiwic2V0UmVmIiwicmVmIiwiY3VycmVudCIsIkNvbnRlbnRJbmplY3RvciIsImlkIiwicXVldWVkRG9tTm9kZXMiLCJjdXJyZW50RG9tTm9kZXMiLCJoYW5kbGVFbCIsImdlbmVyYXRvck5hbWUiLCJoYXNDdXN0b21SZW5kZXJpbmdIYW5kbGVyIiwidXBkYXRlRWxSZWYiLCJlbFJlZiIsImN1c3RvbUdlbmVyYXRvciIsImRlZmF1bHRHZW5lcmF0b3IiLCJyZW5kZXJQcm9wcyIsImF0dHJzIiwiYnVpbGRFbEF0dHJzIiwidXNlRGVmYXVsdCIsImlubmVyQ29udGVudCIsImN1cnJlbnRHZW5lcmF0b3JNZXRhIiwiY3VzdG9tR2VuZXJhdG9yUmVzIiwiaXNPYmplY3QiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCIsImh0bWwiLCJzbGljZSIsImRvbU5vZGVzIiwiZWxUYWciLCJhcHBseVF1ZXVldWREb21Ob2RlcyIsInRyaWdnZXJDdXN0b21SZW5kZXJpbmciLCJjb21wb25lbnREaWRVcGRhdGUiLCJpc0FjdGl2ZSIsImdlbmVyYXRvck1ldGEiLCJjb250YWluZXJFbCIsImJhc2UiLCJyZXBvcnROZXdDb250YWluZXJFbCIsImVsQ2xhc3NlcyIsImZpbHRlciIsImlzVHJ1dGh5IiwibmV3Tm9kZSIsImFwcGVuZENoaWxkIiwiZWxTdHlsZSIsImVsQXR0cnMiLCJleHRyYUNsYXNzTmFtZXMiLCJSZW5kZXJJZCIsIkNvbnRlbnRDb250YWluZXIiLCJJbm5lckNvbnRlbnQiLCJJbm5lckNvbnRlbnRJbmplY3RvciIsImRpZE1vdW50TWlzZmlyZSIsImdlbmVyYXRlZENsYXNzTmFtZXMiLCJnZW5lcmF0ZUNsYXNzTmFtZXMiLCJjbGFzc05hbWVHZW5lcmF0b3IiLCJyZW5kZXJJZCIsImNvbnRhaW5lckNvbXBvbmVudCIsInBhcmVudFByb3BzIiwiVmlld0NvbnRhaW5lciIsInZpZXciLCJidWlsZFZpZXdDbGFzc05hbWVzIiwicGFyc2VSYW5nZSIsImludmVydFJhbmdlcyIsInJhbmdlcyIsImNvbnN0cmFpbnRSYW5nZSIsImludmVydGVkUmFuZ2VzIiwiZGF0ZVJhbmdlIiwic29ydCIsImNvbXBhcmVSYW5nZXMiLCJyYW5nZTAiLCJyYW5nZTEiLCJpbnRlcnNlY3RSYW5nZXMiLCJuZXdSYW5nZSIsInJhbmdlc0VxdWFsIiwicmFuZ2VzSW50ZXJzZWN0IiwicmFuZ2VDb250YWluc1JhbmdlIiwib3V0ZXJSYW5nZSIsImlubmVyUmFuZ2UiLCJyYW5nZUNvbnRhaW5zTWFya2VyIiwicmFuZ2UiLCJjb25zdHJhaW5NYXJrZXJUb1JhbmdlIiwiY29tcHV0ZUFsaWduZWREYXlSYW5nZSIsInRpbWVkUmFuZ2UiLCJkYXlDbnQiLCJjb21wdXRlVmlzaWJsZURheVJhbmdlIiwic3RhcnREYXkiLCJlbmREYXkiLCJlbmRUaW1lTVMiLCJpc011bHRpRGF5UmFuZ2UiLCJkaWZmRGF0ZXMiLCJkYXRlMCIsImRhdGUxIiwibGFyZ2VVbml0IiwicmVkdWNlQ3VycmVudERhdGUiLCJjdXJyZW50RGF0ZSIsImFjdGlvbiIsImRhdGVNYXJrZXIiLCJnZXRJbml0aWFsRGF0ZSIsImluaXRpYWxEYXRlSW5wdXQiLCJnZXROb3ciLCJub3dJbnB1dCIsIkRhdGVQcm9maWxlR2VuZXJhdG9yIiwibm93RGF0ZSIsImluaXRIaWRkZW5EYXlzIiwiYnVpbGRQcmV2IiwiY3VycmVudERhdGVQcm9maWxlIiwiZm9yY2VUb1ZhbGlkIiwicHJldkRhdGUiLCJjdXJyZW50UmFuZ2VVbml0IiwiYnVpbGQiLCJidWlsZE5leHQiLCJuZXh0RGF0ZSIsImN1cnJlbnRJbmZvIiwiaXNSYW5nZUFsbERheSIsInJlbmRlclJhbmdlIiwiYWN0aXZlUmFuZ2UiLCJpc1ZhbGlkIiwiYnVpbGRWYWxpZFJhbmdlIiwidHJpbUhpZGRlbkRheXMiLCJidWlsZEN1cnJlbnRSYW5nZUluZm8iLCJidWlsZFJlbmRlclJhbmdlIiwiYWRqdXN0QWN0aXZlUmFuZ2UiLCJjdXJyZW50UmFuZ2UiLCJidWlsZERhdGVJbmNyZW1lbnQiLCJ2YWxpZFJhbmdlSW5wdXQiLCJzaW1wbGVJbnB1dCIsInJlZmluZVJhbmdlIiwiZHVyYXRpb25Vbml0IiwiYnVpbGRSYW5nZUZyb21EdXJhdGlvbiIsImJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQiLCJidWlsZEN1c3RvbVZpc2libGVSYW5nZSIsImdldEZhbGxiYWNrRHVyYXRpb24iLCJpc0hpZGRlbkRheSIsInNraXBIaWRkZW5EYXlzIiwiY29tcHV0ZVJlcyIsInJ1bm5pbmdDb3VudCIsInZpc2libGVSYW5nZUlucHV0IiwiZmFsbGJhY2siLCJjdXN0b21BbGlnbm1lbnQiLCJyYW5nZUlucHV0IiwiaXNIaWRkZW5EYXlIYXNoIiwiaW5jIiwiaXNFeGNsdXNpdmUiLCJjcmVhdGVFdmVudEluc3RhbmNlIiwiZGVmSWQiLCJpbnN0YW5jZUlkIiwicGFyc2VSZWN1cnJpbmciLCJyZWN1cnJpbmdUeXBlcyIsInBhcnNlZCIsImFsbERheSIsImFsbERheUd1ZXNzIiwidHlwZURhdGEiLCJ0eXBlSWQiLCJleHBhbmRSZWN1cnJpbmciLCJldmVudFN0b3JlIiwiZnJhbWluZ1JhbmdlIiwiZGVmcyIsImluc3RhbmNlcyIsImluc3RhbmNlIiwicmVjdXJyaW5nRGVmIiwiZGVmIiwic3RhcnRzIiwiZXhwYW5kUmVjdXJyaW5nUmFuZ2VzIiwiZXZlbnREZWYiLCJ0eXBlRGVmIiwibWFya2VycyIsImV4cGFuZCIsIm1hcCIsIkVWRU5UX05PTl9EQVRFX1JFRklORVJTIiwiZ3JvdXBJZCIsInRpdGxlIiwidXJsIiwiaW50ZXJhY3RpdmUiLCJFVkVOVF9EQVRFX1JFRklORVJTIiwiRVZFTlRfUkVGSU5FUlMiLCJleHRlbmRlZFByb3BzIiwicGFyc2VFdmVudCIsImV2ZW50U291cmNlIiwiYWxsb3dPcGVuUmFuZ2UiLCJidWlsZEV2ZW50UmVmaW5lcnMiLCJkZWZJZE1hcCIsImluc3RhbmNlSWRNYXAiLCJyZWZpbmVFdmVudERlZiIsImNvbXB1dGVJc0RlZmF1bHRBbGxEYXkiLCJyZWN1cnJpbmdSZXMiLCJwYXJzZUV2ZW50RGVmIiwic291cmNlSWQiLCJzaW5nbGVSZXMiLCJwYXJzZVNpbmdsZSIsImhhc0VuZCIsInB1YmxpY0lkIiwiRVZFTlRfVUlfUkVGSU5FUlMiLCJldmVudFJlZmluZXJzIiwidWkiLCJjcmVhdGVFdmVudFVpIiwibWVtYmVyQWRkZXIiLCJldmVudERlZk1lbWJlckFkZGVycyIsImZyZWV6ZSIsInN0YXJ0TWV0YSIsInN0YXJ0TWFya2VyIiwiZW5kTWV0YSIsImVuZE1hcmtlciIsInN0YXJ0SW5wdXQiLCJwYXJzZUV2ZW50cyIsInJhd0V2ZW50cyIsImNyZWF0ZUVtcHR5RXZlbnRTdG9yZSIsInJhd0V2ZW50IiwidHVwbGUiLCJldmVudFR1cGxlVG9TdG9yZSIsImdldFJlbGV2YW50RXZlbnRzIiwibmV3U3RvcmUiLCJmaWx0ZXJFdmVudFN0b3JlRGVmcyIsImxvb2tEZWYiLCJpc0V2ZW50RGVmc0dyb3VwZWQiLCJkZWYwIiwiZGVmMSIsIm1lcmdlRXZlbnRTdG9yZXMiLCJzdG9yZTAiLCJzdG9yZTEiLCJmaWx0ZXJGdW5jIiwiZXhjbHVkZVN1YkV2ZW50U3RvcmUiLCJtYXN0ZXIiLCJmaWx0ZXJlZERlZnMiLCJmaWx0ZXJlZEluc3RhbmNlcyIsIm5vcm1hbGl6ZUNvbnN0cmFpbnQiLCJwYXJzZUNsYXNzTmFtZXMiLCJzdGFydEVkaXRhYmxlIiwiZHVyYXRpb25FZGl0YWJsZSIsImNvbnN0cmFpbnQiLCJvdmVybGFwIiwiYWxsb3ciLCJjb2xvciIsImJhY2tncm91bmRDb2xvciIsImJvcmRlckNvbG9yIiwidGV4dENvbG9yIiwiRU1QVFlfRVZFTlRfVUkiLCJjb25zdHJhaW50cyIsImFsbG93cyIsImNvbWJpbmVFdmVudFVpcyIsInVpcyIsImNvbWJpbmVUd29FdmVudFVpcyIsIml0ZW0wIiwiaXRlbTEiLCJFVkVOVF9TT1VSQ0VfUkVGSU5FUlMiLCJzdWNjZXNzIiwiZmFpbHVyZSIsInBhcnNlRXZlbnRTb3VyY2UiLCJidWlsZEV2ZW50U291cmNlUmVmaW5lcnMiLCJyYXdPYmoiLCJtZXRhUmVzIiwiYnVpbGRFdmVudFNvdXJjZU1ldGEiLCJfcmF3IiwiaXNGZXRjaGluZyIsImxhdGVzdEZldGNoSWQiLCJmZXRjaFJhbmdlIiwic291cmNlRGVmSWQiLCJldmVudFNvdXJjZVJlZmluZXJzIiwiZXZlbnRTb3VyY2VEZWZzIiwicGFyc2VNZXRhIiwicmVkdWNlRXZlbnRTdG9yZSIsImRhdGVQcm9maWxlIiwicmVjZWl2ZVJhd0V2ZW50cyIsImZldGNoSWQiLCJyZXNldFJhd0V2ZW50cyIsImFkZEV2ZW50IiwiZXhjbHVkZUV2ZW50c0J5U291cmNlSWQiLCJzdWJzZXQiLCJ0cmFuc2Zvcm1SYXdFdmVudHMiLCJleGlzdGluZ0V2ZW50U3RvcmUiLCJidWlsZFB1YmxpY0lkTWFwcyIsIm5ld0V2ZW50U3RvcmUiLCJjYWxFYWNoVHJhbnNmb3JtIiwic291cmNlRWFjaFRyYW5zZm9ybSIsInRyYW5zZm9ybUVhY2hSYXdFdmVudCIsInJlZmluZWRFdmVudHMiLCJyZWZpbmVkRXZlbnQiLCJleHBhbmRSYW5nZSIsInJlem9uZUV2ZW50U3RvcmVEYXRlcyIsIm9sZERhdGVFbnYiLCJuZXdEYXRlRW52IiwiZXhjbHVkZUluc3RhbmNlcyIsInJlbW92YWxzIiwiRW1pdHRlciIsImhhbmRsZXJzIiwidGhpc0NvbnRleHQiLCJzZXRUaGlzQ29udGV4dCIsInNldE9wdGlvbnMiLCJhZGRUb0hhc2giLCJyZW1vdmVGcm9tSGFzaCIsInRyaWdnZXIiLCJhdHRhY2hlZEhhbmRsZXJzIiwib3B0aW9uSGFuZGxlciIsImhhc0hhbmRsZXJzIiwiREVGX0RFRkFVTFRTIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsImRheXNPZldlZWsiLCJwYXJzZUJ1c2luZXNzSG91cnMiLCJyZWZpbmVJbnB1dHMiLCJyYXdEZWZzIiwicmF3RGVmIiwidHJpZ2dlckRhdGVTZWxlY3QiLCJzZWxlY3Rpb24iLCJwZXYiLCJidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQiLCJqc0V2ZW50Iiwib3JpZ0V2ZW50IiwidHJpZ2dlckRhdGVVbnNlbGVjdCIsImRhdGVTcGFuIiwidHJhbnNmb3JtIiwiZGF0ZVNwYW5UcmFuc2Zvcm1zIiwiYnVpbGREYXRlU3BhbkFwaSIsImdldERlZmF1bHRFdmVudEVuZCIsImFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUiLCJldmVudENvbmZpZ0Jhc2UiLCJtdXRhdGlvbiIsImV2ZW50Q29uZmlncyIsImNvbXBpbGVFdmVudFVpcyIsImFwcGx5TXV0YXRpb25Ub0V2ZW50RGVmIiwiYXBwbHlNdXRhdGlvblRvRXZlbnRJbnN0YW5jZSIsImV2ZW50Q29uZmlnIiwic3RhbmRhcmRQcm9wcyIsInN0YXJ0RGVsdGEiLCJlbmREZWx0YSIsImNvcHkiLCJhcHBsaWVyIiwiZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzIiwiZXZlbnRJbnN0YW5jZSIsImZvcmNlQWxsRGF5IiwiY2xlYXJFbmQiLCJkYXRlc0RlbHRhIiwiRXZlbnRTb3VyY2VJbXBsIiwiaW50ZXJuYWxFdmVudFNvdXJjZSIsInJlZmV0Y2giLCJzb3VyY2VJZHMiLCJpc1JlZmV0Y2giLCJFdmVudEltcGwiLCJfY29udGV4dCIsIl9kZWYiLCJfaW5zdGFuY2UiLCJzZXRQcm9wIiwid2FybiIsIm11dGF0ZSIsInNldEV4dGVuZGVkUHJvcCIsInNldFN0YXJ0IiwiaW5zdGFuY2VSYW5nZSIsImdyYW51bGFyaXR5IiwibWFpbnRhaW5EdXJhdGlvbiIsInNldEVuZCIsImVuZElucHV0Iiwic2V0RGF0ZXMiLCJtb3ZlU3RhcnQiLCJkZWx0YUlucHV0IiwiZGVsdGEiLCJtb3ZlRW5kIiwibW92ZURhdGVzIiwic2V0QWxsRGF5IiwiZm9ybWF0SW5wdXQiLCJyZWxldmFudEV2ZW50cyIsIm9sZEV2ZW50IiwiZXZlbnQiLCJyZWxhdGVkRXZlbnRzIiwiYnVpbGRFdmVudEFwaXMiLCJyZXZlcnQiLCJhc1N0b3JlIiwiZXZlbnRBcGlUb1N0b3JlIiwic291cmNlIiwic3RhcnRTdHIiLCJlbmRTdHIiLCJ0b1BsYWluT2JqZWN0IiwiY29sbGFwc2VDb2xvciIsImNvbGxhcHNlRXh0ZW5kZWRQcm9wcyIsInRvSlNPTiIsImV2ZW50QXBpIiwiZXhjbHVkZUluc3RhbmNlIiwiZXZlbnRBcGlzIiwiZXhjbHVkZUluc3RhbmNlSWQiLCJzbGljZUV2ZW50U3RvcmUiLCJldmVudFVpQmFzZXMiLCJpbnZlcnNlQmdCeUdyb3VwSWQiLCJpbnZlcnNlQmdCeURlZklkIiwiZGVmQnlHcm91cElkIiwiYmdSYW5nZXMiLCJmZ1JhbmdlcyIsImV2ZW50VWlzIiwib3JpZ1JhbmdlIiwibm9ybWFsUmFuZ2UiLCJzbGljZWRSYW5nZSIsImlzU3RhcnQiLCJpc0VuZCIsImludmVydGVkUmFuZ2UiLCJiZyIsImZnIiwiaGFzQmdSZW5kZXJpbmciLCJzZXRFbFNlZyIsInNlZyIsImZjU2VnIiwiZ2V0RWxTZWciLCJldmVudERlZnMiLCJjb21waWxlRXZlbnRVaSIsInNvcnRFdmVudFNlZ3MiLCJzZWdzIiwiZXZlbnRPcmRlclNwZWNzIiwib2JqcyIsImJ1aWxkU2VnQ29tcGFyZU9iaiIsIl9zZWciLCJldmVudFJhbmdlIiwiY29tcHV0ZVNlZ0RyYWdnYWJsZSIsInRyYW5zZm9ybWVycyIsImlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzIiwidHJhbnNmb3JtZXIiLCJjb21wdXRlU2VnU3RhcnRSZXNpemFibGUiLCJjb21wdXRlU2VnRW5kUmVzaXphYmxlIiwiYnVpbGRTZWdUaW1lVGV4dCIsInRpbWVGb3JtYXQiLCJkZWZhdWx0RGlzcGxheUV2ZW50VGltZSIsImRlZmF1bHREaXNwbGF5RXZlbnRFbmQiLCJzdGFydE92ZXJyaWRlIiwiZW5kT3ZlcnJpZGUiLCJ3aG9sZUV2ZW50U3RhcnQiLCJ3aG9sZUV2ZW50RW5kIiwic2VnU3RhcnQiLCJzZWdFbmQiLCJpc1N0YXJ0RGF5IiwiaXNFbmREYXkiLCJnZXRTZWdNZXRhIiwidG9kYXlSYW5nZSIsInNlZ1JhbmdlIiwiaXNQYXN0IiwiaXNGdXR1cmUiLCJpc1RvZGF5IiwiZ2V0RXZlbnRDbGFzc05hbWVzIiwiaXNNaXJyb3IiLCJpc0RyYWdnYWJsZSIsImlzU3RhcnRSZXNpemFibGUiLCJpc0VuZFJlc2l6YWJsZSIsImlzRHJhZ2dpbmciLCJpc1Jlc2l6aW5nIiwiaXNTZWxlY3RlZCIsImJ1aWxkRXZlbnRSYW5nZUtleSIsImdldFNlZ0FuY2hvckF0dHJzIiwiaHJlZiIsIlNUQU5EQVJEX1BST1BTIiwicGFyc2VEYXRlU3BhbiIsImRlZmF1bHREdXJhdGlvbiIsInNwYW4iLCJwYXJzZU9wZW5EYXRlU3BhbiIsImlzRGF0ZVNwYW5zRXF1YWwiLCJzcGFuMCIsInNwYW4xIiwiaXNTcGFuUHJvcHNFcXVhbCIsImJ1aWxkUmFuZ2VBcGkiLCJidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lIiwiZmFicmljYXRlRXZlbnRSYW5nZSIsInVucHJvbWlzaWZ5Iiwibm9ybWFsaXplZFN1Y2Nlc3NDYWxsYmFjayIsIm5vcm1hbGl6ZWRGYWlsdXJlQ2FsbGJhY2siLCJpc1Jlc29sdmVkIiwid3JhcHBlZFN1Y2Nlc3MiLCJ3cmFwcGVkRmFpbHVyZSIsImVycm9yIiwidGhlbiIsIkpzb25SZXF1ZXN0RXJyb3IiLCJtZXNzYWdlIiwicmVzcG9uc2UiLCJyZXF1ZXN0SnNvbiIsInBhcmFtcyIsInRvVXBwZXJDYXNlIiwiZmV0Y2hPcHRpb25zIiwiVVJMU2VhcmNoUGFyYW1zIiwiaGVhZGVycyIsImZldGNoIiwiZmV0Y2hSZXMiLCJvayIsImpzb24iLCJwYXJzZWRSZXNwb25zZSIsImNhblZHcm93V2l0aGluQ2VsbCIsImdldENhblZHcm93V2l0aGluQ2VsbCIsImNvbXB1dGVDYW5WR3Jvd1dpdGhpbkNlbGwiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJpbm5lckhUTUwiLCJkaXYiLCJwb3NzaWJsZSIsIm9mZnNldEhlaWdodCIsIkNhbGVuZGFyUm9vdCIsImZvclByaW50IiwiaGFuZGxlQmVmb3JlUHJpbnQiLCJoYW5kbGVBZnRlclByaW50IiwiaXNIZWlnaHRBdXRvIiwiSW50ZXJhY3Rpb24iLCJpc0hpdENvbWJvQWxsb3dlZCIsImRlc3Ryb3kiLCJwYXJzZUludGVyYWN0aW9uU2V0dGluZ3MiLCJ1c2VFdmVudENlbnRlciIsImludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlIiwidWlkIiwiaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlIiwiQ2FsZW5kYXJJbXBsIiwiY3VycmVudERhdGFNYW5hZ2VyIiwiYmF0Y2hSZW5kZXJpbmciLCJ1cGRhdGVTaXplIiwic2V0T3B0aW9uIiwib3B0aW9uTmFtZSIsInJhd09wdGlvblZhbHVlIiwiZ2V0T3B0aW9uIiwiY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0IiwiZ2V0QXZhaWxhYmxlTG9jYWxlQ29kZXMiLCJhdmFpbGFibGVSYXdMb2NhbGVzIiwiaGFuZGxlck5hbWUiLCJjdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnMiLCJjaGFuZ2VWaWV3Iiwidmlld1R5cGUiLCJkYXRlT3JSYW5nZSIsInpvb21UbyIsInNwZWMiLCJ2aWV3U3BlY3MiLCJnZXRVbml0Vmlld1NwZWMiLCJ0b29sYmFyQ29uZmlnIiwidmlld1R5cGVzIiwiaGVhZGVyIiwidmlld3NXaXRoQnV0dG9ucyIsImZvb3RlciIsInNpbmdsZVVuaXQiLCJwcmV2IiwibmV4dCIsInByZXZZZWFyIiwibmV4dFllYXIiLCJ0b2RheSIsImdvdG9EYXRlIiwiem9uZWREYXRlSW5wdXQiLCJpbmNyZW1lbnREYXRlIiwiZm9ybWF0RGF0ZSIsImRhdGVPck9iaiIsImVuZERhdGUiLCJzZWxlY3Rpb25JbnB1dCIsImRhdGVTZWxlY3Rpb24iLCJldmVudElucHV0Iiwic291cmNlSW5wdXQiLCJjdXJyZW50RGF0YSIsInRyaWdnZXJFdmVudEFkZCIsInNvdXJjZUFwaSIsImdldEV2ZW50U291cmNlQnlJZCIsIm5ld0V2ZW50QXBpIiwiZ2V0RXZlbnRCeUlkIiwiZ2V0RXZlbnRzIiwicmVtb3ZlQWxsRXZlbnRzIiwiZ2V0RXZlbnRTb3VyY2VzIiwic291cmNlSGFzaCIsInNvdXJjZUFwaXMiLCJpbnRlcm5hbElkIiwiYWRkRXZlbnRTb3VyY2UiLCJzb3VyY2VzIiwicmVtb3ZlQWxsRXZlbnRTb3VyY2VzIiwicmVmZXRjaEV2ZW50cyIsInNjcm9sbFRvVGltZSIsInRpbWVJbnB1dCIsInBvaW50SW5zaWRlUmVjdCIsInBvaW50IiwicmVjdCIsInJpZ2h0IiwiYm90dG9tIiwiaW50ZXJzZWN0UmVjdHMiLCJyZWN0MSIsInJlY3QyIiwidHJhbnNsYXRlUmVjdCIsImRlbHRhWCIsImRlbHRhWSIsImNvbnN0cmFpblBvaW50IiwiZ2V0UmVjdENlbnRlciIsImRpZmZQb2ludHMiLCJwb2ludDEiLCJwb2ludDIiLCJFTVBUWV9FVkVOVF9TVE9SRSIsIlNwbGl0dGVyIiwiZ2V0S2V5c0ZvckV2ZW50RGVmcyIsIl9nZXRLZXlzRm9yRXZlbnREZWZzIiwic3BsaXREYXRlU2VsZWN0aW9uIiwiX3NwbGl0RGF0ZVNwYW4iLCJzcGxpdEV2ZW50U3RvcmUiLCJfc3BsaXRFdmVudFN0b3JlIiwic3BsaXRJbmRpdmlkdWFsVWkiLCJfc3BsaXRJbmRpdmlkdWFsVWkiLCJzcGxpdEV2ZW50RHJhZyIsIl9zcGxpdEludGVyYWN0aW9uIiwic3BsaXRFdmVudFJlc2l6ZSIsImV2ZW50VWlCdWlsZGVycyIsInNwbGl0UHJvcHMiLCJrZXlJbmZvcyIsImdldEtleUluZm8iLCJkZWZLZXlzIiwiZGF0ZVNlbGVjdGlvbnMiLCJpbmRpdmlkdWFsVWkiLCJldmVudFN0b3JlcyIsImV2ZW50RHJhZ3MiLCJldmVudERyYWciLCJldmVudFJlc2l6ZXMiLCJldmVudFJlc2l6ZSIsImluZm8iLCJidWlsZEV2ZW50VWlGb3JLZXkiLCJrZXlJbmZvIiwiYnVpbGRFdmVudFVpIiwiZXZlbnRTZWxlY3Rpb24iLCJkYXRlU3BhbnMiLCJnZXRLZXlzRm9yRGF0ZVNwYW4iLCJnZXRLZXlzRm9yRXZlbnREZWYiLCJzcGxpdFN0b3JlcyIsInNwbGl0SGFzaGVzIiwiaW50ZXJhY3Rpb24iLCJzcGxpdFN0YXRlcyIsImFmZmVjdGVkU3RvcmVzIiwiYWZmZWN0ZWRFdmVudHMiLCJtdXRhdGVkS2V5c0J5RGVmSWQiLCJtdXRhdGVkRXZlbnRzIiwibXV0YXRlZFN0b3JlcyIsInBvcHVsYXRlIiwiaXNFdmVudCIsImFsbFVpIiwiZXZlbnRVaUZvcktleSIsImJhc2VQYXJ0cyIsInN0dWZmIiwiZ2V0RGF0ZU1ldGEiLCJpc0Rpc2FibGVkIiwiaXNPdGhlciIsImdldERheUNsYXNzTmFtZXMiLCJnZXRTbG90Q2xhc3NOYW1lcyIsIkRBWV9GT1JNQVQiLCJXRUVLX0ZPUk1BVCIsImJ1aWxkTmF2TGlua0F0dHJzIiwiaXNUYWJiYWJsZSIsImRhdGVTdHIiLCJ6b25lZERhdGUiLCJoYW5kbGVJbnRlcmFjdGlvbiIsImN1c3RvbUFjdGlvbiIsIl9pc1J0bFNjcm9sbGJhck9uTGVmdCIsImdldElzUnRsU2Nyb2xsYmFyT25MZWZ0IiwiY29tcHV0ZUlzUnRsU2Nyb2xsYmFyT25MZWZ0Iiwib3V0ZXJFbCIsImJvcmRlciIsInBhZGRpbmciLCJvdmVyZmxvdyIsImlubmVyRWwiLCJfc2Nyb2xsYmFyV2lkdGhzIiwiZ2V0U2Nyb2xsYmFyV2lkdGhzIiwiY29tcHV0ZVNjcm9sbGJhcldpZHRocyIsImNvbXB1dGVTY3JvbGxiYXJXaWR0aHNGb3JFbCIsIngiLCJjbGllbnRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsImNsaWVudFdpZHRoIiwiY29tcHV0ZUVkZ2VzIiwiZ2V0UGFkZGluZyIsImNvbXB1dGVkU3R5bGUiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwiYm9yZGVyTGVmdCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlclJpZ2h0IiwiYm9yZGVyUmlnaHRXaWR0aCIsImJvcmRlclRvcCIsImJvcmRlclRvcFdpZHRoIiwiYm9yZGVyQm90dG9tIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJiYWRTY3JvbGxiYXJXaWR0aHMiLCJzY3JvbGxiYXJMZWZ0UmlnaHQiLCJzY3JvbGxiYXJCb3R0b20iLCJzY3JvbGxiYXJMZWZ0Iiwic2Nyb2xsYmFyUmlnaHQiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwiY29tcHV0ZUlubmVyUmVjdCIsImdvV2l0aGluUGFkZGluZyIsImRvRnJvbVdpbmRvd1ZpZXdwb3J0Iiwib3V0ZXJSZWN0IiwiY29tcHV0ZVJlY3QiLCJlZGdlcyIsInBhZ2VYT2Zmc2V0IiwicGFnZVlPZmZzZXQiLCJjb21wdXRlQ2xpcHBlZENsaWVudFJlY3QiLCJjbGlwcGluZ1BhcmVudHMiLCJnZXRDbGlwcGluZ1BhcmVudHMiLCJjbGlwcGluZ1BhcmVudCIsImludGVyc2VjdGlvbiIsIm92ZXJmbG93WSIsIm92ZXJmbG93WCIsIlBvc2l0aW9uQ2FjaGUiLCJvcmlnaW5FbCIsImVscyIsImlzSG9yaXpvbnRhbCIsImlzVmVydGljYWwiLCJvcmlnaW5DbGllbnRSZWN0IiwiYnVpbGRFbEhvcml6b250YWxzIiwiYnVpbGRFbFZlcnRpY2FscyIsIm9yaWdpbkNsaWVudExlZnQiLCJsZWZ0cyIsInJpZ2h0cyIsIm9yaWdpbkNsaWVudFRvcCIsInRvcHMiLCJib3R0b21zIiwibGVmdFRvSW5kZXgiLCJsZWZ0UG9zaXRpb24iLCJ0b3BUb0luZGV4IiwidG9wUG9zaXRpb24iLCJnZXRXaWR0aCIsImxlZnRJbmRleCIsImdldEhlaWdodCIsInRvcEluZGV4Iiwic2ltaWxhclRvIiwib3RoZXJDYWNoZSIsInNpbWlsYXJOdW1BcnJheXMiLCJTY3JvbGxDb250cm9sbGVyIiwiZ2V0TWF4U2Nyb2xsVG9wIiwiZ2V0U2Nyb2xsSGVpZ2h0IiwiZ2V0Q2xpZW50SGVpZ2h0IiwiZ2V0TWF4U2Nyb2xsTGVmdCIsImdldFNjcm9sbFdpZHRoIiwiZ2V0Q2xpZW50V2lkdGgiLCJjYW5TY3JvbGxWZXJ0aWNhbGx5IiwiY2FuU2Nyb2xsSG9yaXpvbnRhbGx5IiwiY2FuU2Nyb2xsVXAiLCJnZXRTY3JvbGxUb3AiLCJjYW5TY3JvbGxEb3duIiwiY2FuU2Nyb2xsTGVmdCIsImdldFNjcm9sbExlZnQiLCJjYW5TY3JvbGxSaWdodCIsIkVsZW1lbnRTY3JvbGxDb250cm9sbGVyIiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsInNldFNjcm9sbFRvcCIsInNldFNjcm9sbExlZnQiLCJzY3JvbGxXaWR0aCIsInNjcm9sbEhlaWdodCIsIldpbmRvd1Njcm9sbENvbnRyb2xsZXIiLCJzY3JvbGwiLCJEYXRlQ29tcG9uZW50IiwicHJlcGFyZUhpdHMiLCJxdWVyeUhpdCIsInBvc2l0aW9uTGVmdCIsInBvc2l0aW9uVG9wIiwiZWxXaWR0aCIsImVsSGVpZ2h0IiwiaXNWYWxpZFNlZ0Rvd25FbCIsImlzVmFsaWREYXRlRG93bkVsIiwiTmFtZWRUaW1lWm9uZUltcGwiLCJTZWdIaWVyYXJjaHkiLCJnZXRFbnRyeVRoaWNrbmVzcyIsImVudHJ5IiwidGhpY2tuZXNzIiwic3RyaWN0T3JkZXIiLCJhbGxvd1Jlc2xpY2luZyIsIm1heENvb3JkIiwibWF4U3RhY2tDbnQiLCJsZXZlbENvb3JkcyIsImVudHJpZXNCeUxldmVsIiwic3RhY2tDbnRzIiwiYWRkU2VncyIsImlucHV0cyIsImhpZGRlbkVudHJpZXMiLCJpbnNlcnRFbnRyeSIsImZpbmRJbnNlcnRpb24iLCJpc0luc2VydGlvblZhbGlkIiwiaW5zZXJ0RW50cnlBdCIsImhhbmRsZUludmFsaWRJbnNlcnRpb24iLCJsZXZlbENvb3JkIiwic3RhY2tDbnQiLCJ0b3VjaGluZ0VudHJ5Iiwic3BsaXRFbnRyeSIsImJhcnJpZXIiLCJwYXJ0Q250Iiwic3BsaXRIaWRkZW5FbnRyaWVzIiwiZW50cnlTcGFuIiwiYmFycmllclNwYW4iLCJpbnRlcnNlY3RTcGFucyIsImxhdGVyYWwiLCJpbnNlcnRBdCIsImxldmVsIiwiYnVpbGRFbnRyeUtleSIsIm5ld0VudHJ5IiwibGV2ZWxDbnQiLCJjYW5kaWRhdGVDb29yZCIsInRvdWNoaW5nTGV2ZWwiLCJ0b3VjaGluZ0xhdGVyYWwiLCJ0cmFja2luZ0xldmVsIiwidHJhY2tpbmdDb29yZCIsInRyYWNraW5nRW50cmllcyIsInRyYWNraW5nRW50cnkiLCJzZWFyY2hSZXMiLCJiaW5hcnlTZWFyY2giLCJnZXRFbnRyeVNwYW5FbmQiLCJsYXRlcmFsSW5kZXgiLCJ0cmFja2luZ0VudHJ5Qm90dG9tIiwiZGVzdExldmVsIiwiZGVzdExhdGVyYWwiLCJ0b1JlY3RzIiwicmVjdHMiLCJlbnRyaWVzIiwiZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzIiwibWVyZ2VzIiwiZmlsdGVyZWRNZXJnZXMiLCJodW5ncnlNZXJnZSIsIm1lcmdlIiwiam9pblNwYW5zIiwic2VhcmNoVmFsIiwiZ2V0SXRlbVZhbCIsIm1pZGRsZUluZGV4IiwibWlkZGxlVmFsIiwiRWxlbWVudERyYWdnaW5nIiwic2V0TWlycm9ySXNWaXNpYmxlIiwiYm9vbCIsInNldE1pcnJvck5lZWRzUmV2ZXJ0Iiwic2V0QXV0b1Njcm9sbEVuYWJsZWQiLCJjb25maWciLCJEUkFHX01FVEFfUkVGSU5FUlMiLCJwYXJzZURyYWdNZXRhIiwibGVmdG92ZXJQcm9wcyIsImNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdCIsImRhdGVzUmVwRGlzdGluY3REYXlzIiwiQ0xBU1NfTkFNRSIsInJlbmRlcklubmVyJDEiLCJ0ZXh0IiwiVGFibGVEYXRlQ2VsbCIsImRheU1ldGEiLCJuYXZMaW5rQXR0cnMiLCJjb2xDbnQiLCJleHRyYVJlbmRlclByb3BzIiwicm9sZSIsImNvbFNwYW4iLCJleHRyYURhdGFBdHRycyIsIklubmVyQ29udGFpbmVyIiwiaXNTdGlja3kiLCJXRUVLREFZX0ZPUk1BVCIsIlRhYmxlRG93Q2VsbCIsImRhdGVNZXRhIiwiTm93VGltZXIiLCJpbml0aWFsTm93RGF0ZSIsImluaXRpYWxOb3dRdWVyaWVkTXMiLCJjb21wdXRlVGltaW5nIiwiY3VycmVudFN0YXRlIiwicHJldlByb3BzIiwidW5yb3VuZGVkTm93IiwiY3VycmVudFVuaXRTdGFydCIsIm5leHRVbml0U3RhcnQiLCJ3YWl0TXMiLCJidWlsZERheVJhbmdlIiwiRGF5SGVhZGVyIiwiY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyIiwiZGF0ZXMiLCJyZW5kZXJJbnRybyIsImV4cGxpY2l0Rm9ybWF0IiwiZGF0ZUNudCIsIkRheVNlcmllc01vZGVsIiwiaW5kaWNlcyIsImRheUluZGV4IiwiY250Iiwic2xpY2VSYW5nZSIsImZpcnN0SW5kZXgiLCJnZXREYXRlRGF5SW5kZXgiLCJsYXN0SW5kZXgiLCJjbGlwcGVkRmlyc3RJbmRleCIsImNsaXBwZWRMYXN0SW5kZXgiLCJjZWlsIiwiZGF5T2Zmc2V0IiwiRGF5VGFibGVNb2RlbCIsImRheVNlcmllcyIsImJyZWFrT25XZWVrcyIsImRheXNQZXJSb3ciLCJyb3dDbnQiLCJjZWxscyIsImJ1aWxkQ2VsbHMiLCJoZWFkZXJEYXRlcyIsImJ1aWxkSGVhZGVyRGF0ZXMiLCJyb3dzIiwicm93IiwiY29sIiwiYnVpbGRDZWxsIiwic2VyaWVzU2VnIiwibmV4dEluZGV4IiwiZmlyc3RDb2wiLCJsYXN0Q29sIiwiU2xpY2VyIiwic2xpY2VCdXNpbmVzc0hvdXJzIiwiX3NsaWNlQnVzaW5lc3NIb3VycyIsInNsaWNlRGF0ZVNlbGVjdGlvbiIsIl9zbGljZURhdGVTcGFuIiwiX3NsaWNlRXZlbnRTdG9yZSIsInNsaWNlRXZlbnREcmFnIiwiX3NsaWNlSW50ZXJhY3Rpb24iLCJzbGljZUV2ZW50UmVzaXplIiwiZm9yY2VEYXlJZkxpc3RJdGVtIiwic2xpY2VQcm9wcyIsImV4dHJhQXJncyIsImV2ZW50U2VncyIsImRhdGVTZWxlY3Rpb25TZWdzIiwiYnVzaW5lc3NIb3VyU2VncyIsImZnRXZlbnRTZWdzIiwiYmdFdmVudFNlZ3MiLCJzbGljZU5vd0RhdGUiLCJjb21wdXRlQWN0aXZlUmFuZ2UiLCJyYW5nZVJlcyIsInNsaWNlRXZlbnRSYW5nZXMiLCJhZmZlY3RlZEluc3RhbmNlcyIsImFjdGl2ZURhdGVTcGFuUmFuZ2UiLCJldmVudFJhbmdlcyIsInNsaWNlRXZlbnRSYW5nZSIsImlzQ29tcG9uZW50QWxsRGF5IiwiaXNJbnRlcmFjdGlvblZhbGlkIiwiaXNOZXdQcm9wc1ZhbGlkIiwiaXNEYXRlU2VsZWN0aW9uVmFsaWQiLCJjYWxlbmRhclN0YXRlIiwiaXNQcm9wc1ZhbGlkIiwiZGF0ZVNwYW5NZXRhIiwiZmlsdGVyQ29uZmlnIiwiaXNJbnRlcmFjdGlvblByb3BzVmFsaWQiLCJpc0RhdGVTZWxlY3Rpb25Qcm9wc1ZhbGlkIiwic3ViamVjdEV2ZW50U3RvcmUiLCJzdWJqZWN0RGVmcyIsInN1YmplY3RJbnN0YW5jZXMiLCJzdWJqZWN0Q29uZmlncyIsInNlbGVjdGlvbkNvbmZpZyIsIm90aGVyRXZlbnRTdG9yZSIsIm90aGVyRGVmcyIsIm90aGVySW5zdGFuY2VzIiwib3RoZXJDb25maWdzIiwic3ViamVjdEluc3RhbmNlSWQiLCJzdWJqZWN0SW5zdGFuY2UiLCJzdWJqZWN0UmFuZ2UiLCJzdWJqZWN0Q29uZmlnIiwic3ViamVjdERlZiIsImFsbENvbnN0cmFpbnRzUGFzcyIsImV2ZW50T3ZlcmxhcEZ1bmMiLCJvdGhlckluc3RhbmNlSWQiLCJvdGhlckluc3RhbmNlIiwib3RoZXJPdmVybGFwIiwiY2FsZW5kYXJFdmVudFN0b3JlIiwic3ViamVjdEFsbG93Iiwic3ViamVjdERhdGVTcGFuIiwib3JpZ0RlZiIsIm9yaWdJbnN0YW5jZSIsInJlbGV2YW50RXZlbnRTdG9yZSIsInJlbGV2YW50RGVmcyIsInJlbGV2YW50SW5zdGFuY2VzIiwic2VsZWN0aW9uUmFuZ2UiLCJzZWxlY3RPdmVybGFwRnVuYyIsInJlbGV2YW50SW5zdGFuY2VJZCIsInJlbGV2YW50SW5zdGFuY2UiLCJzZWxlY3Rpb25BbGxvdyIsImZ1bGxEYXRlU3BhbiIsImJ1c2luZXNzSG91cnNVbmV4cGFuZGVkIiwiYW55UmFuZ2VzQ29udGFpblJhbmdlIiwiY29uc3RyYWludFRvUmFuZ2VzIiwiZXZlbnRTdG9yZVRvUmFuZ2VzIiwib3V0ZXJSYW5nZXMiLCJWSVNJQkxFX0hJRERFTl9SRSIsIlNjcm9sbGVyIiwibGlxdWlkIiwibGlxdWlkSXNBYnNvbHV0ZSIsImlzQWJzb2x1dGUiLCJvdmVyY29tZUxlZnQiLCJvdmVyY29tZVJpZ2h0Iiwib3ZlcmNvbWVCb3R0b20iLCJtYXJnaW5MZWZ0IiwibWFyZ2luUmlnaHQiLCJtYXJnaW5Cb3R0b20iLCJtYXhIZWlnaHQiLCJuZWVkc1hTY3JvbGxpbmciLCJyZWFsQ2xpZW50V2lkdGgiLCJnZXRZU2Nyb2xsYmFyV2lkdGgiLCJjaGlsZEVsIiwibmVlZHNZU2Nyb2xsaW5nIiwicmVhbENsaWVudEhlaWdodCIsImdldFhTY3JvbGxiYXJXaWR0aCIsIlJlZk1hcCIsIm1hc3RlckNhbGxiYWNrIiwiY3VycmVudE1hcCIsImRlcHRocyIsImNhbGxiYWNrTWFwIiwiaGFuZGxlVmFsdWUiLCJyZW1vdmVkIiwiYWRkZWQiLCJjcmVhdGVSZWYiLCJyZWZDYWxsYmFjayIsImNvbGxlY3QiLCJnZXRBbGwiLCJjb21wdXRlU2hyaW5rV2lkdGgiLCJjaHVua0VscyIsInNocmlua0NlbGxzIiwibGFyZ2VzdFdpZHRoIiwic2hyaW5rQ2VsbCIsImdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQiLCJzZWN0aW9uQ29uZmlnIiwiZ2V0QWxsb3dZU2Nyb2xsaW5nIiwicmVuZGVyQ2h1bmtDb250ZW50IiwiY2h1bmtDb25maWciLCJpc0hlYWRlciIsInRhYmxlQ2xhc3NOYW1lIiwic3luY1Jvd0hlaWdodHMiLCJtaW5XaWR0aCIsInRhYmxlTWluV2lkdGgiLCJ0YWJsZUNvbEdyb3VwTm9kZSIsInJvd0NvbnRlbnQiLCJpc0NvbFByb3BzRXF1YWwiLCJjb2xzMCIsImNvbHMxIiwicmVuZGVyTWljcm9Db2xHcm91cCIsImNvbHMiLCJzaHJpbmtXaWR0aCIsImNvbE5vZGVzIiwiY29sUHJvcHMiLCJzYW5pdGl6ZVNocmlua1dpZHRoIiwiaGFzU2hyaW5rV2lkdGgiLCJnZXRTY3JvbGxHcmlkQ2xhc3NOYW1lcyIsImdldFNlY3Rpb25DbGFzc05hbWVzIiwid2hvbGVUYWJsZVZHcm93IiwicmVuZGVyU2Nyb2xsU2hpbSIsImdldFN0aWNreUhlYWRlckRhdGVzIiwiZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyIiwiU2ltcGxlU2Nyb2xsR3JpZCIsInByb2Nlc3NDb2xzIiwic2Nyb2xsZXJSZWZzIiwic2Nyb2xsZXJFbFJlZnMiLCJfaGFuZGxlU2Nyb2xsZXJFbCIsImZvcmNlWVNjcm9sbGJhcnMiLCJzY3JvbGxlckNsaWVudFdpZHRocyIsInNjcm9sbGVyQ2xpZW50SGVpZ2h0cyIsImhhbmRsZVNpemluZyIsImNvbXB1dGVTY3JvbGxlckRpbXMiLCJzZWN0aW9uQ29uZmlncyIsInNlY3Rpb25zIiwibWljcm9Db2xHcm91cE5vZGUiLCJjb2xsYXBzaWJsZVdpZHRoIiwiY29uZmlnQ250IiwiY29uZmlnSSIsImN1cnJlbnRDb25maWciLCJoZWFkU2VjdGlvbk5vZGVzIiwiYm9keVNlY3Rpb25Ob2RlcyIsImZvb3RTZWN0aW9uTm9kZXMiLCJyZW5kZXJTZWN0aW9uIiwiaXNCdWdneSIsInJvbGVBdHRycyIsIm91dGVyQ29udGVudCIsInJlbmRlckNodW5rVGQiLCJjaHVuayIsImlzTGlxdWlkIiwic2VjdGlvbktleSIsInJvd1N5bmNIZWlnaHRzIiwicmVwb3J0Um93SGVpZ2h0Q2hhbmdlIiwic2Nyb2xsZXJFbCIsInNlY3Rpb24iLCJnZXRTZWN0aW9uQnlLZXkiLCJzY3JvbGxlckVsUmVmIiwic2Nyb2xsYmFyV2lkdGgiLCJzY3JvbGxlciIsImhhcm5lc3NFbCIsIkV2ZW50Q29udGFpbmVyIiwidGltZVRleHQiLCJkaXNhYmxlRHJhZ2dpbmciLCJkaXNhYmxlUmVzaXppbmciLCJpc0RhdGVTZWxlY3RpbmciLCJTdGFuZGFyZEV2ZW50IiwiZGVmYXVsdFRpbWVGb3JtYXQiLCJyZW5kZXJJbm5lckNvbnRlbnQkMSIsImV2ZW50Q29udGVudEFyZyIsImlubmVyUHJvcHMiLCJOb3dJbmRpY2F0b3JDb250YWluZXIiLCJDb25zdW1lciIsImlzQXhpcyIsIkRBWV9OVU1fRk9STUFUIiwiRGF5Q2VsbENvbnRhaW5lciIsInJlZmluZVJlbmRlclByb3BzIiwiaXNNb250aFN0YXJ0Iiwic2hvd0RheU51bWJlciIsImhhc0N1c3RvbURheUNlbGxDb250ZW50IiwiZGF5TnVtYmVyVGV4dCIsIkJnRXZlbnQiLCJyZW5kZXJJbm5lckNvbnRlbnQiLCJyZW5kZXJGaWxsIiwiZmlsbFR5cGUiLCJXZWVrTnVtYmVyQ29udGFpbmVyIiwiZGVmYXVsdEZvcm1hdCIsInJlbmRlcklubmVyIiwiUEFERElOR19GUk9NX1ZJRVdQT1JUIiwiUG9wb3ZlciIsInRpdGxlSWQiLCJoYW5kbGVSb290RWwiLCJyb290RWwiLCJoYW5kbGVEb2N1bWVudE1vdXNlRG93biIsImhhbmRsZUNsb3NlQ2xpY2siLCJoYW5kbGVEb2N1bWVudEtleURvd24iLCJvbkNsb3NlIiwiZXh0cmFBdHRycyIsImFsaWdubWVudEVsIiwiYWxpZ25HcmlkVG9wIiwiYWxpZ25tZW50UmVjdCIsInBvcG92ZXJEaW1zIiwicG9wb3ZlclRvcCIsInBvcG92ZXJMZWZ0Iiwib3JpZ2luIiwib2Zmc2V0UGFyZW50IiwiTW9yZVBvcG92ZXIiLCJzdGFydERhdGUiLCJmb3JjZVRpbWVkIiwiZXh0cmFEYXRlU3BhbiIsImRheUVsIiwibGF5ZXIiLCJNb3JlTGlua0NvbnRhaW5lciIsImlzUG9wb3Zlck9wZW4iLCJwb3BvdmVySWQiLCJoYW5kbGVMaW5rRWwiLCJsaW5rRWwiLCJoYW5kbGVDbGljayIsImNvbXB1dGVSYW5nZSIsImJ1aWxkUHVibGljU2VnIiwiYWxsRGF5RGF0ZSIsImFsbFNlZ3MiLCJoaWRkZW5TZWdzIiwiaGFuZGxlUG9wb3ZlckNsb3NlIiwibW9yZUNudCIsImhpbnQiLCJzaG9ydFRleHQiLCJyZW5kZXJNb3JlTGlua0lubmVyIiwiYWxpZ25tZW50RWxSZWYiLCJwb3BvdmVyQ29udGVudCIsInVwZGF0ZVBhcmVudEVsIiwiY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQiLCJjb21wdXRlTGF0ZXN0U2VnRW5kIiwicGlja0VhcmxpZXN0U3RhcnQiLCJzZWcwIiwic2VnMSIsInBpY2tMYXRlc3RFbmQiLCJTdG9yZSIsImN1cnJlbnRWYWx1ZSIsInN1YnNjcmliZSIsIkN1c3RvbVJlbmRlcmluZ1N0b3JlIiwiaGFuZGxlIiwiY3VzdG9tUmVuZGVyaW5nIiwidXBkYXRlZCIsImhhcyIsImRlbGV0ZSIsIiQiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsIkkiLCJKIiwiSyIsIkwiLCJNIiwiTiIsIk8iLCJQIiwiUSIsIlIiLCJTIiwiVCIsIlUiLCJWIiwiVyIsIlgiLCJZIiwiWiIsIl8iLCJhJCIsImEyIiwiYTMiLCJhNCIsImE1IiwiYTYiLCJhNyIsImE4IiwiYTkiLCJhQSIsImFCIiwiYUMiLCJhRCIsImFFIiwiYUYiLCJhRyIsImFIIiwiYUkiLCJhSiIsImFLIiwiYUwiLCJhTSIsImFOIiwiYU8iLCJhUCIsImFRIiwiYVIiLCJhUyIsImFUIiwiYVUiLCJhViIsImFXIiwiYVgiLCJhWSIsImFaIiwiYV8iLCJhYSIsImFiIiwiYWMiLCJhZCIsImFlIiwiYWYiLCJhZyIsImFoIiwiYWkiLCJhaiIsImFrIiwiYWwiLCJhbSIsImFuIiwiYW8iLCJhcCIsImFxIiwiYXIiLCJhcyIsImF0IiwiYXUiLCJhdiIsImF3IiwiYXgiLCJheSIsImF6IiwiYiQiLCJiMCIsImIxIiwiYjIiLCJiMyIsImI0IiwiYjUiLCJiNiIsImI3IiwiYjgiLCJiOSIsImJBIiwiYkIiLCJiQyIsImJEIiwiYkUiLCJiRiIsImJHIiwiYkgiLCJiSSIsImJKIiwiYksiLCJiTCIsImJNIiwiYk4iLCJiTyIsImJQIiwiYlEiLCJiUiIsImJTIiwiYlQiLCJiVSIsImJWIiwiYlciLCJiWCIsImJZIiwiYloiLCJiXyIsImJhIiwiYmIiLCJiYyIsImJkIiwiYmUiLCJiZiIsImJoIiwiYmkiLCJiaiIsImJrIiwiYmwiLCJibSIsImJuIiwiYm8iLCJicCIsImJxIiwiYnIiLCJicyIsImJ0IiwiYnUiLCJidiIsImJ3IiwiYngiLCJieSIsImJ6IiwiYzAiLCJjMSIsImMyIiwiYzMiLCJjNCIsImM1IiwiYzYiLCJjNyIsImM4IiwiYzkiLCJjYiIsImNjIiwiY2QiLCJjZSIsImNmIiwiY2ciLCJjaCIsImNpIiwiY2oiLCJjayIsImNsIiwiY20iLCJjbiIsImNvIiwiY3AiLCJjcSIsImNyIiwiY3MiLCJjdCIsImN1IiwiY3YiLCJjdyIsImN4IiwiY3kiLCJlIiwiZiIsImciLCJoIiwiayIsImwiLCJvIiwicCIsInEiLCJyIiwidCIsInUiLCJ2IiwieiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/core/internal-common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@fullcalendar/core/locales/ja.js":
/*!*******************************************************!*\
  !*** ./node_modules/@fullcalendar/core/locales/ja.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ l41)\n/* harmony export */ });\nvar l41 = {\n    code: \"ja\",\n    buttonText: {\n        prev: \"\",\n        next: \"\",\n        today: \"\",\n        year: \"\",\n        month: \"\",\n        week: \"\",\n        day: \"\",\n        list: \"\"\n    },\n    weekText: \"\",\n    allDayText: \"\",\n    moreLinkText (n) {\n        return \" \" + n + \" \";\n    },\n    noEventsText: \"\"\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL2xvY2FsZXMvamEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLElBQUlBLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxZQUFZO1FBQ1JDLE1BQU07UUFDTkMsTUFBTTtRQUNOQyxPQUFPO1FBQ1BDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxNQUFNO1FBQ05DLEtBQUs7UUFDTEMsTUFBTTtJQUNWO0lBQ0FDLFVBQVU7SUFDVkMsWUFBWTtJQUNaQyxjQUFhQyxDQUFDO1FBQ1YsT0FBTyxPQUFPQSxJQUFJO0lBQ3RCO0lBQ0FDLGNBQWM7QUFDbEI7QUFFMEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbG9jYWxlcy9qYS5qcz80MmM0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBsNDEgPSB7XG4gICAgY29kZTogJ2phJyxcbiAgICBidXR0b25UZXh0OiB7XG4gICAgICAgIHByZXY6ICfliY0nLFxuICAgICAgICBuZXh0OiAn5qyhJyxcbiAgICAgICAgdG9kYXk6ICfku4rml6UnLFxuICAgICAgICB5ZWFyOiAn5bm0JyxcbiAgICAgICAgbW9udGg6ICfmnIgnLFxuICAgICAgICB3ZWVrOiAn6YCxJyxcbiAgICAgICAgZGF5OiAn5pelJyxcbiAgICAgICAgbGlzdDogJ+S6iOWumuODquOCueODiCcsXG4gICAgfSxcbiAgICB3ZWVrVGV4dDogJ+mAsScsXG4gICAgYWxsRGF5VGV4dDogJ+e1guaXpScsXG4gICAgbW9yZUxpbmtUZXh0KG4pIHtcbiAgICAgICAgcmV0dXJuICfku5YgJyArIG4gKyAnIOS7tic7XG4gICAgfSxcbiAgICBub0V2ZW50c1RleHQ6ICfooajnpLrjgZnjgovkuojlrprjga/jgYLjgorjgb7jgZvjgpMnLFxufTtcblxuZXhwb3J0IHsgbDQxIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6WyJsNDEiLCJjb2RlIiwiYnV0dG9uVGV4dCIsInByZXYiLCJuZXh0IiwidG9kYXkiLCJ5ZWFyIiwibW9udGgiLCJ3ZWVrIiwiZGF5IiwibGlzdCIsIndlZWtUZXh0IiwiYWxsRGF5VGV4dCIsIm1vcmVMaW5rVGV4dCIsIm4iLCJub0V2ZW50c1RleHQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/core/locales/ja.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@fullcalendar/core/node_modules/preact/compat/dist/compat.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/@fullcalendar/core/node_modules/preact/compat/dist/compat.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Children: () => (/* binding */ O),\n/* harmony export */   Component: () => (/* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_0__.Component),\n/* harmony export */   Fragment: () => (/* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_0__.Fragment),\n/* harmony export */   PureComponent: () => (/* binding */ w),\n/* harmony export */   StrictMode: () => (/* binding */ vn),\n/* harmony export */   Suspense: () => (/* binding */ D),\n/* harmony export */   SuspenseList: () => (/* binding */ V),\n/* harmony export */   __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: () => (/* binding */ rn),\n/* harmony export */   cloneElement: () => (/* binding */ cn),\n/* harmony export */   createContext: () => (/* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_0__.createContext),\n/* harmony export */   createElement: () => (/* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_0__.createElement),\n/* harmony export */   createFactory: () => (/* binding */ on),\n/* harmony export */   createPortal: () => (/* binding */ j),\n/* harmony export */   createRef: () => (/* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_0__.createRef),\n/* harmony export */   \"default\": () => (/* binding */ bn),\n/* harmony export */   findDOMNode: () => (/* binding */ an),\n/* harmony export */   flushSync: () => (/* binding */ hn),\n/* harmony export */   forwardRef: () => (/* binding */ k),\n/* harmony export */   hydrate: () => (/* binding */ q),\n/* harmony export */   isValidElement: () => (/* binding */ ln),\n/* harmony export */   lazy: () => (/* binding */ M),\n/* harmony export */   memo: () => (/* binding */ R),\n/* harmony export */   render: () => (/* binding */ Y),\n/* harmony export */   startTransition: () => (/* binding */ dn),\n/* harmony export */   unmountComponentAtNode: () => (/* binding */ fn),\n/* harmony export */   unstable_batchedUpdates: () => (/* binding */ sn),\n/* harmony export */   useCallback: () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useCallback),\n/* harmony export */   useContext: () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useContext),\n/* harmony export */   useDebugValue: () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useDebugValue),\n/* harmony export */   useDeferredValue: () => (/* binding */ pn),\n/* harmony export */   useEffect: () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useEffect),\n/* harmony export */   useErrorBoundary: () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useErrorBoundary),\n/* harmony export */   useId: () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useId),\n/* harmony export */   useImperativeHandle: () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle),\n/* harmony export */   useInsertionEffect: () => (/* binding */ yn),\n/* harmony export */   useLayoutEffect: () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect),\n/* harmony export */   useMemo: () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useMemo),\n/* harmony export */   useReducer: () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useReducer),\n/* harmony export */   useRef: () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useRef),\n/* harmony export */   useState: () => (/* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useState),\n/* harmony export */   useSyncExternalStore: () => (/* binding */ _n),\n/* harmony export */   useTransition: () => (/* binding */ mn),\n/* harmony export */   version: () => (/* binding */ un)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"(ssr)/./node_modules/@fullcalendar/core/node_modules/preact/dist/preact.mjs\");\n/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact/hooks */ \"(ssr)/./node_modules/@fullcalendar/core/node_modules/preact/hooks/dist/hooks.mjs\");\n\n\n\n\nfunction g(n, t) {\n    for(var e in t)n[e] = t[e];\n    return n;\n}\nfunction C(n, t) {\n    for(var e in n)if (\"__source\" !== e && !(e in t)) return !0;\n    for(var r in t)if (\"__source\" !== r && n[r] !== t[r]) return !0;\n    return !1;\n}\nfunction E(n, t) {\n    return n === t && (0 !== n || 1 / n == 1 / t) || n != n && t != t;\n}\nfunction w(n) {\n    this.props = n;\n}\nfunction R(n, e) {\n    function r(n) {\n        var t = this.props.ref, r = t == n.ref;\n        return !r && t && (t.call ? t(null) : t.current = null), e ? !e(this.props, n) || !r : C(this.props, n);\n    }\n    function u(e) {\n        return this.shouldComponentUpdate = r, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(n, e);\n    }\n    return u.displayName = \"Memo(\" + (n.displayName || n.name) + \")\", u.prototype.isReactComponent = !0, u.__f = !0, u;\n}\n(w.prototype = new preact__WEBPACK_IMPORTED_MODULE_0__.Component).isPureReactComponent = !0, w.prototype.shouldComponentUpdate = function(n, t) {\n    return C(this.props, n) || C(this.state, t);\n};\nvar x = preact__WEBPACK_IMPORTED_MODULE_0__.options.__b;\npreact__WEBPACK_IMPORTED_MODULE_0__.options.__b = function(n) {\n    n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), x && x(n);\n};\nvar N = \"undefined\" != typeof Symbol && Symbol.for && Symbol.for(\"react.forward_ref\") || 3911;\nfunction k(n) {\n    function t(t) {\n        var e = g({}, t);\n        return delete e.ref, n(e, t.ref || null);\n    }\n    return t.$$typeof = N, t.render = t, t.prototype.isReactComponent = t.__f = !0, t.displayName = \"ForwardRef(\" + (n.displayName || n.name) + \")\", t;\n}\nvar A = function(n, t) {\n    return null == n ? null : (0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)((0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n).map(t));\n}, O = {\n    map: A,\n    forEach: A,\n    count: function(n) {\n        return n ? (0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n).length : 0;\n    },\n    only: function(n) {\n        var t = (0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n);\n        if (1 !== t.length) throw \"Children.only\";\n        return t[0];\n    },\n    toArray: preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray\n}, T = preact__WEBPACK_IMPORTED_MODULE_0__.options.__e;\npreact__WEBPACK_IMPORTED_MODULE_0__.options.__e = function(n, t, e, r) {\n    if (n.then) {\n        for(var u, o = t; o = o.__;)if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);\n    }\n    T(n, t, e, r);\n};\nvar I = preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount;\nfunction L(n, t, e) {\n    return n && (n.__c && n.__c.__H && (n.__c.__H.__.forEach(function(n) {\n        \"function\" == typeof n.__c && n.__c();\n    }), n.__c.__H = null), null != (n = g({}, n)).__c && (n.__c.__P === e && (n.__c.__P = t), n.__c = null), n.__k = n.__k && n.__k.map(function(n) {\n        return L(n, t, e);\n    })), n;\n}\nfunction U(n, t, e) {\n    return n && (n.__v = null, n.__k = n.__k && n.__k.map(function(n) {\n        return U(n, t, e);\n    }), n.__c && n.__c.__P === t && (n.__e && e.insertBefore(n.__e, n.__d), n.__c.__e = !0, n.__c.__P = e)), n;\n}\nfunction D() {\n    this.__u = 0, this.t = null, this.__b = null;\n}\nfunction F(n) {\n    var t = n.__.__c;\n    return t && t.__a && t.__a(n);\n}\nfunction M(n) {\n    var e, r, u;\n    function o(o) {\n        if (e || (e = n()).then(function(n) {\n            r = n.default || n;\n        }, function(n) {\n            u = n;\n        }), u) throw u;\n        if (!r) throw e;\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(r, o);\n    }\n    return o.displayName = \"Lazy\", o.__f = !0, o;\n}\nfunction V() {\n    this.u = null, this.o = null;\n}\npreact__WEBPACK_IMPORTED_MODULE_0__.options.unmount = function(n) {\n    var t = n.__c;\n    t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), I && I(n);\n}, (D.prototype = new preact__WEBPACK_IMPORTED_MODULE_0__.Component).__c = function(n, t) {\n    var e = t.__c, r = this;\n    null == r.t && (r.t = []), r.t.push(e);\n    var u = F(r.__v), o = !1, i = function() {\n        o || (o = !0, e.__R = null, u ? u(l) : l());\n    };\n    e.__R = i;\n    var l = function() {\n        if (!--r.__u) {\n            if (r.state.__a) {\n                var n = r.state.__a;\n                r.__v.__k[0] = U(n, n.__c.__P, n.__c.__O);\n            }\n            var t;\n            for(r.setState({\n                __a: r.__b = null\n            }); t = r.t.pop();)t.forceUpdate();\n        }\n    }, c = !0 === t.__h;\n    r.__u++ || c || r.setState({\n        __a: r.__b = r.__v.__k[0]\n    }), n.then(i, i);\n}, D.prototype.componentWillUnmount = function() {\n    this.t = [];\n}, D.prototype.render = function(n, e) {\n    if (this.__b) {\n        if (this.__v.__k) {\n            var r = document.createElement(\"div\"), o = this.__v.__k[0].__c;\n            this.__v.__k[0] = L(this.__b, r, o.__O = o.__P);\n        }\n        this.__b = null;\n    }\n    var i = e.__a && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, n.fallback);\n    return i && (i.__h = null), [\n        (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, e.__a ? null : n.children),\n        i\n    ];\n};\nvar W = function(n, t, e) {\n    if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && (\"t\" !== n.props.revealOrder[0] || !n.o.size)) for(e = n.u; e;){\n        for(; e.length > 3;)e.pop()();\n        if (e[1] < e[0]) break;\n        n.u = e = e[2];\n    }\n};\nfunction P(n) {\n    return this.getChildContext = function() {\n        return n.context;\n    }, n.children;\n}\nfunction $(n) {\n    var e = this, r = n.i;\n    e.componentWillUnmount = function() {\n        (0,preact__WEBPACK_IMPORTED_MODULE_0__.render)(null, e.l), e.l = null, e.i = null;\n    }, e.i && e.i !== r && e.componentWillUnmount(), n.__v ? (e.l || (e.i = r, e.l = {\n        nodeType: 1,\n        parentNode: r,\n        childNodes: [],\n        appendChild: function(n) {\n            this.childNodes.push(n), e.i.appendChild(n);\n        },\n        insertBefore: function(n, t) {\n            this.childNodes.push(n), e.i.appendChild(n);\n        },\n        removeChild: function(n) {\n            this.childNodes.splice(this.childNodes.indexOf(n) >>> 1, 1), e.i.removeChild(n);\n        }\n    }), (0,preact__WEBPACK_IMPORTED_MODULE_0__.render)((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(P, {\n        context: e.context\n    }, n.__v), e.l)) : e.l && e.componentWillUnmount();\n}\nfunction j(n, e) {\n    var r = (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)($, {\n        __v: n,\n        i: e\n    });\n    return r.containerInfo = e, r;\n}\n(V.prototype = new preact__WEBPACK_IMPORTED_MODULE_0__.Component).__a = function(n) {\n    var t = this, e = F(t.__v), r = t.o.get(n);\n    return r[0]++, function(u) {\n        var o = function() {\n            t.props.revealOrder ? (r.push(u), W(t, n, r)) : u();\n        };\n        e ? e(o) : o();\n    };\n}, V.prototype.render = function(n) {\n    this.u = null, this.o = new Map;\n    var t = (0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n.children);\n    n.revealOrder && \"b\" === n.revealOrder[0] && t.reverse();\n    for(var e = t.length; e--;)this.o.set(t[e], this.u = [\n        1,\n        0,\n        this.u\n    ]);\n    return n.children;\n}, V.prototype.componentDidUpdate = V.prototype.componentDidMount = function() {\n    var n = this;\n    this.o.forEach(function(t, e) {\n        W(n, e, t);\n    });\n};\nvar z = \"undefined\" != typeof Symbol && Symbol.for && Symbol.for(\"react.element\") || 60103, B = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, H = \"undefined\" != typeof document, Z = function(n) {\n    return (\"undefined\" != typeof Symbol && \"symbol\" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n);\n};\nfunction Y(n, t, e) {\n    return null == t.__k && (t.textContent = \"\"), (0,preact__WEBPACK_IMPORTED_MODULE_0__.render)(n, t), \"function\" == typeof e && e(), n ? n.__c : null;\n}\nfunction q(n, t, e) {\n    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.hydrate)(n, t), \"function\" == typeof e && e(), n ? n.__c : null;\n}\npreact__WEBPACK_IMPORTED_MODULE_0__.Component.prototype.isReactComponent = {}, [\n    \"componentWillMount\",\n    \"componentWillReceiveProps\",\n    \"componentWillUpdate\"\n].forEach(function(t) {\n    Object.defineProperty(preact__WEBPACK_IMPORTED_MODULE_0__.Component.prototype, t, {\n        configurable: !0,\n        get: function() {\n            return this[\"UNSAFE_\" + t];\n        },\n        set: function(n) {\n            Object.defineProperty(this, t, {\n                configurable: !0,\n                writable: !0,\n                value: n\n            });\n        }\n    });\n});\nvar G = preact__WEBPACK_IMPORTED_MODULE_0__.options.event;\nfunction J() {}\nfunction K() {\n    return this.cancelBubble;\n}\nfunction Q() {\n    return this.defaultPrevented;\n}\npreact__WEBPACK_IMPORTED_MODULE_0__.options.event = function(n) {\n    return G && (n = G(n)), n.persist = J, n.isPropagationStopped = K, n.isDefaultPrevented = Q, n.nativeEvent = n;\n};\nvar X, nn = {\n    configurable: !0,\n    get: function() {\n        return this.class;\n    }\n}, tn = preact__WEBPACK_IMPORTED_MODULE_0__.options.vnode;\npreact__WEBPACK_IMPORTED_MODULE_0__.options.vnode = function(n) {\n    var t = n.type, e = n.props, u = e;\n    if (\"string\" == typeof t) {\n        var o = -1 === t.indexOf(\"-\");\n        for(var i in u = {}, e){\n            var l = e[i];\n            H && \"children\" === i && \"noscript\" === t || \"value\" === i && \"defaultValue\" in e && null == l || (\"defaultValue\" === i && \"value\" in e && null == e.value ? i = \"value\" : \"download\" === i && !0 === l ? l = \"\" : /ondoubleclick/i.test(i) ? i = \"ondblclick\" : /^onchange(textarea|input)/i.test(i + t) && !Z(e.type) ? i = \"oninput\" : /^onfocus$/i.test(i) ? i = \"onfocusin\" : /^onblur$/i.test(i) ? i = \"onfocusout\" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i) ? i = i.toLowerCase() : o && B.test(i) ? i = i.replace(/[A-Z0-9]/g, \"-$&\").toLowerCase() : null === l && (l = void 0), /^oninput$/i.test(i) && (i = i.toLowerCase(), u[i] && (i = \"oninputCapture\")), u[i] = l);\n        }\n        \"select\" == t && u.multiple && Array.isArray(u.value) && (u.value = (0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(e.children).forEach(function(n) {\n            n.props.selected = -1 != u.value.indexOf(n.props.value);\n        })), \"select\" == t && null != u.defaultValue && (u.value = (0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(e.children).forEach(function(n) {\n            n.props.selected = u.multiple ? -1 != u.defaultValue.indexOf(n.props.value) : u.defaultValue == n.props.value;\n        })), n.props = u, e.class != e.className && (nn.enumerable = \"className\" in e, null != e.className && (u.class = e.className), Object.defineProperty(u, \"className\", nn));\n    }\n    n.$$typeof = z, tn && tn(n);\n};\nvar en = preact__WEBPACK_IMPORTED_MODULE_0__.options.__r;\npreact__WEBPACK_IMPORTED_MODULE_0__.options.__r = function(n) {\n    en && en(n), X = n.__c;\n};\nvar rn = {\n    ReactCurrentDispatcher: {\n        current: {\n            readContext: function(n) {\n                return X.__n[n.__c].props.value;\n            }\n        }\n    }\n}, un = \"17.0.2\";\nfunction on(n) {\n    return preact__WEBPACK_IMPORTED_MODULE_0__.createElement.bind(null, n);\n}\nfunction ln(n) {\n    return !!n && n.$$typeof === z;\n}\nfunction cn(n) {\n    return ln(n) ? preact__WEBPACK_IMPORTED_MODULE_0__.cloneElement.apply(null, arguments) : n;\n}\nfunction fn(n) {\n    return !!n.__k && ((0,preact__WEBPACK_IMPORTED_MODULE_0__.render)(null, n), !0);\n}\nfunction an(n) {\n    return n && (n.base || 1 === n.nodeType && n) || null;\n}\nvar sn = function(n, t) {\n    return n(t);\n}, hn = function(n, t) {\n    return n(t);\n}, vn = preact__WEBPACK_IMPORTED_MODULE_0__.Fragment;\nfunction dn(n) {\n    n();\n}\nfunction pn(n) {\n    return n;\n}\nfunction mn() {\n    return [\n        !1,\n        dn\n    ];\n}\nvar yn = preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect;\nfunction _n(n, t) {\n    var e = t(), r = (0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        h: {\n            __: e,\n            v: t\n        }\n    }), u = r[0].h, o = r[1];\n    return (0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(function() {\n        u.__ = e, u.v = t, E(u.__, t()) || o({\n            h: u\n        });\n    }, [\n        n,\n        e,\n        t\n    ]), (0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        return E(u.__, u.v()) || o({\n            h: u\n        }), n(function() {\n            E(u.__, u.v()) || o({\n                h: u\n            });\n        });\n    }, [\n        n\n    ]), e;\n}\nvar bn = {\n    useState: preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useState,\n    useId: preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useId,\n    useReducer: preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useReducer,\n    useEffect: preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useEffect,\n    useLayoutEffect: preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect,\n    useInsertionEffect: yn,\n    useTransition: mn,\n    useDeferredValue: pn,\n    useSyncExternalStore: _n,\n    startTransition: dn,\n    useRef: preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useRef,\n    useImperativeHandle: preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle,\n    useMemo: preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useMemo,\n    useCallback: preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useCallback,\n    useContext: preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useContext,\n    useDebugValue: preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useDebugValue,\n    version: \"17.0.2\",\n    Children: O,\n    render: Y,\n    hydrate: q,\n    unmountComponentAtNode: fn,\n    createPortal: j,\n    createElement: preact__WEBPACK_IMPORTED_MODULE_0__.createElement,\n    createContext: preact__WEBPACK_IMPORTED_MODULE_0__.createContext,\n    createFactory: on,\n    cloneElement: cn,\n    createRef: preact__WEBPACK_IMPORTED_MODULE_0__.createRef,\n    Fragment: preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,\n    isValidElement: ln,\n    findDOMNode: an,\n    Component: preact__WEBPACK_IMPORTED_MODULE_0__.Component,\n    PureComponent: w,\n    memo: R,\n    forwardRef: k,\n    flushSync: hn,\n    unstable_batchedUpdates: sn,\n    StrictMode: vn,\n    Suspense: D,\n    SuspenseList: V,\n    lazy: M,\n    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: rn\n};\n //# sourceMappingURL=compat.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L2Rpc3QvY29tcGF0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0w7QUFBNkU7QUFBNk07QUFBMEI7QUFBQSxTQUFTMEMsRUFBRXpDLENBQUMsRUFBQ0UsQ0FBQztJQUFFLElBQUksSUFBSUUsS0FBS0YsRUFBRUYsQ0FBQyxDQUFDSSxFQUFFLEdBQUNGLENBQUMsQ0FBQ0UsRUFBRTtJQUFDLE9BQU9KO0FBQUM7QUFBQyxTQUFTMEMsRUFBRTFDLENBQUMsRUFBQ0UsQ0FBQztJQUFFLElBQUksSUFBSUUsS0FBS0osRUFBRSxJQUFHLGVBQWFJLEtBQUcsQ0FBRUEsQ0FBQUEsS0FBS0YsQ0FBQUEsR0FBRyxPQUFNLENBQUM7SUFBRSxJQUFJLElBQUlJLEtBQUtKLEVBQUUsSUFBRyxlQUFhSSxLQUFHTixDQUFDLENBQUNNLEVBQUUsS0FBR0osQ0FBQyxDQUFDSSxFQUFFLEVBQUMsT0FBTSxDQUFDO0lBQUUsT0FBTSxDQUFDO0FBQUM7QUFBQyxTQUFTcUMsRUFBRTNDLENBQUMsRUFBQ0UsQ0FBQztJQUFFLE9BQU9GLE1BQUlFLEtBQUksT0FBSUYsS0FBRyxJQUFFQSxLQUFHLElBQUVFLENBQUFBLEtBQUlGLEtBQUdBLEtBQUdFLEtBQUdBO0FBQUM7QUFBQyxTQUFTMEMsRUFBRTVDLENBQUM7SUFBRSxJQUFJLENBQUM2QyxLQUFLLEdBQUM3QztBQUFDO0FBQUMsU0FBUzhDLEVBQUU5QyxDQUFDLEVBQUNJLENBQUM7SUFBRSxTQUFTRSxFQUFFTixDQUFDO1FBQUUsSUFBSUUsSUFBRSxJQUFJLENBQUMyQyxLQUFLLENBQUNFLEdBQUcsRUFBQ3pDLElBQUVKLEtBQUdGLEVBQUUrQyxHQUFHO1FBQUMsT0FBTSxDQUFDekMsS0FBR0osS0FBSUEsQ0FBQUEsRUFBRThDLElBQUksR0FB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Vy9JO0lBQUVnSixXQUFVdkI7SUFBR3dCLHlCQUF3QnpCO0lBQUcwQixZQUFXeEI7SUFBR3lCLFVBQVMxSDtJQUFFMkgsY0FBYXJIO0lBQUVzSCxNQUFLeEg7SUFBRXlILG9EQUFtRDVDO0FBQUU7QUFBOGdCLENBQ2xsUyx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvZGlzdC9jb21wYXQubWpzPzE4ZGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0e0NvbXBvbmVudCBhcyBuLGNyZWF0ZUVsZW1lbnQgYXMgdCxvcHRpb25zIGFzIGUsdG9DaGlsZEFycmF5IGFzIHIsRnJhZ21lbnQgYXMgdSxyZW5kZXIgYXMgbyxoeWRyYXRlIGFzIGksY3JlYXRlQ29udGV4dCBhcyBsLGNyZWF0ZVJlZiBhcyBjLGNsb25lRWxlbWVudCBhcyBmfWZyb21cInByZWFjdFwiO2V4cG9ydHtDb21wb25lbnQsRnJhZ21lbnQsY3JlYXRlQ29udGV4dCxjcmVhdGVFbGVtZW50LGNyZWF0ZVJlZn1mcm9tXCJwcmVhY3RcIjtpbXBvcnR7dXNlU3RhdGUgYXMgYSx1c2VJZCBhcyBzLHVzZVJlZHVjZXIgYXMgaCx1c2VFZmZlY3QgYXMgdix1c2VMYXlvdXRFZmZlY3QgYXMgZCx1c2VSZWYgYXMgcCx1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIG0sdXNlTWVtbyBhcyB5LHVzZUNhbGxiYWNrIGFzIF8sdXNlQ29udGV4dCBhcyBiLHVzZURlYnVnVmFsdWUgYXMgU31mcm9tXCJwcmVhY3QvaG9va3NcIjtleHBvcnQqZnJvbVwicHJlYWN0L2hvb2tzXCI7ZnVuY3Rpb24gZyhuLHQpe2Zvcih2YXIgZSBpbiB0KW5bZV09dFtlXTtyZXR1cm4gbn1mdW5jdGlvbiBDKG4sdCl7Zm9yKHZhciBlIGluIG4paWYoXCJfX3NvdXJjZVwiIT09ZSYmIShlIGluIHQpKXJldHVybiEwO2Zvcih2YXIgciBpbiB0KWlmKFwiX19zb3VyY2VcIiE9PXImJm5bcl0hPT10W3JdKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIEUobix0KXtyZXR1cm4gbj09PXQmJigwIT09bnx8MS9uPT0xL3QpfHxuIT1uJiZ0IT10fWZ1bmN0aW9uIHcobil7dGhpcy5wcm9wcz1ufWZ1bmN0aW9uIFIobixlKXtmdW5jdGlvbiByKG4pe3ZhciB0PXRoaXMucHJvcHMucmVmLHI9dD09bi5yZWY7cmV0dXJuIXImJnQmJih0LmNhbGw/dChudWxsKTp0LmN1cnJlbnQ9bnVsbCksZT8hZSh0aGlzLnByb3BzLG4pfHwhcjpDKHRoaXMucHJvcHMsbil9ZnVuY3Rpb24gdShlKXtyZXR1cm4gdGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGU9cix0KG4sZSl9cmV0dXJuIHUuZGlzcGxheU5hbWU9XCJNZW1vKFwiKyhuLmRpc3BsYXlOYW1lfHxuLm5hbWUpK1wiKVwiLHUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ9ITAsdS5fX2Y9ITAsdX0ody5wcm90b3R5cGU9bmV3IG4pLmlzUHVyZVJlYWN0Q29tcG9uZW50PSEwLHcucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZT1mdW5jdGlvbihuLHQpe3JldHVybiBDKHRoaXMucHJvcHMsbil8fEModGhpcy5zdGF0ZSx0KX07dmFyIHg9ZS5fX2I7ZS5fX2I9ZnVuY3Rpb24obil7bi50eXBlJiZuLnR5cGUuX19mJiZuLnJlZiYmKG4ucHJvcHMucmVmPW4ucmVmLG4ucmVmPW51bGwpLHgmJngobil9O3ZhciBOPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5mb3ImJlN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKXx8MzkxMTtmdW5jdGlvbiBrKG4pe2Z1bmN0aW9uIHQodCl7dmFyIGU9Zyh7fSx0KTtyZXR1cm4gZGVsZXRlIGUucmVmLG4oZSx0LnJlZnx8bnVsbCl9cmV0dXJuIHQuJCR0eXBlb2Y9Tix0LnJlbmRlcj10LHQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ9dC5fX2Y9ITAsdC5kaXNwbGF5TmFtZT1cIkZvcndhcmRSZWYoXCIrKG4uZGlzcGxheU5hbWV8fG4ubmFtZSkrXCIpXCIsdH12YXIgQT1mdW5jdGlvbihuLHQpe3JldHVybiBudWxsPT1uP251bGw6cihyKG4pLm1hcCh0KSl9LE89e21hcDpBLGZvckVhY2g6QSxjb3VudDpmdW5jdGlvbihuKXtyZXR1cm4gbj9yKG4pLmxlbmd0aDowfSxvbmx5OmZ1bmN0aW9uKG4pe3ZhciB0PXIobik7aWYoMSE9PXQubGVuZ3RoKXRocm93XCJDaGlsZHJlbi5vbmx5XCI7cmV0dXJuIHRbMF19LHRvQXJyYXk6cn0sVD1lLl9fZTtlLl9fZT1mdW5jdGlvbihuLHQsZSxyKXtpZihuLnRoZW4pZm9yKHZhciB1LG89dDtvPW8uX187KWlmKCh1PW8uX19jKSYmdS5fX2MpcmV0dXJuIG51bGw9PXQuX19lJiYodC5fX2U9ZS5fX2UsdC5fX2s9ZS5fX2spLHUuX19jKG4sdCk7VChuLHQsZSxyKX07dmFyIEk9ZS51bm1vdW50O2Z1bmN0aW9uIEwobix0LGUpe3JldHVybiBuJiYobi5fX2MmJm4uX19jLl9fSCYmKG4uX19jLl9fSC5fXy5mb3JFYWNoKGZ1bmN0aW9uKG4pe1wiZnVuY3Rpb25cIj09dHlwZW9mIG4uX19jJiZuLl9fYygpfSksbi5fX2MuX19IPW51bGwpLG51bGwhPShuPWcoe30sbikpLl9fYyYmKG4uX19jLl9fUD09PWUmJihuLl9fYy5fX1A9dCksbi5fX2M9bnVsbCksbi5fX2s9bi5fX2smJm4uX19rLm1hcChmdW5jdGlvbihuKXtyZXR1cm4gTChuLHQsZSl9KSksbn1mdW5jdGlvbiBVKG4sdCxlKXtyZXR1cm4gbiYmKG4uX192PW51bGwsbi5fX2s9bi5fX2smJm4uX19rLm1hcChmdW5jdGlvbihuKXtyZXR1cm4gVShuLHQsZSl9KSxuLl9fYyYmbi5fX2MuX19QPT09dCYmKG4uX19lJiZlLmluc2VydEJlZm9yZShuLl9fZSxuLl9fZCksbi5fX2MuX19lPSEwLG4uX19jLl9fUD1lKSksbn1mdW5jdGlvbiBEKCl7dGhpcy5fX3U9MCx0aGlzLnQ9bnVsbCx0aGlzLl9fYj1udWxsfWZ1bmN0aW9uIEYobil7dmFyIHQ9bi5fXy5fX2M7cmV0dXJuIHQmJnQuX19hJiZ0Ll9fYShuKX1mdW5jdGlvbiBNKG4pe3ZhciBlLHIsdTtmdW5jdGlvbiBvKG8pe2lmKGV8fChlPW4oKSkudGhlbihmdW5jdGlvbihuKXtyPW4uZGVmYXVsdHx8bn0sZnVuY3Rpb24obil7dT1ufSksdSl0aHJvdyB1O2lmKCFyKXRocm93IGU7cmV0dXJuIHQocixvKX1yZXR1cm4gby5kaXNwbGF5TmFtZT1cIkxhenlcIixvLl9fZj0hMCxvfWZ1bmN0aW9uIFYoKXt0aGlzLnU9bnVsbCx0aGlzLm89bnVsbH1lLnVubW91bnQ9ZnVuY3Rpb24obil7dmFyIHQ9bi5fX2M7dCYmdC5fX1ImJnQuX19SKCksdCYmITA9PT1uLl9faCYmKG4udHlwZT1udWxsKSxJJiZJKG4pfSwoRC5wcm90b3R5cGU9bmV3IG4pLl9fYz1mdW5jdGlvbihuLHQpe3ZhciBlPXQuX19jLHI9dGhpcztudWxsPT1yLnQmJihyLnQ9W10pLHIudC5wdXNoKGUpO3ZhciB1PUYoci5fX3YpLG89ITEsaT1mdW5jdGlvbigpe298fChvPSEwLGUuX19SPW51bGwsdT91KGwpOmwoKSl9O2UuX19SPWk7dmFyIGw9ZnVuY3Rpb24oKXtpZighLS1yLl9fdSl7aWYoci5zdGF0ZS5fX2Epe3ZhciBuPXIuc3RhdGUuX19hO3IuX192Ll9fa1swXT1VKG4sbi5fX2MuX19QLG4uX19jLl9fTyl9dmFyIHQ7Zm9yKHIuc2V0U3RhdGUoe19fYTpyLl9fYj1udWxsfSk7dD1yLnQucG9wKCk7KXQuZm9yY2VVcGRhdGUoKX19LGM9ITA9PT10Ll9faDtyLl9fdSsrfHxjfHxyLnNldFN0YXRlKHtfX2E6ci5fX2I9ci5fX3YuX19rWzBdfSksbi50aGVuKGksaSl9LEQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50PWZ1bmN0aW9uKCl7dGhpcy50PVtdfSxELnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24obixlKXtpZih0aGlzLl9fYil7aWYodGhpcy5fX3YuX19rKXt2YXIgcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLG89dGhpcy5fX3YuX19rWzBdLl9fYzt0aGlzLl9fdi5fX2tbMF09TCh0aGlzLl9fYixyLG8uX19PPW8uX19QKX10aGlzLl9fYj1udWxsfXZhciBpPWUuX19hJiZ0KHUsbnVsbCxuLmZhbGxiYWNrKTtyZXR1cm4gaSYmKGkuX19oPW51bGwpLFt0KHUsbnVsbCxlLl9fYT9udWxsOm4uY2hpbGRyZW4pLGldfTt2YXIgVz1mdW5jdGlvbihuLHQsZSl7aWYoKytlWzFdPT09ZVswXSYmbi5vLmRlbGV0ZSh0KSxuLnByb3BzLnJldmVhbE9yZGVyJiYoXCJ0XCIhPT1uLnByb3BzLnJldmVhbE9yZGVyWzBdfHwhbi5vLnNpemUpKWZvcihlPW4udTtlOyl7Zm9yKDtlLmxlbmd0aD4zOyllLnBvcCgpKCk7aWYoZVsxXTxlWzBdKWJyZWFrO24udT1lPWVbMl19fTtmdW5jdGlvbiBQKG4pe3JldHVybiB0aGlzLmdldENoaWxkQ29udGV4dD1mdW5jdGlvbigpe3JldHVybiBuLmNvbnRleHR9LG4uY2hpbGRyZW59ZnVuY3Rpb24gJChuKXt2YXIgZT10aGlzLHI9bi5pO2UuY29tcG9uZW50V2lsbFVubW91bnQ9ZnVuY3Rpb24oKXtvKG51bGwsZS5sKSxlLmw9bnVsbCxlLmk9bnVsbH0sZS5pJiZlLmkhPT1yJiZlLmNvbXBvbmVudFdpbGxVbm1vdW50KCksbi5fX3Y/KGUubHx8KGUuaT1yLGUubD17bm9kZVR5cGU6MSxwYXJlbnROb2RlOnIsY2hpbGROb2RlczpbXSxhcHBlbmRDaGlsZDpmdW5jdGlvbihuKXt0aGlzLmNoaWxkTm9kZXMucHVzaChuKSxlLmkuYXBwZW5kQ2hpbGQobil9LGluc2VydEJlZm9yZTpmdW5jdGlvbihuLHQpe3RoaXMuY2hpbGROb2Rlcy5wdXNoKG4pLGUuaS5hcHBlbmRDaGlsZChuKX0scmVtb3ZlQ2hpbGQ6ZnVuY3Rpb24obil7dGhpcy5jaGlsZE5vZGVzLnNwbGljZSh0aGlzLmNoaWxkTm9kZXMuaW5kZXhPZihuKT4+PjEsMSksZS5pLnJlbW92ZUNoaWxkKG4pfX0pLG8odChQLHtjb250ZXh0OmUuY29udGV4dH0sbi5fX3YpLGUubCkpOmUubCYmZS5jb21wb25lbnRXaWxsVW5tb3VudCgpfWZ1bmN0aW9uIGoobixlKXt2YXIgcj10KCQse19fdjpuLGk6ZX0pO3JldHVybiByLmNvbnRhaW5lckluZm89ZSxyfShWLnByb3RvdHlwZT1uZXcgbikuX19hPWZ1bmN0aW9uKG4pe3ZhciB0PXRoaXMsZT1GKHQuX192KSxyPXQuby5nZXQobik7cmV0dXJuIHJbMF0rKyxmdW5jdGlvbih1KXt2YXIgbz1mdW5jdGlvbigpe3QucHJvcHMucmV2ZWFsT3JkZXI/KHIucHVzaCh1KSxXKHQsbixyKSk6dSgpfTtlP2Uobyk6bygpfX0sVi5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKG4pe3RoaXMudT1udWxsLHRoaXMubz1uZXcgTWFwO3ZhciB0PXIobi5jaGlsZHJlbik7bi5yZXZlYWxPcmRlciYmXCJiXCI9PT1uLnJldmVhbE9yZGVyWzBdJiZ0LnJldmVyc2UoKTtmb3IodmFyIGU9dC5sZW5ndGg7ZS0tOyl0aGlzLm8uc2V0KHRbZV0sdGhpcy51PVsxLDAsdGhpcy51XSk7cmV0dXJuIG4uY2hpbGRyZW59LFYucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZT1WLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudD1mdW5jdGlvbigpe3ZhciBuPXRoaXM7dGhpcy5vLmZvckVhY2goZnVuY3Rpb24odCxlKXtXKG4sZSx0KX0pfTt2YXIgej1cInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuZm9yJiZTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKXx8NjAxMDMsQj0vXig/OmFjY2VudHxhbGlnbm1lbnR8YXJhYmljfGJhc2VsaW5lfGNhcHxjbGlwKD8hUGF0aFUpfGNvbG9yfGRvbWluYW50fGZpbGx8Zmxvb2R8Zm9udHxnbHlwaCg/IVIpfGhvcml6fGltYWdlfGxldHRlcnxsaWdodGluZ3xtYXJrZXIoPyFIfFd8VSl8b3ZlcmxpbmV8cGFpbnR8cG9pbnRlcnxzaGFwZXxzdG9wfHN0cmlrZXRocm91Z2h8c3Ryb2tlfHRleHQoPyFMKXx0cmFuc2Zvcm18dW5kZXJsaW5lfHVuaWNvZGV8dW5pdHN8dnx2ZWN0b3J8dmVydHx3b3JkfHdyaXRpbmd8eCg/IUMpKVtBLVpdLyxIPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCxaPWZ1bmN0aW9uKG4pe3JldHVybihcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sKCk/L2ZpbHxjaGV8cmFkL2k6L2ZpbHxjaGV8cmEvaSkudGVzdChuKX07ZnVuY3Rpb24gWShuLHQsZSl7cmV0dXJuIG51bGw9PXQuX19rJiYodC50ZXh0Q29udGVudD1cIlwiKSxvKG4sdCksXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmZSgpLG4/bi5fX2M6bnVsbH1mdW5jdGlvbiBxKG4sdCxlKXtyZXR1cm4gaShuLHQpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJmUoKSxuP24uX19jOm51bGx9bi5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD17fSxbXCJjb21wb25lbnRXaWxsTW91bnRcIixcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIixcImNvbXBvbmVudFdpbGxVcGRhdGVcIl0uZm9yRWFjaChmdW5jdGlvbih0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkobi5wcm90b3R5cGUsdCx7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW1wiVU5TQUZFX1wiK3RdfSxzZXQ6ZnVuY3Rpb24obil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsdCx7Y29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm59KX19KX0pO3ZhciBHPWUuZXZlbnQ7ZnVuY3Rpb24gSigpe31mdW5jdGlvbiBLKCl7cmV0dXJuIHRoaXMuY2FuY2VsQnViYmxlfWZ1bmN0aW9uIFEoKXtyZXR1cm4gdGhpcy5kZWZhdWx0UHJldmVudGVkfWUuZXZlbnQ9ZnVuY3Rpb24obil7cmV0dXJuIEcmJihuPUcobikpLG4ucGVyc2lzdD1KLG4uaXNQcm9wYWdhdGlvblN0b3BwZWQ9SyxuLmlzRGVmYXVsdFByZXZlbnRlZD1RLG4ubmF0aXZlRXZlbnQ9bn07dmFyIFgsbm49e2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbGFzc319LHRuPWUudm5vZGU7ZS52bm9kZT1mdW5jdGlvbihuKXt2YXIgdD1uLnR5cGUsZT1uLnByb3BzLHU9ZTtpZihcInN0cmluZ1wiPT10eXBlb2YgdCl7dmFyIG89LTE9PT10LmluZGV4T2YoXCItXCIpO2Zvcih2YXIgaSBpbiB1PXt9LGUpe3ZhciBsPWVbaV07SCYmXCJjaGlsZHJlblwiPT09aSYmXCJub3NjcmlwdFwiPT09dHx8XCJ2YWx1ZVwiPT09aSYmXCJkZWZhdWx0VmFsdWVcImluIGUmJm51bGw9PWx8fChcImRlZmF1bHRWYWx1ZVwiPT09aSYmXCJ2YWx1ZVwiaW4gZSYmbnVsbD09ZS52YWx1ZT9pPVwidmFsdWVcIjpcImRvd25sb2FkXCI9PT1pJiYhMD09PWw/bD1cIlwiOi9vbmRvdWJsZWNsaWNrL2kudGVzdChpKT9pPVwib25kYmxjbGlja1wiOi9eb25jaGFuZ2UodGV4dGFyZWF8aW5wdXQpL2kudGVzdChpK3QpJiYhWihlLnR5cGUpP2k9XCJvbmlucHV0XCI6L15vbmZvY3VzJC9pLnRlc3QoaSk/aT1cIm9uZm9jdXNpblwiOi9eb25ibHVyJC9pLnRlc3QoaSk/aT1cIm9uZm9jdXNvdXRcIjovXm9uKEFuaXxUcmF8VG91fEJlZm9yZUlucHxDb21wbykvLnRlc3QoaSk/aT1pLnRvTG93ZXJDYXNlKCk6byYmQi50ZXN0KGkpP2k9aS5yZXBsYWNlKC9bQS1aMC05XS9nLFwiLSQmXCIpLnRvTG93ZXJDYXNlKCk6bnVsbD09PWwmJihsPXZvaWQgMCksL15vbmlucHV0JC9pLnRlc3QoaSkmJihpPWkudG9Mb3dlckNhc2UoKSx1W2ldJiYoaT1cIm9uaW5wdXRDYXB0dXJlXCIpKSx1W2ldPWwpfVwic2VsZWN0XCI9PXQmJnUubXVsdGlwbGUmJkFycmF5LmlzQXJyYXkodS52YWx1ZSkmJih1LnZhbHVlPXIoZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbihuKXtuLnByb3BzLnNlbGVjdGVkPS0xIT11LnZhbHVlLmluZGV4T2Yobi5wcm9wcy52YWx1ZSl9KSksXCJzZWxlY3RcIj09dCYmbnVsbCE9dS5kZWZhdWx0VmFsdWUmJih1LnZhbHVlPXIoZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbihuKXtuLnByb3BzLnNlbGVjdGVkPXUubXVsdGlwbGU/LTEhPXUuZGVmYXVsdFZhbHVlLmluZGV4T2Yobi5wcm9wcy52YWx1ZSk6dS5kZWZhdWx0VmFsdWU9PW4ucHJvcHMudmFsdWV9KSksbi5wcm9wcz11LGUuY2xhc3MhPWUuY2xhc3NOYW1lJiYobm4uZW51bWVyYWJsZT1cImNsYXNzTmFtZVwiaW4gZSxudWxsIT1lLmNsYXNzTmFtZSYmKHUuY2xhc3M9ZS5jbGFzc05hbWUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LFwiY2xhc3NOYW1lXCIsbm4pKX1uLiQkdHlwZW9mPXosdG4mJnRuKG4pfTt2YXIgZW49ZS5fX3I7ZS5fX3I9ZnVuY3Rpb24obil7ZW4mJmVuKG4pLFg9bi5fX2N9O3ZhciBybj17UmVhY3RDdXJyZW50RGlzcGF0Y2hlcjp7Y3VycmVudDp7cmVhZENvbnRleHQ6ZnVuY3Rpb24obil7cmV0dXJuIFguX19uW24uX19jXS5wcm9wcy52YWx1ZX19fX0sdW49XCIxNy4wLjJcIjtmdW5jdGlvbiBvbihuKXtyZXR1cm4gdC5iaW5kKG51bGwsbil9ZnVuY3Rpb24gbG4obil7cmV0dXJuISFuJiZuLiQkdHlwZW9mPT09en1mdW5jdGlvbiBjbihuKXtyZXR1cm4gbG4obik/Zi5hcHBseShudWxsLGFyZ3VtZW50cyk6bn1mdW5jdGlvbiBmbihuKXtyZXR1cm4hIW4uX19rJiYobyhudWxsLG4pLCEwKX1mdW5jdGlvbiBhbihuKXtyZXR1cm4gbiYmKG4uYmFzZXx8MT09PW4ubm9kZVR5cGUmJm4pfHxudWxsfXZhciBzbj1mdW5jdGlvbihuLHQpe3JldHVybiBuKHQpfSxobj1mdW5jdGlvbihuLHQpe3JldHVybiBuKHQpfSx2bj11O2Z1bmN0aW9uIGRuKG4pe24oKX1mdW5jdGlvbiBwbihuKXtyZXR1cm4gbn1mdW5jdGlvbiBtbigpe3JldHVyblshMSxkbl19dmFyIHluPWQ7ZnVuY3Rpb24gX24obix0KXt2YXIgZT10KCkscj1hKHtoOntfXzplLHY6dH19KSx1PXJbMF0uaCxvPXJbMV07cmV0dXJuIGQoZnVuY3Rpb24oKXt1Ll9fPWUsdS52PXQsRSh1Ll9fLHQoKSl8fG8oe2g6dX0pfSxbbixlLHRdKSx2KGZ1bmN0aW9uKCl7cmV0dXJuIEUodS5fXyx1LnYoKSl8fG8oe2g6dX0pLG4oZnVuY3Rpb24oKXtFKHUuX18sdS52KCkpfHxvKHtoOnV9KX0pfSxbbl0pLGV9dmFyIGJuPXt1c2VTdGF0ZTphLHVzZUlkOnMsdXNlUmVkdWNlcjpoLHVzZUVmZmVjdDp2LHVzZUxheW91dEVmZmVjdDpkLHVzZUluc2VydGlvbkVmZmVjdDp5bix1c2VUcmFuc2l0aW9uOm1uLHVzZURlZmVycmVkVmFsdWU6cG4sdXNlU3luY0V4dGVybmFsU3RvcmU6X24sc3RhcnRUcmFuc2l0aW9uOmRuLHVzZVJlZjpwLHVzZUltcGVyYXRpdmVIYW5kbGU6bSx1c2VNZW1vOnksdXNlQ2FsbGJhY2s6Xyx1c2VDb250ZXh0OmIsdXNlRGVidWdWYWx1ZTpTLHZlcnNpb246XCIxNy4wLjJcIixDaGlsZHJlbjpPLHJlbmRlcjpZLGh5ZHJhdGU6cSx1bm1vdW50Q29tcG9uZW50QXROb2RlOmZuLGNyZWF0ZVBvcnRhbDpqLGNyZWF0ZUVsZW1lbnQ6dCxjcmVhdGVDb250ZXh0OmwsY3JlYXRlRmFjdG9yeTpvbixjbG9uZUVsZW1lbnQ6Y24sY3JlYXRlUmVmOmMsRnJhZ21lbnQ6dSxpc1ZhbGlkRWxlbWVudDpsbixmaW5kRE9NTm9kZTphbixDb21wb25lbnQ6bixQdXJlQ29tcG9uZW50OncsbWVtbzpSLGZvcndhcmRSZWY6ayxmbHVzaFN5bmM6aG4sdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6c24sU3RyaWN0TW9kZTp2bixTdXNwZW5zZTpELFN1c3BlbnNlTGlzdDpWLGxhenk6TSxfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDpybn07ZXhwb3J0e08gYXMgQ2hpbGRyZW4sdyBhcyBQdXJlQ29tcG9uZW50LHZuIGFzIFN0cmljdE1vZGUsRCBhcyBTdXNwZW5zZSxWIGFzIFN1c3BlbnNlTGlzdCxybiBhcyBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCxjbiBhcyBjbG9uZUVsZW1lbnQsb24gYXMgY3JlYXRlRmFjdG9yeSxqIGFzIGNyZWF0ZVBvcnRhbCxibiBhcyBkZWZhdWx0LGFuIGFzIGZpbmRET01Ob2RlLGhuIGFzIGZsdXNoU3luYyxrIGFzIGZvcndhcmRSZWYscSBhcyBoeWRyYXRlLGxuIGFzIGlzVmFsaWRFbGVtZW50LE0gYXMgbGF6eSxSIGFzIG1lbW8sWSBhcyByZW5kZXIsZG4gYXMgc3RhcnRUcmFuc2l0aW9uLGZuIGFzIHVubW91bnRDb21wb25lbnRBdE5vZGUsc24gYXMgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMscG4gYXMgdXNlRGVmZXJyZWRWYWx1ZSx5biBhcyB1c2VJbnNlcnRpb25FZmZlY3QsX24gYXMgdXNlU3luY0V4dGVybmFsU3RvcmUsbW4gYXMgdXNlVHJhbnNpdGlvbix1biBhcyB2ZXJzaW9ufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBhdC5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwibiIsImNyZWF0ZUVsZW1lbnQiLCJ0Iiwib3B0aW9ucyIsImUiLCJ0b0NoaWxkQXJyYXkiLCJyIiwiRnJhZ21lbnQiLCJ1IiwicmVuZGVyIiwibyIsImh5ZHJhdGUiLCJpIiwiY3JlYXRlQ29udGV4dCIsImwiLCJjcmVhdGVSZWYiLCJjIiwiY2xvbmVFbGVtZW50IiwiZiIsInVzZVN0YXRlIiwiYSIsInVzZUlkIiwicyIsInVzZVJlZHVjZXIiLCJoIiwidXNlRWZmZWN0IiwidiIsInVzZUxheW91dEVmZmVjdCIsImQiLCJ1c2VSZWYiLCJwIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsIm0iLCJ1c2VNZW1vIiwieSIsInVzZUNhbGxiYWNrIiwiXyIsInVzZUNvbnRleHQiLCJiIiwidXNlRGVidWdWYWx1ZSIsIlMiLCJnIiwiQyIsIkUiLCJ3IiwicHJvcHMiLCJSIiwicmVmIiwiY2FsbCIsImN1cnJlbnQiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJwcm90b3R5cGUiLCJpc1JlYWN0Q29tcG9uZW50IiwiX19mIiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJzdGF0ZSIsIngiLCJfX2IiLCJ0eXBlIiwiTiIsIlN5bWJvbCIsImZvciIsImsiLCIkJHR5cGVvZiIsIkEiLCJtYXAiLCJPIiwiZm9yRWFjaCIsImNvdW50IiwibGVuZ3RoIiwib25seSIsInRvQXJyYXkiLCJUIiwiX19lIiwidGhlbiIsIl9fIiwiX19jIiwiX19rIiwiSSIsInVubW91bnQiLCJMIiwiX19IIiwiX19QIiwiVSIsIl9fdiIsImluc2VydEJlZm9yZSIsIl9fZCIsIkQiLCJfX3UiLCJGIiwiX19hIiwiTSIsImRlZmF1bHQiLCJWIiwiX19SIiwiX19oIiwicHVzaCIsIl9fTyIsInNldFN0YXRlIiwicG9wIiwiZm9yY2VVcGRhdGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImRvY3VtZW50IiwiZmFsbGJhY2siLCJjaGlsZHJlbiIsIlciLCJkZWxldGUiLCJyZXZlYWxPcmRlciIsInNpemUiLCJQIiwiZ2V0Q2hpbGRDb250ZXh0IiwiY29udGV4dCIsIiQiLCJub2RlVHlwZSIsInBhcmVudE5vZGUiLCJjaGlsZE5vZGVzIiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVDaGlsZCIsInNwbGljZSIsImluZGV4T2YiLCJqIiwiY29udGFpbmVySW5mbyIsImdldCIsIk1hcCIsInJldmVyc2UiLCJzZXQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJjb21wb25lbnREaWRNb3VudCIsInoiLCJCIiwiSCIsIloiLCJ0ZXN0IiwiWSIsInRleHRDb250ZW50IiwicSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsIkciLCJldmVudCIsIkoiLCJLIiwiY2FuY2VsQnViYmxlIiwiUSIsImRlZmF1bHRQcmV2ZW50ZWQiLCJwZXJzaXN0IiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJuYXRpdmVFdmVudCIsIlgiLCJubiIsImNsYXNzIiwidG4iLCJ2bm9kZSIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsIm11bHRpcGxlIiwiQXJyYXkiLCJpc0FycmF5Iiwic2VsZWN0ZWQiLCJkZWZhdWx0VmFsdWUiLCJjbGFzc05hbWUiLCJlbnVtZXJhYmxlIiwiZW4iLCJfX3IiLCJybiIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJyZWFkQ29udGV4dCIsIl9fbiIsInVuIiwib24iLCJiaW5kIiwibG4iLCJjbiIsImFwcGx5IiwiYXJndW1lbnRzIiwiZm4iLCJhbiIsImJhc2UiLCJzbiIsImhuIiwidm4iLCJkbiIsInBuIiwibW4iLCJ5biIsIl9uIiwiYm4iLCJ1c2VJbnNlcnRpb25FZmZlY3QiLCJ1c2VUcmFuc2l0aW9uIiwidXNlRGVmZXJyZWRWYWx1ZSIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwic3RhcnRUcmFuc2l0aW9uIiwidmVyc2lvbiIsIkNoaWxkcmVuIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsImNyZWF0ZVBvcnRhbCIsImNyZWF0ZUZhY3RvcnkiLCJpc1ZhbGlkRWxlbWVudCIsImZpbmRET01Ob2RlIiwiUHVyZUNvbXBvbmVudCIsIm1lbW8iLCJmb3J3YXJkUmVmIiwiZmx1c2hTeW5jIiwidW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMiLCJTdHJpY3RNb2RlIiwiU3VzcGVuc2UiLCJTdXNwZW5zZUxpc3QiLCJsYXp5IiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/core/node_modules/preact/compat/dist/compat.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@fullcalendar/core/node_modules/preact/dist/preact.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@fullcalendar/core/node_modules/preact/dist/preact.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: () => (/* binding */ x),\n/* harmony export */   Fragment: () => (/* binding */ _),\n/* harmony export */   cloneElement: () => (/* binding */ F),\n/* harmony export */   createContext: () => (/* binding */ G),\n/* harmony export */   createElement: () => (/* binding */ y),\n/* harmony export */   createRef: () => (/* binding */ d),\n/* harmony export */   h: () => (/* binding */ y),\n/* harmony export */   hydrate: () => (/* binding */ E),\n/* harmony export */   isValidElement: () => (/* binding */ i),\n/* harmony export */   options: () => (/* binding */ l),\n/* harmony export */   render: () => (/* binding */ D),\n/* harmony export */   toChildArray: () => (/* binding */ j)\n/* harmony export */ });\nvar n, l, u, i, t, r, o, f, e, c = {}, s = [], a = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\nfunction h(n, l) {\n    for(var u in l)n[u] = l[u];\n    return n;\n}\nfunction v(n) {\n    var l = n.parentNode;\n    l && l.removeChild(n);\n}\nfunction y(l, u, i) {\n    var t, r, o, f = {};\n    for(o in u)\"key\" == o ? t = u[o] : \"ref\" == o ? r = u[o] : f[o] = u[o];\n    if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), \"function\" == typeof l && null != l.defaultProps) for(o in l.defaultProps)void 0 === f[o] && (f[o] = l.defaultProps[o]);\n    return p(l, f, t, r, null);\n}\nfunction p(n, i, t, r, o) {\n    var f = {\n        type: n,\n        props: i,\n        key: t,\n        ref: r,\n        __k: null,\n        __: null,\n        __b: 0,\n        __e: null,\n        __d: void 0,\n        __c: null,\n        __h: null,\n        constructor: void 0,\n        __v: null == o ? ++u : o\n    };\n    return null == o && null != l.vnode && l.vnode(f), f;\n}\nfunction d() {\n    return {\n        current: null\n    };\n}\nfunction _(n) {\n    return n.children;\n}\nfunction k(n, l, u, i, t) {\n    var r;\n    for(r in u)\"children\" === r || \"key\" === r || r in l || g(n, r, null, u[r], i);\n    for(r in l)t && \"function\" != typeof l[r] || \"children\" === r || \"key\" === r || \"value\" === r || \"checked\" === r || u[r] === l[r] || g(n, r, l[r], u[r], i);\n}\nfunction b(n, l, u) {\n    \"-\" === l[0] ? n.setProperty(l, null == u ? \"\" : u) : n[l] = null == u ? \"\" : \"number\" != typeof u || a.test(l) ? u : u + \"px\";\n}\nfunction g(n, l, u, i, t) {\n    var r;\n    n: if (\"style\" === l) if (\"string\" == typeof u) n.style.cssText = u;\n    else {\n        if (\"string\" == typeof i && (n.style.cssText = i = \"\"), i) for(l in i)u && l in u || b(n.style, l, \"\");\n        if (u) for(l in u)i && u[l] === i[l] || b(n.style, l, u[l]);\n    }\n    else if (\"o\" === l[0] && \"n\" === l[1]) r = l !== (l = l.replace(/Capture$/, \"\")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + r] = u, u ? i || n.addEventListener(l, r ? w : m, r) : n.removeEventListener(l, r ? w : m, r);\n    else if (\"dangerouslySetInnerHTML\" !== l) {\n        if (t) l = l.replace(/xlink(H|:h)/, \"h\").replace(/sName$/, \"s\");\n        else if (\"width\" !== l && \"height\" !== l && \"href\" !== l && \"list\" !== l && \"form\" !== l && \"tabIndex\" !== l && \"download\" !== l && l in n) try {\n            n[l] = null == u ? \"\" : u;\n            break n;\n        } catch (n) {}\n        \"function\" == typeof u || (null == u || !1 === u && -1 == l.indexOf(\"-\") ? n.removeAttribute(l) : n.setAttribute(l, u));\n    }\n}\nfunction m(n) {\n    t = !0;\n    try {\n        return this.l[n.type + !1](l.event ? l.event(n) : n);\n    } finally{\n        t = !1;\n    }\n}\nfunction w(n) {\n    t = !0;\n    try {\n        return this.l[n.type + !0](l.event ? l.event(n) : n);\n    } finally{\n        t = !1;\n    }\n}\nfunction x(n, l) {\n    this.props = n, this.context = l;\n}\nfunction A(n, l) {\n    if (null == l) return n.__ ? A(n.__, n.__.__k.indexOf(n) + 1) : null;\n    for(var u; l < n.__k.length; l++)if (null != (u = n.__k[l]) && null != u.__e) return u.__e;\n    return \"function\" == typeof n.type ? A(n) : null;\n}\nfunction P(n) {\n    var l, u;\n    if (null != (n = n.__) && null != n.__c) {\n        for(n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++)if (null != (u = n.__k[l]) && null != u.__e) {\n            n.__e = n.__c.base = u.__e;\n            break;\n        }\n        return P(n);\n    }\n}\nfunction C(n) {\n    t ? setTimeout(n) : f(n);\n}\nfunction T(n) {\n    (!n.__d && (n.__d = !0) && r.push(n) && !$.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || C)($);\n}\nfunction $() {\n    var n, l, u, i, t, o, f, e;\n    for(r.sort(function(n, l) {\n        return n.__v.__b - l.__v.__b;\n    }); n = r.shift();)n.__d && (l = r.length, i = void 0, t = void 0, f = (o = (u = n).__v).__e, (e = u.__P) && (i = [], (t = h({}, o)).__v = o.__v + 1, M(e, o, t, u.__n, void 0 !== e.ownerSVGElement, null != o.__h ? [\n        f\n    ] : null, i, null == f ? A(o) : f, o.__h), N(i, o), o.__e != f && P(o)), r.length > l && r.sort(function(n, l) {\n        return n.__v.__b - l.__v.__b;\n    }));\n    $.__r = 0;\n}\nfunction H(n, l, u, i, t, r, o, f, e, a) {\n    var h, v, y, d, k, b, g, m = i && i.__k || s, w = m.length;\n    for(u.__k = [], h = 0; h < l.length; h++)if (null != (d = u.__k[h] = null == (d = l[h]) || \"boolean\" == typeof d ? null : \"string\" == typeof d || \"number\" == typeof d || \"bigint\" == typeof d ? p(null, d, null, null, d) : Array.isArray(d) ? p(_, {\n        children: d\n    }, null, null, null) : d.__b > 0 ? p(d.type, d.props, d.key, d.ref ? d.ref : null, d.__v) : d)) {\n        if (d.__ = u, d.__b = u.__b + 1, null === (y = m[h]) || y && d.key == y.key && d.type === y.type) m[h] = void 0;\n        else for(v = 0; v < w; v++){\n            if ((y = m[v]) && d.key == y.key && d.type === y.type) {\n                m[v] = void 0;\n                break;\n            }\n            y = null;\n        }\n        M(n, d, y = y || c, t, r, o, f, e, a), k = d.__e, (v = d.ref) && y.ref != v && (g || (g = []), y.ref && g.push(y.ref, null, d), g.push(v, d.__c || k, d)), null != k ? (null == b && (b = k), \"function\" == typeof d.type && d.__k === y.__k ? d.__d = e = I(d, e, n) : e = z(n, d, y, m, k, e), \"function\" == typeof u.type && (u.__d = e)) : e && y.__e == e && e.parentNode != n && (e = A(y));\n    }\n    for(u.__e = b, h = w; h--;)null != m[h] && (\"function\" == typeof u.type && null != m[h].__e && m[h].__e == u.__d && (u.__d = L(i).nextSibling), q(m[h], m[h]));\n    if (g) for(h = 0; h < g.length; h++)S(g[h], g[++h], g[++h]);\n}\nfunction I(n, l, u) {\n    for(var i, t = n.__k, r = 0; t && r < t.length; r++)(i = t[r]) && (i.__ = n, l = \"function\" == typeof i.type ? I(i, l, u) : z(u, i, i, t, i.__e, l));\n    return l;\n}\nfunction j(n, l) {\n    return l = l || [], null == n || \"boolean\" == typeof n || (Array.isArray(n) ? n.some(function(n) {\n        j(n, l);\n    }) : l.push(n)), l;\n}\nfunction z(n, l, u, i, t, r) {\n    var o, f, e;\n    if (void 0 !== l.__d) o = l.__d, l.__d = void 0;\n    else if (null == u || t != r || null == t.parentNode) n: if (null == r || r.parentNode !== n) n.appendChild(t), o = null;\n    else {\n        for(f = r, e = 0; (f = f.nextSibling) && e < i.length; e += 1)if (f == t) break n;\n        n.insertBefore(t, r), o = r;\n    }\n    return void 0 !== o ? o : t.nextSibling;\n}\nfunction L(n) {\n    var l, u, i;\n    if (null == n.type || \"string\" == typeof n.type) return n.__e;\n    if (n.__k) {\n        for(l = n.__k.length - 1; l >= 0; l--)if ((u = n.__k[l]) && (i = L(u))) return i;\n    }\n    return null;\n}\nfunction M(n, u, i, t, r, o, f, e, c) {\n    var s, a, v, y, p, d, k, b, g, m, w, A, P, C, T, $ = u.type;\n    if (void 0 !== u.constructor) return null;\n    null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, o = [\n        e\n    ]), (s = l.__b) && s(u);\n    try {\n        n: if (\"function\" == typeof $) {\n            if (b = u.props, g = (s = $.contextType) && t[s.__c], m = s ? g ? g.props.value : s.__ : t, i.__c ? k = (a = u.__c = i.__c).__ = a.__E : (\"prototype\" in $ && $.prototype.render ? u.__c = a = new $(b, m) : (u.__c = a = new x(b, m), a.constructor = $, a.render = B), g && g.sub(a), a.props = b, a.state || (a.state = {}), a.context = m, a.__n = t, v = a.__d = !0, a.__h = [], a._sb = []), null == a.__s && (a.__s = a.state), null != $.getDerivedStateFromProps && (a.__s == a.state && (a.__s = h({}, a.__s)), h(a.__s, $.getDerivedStateFromProps(b, a.__s))), y = a.props, p = a.state, a.__v = u, v) null == $.getDerivedStateFromProps && null != a.componentWillMount && a.componentWillMount(), null != a.componentDidMount && a.__h.push(a.componentDidMount);\n            else {\n                if (null == $.getDerivedStateFromProps && b !== y && null != a.componentWillReceiveProps && a.componentWillReceiveProps(b, m), !a.__e && null != a.shouldComponentUpdate && !1 === a.shouldComponentUpdate(b, a.__s, m) || u.__v === i.__v) {\n                    for(u.__v !== i.__v && (a.props = b, a.state = a.__s, a.__d = !1), u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function(n) {\n                        n && (n.__ = u);\n                    }), w = 0; w < a._sb.length; w++)a.__h.push(a._sb[w]);\n                    a._sb = [], a.__h.length && f.push(a);\n                    break n;\n                }\n                null != a.componentWillUpdate && a.componentWillUpdate(b, a.__s, m), null != a.componentDidUpdate && a.__h.push(function() {\n                    a.componentDidUpdate(y, p, d);\n                });\n            }\n            if (a.context = m, a.props = b, a.__P = n, A = l.__r, P = 0, \"prototype\" in $ && $.prototype.render) {\n                for(a.state = a.__s, a.__d = !1, A && A(u), s = a.render(a.props, a.state, a.context), C = 0; C < a._sb.length; C++)a.__h.push(a._sb[C]);\n                a._sb = [];\n            } else do {\n                a.__d = !1, A && A(u), s = a.render(a.props, a.state, a.context), a.state = a.__s;\n            }while (a.__d && ++P < 25);\n            a.state = a.__s, null != a.getChildContext && (t = h(h({}, t), a.getChildContext())), v || null == a.getSnapshotBeforeUpdate || (d = a.getSnapshotBeforeUpdate(y, p)), T = null != s && s.type === _ && null == s.key ? s.props.children : s, H(n, Array.isArray(T) ? T : [\n                T\n            ], u, i, t, r, o, f, e, c), a.base = u.__e, u.__h = null, a.__h.length && f.push(a), k && (a.__E = a.__ = null), a.__e = !1;\n        } else null == o && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = O(i.__e, u, i, t, r, o, f, c);\n        (s = l.diffed) && s(u);\n    } catch (n) {\n        u.__v = null, (c || null != o) && (u.__e = e, u.__h = !!c, o[o.indexOf(e)] = null), l.__e(n, u, i);\n    }\n}\nfunction N(n, u) {\n    l.__c && l.__c(u, n), n.some(function(u) {\n        try {\n            n = u.__h, u.__h = [], n.some(function(n) {\n                n.call(u);\n            });\n        } catch (n) {\n            l.__e(n, u.__v);\n        }\n    });\n}\nfunction O(l, u, i, t, r, o, f, e) {\n    var s, a, h, y = i.props, p = u.props, d = u.type, _ = 0;\n    if (\"svg\" === d && (r = !0), null != o) {\n        for(; _ < o.length; _++)if ((s = o[_]) && \"setAttribute\" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {\n            l = s, o[_] = null;\n            break;\n        }\n    }\n    if (null == l) {\n        if (null === d) return document.createTextNode(p);\n        l = r ? document.createElementNS(\"http://www.w3.org/2000/svg\", d) : document.createElement(d, p.is && p), o = null, e = !1;\n    }\n    if (null === d) y === p || e && l.data === p || (l.data = p);\n    else {\n        if (o = o && n.call(l.childNodes), a = (y = i.props || c).dangerouslySetInnerHTML, h = p.dangerouslySetInnerHTML, !e) {\n            if (null != o) for(y = {}, _ = 0; _ < l.attributes.length; _++)y[l.attributes[_].name] = l.attributes[_].value;\n            (h || a) && (h && (a && h.__html == a.__html || h.__html === l.innerHTML) || (l.innerHTML = h && h.__html || \"\"));\n        }\n        if (k(l, p, y, r, e), h) u.__k = [];\n        else if (_ = u.props.children, H(l, Array.isArray(_) ? _ : [\n            _\n        ], u, i, t, r && \"foreignObject\" !== d, o, f, o ? o[0] : i.__k && A(i, 0), e), null != o) for(_ = o.length; _--;)null != o[_] && v(o[_]);\n        e || (\"value\" in p && void 0 !== (_ = p.value) && (_ !== l.value || \"progress\" === d && !_ || \"option\" === d && _ !== y.value) && g(l, \"value\", _, y.value, !1), \"checked\" in p && void 0 !== (_ = p.checked) && _ !== l.checked && g(l, \"checked\", _, y.checked, !1));\n    }\n    return l;\n}\nfunction S(n, u, i) {\n    try {\n        \"function\" == typeof n ? n(u) : n.current = u;\n    } catch (n) {\n        l.__e(n, i);\n    }\n}\nfunction q(n, u, i) {\n    var t, r;\n    if (l.unmount && l.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || S(t, null, u)), null != (t = n.__c)) {\n        if (t.componentWillUnmount) try {\n            t.componentWillUnmount();\n        } catch (n) {\n            l.__e(n, u);\n        }\n        t.base = t.__P = null, n.__c = void 0;\n    }\n    if (t = n.__k) for(r = 0; r < t.length; r++)t[r] && q(t[r], u, i || \"function\" != typeof n.type);\n    i || null == n.__e || v(n.__e), n.__ = n.__e = n.__d = void 0;\n}\nfunction B(n, l, u) {\n    return this.constructor(n, u);\n}\nfunction D(u, i, t) {\n    var r, o, f;\n    l.__ && l.__(u, i), o = (r = \"function\" == typeof t) ? null : t && t.__k || i.__k, f = [], M(i, u = (!r && t || i).__k = y(_, null, [\n        u\n    ]), o || c, c, void 0 !== i.ownerSVGElement, !r && t ? [\n        t\n    ] : o ? null : i.firstChild ? n.call(i.childNodes) : null, f, !r && t ? t : o ? o.__e : i.firstChild, r), N(f, u);\n}\nfunction E(n, l) {\n    D(n, l, E);\n}\nfunction F(l, u, i) {\n    var t, r, o, f = h({}, l.props);\n    for(o in u)\"key\" == o ? t = u[o] : \"ref\" == o ? r = u[o] : f[o] = u[o];\n    return arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), p(l.type, f, t || l.key, r || l.ref, null);\n}\nfunction G(n, l) {\n    var u = {\n        __c: l = \"__cC\" + e++,\n        __: n,\n        Consumer: function(n, l) {\n            return n.children(l);\n        },\n        Provider: function(n) {\n            var u, i;\n            return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function() {\n                return i;\n            }, this.shouldComponentUpdate = function(n) {\n                this.props.value !== n.value && u.some(function(n) {\n                    n.__e = !0, T(n);\n                });\n            }, this.sub = function(n) {\n                u.push(n);\n                var l = n.componentWillUnmount;\n                n.componentWillUnmount = function() {\n                    u.splice(u.indexOf(n), 1), l && l.call(n);\n                };\n            }), n.children;\n        }\n    };\n    return u.Provider.__ = u.Consumer.contextType = u;\n}\nn = s.slice, l = {\n    __e: function(n, l, u, i) {\n        for(var t, r, o; l = l.__;)if ((t = l.__c) && !t.__) try {\n            if ((r = t.constructor) && null != r.getDerivedStateFromError && (t.setState(r.getDerivedStateFromError(n)), o = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), o = t.__d), o) return t.__E = t;\n        } catch (l) {\n            n = l;\n        }\n        throw n;\n    }\n}, u = 0, i = function(n) {\n    return null != n && void 0 === n.constructor;\n}, t = !1, x.prototype.setState = function(n, l) {\n    var u;\n    u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = h({}, this.state), \"function\" == typeof n && (n = n(h({}, u), this.props)), n && h(u, n), null != n && this.__v && (l && this._sb.push(l), T(this));\n}, x.prototype.forceUpdate = function(n) {\n    this.__v && (this.__e = !0, n && this.__h.push(n), T(this));\n}, x.prototype.render = _, r = [], f = \"function\" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, $.__r = 0, e = 0;\n //# sourceMappingURL=preact.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3QvZGlzdC9wcmVhY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLEdBQUVDLEdBQUVDLEdBQUVDLEdBQUVDLEdBQUVDLEdBQUVDLEdBQUVDLEdBQUVDLEdBQUVDLElBQUUsQ0FBQyxHQUFFQyxJQUFFLEVBQUUsRUFBQ0MsSUFBRTtBQUFvRSxTQUFTQyxFQUFFWixDQUFDLEVBQUNDLENBQUM7SUFBRSxJQUFJLElBQUlDLEtBQUtELEVBQUVELENBQUMsQ0FBQ0UsRUFBRSxHQUFDRCxDQUFDLENBQUNDLEVBQUU7SUFBQyxPQUFPRjtBQUFDO0FBQUMsU0FBU2EsRUFBRWIsQ0FBQztJQUFFLElBQUlDLElBQUVELEVBQUVjLFVBQVU7SUFBQ2IsS0FBR0EsRUFBRWMsV0FBVyxDQUFDZjtBQUFFO0FBQUMsU0FBU2dCLEVBQUVmLENBQUMsRUFBQ0MsQ0FBQyxFQUFDQyxDQUFDO0lBQUUsSUFBSUMsR0FBRUMsR0FBRUMsR0FBRUMsSUFBRSxDQUFDO0lBQUUsSUFBSUQsS0FBS0osRUFBRSxTQUFPSSxJQUFFRixJQUFFRixDQUFDLENBQUNJLEVBQUUsR0FBQyxTQUFPQSxJQUFFRCxJQUFFSCxDQUFDLENBQUNJLEVBQUUsR0FBQ0MsQ0FBQyxDQUFDRCxFQUFFLEdBQUNKLENBQUMsQ0FBQ0ksRUFBRTtJQUFDLElBQUdXLFVBQVVDLE1BQU0sR0FBQyxLQUFJWCxDQUFBQSxFQUFFWSxRQUFRLEdBQUNGLFVBQVVDLE1BQU0sR0FBQyxJQUFFbEIsRUFBRW9CLElBQUksQ0FBQ0gsV0FBVSxLQUFHZCxDQUFBQSxHQUFHLGNBQVksT0FBT0YsS0FBRyxRQUFNQSxFQUFFb0IsWUFBWSxFQUFDLElBQUlmLEtBQUtMLEVBQUVvQixZQUFZLENBQUMsS0FBSyxNQUFJZCxDQUFDLENBQUNELEVBQUUsSUFBR0MsQ0FBQUEsQ0FBQyxDQUFDRCxFQUFFLEdBQUNMLEVB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LElBQUcsS0FBSSxDQUFDTCxHQUFHLEdBQUMsQ0FBQyxHQUFFOUIsS0FBRyxJQUFJLENBQUNpQyxHQUFHLENBQUNpQyxJQUFJLENBQUNsRSxJQUFHaUUsRUFBRSxJQUFJO0FBQUUsR0FBRVAsRUFBRW1DLFNBQVMsQ0FBQ0MsTUFBTSxHQUFDdkQsR0FBRWxDLElBQUUsRUFBRSxFQUFDRSxJQUFFLGNBQVksT0FBT3NJLFVBQVFBLFFBQVFoRCxTQUFTLENBQUNpRCxJQUFJLENBQUNDLElBQUksQ0FBQ0YsUUFBUUcsT0FBTyxNQUFJaEYsWUFBV0csRUFBRUMsR0FBRyxHQUFDLEdBQUU1RCxJQUFFO0FBQWlNLENBQzM3VSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9kaXN0L3ByZWFjdC5tanM/MGRmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbixsLHUsaSx0LHIsbyxmLGUsYz17fSxzPVtdLGE9L2FjaXR8ZXgoPzpzfGd8bnxwfCQpfHJwaHxncmlkfG93c3xtbmN8bnR3fGluZVtjaF18em9vfF5vcmR8aXRlcmEvaTtmdW5jdGlvbiBoKG4sbCl7Zm9yKHZhciB1IGluIGwpblt1XT1sW3VdO3JldHVybiBufWZ1bmN0aW9uIHYobil7dmFyIGw9bi5wYXJlbnROb2RlO2wmJmwucmVtb3ZlQ2hpbGQobil9ZnVuY3Rpb24geShsLHUsaSl7dmFyIHQscixvLGY9e307Zm9yKG8gaW4gdSlcImtleVwiPT1vP3Q9dVtvXTpcInJlZlwiPT1vP3I9dVtvXTpmW29dPXVbb107aWYoYXJndW1lbnRzLmxlbmd0aD4yJiYoZi5jaGlsZHJlbj1hcmd1bWVudHMubGVuZ3RoPjM/bi5jYWxsKGFyZ3VtZW50cywyKTppKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBsJiZudWxsIT1sLmRlZmF1bHRQcm9wcylmb3IobyBpbiBsLmRlZmF1bHRQcm9wcyl2b2lkIDA9PT1mW29dJiYoZltvXT1sLmRlZmF1bHRQcm9wc1tvXSk7cmV0dXJuIHAobCxmLHQscixudWxsKX1mdW5jdGlvbiBwKG4saSx0LHIsbyl7dmFyIGY9e3R5cGU6bixwcm9wczppLGtleTp0LHJlZjpyLF9fazpudWxsLF9fOm51bGwsX19iOjAsX19lOm51bGwsX19kOnZvaWQgMCxfX2M6bnVsbCxfX2g6bnVsbCxjb25zdHJ1Y3Rvcjp2b2lkIDAsX192Om51bGw9PW8/Kyt1Om99O3JldHVybiBudWxsPT1vJiZudWxsIT1sLnZub2RlJiZsLnZub2RlKGYpLGZ9ZnVuY3Rpb24gZCgpe3JldHVybntjdXJyZW50Om51bGx9fWZ1bmN0aW9uIF8obil7cmV0dXJuIG4uY2hpbGRyZW59ZnVuY3Rpb24gayhuLGwsdSxpLHQpe3ZhciByO2ZvcihyIGluIHUpXCJjaGlsZHJlblwiPT09cnx8XCJrZXlcIj09PXJ8fHIgaW4gbHx8ZyhuLHIsbnVsbCx1W3JdLGkpO2ZvcihyIGluIGwpdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgbFtyXXx8XCJjaGlsZHJlblwiPT09cnx8XCJrZXlcIj09PXJ8fFwidmFsdWVcIj09PXJ8fFwiY2hlY2tlZFwiPT09cnx8dVtyXT09PWxbcl18fGcobixyLGxbcl0sdVtyXSxpKX1mdW5jdGlvbiBiKG4sbCx1KXtcIi1cIj09PWxbMF0/bi5zZXRQcm9wZXJ0eShsLG51bGw9PXU/XCJcIjp1KTpuW2xdPW51bGw9PXU/XCJcIjpcIm51bWJlclwiIT10eXBlb2YgdXx8YS50ZXN0KGwpP3U6dStcInB4XCJ9ZnVuY3Rpb24gZyhuLGwsdSxpLHQpe3ZhciByO246aWYoXCJzdHlsZVwiPT09bClpZihcInN0cmluZ1wiPT10eXBlb2YgdSluLnN0eWxlLmNzc1RleHQ9dTtlbHNle2lmKFwic3RyaW5nXCI9PXR5cGVvZiBpJiYobi5zdHlsZS5jc3NUZXh0PWk9XCJcIiksaSlmb3IobCBpbiBpKXUmJmwgaW4gdXx8YihuLnN0eWxlLGwsXCJcIik7aWYodSlmb3IobCBpbiB1KWkmJnVbbF09PT1pW2xdfHxiKG4uc3R5bGUsbCx1W2xdKX1lbHNlIGlmKFwib1wiPT09bFswXSYmXCJuXCI9PT1sWzFdKXI9bCE9PShsPWwucmVwbGFjZSgvQ2FwdHVyZSQvLFwiXCIpKSxsPWwudG9Mb3dlckNhc2UoKWluIG4/bC50b0xvd2VyQ2FzZSgpLnNsaWNlKDIpOmwuc2xpY2UoMiksbi5sfHwobi5sPXt9KSxuLmxbbCtyXT11LHU/aXx8bi5hZGRFdmVudExpc3RlbmVyKGwscj93Om0scik6bi5yZW1vdmVFdmVudExpc3RlbmVyKGwscj93Om0scik7ZWxzZSBpZihcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIhPT1sKXtpZih0KWw9bC5yZXBsYWNlKC94bGluayhIfDpoKS8sXCJoXCIpLnJlcGxhY2UoL3NOYW1lJC8sXCJzXCIpO2Vsc2UgaWYoXCJ3aWR0aFwiIT09bCYmXCJoZWlnaHRcIiE9PWwmJlwiaHJlZlwiIT09bCYmXCJsaXN0XCIhPT1sJiZcImZvcm1cIiE9PWwmJlwidGFiSW5kZXhcIiE9PWwmJlwiZG93bmxvYWRcIiE9PWwmJmwgaW4gbil0cnl7bltsXT1udWxsPT11P1wiXCI6dTticmVhayBufWNhdGNoKG4pe31cImZ1bmN0aW9uXCI9PXR5cGVvZiB1fHwobnVsbD09dXx8ITE9PT11JiYtMT09bC5pbmRleE9mKFwiLVwiKT9uLnJlbW92ZUF0dHJpYnV0ZShsKTpuLnNldEF0dHJpYnV0ZShsLHUpKX19ZnVuY3Rpb24gbShuKXt0PSEwO3RyeXtyZXR1cm4gdGhpcy5sW24udHlwZSshMV0obC5ldmVudD9sLmV2ZW50KG4pOm4pfWZpbmFsbHl7dD0hMX19ZnVuY3Rpb24gdyhuKXt0PSEwO3RyeXtyZXR1cm4gdGhpcy5sW24udHlwZSshMF0obC5ldmVudD9sLmV2ZW50KG4pOm4pfWZpbmFsbHl7dD0hMX19ZnVuY3Rpb24geChuLGwpe3RoaXMucHJvcHM9bix0aGlzLmNvbnRleHQ9bH1mdW5jdGlvbiBBKG4sbCl7aWYobnVsbD09bClyZXR1cm4gbi5fXz9BKG4uX18sbi5fXy5fX2suaW5kZXhPZihuKSsxKTpudWxsO2Zvcih2YXIgdTtsPG4uX19rLmxlbmd0aDtsKyspaWYobnVsbCE9KHU9bi5fX2tbbF0pJiZudWxsIT11Ll9fZSlyZXR1cm4gdS5fX2U7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2Ygbi50eXBlP0Eobik6bnVsbH1mdW5jdGlvbiBQKG4pe3ZhciBsLHU7aWYobnVsbCE9KG49bi5fXykmJm51bGwhPW4uX19jKXtmb3Iobi5fX2U9bi5fX2MuYmFzZT1udWxsLGw9MDtsPG4uX19rLmxlbmd0aDtsKyspaWYobnVsbCE9KHU9bi5fX2tbbF0pJiZudWxsIT11Ll9fZSl7bi5fX2U9bi5fX2MuYmFzZT11Ll9fZTticmVha31yZXR1cm4gUChuKX19ZnVuY3Rpb24gQyhuKXt0P3NldFRpbWVvdXQobik6ZihuKX1mdW5jdGlvbiBUKG4peyghbi5fX2QmJihuLl9fZD0hMCkmJnIucHVzaChuKSYmISQuX19yKyt8fG8hPT1sLmRlYm91bmNlUmVuZGVyaW5nKSYmKChvPWwuZGVib3VuY2VSZW5kZXJpbmcpfHxDKSgkKX1mdW5jdGlvbiAkKCl7dmFyIG4sbCx1LGksdCxvLGYsZTtmb3Ioci5zb3J0KGZ1bmN0aW9uKG4sbCl7cmV0dXJuIG4uX192Ll9fYi1sLl9fdi5fX2J9KTtuPXIuc2hpZnQoKTspbi5fX2QmJihsPXIubGVuZ3RoLGk9dm9pZCAwLHQ9dm9pZCAwLGY9KG89KHU9bikuX192KS5fX2UsKGU9dS5fX1ApJiYoaT1bXSwodD1oKHt9LG8pKS5fX3Y9by5fX3YrMSxNKGUsbyx0LHUuX19uLHZvaWQgMCE9PWUub3duZXJTVkdFbGVtZW50LG51bGwhPW8uX19oP1tmXTpudWxsLGksbnVsbD09Zj9BKG8pOmYsby5fX2gpLE4oaSxvKSxvLl9fZSE9ZiYmUChvKSksci5sZW5ndGg+bCYmci5zb3J0KGZ1bmN0aW9uKG4sbCl7cmV0dXJuIG4uX192Ll9fYi1sLl9fdi5fX2J9KSk7JC5fX3I9MH1mdW5jdGlvbiBIKG4sbCx1LGksdCxyLG8sZixlLGEpe3ZhciBoLHYseSxkLGssYixnLG09aSYmaS5fX2t8fHMsdz1tLmxlbmd0aDtmb3IodS5fX2s9W10saD0wO2g8bC5sZW5ndGg7aCsrKWlmKG51bGwhPShkPXUuX19rW2hdPW51bGw9PShkPWxbaF0pfHxcImJvb2xlYW5cIj09dHlwZW9mIGQ/bnVsbDpcInN0cmluZ1wiPT10eXBlb2YgZHx8XCJudW1iZXJcIj09dHlwZW9mIGR8fFwiYmlnaW50XCI9PXR5cGVvZiBkP3AobnVsbCxkLG51bGwsbnVsbCxkKTpBcnJheS5pc0FycmF5KGQpP3AoXyx7Y2hpbGRyZW46ZH0sbnVsbCxudWxsLG51bGwpOmQuX19iPjA/cChkLnR5cGUsZC5wcm9wcyxkLmtleSxkLnJlZj9kLnJlZjpudWxsLGQuX192KTpkKSl7aWYoZC5fXz11LGQuX19iPXUuX19iKzEsbnVsbD09PSh5PW1baF0pfHx5JiZkLmtleT09eS5rZXkmJmQudHlwZT09PXkudHlwZSltW2hdPXZvaWQgMDtlbHNlIGZvcih2PTA7djx3O3YrKyl7aWYoKHk9bVt2XSkmJmQua2V5PT15LmtleSYmZC50eXBlPT09eS50eXBlKXttW3ZdPXZvaWQgMDticmVha315PW51bGx9TShuLGQseT15fHxjLHQscixvLGYsZSxhKSxrPWQuX19lLCh2PWQucmVmKSYmeS5yZWYhPXYmJihnfHwoZz1bXSkseS5yZWYmJmcucHVzaCh5LnJlZixudWxsLGQpLGcucHVzaCh2LGQuX19jfHxrLGQpKSxudWxsIT1rPyhudWxsPT1iJiYoYj1rKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBkLnR5cGUmJmQuX19rPT09eS5fX2s/ZC5fX2Q9ZT1JKGQsZSxuKTplPXoobixkLHksbSxrLGUpLFwiZnVuY3Rpb25cIj09dHlwZW9mIHUudHlwZSYmKHUuX19kPWUpKTplJiZ5Ll9fZT09ZSYmZS5wYXJlbnROb2RlIT1uJiYoZT1BKHkpKX1mb3IodS5fX2U9YixoPXc7aC0tOyludWxsIT1tW2hdJiYoXCJmdW5jdGlvblwiPT10eXBlb2YgdS50eXBlJiZudWxsIT1tW2hdLl9fZSYmbVtoXS5fX2U9PXUuX19kJiYodS5fX2Q9TChpKS5uZXh0U2libGluZykscShtW2hdLG1baF0pKTtpZihnKWZvcihoPTA7aDxnLmxlbmd0aDtoKyspUyhnW2hdLGdbKytoXSxnWysraF0pfWZ1bmN0aW9uIEkobixsLHUpe2Zvcih2YXIgaSx0PW4uX19rLHI9MDt0JiZyPHQubGVuZ3RoO3IrKykoaT10W3JdKSYmKGkuX189bixsPVwiZnVuY3Rpb25cIj09dHlwZW9mIGkudHlwZT9JKGksbCx1KTp6KHUsaSxpLHQsaS5fX2UsbCkpO3JldHVybiBsfWZ1bmN0aW9uIGoobixsKXtyZXR1cm4gbD1sfHxbXSxudWxsPT1ufHxcImJvb2xlYW5cIj09dHlwZW9mIG58fChBcnJheS5pc0FycmF5KG4pP24uc29tZShmdW5jdGlvbihuKXtqKG4sbCl9KTpsLnB1c2gobikpLGx9ZnVuY3Rpb24geihuLGwsdSxpLHQscil7dmFyIG8sZixlO2lmKHZvaWQgMCE9PWwuX19kKW89bC5fX2QsbC5fX2Q9dm9pZCAwO2Vsc2UgaWYobnVsbD09dXx8dCE9cnx8bnVsbD09dC5wYXJlbnROb2RlKW46aWYobnVsbD09cnx8ci5wYXJlbnROb2RlIT09biluLmFwcGVuZENoaWxkKHQpLG89bnVsbDtlbHNle2ZvcihmPXIsZT0wOyhmPWYubmV4dFNpYmxpbmcpJiZlPGkubGVuZ3RoO2UrPTEpaWYoZj09dClicmVhayBuO24uaW5zZXJ0QmVmb3JlKHQsciksbz1yfXJldHVybiB2b2lkIDAhPT1vP286dC5uZXh0U2libGluZ31mdW5jdGlvbiBMKG4pe3ZhciBsLHUsaTtpZihudWxsPT1uLnR5cGV8fFwic3RyaW5nXCI9PXR5cGVvZiBuLnR5cGUpcmV0dXJuIG4uX19lO2lmKG4uX19rKWZvcihsPW4uX19rLmxlbmd0aC0xO2w+PTA7bC0tKWlmKCh1PW4uX19rW2xdKSYmKGk9TCh1KSkpcmV0dXJuIGk7cmV0dXJuIG51bGx9ZnVuY3Rpb24gTShuLHUsaSx0LHIsbyxmLGUsYyl7dmFyIHMsYSx2LHkscCxkLGssYixnLG0sdyxBLFAsQyxULCQ9dS50eXBlO2lmKHZvaWQgMCE9PXUuY29uc3RydWN0b3IpcmV0dXJuIG51bGw7bnVsbCE9aS5fX2gmJihjPWkuX19oLGU9dS5fX2U9aS5fX2UsdS5fX2g9bnVsbCxvPVtlXSksKHM9bC5fX2IpJiZzKHUpO3RyeXtuOmlmKFwiZnVuY3Rpb25cIj09dHlwZW9mICQpe2lmKGI9dS5wcm9wcyxnPShzPSQuY29udGV4dFR5cGUpJiZ0W3MuX19jXSxtPXM/Zz9nLnByb3BzLnZhbHVlOnMuX186dCxpLl9fYz9rPShhPXUuX19jPWkuX19jKS5fXz1hLl9fRTooXCJwcm90b3R5cGVcImluICQmJiQucHJvdG90eXBlLnJlbmRlcj91Ll9fYz1hPW5ldyAkKGIsbSk6KHUuX19jPWE9bmV3IHgoYixtKSxhLmNvbnN0cnVjdG9yPSQsYS5yZW5kZXI9QiksZyYmZy5zdWIoYSksYS5wcm9wcz1iLGEuc3RhdGV8fChhLnN0YXRlPXt9KSxhLmNvbnRleHQ9bSxhLl9fbj10LHY9YS5fX2Q9ITAsYS5fX2g9W10sYS5fc2I9W10pLG51bGw9PWEuX19zJiYoYS5fX3M9YS5zdGF0ZSksbnVsbCE9JC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMmJihhLl9fcz09YS5zdGF0ZSYmKGEuX19zPWgoe30sYS5fX3MpKSxoKGEuX19zLCQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKGIsYS5fX3MpKSkseT1hLnByb3BzLHA9YS5zdGF0ZSxhLl9fdj11LHYpbnVsbD09JC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMmJm51bGwhPWEuY29tcG9uZW50V2lsbE1vdW50JiZhLmNvbXBvbmVudFdpbGxNb3VudCgpLG51bGwhPWEuY29tcG9uZW50RGlkTW91bnQmJmEuX19oLnB1c2goYS5jb21wb25lbnREaWRNb3VudCk7ZWxzZXtpZihudWxsPT0kLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyYmYiE9PXkmJm51bGwhPWEuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyYmYS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKGIsbSksIWEuX19lJiZudWxsIT1hLnNob3VsZENvbXBvbmVudFVwZGF0ZSYmITE9PT1hLnNob3VsZENvbXBvbmVudFVwZGF0ZShiLGEuX19zLG0pfHx1Ll9fdj09PWkuX192KXtmb3IodS5fX3YhPT1pLl9fdiYmKGEucHJvcHM9YixhLnN0YXRlPWEuX19zLGEuX19kPSExKSx1Ll9fZT1pLl9fZSx1Ll9faz1pLl9fayx1Ll9fay5mb3JFYWNoKGZ1bmN0aW9uKG4pe24mJihuLl9fPXUpfSksdz0wO3c8YS5fc2IubGVuZ3RoO3crKylhLl9faC5wdXNoKGEuX3NiW3ddKTthLl9zYj1bXSxhLl9faC5sZW5ndGgmJmYucHVzaChhKTticmVhayBufW51bGwhPWEuY29tcG9uZW50V2lsbFVwZGF0ZSYmYS5jb21wb25lbnRXaWxsVXBkYXRlKGIsYS5fX3MsbSksbnVsbCE9YS5jb21wb25lbnREaWRVcGRhdGUmJmEuX19oLnB1c2goZnVuY3Rpb24oKXthLmNvbXBvbmVudERpZFVwZGF0ZSh5LHAsZCl9KX1pZihhLmNvbnRleHQ9bSxhLnByb3BzPWIsYS5fX1A9bixBPWwuX19yLFA9MCxcInByb3RvdHlwZVwiaW4gJCYmJC5wcm90b3R5cGUucmVuZGVyKXtmb3IoYS5zdGF0ZT1hLl9fcyxhLl9fZD0hMSxBJiZBKHUpLHM9YS5yZW5kZXIoYS5wcm9wcyxhLnN0YXRlLGEuY29udGV4dCksQz0wO0M8YS5fc2IubGVuZ3RoO0MrKylhLl9faC5wdXNoKGEuX3NiW0NdKTthLl9zYj1bXX1lbHNlIGRve2EuX19kPSExLEEmJkEodSkscz1hLnJlbmRlcihhLnByb3BzLGEuc3RhdGUsYS5jb250ZXh0KSxhLnN0YXRlPWEuX19zfXdoaWxlKGEuX19kJiYrK1A8MjUpO2Euc3RhdGU9YS5fX3MsbnVsbCE9YS5nZXRDaGlsZENvbnRleHQmJih0PWgoaCh7fSx0KSxhLmdldENoaWxkQ29udGV4dCgpKSksdnx8bnVsbD09YS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8KGQ9YS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSh5LHApKSxUPW51bGwhPXMmJnMudHlwZT09PV8mJm51bGw9PXMua2V5P3MucHJvcHMuY2hpbGRyZW46cyxIKG4sQXJyYXkuaXNBcnJheShUKT9UOltUXSx1LGksdCxyLG8sZixlLGMpLGEuYmFzZT11Ll9fZSx1Ll9faD1udWxsLGEuX19oLmxlbmd0aCYmZi5wdXNoKGEpLGsmJihhLl9fRT1hLl9fPW51bGwpLGEuX19lPSExfWVsc2UgbnVsbD09byYmdS5fX3Y9PT1pLl9fdj8odS5fX2s9aS5fX2ssdS5fX2U9aS5fX2UpOnUuX19lPU8oaS5fX2UsdSxpLHQscixvLGYsYyk7KHM9bC5kaWZmZWQpJiZzKHUpfWNhdGNoKG4pe3UuX192PW51bGwsKGN8fG51bGwhPW8pJiYodS5fX2U9ZSx1Ll9faD0hIWMsb1tvLmluZGV4T2YoZSldPW51bGwpLGwuX19lKG4sdSxpKX19ZnVuY3Rpb24gTihuLHUpe2wuX19jJiZsLl9fYyh1LG4pLG4uc29tZShmdW5jdGlvbih1KXt0cnl7bj11Ll9faCx1Ll9faD1bXSxuLnNvbWUoZnVuY3Rpb24obil7bi5jYWxsKHUpfSl9Y2F0Y2gobil7bC5fX2Uobix1Ll9fdil9fSl9ZnVuY3Rpb24gTyhsLHUsaSx0LHIsbyxmLGUpe3ZhciBzLGEsaCx5PWkucHJvcHMscD11LnByb3BzLGQ9dS50eXBlLF89MDtpZihcInN2Z1wiPT09ZCYmKHI9ITApLG51bGwhPW8pZm9yKDtfPG8ubGVuZ3RoO18rKylpZigocz1vW19dKSYmXCJzZXRBdHRyaWJ1dGVcImluIHM9PSEhZCYmKGQ/cy5sb2NhbE5hbWU9PT1kOjM9PT1zLm5vZGVUeXBlKSl7bD1zLG9bX109bnVsbDticmVha31pZihudWxsPT1sKXtpZihudWxsPT09ZClyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocCk7bD1yP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsZCk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChkLHAuaXMmJnApLG89bnVsbCxlPSExfWlmKG51bGw9PT1kKXk9PT1wfHxlJiZsLmRhdGE9PT1wfHwobC5kYXRhPXApO2Vsc2V7aWYobz1vJiZuLmNhbGwobC5jaGlsZE5vZGVzKSxhPSh5PWkucHJvcHN8fGMpLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLGg9cC5kYW5nZXJvdXNseVNldElubmVySFRNTCwhZSl7aWYobnVsbCE9bylmb3IoeT17fSxfPTA7XzxsLmF0dHJpYnV0ZXMubGVuZ3RoO18rKyl5W2wuYXR0cmlidXRlc1tfXS5uYW1lXT1sLmF0dHJpYnV0ZXNbX10udmFsdWU7KGh8fGEpJiYoaCYmKGEmJmguX19odG1sPT1hLl9faHRtbHx8aC5fX2h0bWw9PT1sLmlubmVySFRNTCl8fChsLmlubmVySFRNTD1oJiZoLl9faHRtbHx8XCJcIikpfWlmKGsobCxwLHkscixlKSxoKXUuX19rPVtdO2Vsc2UgaWYoXz11LnByb3BzLmNoaWxkcmVuLEgobCxBcnJheS5pc0FycmF5KF8pP186W19dLHUsaSx0LHImJlwiZm9yZWlnbk9iamVjdFwiIT09ZCxvLGYsbz9vWzBdOmkuX19rJiZBKGksMCksZSksbnVsbCE9bylmb3IoXz1vLmxlbmd0aDtfLS07KW51bGwhPW9bX10mJnYob1tfXSk7ZXx8KFwidmFsdWVcImluIHAmJnZvaWQgMCE9PShfPXAudmFsdWUpJiYoXyE9PWwudmFsdWV8fFwicHJvZ3Jlc3NcIj09PWQmJiFffHxcIm9wdGlvblwiPT09ZCYmXyE9PXkudmFsdWUpJiZnKGwsXCJ2YWx1ZVwiLF8seS52YWx1ZSwhMSksXCJjaGVja2VkXCJpbiBwJiZ2b2lkIDAhPT0oXz1wLmNoZWNrZWQpJiZfIT09bC5jaGVja2VkJiZnKGwsXCJjaGVja2VkXCIsXyx5LmNoZWNrZWQsITEpKX1yZXR1cm4gbH1mdW5jdGlvbiBTKG4sdSxpKXt0cnl7XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uKHUpOm4uY3VycmVudD11fWNhdGNoKG4pe2wuX19lKG4saSl9fWZ1bmN0aW9uIHEobix1LGkpe3ZhciB0LHI7aWYobC51bm1vdW50JiZsLnVubW91bnQobiksKHQ9bi5yZWYpJiYodC5jdXJyZW50JiZ0LmN1cnJlbnQhPT1uLl9fZXx8Uyh0LG51bGwsdSkpLG51bGwhPSh0PW4uX19jKSl7aWYodC5jb21wb25lbnRXaWxsVW5tb3VudCl0cnl7dC5jb21wb25lbnRXaWxsVW5tb3VudCgpfWNhdGNoKG4pe2wuX19lKG4sdSl9dC5iYXNlPXQuX19QPW51bGwsbi5fX2M9dm9pZCAwfWlmKHQ9bi5fX2spZm9yKHI9MDtyPHQubGVuZ3RoO3IrKyl0W3JdJiZxKHRbcl0sdSxpfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBuLnR5cGUpO2l8fG51bGw9PW4uX19lfHx2KG4uX19lKSxuLl9fPW4uX19lPW4uX19kPXZvaWQgMH1mdW5jdGlvbiBCKG4sbCx1KXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvcihuLHUpfWZ1bmN0aW9uIEQodSxpLHQpe3ZhciByLG8sZjtsLl9fJiZsLl9fKHUsaSksbz0ocj1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0KT9udWxsOnQmJnQuX19rfHxpLl9fayxmPVtdLE0oaSx1PSghciYmdHx8aSkuX19rPXkoXyxudWxsLFt1XSksb3x8YyxjLHZvaWQgMCE9PWkub3duZXJTVkdFbGVtZW50LCFyJiZ0P1t0XTpvP251bGw6aS5maXJzdENoaWxkP24uY2FsbChpLmNoaWxkTm9kZXMpOm51bGwsZiwhciYmdD90Om8/by5fX2U6aS5maXJzdENoaWxkLHIpLE4oZix1KX1mdW5jdGlvbiBFKG4sbCl7RChuLGwsRSl9ZnVuY3Rpb24gRihsLHUsaSl7dmFyIHQscixvLGY9aCh7fSxsLnByb3BzKTtmb3IobyBpbiB1KVwia2V5XCI9PW8/dD11W29dOlwicmVmXCI9PW8/cj11W29dOmZbb109dVtvXTtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD4yJiYoZi5jaGlsZHJlbj1hcmd1bWVudHMubGVuZ3RoPjM/bi5jYWxsKGFyZ3VtZW50cywyKTppKSxwKGwudHlwZSxmLHR8fGwua2V5LHJ8fGwucmVmLG51bGwpfWZ1bmN0aW9uIEcobixsKXt2YXIgdT17X19jOmw9XCJfX2NDXCIrZSsrLF9fOm4sQ29uc3VtZXI6ZnVuY3Rpb24obixsKXtyZXR1cm4gbi5jaGlsZHJlbihsKX0sUHJvdmlkZXI6ZnVuY3Rpb24obil7dmFyIHUsaTtyZXR1cm4gdGhpcy5nZXRDaGlsZENvbnRleHR8fCh1PVtdLChpPXt9KVtsXT10aGlzLHRoaXMuZ2V0Q2hpbGRDb250ZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIGl9LHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlPWZ1bmN0aW9uKG4pe3RoaXMucHJvcHMudmFsdWUhPT1uLnZhbHVlJiZ1LnNvbWUoZnVuY3Rpb24obil7bi5fX2U9ITAsVChuKX0pfSx0aGlzLnN1Yj1mdW5jdGlvbihuKXt1LnB1c2gobik7dmFyIGw9bi5jb21wb25lbnRXaWxsVW5tb3VudDtuLmNvbXBvbmVudFdpbGxVbm1vdW50PWZ1bmN0aW9uKCl7dS5zcGxpY2UodS5pbmRleE9mKG4pLDEpLGwmJmwuY2FsbChuKX19KSxuLmNoaWxkcmVufX07cmV0dXJuIHUuUHJvdmlkZXIuX189dS5Db25zdW1lci5jb250ZXh0VHlwZT11fW49cy5zbGljZSxsPXtfX2U6ZnVuY3Rpb24obixsLHUsaSl7Zm9yKHZhciB0LHIsbztsPWwuX187KWlmKCh0PWwuX19jKSYmIXQuX18pdHJ5e2lmKChyPXQuY29uc3RydWN0b3IpJiZudWxsIT1yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciYmKHQuc2V0U3RhdGUoci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IobikpLG89dC5fX2QpLG51bGwhPXQuY29tcG9uZW50RGlkQ2F0Y2gmJih0LmNvbXBvbmVudERpZENhdGNoKG4saXx8e30pLG89dC5fX2QpLG8pcmV0dXJuIHQuX19FPXR9Y2F0Y2gobCl7bj1sfXRocm93IG59fSx1PTAsaT1mdW5jdGlvbihuKXtyZXR1cm4gbnVsbCE9biYmdm9pZCAwPT09bi5jb25zdHJ1Y3Rvcn0sdD0hMSx4LnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihuLGwpe3ZhciB1O3U9bnVsbCE9dGhpcy5fX3MmJnRoaXMuX19zIT09dGhpcy5zdGF0ZT90aGlzLl9fczp0aGlzLl9fcz1oKHt9LHRoaXMuc3RhdGUpLFwiZnVuY3Rpb25cIj09dHlwZW9mIG4mJihuPW4oaCh7fSx1KSx0aGlzLnByb3BzKSksbiYmaCh1LG4pLG51bGwhPW4mJnRoaXMuX192JiYobCYmdGhpcy5fc2IucHVzaChsKSxUKHRoaXMpKX0seC5wcm90b3R5cGUuZm9yY2VVcGRhdGU9ZnVuY3Rpb24obil7dGhpcy5fX3YmJih0aGlzLl9fZT0hMCxuJiZ0aGlzLl9faC5wdXNoKG4pLFQodGhpcykpfSx4LnByb3RvdHlwZS5yZW5kZXI9XyxyPVtdLGY9XCJmdW5jdGlvblwiPT10eXBlb2YgUHJvbWlzZT9Qcm9taXNlLnByb3RvdHlwZS50aGVuLmJpbmQoUHJvbWlzZS5yZXNvbHZlKCkpOnNldFRpbWVvdXQsJC5fX3I9MCxlPTA7ZXhwb3J0e3ggYXMgQ29tcG9uZW50LF8gYXMgRnJhZ21lbnQsRiBhcyBjbG9uZUVsZW1lbnQsRyBhcyBjcmVhdGVDb250ZXh0LHkgYXMgY3JlYXRlRWxlbWVudCxkIGFzIGNyZWF0ZVJlZix5IGFzIGgsRSBhcyBoeWRyYXRlLGkgYXMgaXNWYWxpZEVsZW1lbnQsbCBhcyBvcHRpb25zLEQgYXMgcmVuZGVyLGogYXMgdG9DaGlsZEFycmF5fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWFjdC5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsibiIsImwiLCJ1IiwiaSIsInQiLCJyIiwibyIsImYiLCJlIiwiYyIsInMiLCJhIiwiaCIsInYiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJ5IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiY2hpbGRyZW4iLCJjYWxsIiwiZGVmYXVsdFByb3BzIiwicCIsInR5cGUiLCJwcm9wcyIsImtleSIsInJlZiIsIl9fayIsIl9fIiwiX19iIiwiX19lIiwiX19kIiwiX19jIiwiX19oIiwiY29uc3RydWN0b3IiLCJfX3YiLCJ2bm9kZSIsImQiLCJjdXJyZW50IiwiXyIsImsiLCJnIiwiYiIsInNldFByb3BlcnR5IiwidGVzdCIsInN0eWxlIiwiY3NzVGV4dCIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsInNsaWNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInciLCJtIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImluZGV4T2YiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJldmVudCIsIngiLCJjb250ZXh0IiwiQSIsIlAiLCJiYXNlIiwiQyIsInNldFRpbWVvdXQiLCJUIiwicHVzaCIsIiQiLCJfX3IiLCJkZWJvdW5jZVJlbmRlcmluZyIsInNvcnQiLCJzaGlmdCIsIl9fUCIsIk0iLCJfX24iLCJvd25lclNWR0VsZW1lbnQiLCJOIiwiSCIsIkFycmF5IiwiaXNBcnJheSIsIkkiLCJ6IiwiTCIsIm5leHRTaWJsaW5nIiwicSIsIlMiLCJqIiwic29tZSIsImFwcGVuZENoaWxkIiwiaW5zZXJ0QmVmb3JlIiwiY29udGV4dFR5cGUiLCJ2YWx1ZSIsIl9fRSIsInByb3RvdHlwZSIsInJlbmRlciIsIkIiLCJzdWIiLCJzdGF0ZSIsIl9zYiIsIl9fcyIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImNvbXBvbmVudFdpbGxNb3VudCIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsImZvckVhY2giLCJjb21wb25lbnRXaWxsVXBkYXRlIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiZ2V0Q2hpbGRDb250ZXh0IiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJPIiwiZGlmZmVkIiwibG9jYWxOYW1lIiwibm9kZVR5cGUiLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwiY3JlYXRlRWxlbWVudE5TIiwiY3JlYXRlRWxlbWVudCIsImlzIiwiZGF0YSIsImNoaWxkTm9kZXMiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsImF0dHJpYnV0ZXMiLCJuYW1lIiwiX19odG1sIiwiaW5uZXJIVE1MIiwiY2hlY2tlZCIsInVubW91bnQiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsIkQiLCJmaXJzdENoaWxkIiwiRSIsIkYiLCJHIiwiQ29uc3VtZXIiLCJQcm92aWRlciIsInNwbGljZSIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsInNldFN0YXRlIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJmb3JjZVVwZGF0ZSIsIlByb21pc2UiLCJ0aGVuIiwiYmluZCIsInJlc29sdmUiLCJDb21wb25lbnQiLCJGcmFnbWVudCIsImNsb25lRWxlbWVudCIsImNyZWF0ZUNvbnRleHQiLCJjcmVhdGVSZWYiLCJoeWRyYXRlIiwiaXNWYWxpZEVsZW1lbnQiLCJvcHRpb25zIiwidG9DaGlsZEFycmF5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/core/node_modules/preact/dist/preact.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@fullcalendar/core/node_modules/preact/hooks/dist/hooks.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@fullcalendar/core/node_modules/preact/hooks/dist/hooks.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCallback: () => (/* binding */ T),\n/* harmony export */   useContext: () => (/* binding */ q),\n/* harmony export */   useDebugValue: () => (/* binding */ x),\n/* harmony export */   useEffect: () => (/* binding */ h),\n/* harmony export */   useErrorBoundary: () => (/* binding */ P),\n/* harmony export */   useId: () => (/* binding */ V),\n/* harmony export */   useImperativeHandle: () => (/* binding */ A),\n/* harmony export */   useLayoutEffect: () => (/* binding */ s),\n/* harmony export */   useMemo: () => (/* binding */ F),\n/* harmony export */   useReducer: () => (/* binding */ y),\n/* harmony export */   useRef: () => (/* binding */ _),\n/* harmony export */   useState: () => (/* binding */ p)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"(ssr)/./node_modules/@fullcalendar/core/node_modules/preact/dist/preact.mjs\");\n\nvar t, r, u, i, o = 0, f = [], c = [], e = preact__WEBPACK_IMPORTED_MODULE_0__.options.__b, a = preact__WEBPACK_IMPORTED_MODULE_0__.options.__r, v = preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed, l = preact__WEBPACK_IMPORTED_MODULE_0__.options.__c, m = preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount;\nfunction d(t, u) {\n    preact__WEBPACK_IMPORTED_MODULE_0__.options.__h && preact__WEBPACK_IMPORTED_MODULE_0__.options.__h(r, t, o || u), o = 0;\n    var i = r.__H || (r.__H = {\n        __: [],\n        __h: []\n    });\n    return t >= i.__.length && i.__.push({\n        __V: c\n    }), i.__[t];\n}\nfunction p(n) {\n    return o = 1, y(B, n);\n}\nfunction y(n, u, i) {\n    var o = d(t++, 2);\n    if (o.t = n, !o.__c && (o.__ = [\n        i ? i(u) : B(void 0, u),\n        function(n) {\n            var t = o.__N ? o.__N[0] : o.__[0], r = o.t(t, n);\n            t !== r && (o.__N = [\n                r,\n                o.__[1]\n            ], o.__c.setState({}));\n        }\n    ], o.__c = r, !r.u)) {\n        r.u = !0;\n        var f = r.shouldComponentUpdate;\n        r.shouldComponentUpdate = function(n, t, r) {\n            if (!o.__c.__H) return !0;\n            var u = o.__c.__H.__.filter(function(n) {\n                return n.__c;\n            });\n            if (u.every(function(n) {\n                return !n.__N;\n            })) return !f || f.call(this, n, t, r);\n            var i = !1;\n            return u.forEach(function(n) {\n                if (n.__N) {\n                    var t = n.__[0];\n                    n.__ = n.__N, n.__N = void 0, t !== n.__[0] && (i = !0);\n                }\n            }), !(!i && o.__c.props === n) && (!f || f.call(this, n, t, r));\n        };\n    }\n    return o.__N || o.__;\n}\nfunction h(u, i) {\n    var o = d(t++, 3);\n    !preact__WEBPACK_IMPORTED_MODULE_0__.options.__s && z(o.__H, i) && (o.__ = u, o.i = i, r.__H.__h.push(o));\n}\nfunction s(u, i) {\n    var o = d(t++, 4);\n    !preact__WEBPACK_IMPORTED_MODULE_0__.options.__s && z(o.__H, i) && (o.__ = u, o.i = i, r.__h.push(o));\n}\nfunction _(n) {\n    return o = 5, F(function() {\n        return {\n            current: n\n        };\n    }, []);\n}\nfunction A(n, t, r) {\n    o = 6, s(function() {\n        return \"function\" == typeof n ? (n(t()), function() {\n            return n(null);\n        }) : n ? (n.current = t(), function() {\n            return n.current = null;\n        }) : void 0;\n    }, null == r ? r : r.concat(n));\n}\nfunction F(n, r) {\n    var u = d(t++, 7);\n    return z(u.__H, r) ? (u.__V = n(), u.i = r, u.__h = n, u.__V) : u.__;\n}\nfunction T(n, t) {\n    return o = 8, F(function() {\n        return n;\n    }, t);\n}\nfunction q(n) {\n    var u = r.context[n.__c], i = d(t++, 9);\n    return i.c = n, u ? (null == i.__ && (i.__ = !0, u.sub(r)), u.props.value) : n.__;\n}\nfunction x(t, r) {\n    preact__WEBPACK_IMPORTED_MODULE_0__.options.useDebugValue && preact__WEBPACK_IMPORTED_MODULE_0__.options.useDebugValue(r ? r(t) : t);\n}\nfunction P(n) {\n    var u = d(t++, 10), i = p();\n    return u.__ = n, r.componentDidCatch || (r.componentDidCatch = function(n, t) {\n        u.__ && u.__(n, t), i[1](n);\n    }), [\n        i[0],\n        function() {\n            i[1](void 0);\n        }\n    ];\n}\nfunction V() {\n    var n = d(t++, 11);\n    if (!n.__) {\n        for(var u = r.__v; null !== u && !u.__m && null !== u.__;)u = u.__;\n        var i = u.__m || (u.__m = [\n            0,\n            0\n        ]);\n        n.__ = \"P\" + i[0] + \"-\" + i[1]++;\n    }\n    return n.__;\n}\nfunction b() {\n    for(var t; t = f.shift();)if (t.__P && t.__H) try {\n        t.__H.__h.forEach(k), t.__H.__h.forEach(w), t.__H.__h = [];\n    } catch (r) {\n        t.__H.__h = [], preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(r, t.__v);\n    }\n}\npreact__WEBPACK_IMPORTED_MODULE_0__.options.__b = function(n) {\n    r = null, e && e(n);\n}, preact__WEBPACK_IMPORTED_MODULE_0__.options.__r = function(n) {\n    a && a(n), t = 0;\n    var i = (r = n.__c).__H;\n    i && (u === r ? (i.__h = [], r.__h = [], i.__.forEach(function(n) {\n        n.__N && (n.__ = n.__N), n.__V = c, n.__N = n.i = void 0;\n    })) : (i.__h.forEach(k), i.__h.forEach(w), i.__h = [])), u = r;\n}, preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed = function(t) {\n    v && v(t);\n    var o = t.__c;\n    o && o.__H && (o.__H.__h.length && (1 !== f.push(o) && i === preact__WEBPACK_IMPORTED_MODULE_0__.options.requestAnimationFrame || ((i = preact__WEBPACK_IMPORTED_MODULE_0__.options.requestAnimationFrame) || j)(b)), o.__H.__.forEach(function(n) {\n        n.i && (n.__H = n.i), n.__V !== c && (n.__ = n.__V), n.i = void 0, n.__V = c;\n    })), u = r = null;\n}, preact__WEBPACK_IMPORTED_MODULE_0__.options.__c = function(t, r) {\n    r.some(function(t) {\n        try {\n            t.__h.forEach(k), t.__h = t.__h.filter(function(n) {\n                return !n.__ || w(n);\n            });\n        } catch (u) {\n            r.some(function(n) {\n                n.__h && (n.__h = []);\n            }), r = [], preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(u, t.__v);\n        }\n    }), l && l(t, r);\n}, preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount = function(t) {\n    m && m(t);\n    var r, u = t.__c;\n    u && u.__H && (u.__H.__.forEach(function(n) {\n        try {\n            k(n);\n        } catch (n) {\n            r = n;\n        }\n    }), u.__H = void 0, r && preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(r, u.__v));\n};\nvar g = \"function\" == typeof requestAnimationFrame;\nfunction j(n) {\n    var t, r = function() {\n        clearTimeout(u), g && cancelAnimationFrame(t), setTimeout(n);\n    }, u = setTimeout(r, 100);\n    g && (t = requestAnimationFrame(r));\n}\nfunction k(n) {\n    var t = r, u = n.__c;\n    \"function\" == typeof u && (n.__c = void 0, u()), r = t;\n}\nfunction w(n) {\n    var t = r;\n    n.__c = n.__(), r = t;\n}\nfunction z(n, t) {\n    return !n || n.length !== t.length || t.some(function(t, r) {\n        return t !== n[r];\n    });\n}\nfunction B(n, t) {\n    return \"function\" == typeof t ? t(n) : t;\n}\n //# sourceMappingURL=hooks.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3QvaG9va3MvZGlzdC9ob29rcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFpQztBQUFBLElBQUlFLEdBQUVDLEdBQUVDLEdBQUVDLEdBQUVDLElBQUUsR0FBRUMsSUFBRSxFQUFFLEVBQUNDLElBQUUsRUFBRSxFQUFDQyxJQUFFUiwyQ0FBQ0EsQ0FBQ1MsR0FBRyxFQUFDQyxJQUFFViwyQ0FBQ0EsQ0FBQ1csR0FBRyxFQUFDQyxJQUFFWiwyQ0FBQ0EsQ0FBQ2EsTUFBTSxFQUFDQyxJQUFFZCwyQ0FBQ0EsQ0FBQ2UsR0FBRyxFQUFDQyxJQUFFaEIsMkNBQUNBLENBQUNpQixPQUFPO0FBQUMsU0FBU0MsRUFBRWpCLENBQUMsRUFBQ0UsQ0FBQztJQUFFSCwyQ0FBQ0EsQ0FBQ21CLEdBQUcsSUFBRW5CLDJDQUFDQSxDQUFDbUIsR0FBRyxDQUFDakIsR0FBRUQsR0FBRUksS0FBR0YsSUFBR0UsSUFBRTtJQUFFLElBQUlELElBQUVGLEVBQUVrQixHQUFHLElBQUdsQixDQUFBQSxFQUFFa0IsR0FBRyxHQUFDO1FBQUNDLElBQUcsRUFBRTtRQUFDRixLQUFJLEVBQUU7SUFBQTtJQUFHLE9BQU9sQixLQUFHRyxFQUFFaUIsRUFBRSxDQUFDQyxNQUFNLElBQUVsQixFQUFFaUIsRUFBRSxDQUFDRSxJQUFJLENBQUM7UUFBQ0MsS0FBSWpCO0lBQUMsSUFBR0gsRUFBRWlCLEVBQUUsQ0FBQ3BCLEVBQUU7QUFBQTtBQUFDLFNBQVN3QixFQUFFekIsQ0FBQztJQUFFLE9BQU9LLElBQUUsR0FBRXFCLEVBQUVDLEdBQUUzQjtBQUFFO0FBQUMsU0FBUzBCLEVBQUUxQixDQUFDLEVBQUNHLENBQUMsRUFBQ0MsQ0FBQztJQUFFLElBQUlDLElBQUVhLEVBQUVqQixLQUFJO0lBQUcsSUFBR0ksRUFBRUosQ0FBQyxHQUFDRCxHQUFFLENBQUNLLEVBQUVVLEdBQUcsSUFB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LENBQUNELEtBQUdBLEVBQUVzQixNQUFNLEtBQUdyQixFQUFFcUIsTUFBTSxJQUFFckIsRUFBRWdFLElBQUksQ0FBQyxTQUFTaEUsQ0FBQyxFQUFDQyxDQUFDO1FBQUUsT0FBT0QsTUFBSUQsQ0FBQyxDQUFDRSxFQUFFO0lBQUE7QUFBRTtBQUFDLFNBQVN5QixFQUFFM0IsQ0FBQyxFQUFDQyxDQUFDO0lBQUUsT0FBTSxjQUFZLE9BQU9BLElBQUVBLEVBQUVELEtBQUdDO0FBQUM7QUFBa04sQ0FDaDhHLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL2Rpc3QvaG9va3MubWpzPzA2M2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0e29wdGlvbnMgYXMgbn1mcm9tXCJwcmVhY3RcIjt2YXIgdCxyLHUsaSxvPTAsZj1bXSxjPVtdLGU9bi5fX2IsYT1uLl9fcix2PW4uZGlmZmVkLGw9bi5fX2MsbT1uLnVubW91bnQ7ZnVuY3Rpb24gZCh0LHUpe24uX19oJiZuLl9faChyLHQsb3x8dSksbz0wO3ZhciBpPXIuX19IfHwoci5fX0g9e19fOltdLF9faDpbXX0pO3JldHVybiB0Pj1pLl9fLmxlbmd0aCYmaS5fXy5wdXNoKHtfX1Y6Y30pLGkuX19bdF19ZnVuY3Rpb24gcChuKXtyZXR1cm4gbz0xLHkoQixuKX1mdW5jdGlvbiB5KG4sdSxpKXt2YXIgbz1kKHQrKywyKTtpZihvLnQ9biwhby5fX2MmJihvLl9fPVtpP2kodSk6Qih2b2lkIDAsdSksZnVuY3Rpb24obil7dmFyIHQ9by5fX04/by5fX05bMF06by5fX1swXSxyPW8udCh0LG4pO3QhPT1yJiYoby5fX049W3Isby5fX1sxXV0sby5fX2Muc2V0U3RhdGUoe30pKX1dLG8uX19jPXIsIXIudSkpe3IudT0hMDt2YXIgZj1yLnNob3VsZENvbXBvbmVudFVwZGF0ZTtyLnNob3VsZENvbXBvbmVudFVwZGF0ZT1mdW5jdGlvbihuLHQscil7aWYoIW8uX19jLl9fSClyZXR1cm4hMDt2YXIgdT1vLl9fYy5fX0guX18uZmlsdGVyKGZ1bmN0aW9uKG4pe3JldHVybiBuLl9fY30pO2lmKHUuZXZlcnkoZnVuY3Rpb24obil7cmV0dXJuIW4uX19OfSkpcmV0dXJuIWZ8fGYuY2FsbCh0aGlzLG4sdCxyKTt2YXIgaT0hMTtyZXR1cm4gdS5mb3JFYWNoKGZ1bmN0aW9uKG4pe2lmKG4uX19OKXt2YXIgdD1uLl9fWzBdO24uX189bi5fX04sbi5fX049dm9pZCAwLHQhPT1uLl9fWzBdJiYoaT0hMCl9fSksISghaSYmby5fX2MucHJvcHM9PT1uKSYmKCFmfHxmLmNhbGwodGhpcyxuLHQscikpfX1yZXR1cm4gby5fX058fG8uX199ZnVuY3Rpb24gaCh1LGkpe3ZhciBvPWQodCsrLDMpOyFuLl9fcyYmeihvLl9fSCxpKSYmKG8uX189dSxvLmk9aSxyLl9fSC5fX2gucHVzaChvKSl9ZnVuY3Rpb24gcyh1LGkpe3ZhciBvPWQodCsrLDQpOyFuLl9fcyYmeihvLl9fSCxpKSYmKG8uX189dSxvLmk9aSxyLl9faC5wdXNoKG8pKX1mdW5jdGlvbiBfKG4pe3JldHVybiBvPTUsRihmdW5jdGlvbigpe3JldHVybntjdXJyZW50Om59fSxbXSl9ZnVuY3Rpb24gQShuLHQscil7bz02LHMoZnVuY3Rpb24oKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBuPyhuKHQoKSksZnVuY3Rpb24oKXtyZXR1cm4gbihudWxsKX0pOm4/KG4uY3VycmVudD10KCksZnVuY3Rpb24oKXtyZXR1cm4gbi5jdXJyZW50PW51bGx9KTp2b2lkIDB9LG51bGw9PXI/cjpyLmNvbmNhdChuKSl9ZnVuY3Rpb24gRihuLHIpe3ZhciB1PWQodCsrLDcpO3JldHVybiB6KHUuX19ILHIpPyh1Ll9fVj1uKCksdS5pPXIsdS5fX2g9bix1Ll9fVik6dS5fX31mdW5jdGlvbiBUKG4sdCl7cmV0dXJuIG89OCxGKGZ1bmN0aW9uKCl7cmV0dXJuIG59LHQpfWZ1bmN0aW9uIHEobil7dmFyIHU9ci5jb250ZXh0W24uX19jXSxpPWQodCsrLDkpO3JldHVybiBpLmM9bix1PyhudWxsPT1pLl9fJiYoaS5fXz0hMCx1LnN1YihyKSksdS5wcm9wcy52YWx1ZSk6bi5fX31mdW5jdGlvbiB4KHQscil7bi51c2VEZWJ1Z1ZhbHVlJiZuLnVzZURlYnVnVmFsdWUocj9yKHQpOnQpfWZ1bmN0aW9uIFAobil7dmFyIHU9ZCh0KyssMTApLGk9cCgpO3JldHVybiB1Ll9fPW4sci5jb21wb25lbnREaWRDYXRjaHx8KHIuY29tcG9uZW50RGlkQ2F0Y2g9ZnVuY3Rpb24obix0KXt1Ll9fJiZ1Ll9fKG4sdCksaVsxXShuKX0pLFtpWzBdLGZ1bmN0aW9uKCl7aVsxXSh2b2lkIDApfV19ZnVuY3Rpb24gVigpe3ZhciBuPWQodCsrLDExKTtpZighbi5fXyl7Zm9yKHZhciB1PXIuX192O251bGwhPT11JiYhdS5fX20mJm51bGwhPT11Ll9fOyl1PXUuX187dmFyIGk9dS5fX218fCh1Ll9fbT1bMCwwXSk7bi5fXz1cIlBcIitpWzBdK1wiLVwiK2lbMV0rK31yZXR1cm4gbi5fX31mdW5jdGlvbiBiKCl7Zm9yKHZhciB0O3Q9Zi5zaGlmdCgpOylpZih0Ll9fUCYmdC5fX0gpdHJ5e3QuX19ILl9faC5mb3JFYWNoKGspLHQuX19ILl9faC5mb3JFYWNoKHcpLHQuX19ILl9faD1bXX1jYXRjaChyKXt0Ll9fSC5fX2g9W10sbi5fX2Uocix0Ll9fdil9fW4uX19iPWZ1bmN0aW9uKG4pe3I9bnVsbCxlJiZlKG4pfSxuLl9fcj1mdW5jdGlvbihuKXthJiZhKG4pLHQ9MDt2YXIgaT0ocj1uLl9fYykuX19IO2kmJih1PT09cj8oaS5fX2g9W10sci5fX2g9W10saS5fXy5mb3JFYWNoKGZ1bmN0aW9uKG4pe24uX19OJiYobi5fXz1uLl9fTiksbi5fX1Y9YyxuLl9fTj1uLmk9dm9pZCAwfSkpOihpLl9faC5mb3JFYWNoKGspLGkuX19oLmZvckVhY2godyksaS5fX2g9W10pKSx1PXJ9LG4uZGlmZmVkPWZ1bmN0aW9uKHQpe3YmJnYodCk7dmFyIG89dC5fX2M7byYmby5fX0gmJihvLl9fSC5fX2gubGVuZ3RoJiYoMSE9PWYucHVzaChvKSYmaT09PW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHwoKGk9bi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpfHxqKShiKSksby5fX0guX18uZm9yRWFjaChmdW5jdGlvbihuKXtuLmkmJihuLl9fSD1uLmkpLG4uX19WIT09YyYmKG4uX189bi5fX1YpLG4uaT12b2lkIDAsbi5fX1Y9Y30pKSx1PXI9bnVsbH0sbi5fX2M9ZnVuY3Rpb24odCxyKXtyLnNvbWUoZnVuY3Rpb24odCl7dHJ5e3QuX19oLmZvckVhY2goayksdC5fX2g9dC5fX2guZmlsdGVyKGZ1bmN0aW9uKG4pe3JldHVybiFuLl9ffHx3KG4pfSl9Y2F0Y2godSl7ci5zb21lKGZ1bmN0aW9uKG4pe24uX19oJiYobi5fX2g9W10pfSkscj1bXSxuLl9fZSh1LHQuX192KX19KSxsJiZsKHQscil9LG4udW5tb3VudD1mdW5jdGlvbih0KXttJiZtKHQpO3ZhciByLHU9dC5fX2M7dSYmdS5fX0gmJih1Ll9fSC5fXy5mb3JFYWNoKGZ1bmN0aW9uKG4pe3RyeXtrKG4pfWNhdGNoKG4pe3I9bn19KSx1Ll9fSD12b2lkIDAsciYmbi5fX2Uocix1Ll9fdikpfTt2YXIgZz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ZnVuY3Rpb24gaihuKXt2YXIgdCxyPWZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHUpLGcmJmNhbmNlbEFuaW1hdGlvbkZyYW1lKHQpLHNldFRpbWVvdXQobil9LHU9c2V0VGltZW91dChyLDEwMCk7ZyYmKHQ9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHIpKX1mdW5jdGlvbiBrKG4pe3ZhciB0PXIsdT1uLl9fYztcImZ1bmN0aW9uXCI9PXR5cGVvZiB1JiYobi5fX2M9dm9pZCAwLHUoKSkscj10fWZ1bmN0aW9uIHcobil7dmFyIHQ9cjtuLl9fYz1uLl9fKCkscj10fWZ1bmN0aW9uIHoobix0KXtyZXR1cm4hbnx8bi5sZW5ndGghPT10Lmxlbmd0aHx8dC5zb21lKGZ1bmN0aW9uKHQscil7cmV0dXJuIHQhPT1uW3JdfSl9ZnVuY3Rpb24gQihuLHQpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/dChuKTp0fWV4cG9ydHtUIGFzIHVzZUNhbGxiYWNrLHEgYXMgdXNlQ29udGV4dCx4IGFzIHVzZURlYnVnVmFsdWUsaCBhcyB1c2VFZmZlY3QsUCBhcyB1c2VFcnJvckJvdW5kYXJ5LFYgYXMgdXNlSWQsQSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlLHMgYXMgdXNlTGF5b3V0RWZmZWN0LEYgYXMgdXNlTWVtbyx5IGFzIHVzZVJlZHVjZXIsXyBhcyB1c2VSZWYscCBhcyB1c2VTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob29rcy5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsib3B0aW9ucyIsIm4iLCJ0IiwiciIsInUiLCJpIiwibyIsImYiLCJjIiwiZSIsIl9fYiIsImEiLCJfX3IiLCJ2IiwiZGlmZmVkIiwibCIsIl9fYyIsIm0iLCJ1bm1vdW50IiwiZCIsIl9faCIsIl9fSCIsIl9fIiwibGVuZ3RoIiwicHVzaCIsIl9fViIsInAiLCJ5IiwiQiIsIl9fTiIsInNldFN0YXRlIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiZmlsdGVyIiwiZXZlcnkiLCJjYWxsIiwiZm9yRWFjaCIsInByb3BzIiwiaCIsIl9fcyIsInoiLCJzIiwiXyIsIkYiLCJjdXJyZW50IiwiQSIsImNvbmNhdCIsIlQiLCJxIiwiY29udGV4dCIsInN1YiIsInZhbHVlIiwieCIsInVzZURlYnVnVmFsdWUiLCJQIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJWIiwiX192IiwiX19tIiwiYiIsInNoaWZ0IiwiX19QIiwiayIsInciLCJfX2UiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJqIiwic29tZSIsImciLCJjbGVhclRpbWVvdXQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInNldFRpbWVvdXQiLCJ1c2VDYWxsYmFjayIsInVzZUNvbnRleHQiLCJ1c2VFZmZlY3QiLCJ1c2VFcnJvckJvdW5kYXJ5IiwidXNlSWQiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZHVjZXIiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/core/node_modules/preact/hooks/dist/hooks.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@fullcalendar/daygrid/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@fullcalendar/daygrid/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ index)\n/* harmony export */ });\n/* harmony import */ var _fullcalendar_core_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/core/index.js */ \"(ssr)/./node_modules/@fullcalendar/core/index.js\");\n/* harmony import */ var _internal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal.js */ \"(ssr)/./node_modules/@fullcalendar/daygrid/internal.js\");\n\n\n\n\nvar index = (0,_fullcalendar_core_index_js__WEBPACK_IMPORTED_MODULE_0__.createPlugin)({\n    name: \"@fullcalendar/daygrid\",\n    initialView: \"dayGridMonth\",\n    views: {\n        dayGrid: {\n            component: _internal_js__WEBPACK_IMPORTED_MODULE_1__.DayGridView,\n            dateProfileGeneratorClass: _internal_js__WEBPACK_IMPORTED_MODULE_1__.TableDateProfileGenerator\n        },\n        dayGridDay: {\n            type: \"dayGrid\",\n            duration: {\n                days: 1\n            }\n        },\n        dayGridWeek: {\n            type: \"dayGrid\",\n            duration: {\n                weeks: 1\n            }\n        },\n        dayGridMonth: {\n            type: \"dayGrid\",\n            duration: {\n                months: 1\n            },\n            fixedWeekCount: true\n        },\n        dayGridYear: {\n            type: \"dayGrid\",\n            duration: {\n                years: 1\n            }\n        }\n    }\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyRDtBQUM0QjtBQUMvQztBQUNGO0FBRXRDLElBQUlJLFFBQVFKLHlFQUFZQSxDQUFDO0lBQ3JCSyxNQUFNO0lBQ05DLGFBQWE7SUFDYkMsT0FBTztRQUNIQyxTQUFTO1lBQ0xDLFdBQVdQLHFEQUFZQTtZQUN2QlEsMkJBQTJCUCxtRUFBeUJBO1FBQ3hEO1FBQ0FRLFlBQVk7WUFDUkMsTUFBTTtZQUNOQyxVQUFVO2dCQUFFQyxNQUFNO1lBQUU7UUFDeEI7UUFDQUMsYUFBYTtZQUNUSCxNQUFNO1lBQ05DLFVBQVU7Z0JBQUVHLE9BQU87WUFBRTtRQUN6QjtRQUNBQyxjQUFjO1lBQ1ZMLE1BQU07WUFDTkMsVUFBVTtnQkFBRUssUUFBUTtZQUFFO1lBQ3RCQyxnQkFBZ0I7UUFDcEI7UUFDQUMsYUFBYTtZQUNUUixNQUFNO1lBQ05DLFVBQVU7Z0JBQUVRLE9BQU87WUFBRTtRQUN6QjtJQUNKO0FBQ0o7QUFFNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2RheWdyaWQvaW5kZXguanM/YzFjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW5kZXguanMnO1xuaW1wb3J0IHsgRGF5R3JpZFZpZXcgYXMgRGF5VGFibGVWaWV3LCBUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yIH0gZnJvbSAnLi9pbnRlcm5hbC5qcyc7XG5pbXBvcnQgJ0BmdWxsY2FsZW5kYXIvY29yZS9pbnRlcm5hbC5qcyc7XG5pbXBvcnQgJ0BmdWxsY2FsZW5kYXIvY29yZS9wcmVhY3QuanMnO1xuXG52YXIgaW5kZXggPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdAZnVsbGNhbGVuZGFyL2RheWdyaWQnLFxuICAgIGluaXRpYWxWaWV3OiAnZGF5R3JpZE1vbnRoJyxcbiAgICB2aWV3czoge1xuICAgICAgICBkYXlHcmlkOiB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IERheVRhYmxlVmlldyxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3M6IFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IsXG4gICAgICAgIH0sXG4gICAgICAgIGRheUdyaWREYXk6IHtcbiAgICAgICAgICAgIHR5cGU6ICdkYXlHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZGF5R3JpZFdlZWs6IHtcbiAgICAgICAgICAgIHR5cGU6ICdkYXlHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGRheUdyaWRNb250aDoge1xuICAgICAgICAgICAgdHlwZTogJ2RheUdyaWQnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgbW9udGhzOiAxIH0sXG4gICAgICAgICAgICBmaXhlZFdlZWtDb3VudDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgZGF5R3JpZFllYXI6IHtcbiAgICAgICAgICAgIHR5cGU6ICdkYXlHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IHllYXJzOiAxIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBpbmRleCBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOlsiY3JlYXRlUGx1Z2luIiwiRGF5R3JpZFZpZXciLCJEYXlUYWJsZVZpZXciLCJUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yIiwiaW5kZXgiLCJuYW1lIiwiaW5pdGlhbFZpZXciLCJ2aWV3cyIsImRheUdyaWQiLCJjb21wb25lbnQiLCJkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzIiwiZGF5R3JpZERheSIsInR5cGUiLCJkdXJhdGlvbiIsImRheXMiLCJkYXlHcmlkV2VlayIsIndlZWtzIiwiZGF5R3JpZE1vbnRoIiwibW9udGhzIiwiZml4ZWRXZWVrQ291bnQiLCJkYXlHcmlkWWVhciIsInllYXJzIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/daygrid/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@fullcalendar/daygrid/internal.js":
/*!********************************************************!*\
  !*** ./node_modules/@fullcalendar/daygrid/internal.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DayGridView: () => (/* binding */ DayTableView),\n/* harmony export */   DayTable: () => (/* binding */ DayTable),\n/* harmony export */   DayTableSlicer: () => (/* binding */ DayTableSlicer),\n/* harmony export */   Table: () => (/* binding */ Table),\n/* harmony export */   TableDateProfileGenerator: () => (/* binding */ TableDateProfileGenerator),\n/* harmony export */   TableRows: () => (/* binding */ TableRows),\n/* harmony export */   TableView: () => (/* binding */ TableView),\n/* harmony export */   buildDayTableModel: () => (/* binding */ buildDayTableModel),\n/* harmony export */   buildDayTableRenderRange: () => (/* binding */ buildDayTableRenderRange)\n/* harmony export */ });\n/* harmony import */ var _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/core/internal.js */ \"(ssr)/./node_modules/@fullcalendar/core/internal-common.js\");\n/* harmony import */ var _fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/core/preact.js */ \"(ssr)/./node_modules/@fullcalendar/core/node_modules/preact/dist/preact.mjs\");\n\n\n/* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.\n----------------------------------------------------------------------------------------------------------------------*/ // It is a manager for a Table subcomponent, which does most of the heavy lifting.\n// It is responsible for managing width/height.\nclass TableView extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be {\n    constructor(){\n        super(...arguments);\n        this.headerElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    }\n    renderSimpleLayout(headerRowContent, bodyContent) {\n        let { props, context } = this;\n        let sections = [];\n        let stickyHeaderDates = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cc)(context.options);\n        if (headerRowContent) {\n            sections.push({\n                type: \"header\",\n                key: \"header\",\n                isSticky: stickyHeaderDates,\n                chunk: {\n                    elRef: this.headerElRef,\n                    tableClassName: \"fc-col-header\",\n                    rowContent: headerRowContent\n                }\n            });\n        }\n        sections.push({\n            type: \"body\",\n            key: \"body\",\n            liquid: true,\n            chunk: {\n                content: bodyContent\n            }\n        });\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ct, {\n            elClasses: [\n                \"fc-daygrid\"\n            ],\n            viewSpec: context.viewSpec\n        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b$, {\n            liquid: !props.isHeightAuto && !props.forPrint,\n            collapsibleWidth: props.forPrint,\n            cols: [],\n            sections: sections\n        }));\n    }\n    renderHScrollLayout(headerRowContent, bodyContent, colCnt, dayMinWidth) {\n        let ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n        if (!ScrollGrid) {\n            throw new Error(\"No ScrollGrid implementation\");\n        }\n        let { props, context } = this;\n        let stickyHeaderDates = !props.forPrint && (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cc)(context.options);\n        let stickyFooterScrollbar = !props.forPrint && (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cb)(context.options);\n        let sections = [];\n        if (headerRowContent) {\n            sections.push({\n                type: \"header\",\n                key: \"header\",\n                isSticky: stickyHeaderDates,\n                chunks: [\n                    {\n                        key: \"main\",\n                        elRef: this.headerElRef,\n                        tableClassName: \"fc-col-header\",\n                        rowContent: headerRowContent\n                    }\n                ]\n            });\n        }\n        sections.push({\n            type: \"body\",\n            key: \"body\",\n            liquid: true,\n            chunks: [\n                {\n                    key: \"main\",\n                    content: bodyContent\n                }\n            ]\n        });\n        if (stickyFooterScrollbar) {\n            sections.push({\n                type: \"footer\",\n                key: \"footer\",\n                isSticky: true,\n                chunks: [\n                    {\n                        key: \"main\",\n                        content: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ca\n                    }\n                ]\n            });\n        }\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ct, {\n            elClasses: [\n                \"fc-daygrid\"\n            ],\n            viewSpec: context.viewSpec\n        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ScrollGrid, {\n            liquid: !props.isHeightAuto && !props.forPrint,\n            forPrint: props.forPrint,\n            collapsibleWidth: props.forPrint,\n            colGroups: [\n                {\n                    cols: [\n                        {\n                            span: colCnt,\n                            minWidth: dayMinWidth\n                        }\n                    ]\n                }\n            ],\n            sections: sections\n        }));\n    }\n}\nfunction splitSegsByRow(segs, rowCnt) {\n    let byRow = [];\n    for(let i = 0; i < rowCnt; i += 1){\n        byRow[i] = [];\n    }\n    for (let seg of segs){\n        byRow[seg.row].push(seg);\n    }\n    return byRow;\n}\nfunction splitSegsByFirstCol(segs, colCnt) {\n    let byCol = [];\n    for(let i = 0; i < colCnt; i += 1){\n        byCol[i] = [];\n    }\n    for (let seg of segs){\n        byCol[seg.firstCol].push(seg);\n    }\n    return byCol;\n}\nfunction splitInteractionByRow(ui, rowCnt) {\n    let byRow = [];\n    if (!ui) {\n        for(let i = 0; i < rowCnt; i += 1){\n            byRow[i] = null;\n        }\n    } else {\n        for(let i = 0; i < rowCnt; i += 1){\n            byRow[i] = {\n                affectedInstances: ui.affectedInstances,\n                isEvent: ui.isEvent,\n                segs: []\n            };\n        }\n        for (let seg of ui.segs){\n            byRow[seg.row].segs.push(seg);\n        }\n    }\n    return byRow;\n}\nconst DEFAULT_TABLE_EVENT_TIME_FORMAT = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.x)({\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    omitZeroMinute: true,\n    meridiem: \"narrow\"\n});\nfunction hasListItemDisplay(seg) {\n    let { display } = seg.eventRange.ui;\n    return display === \"list-item\" || display === \"auto\" && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day\n    seg.isStart && // \"\n    seg.isEnd // \"\n    ;\n}\nclass TableBlockEvent extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        let { props } = this;\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cj, Object.assign({}, props, {\n            elClasses: [\n                \"fc-daygrid-event\",\n                \"fc-daygrid-block-event\",\n                \"fc-h-event\"\n            ],\n            defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT,\n            defaultDisplayEventEnd: props.defaultDisplayEventEnd,\n            disableResizing: !props.seg.eventRange.def.allDay\n        }));\n    }\n}\nclass TableListItemEvent extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let { seg } = props;\n        let timeFormat = options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;\n        let timeText = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bQ)(seg, timeFormat, context, true, props.defaultDisplayEventEnd);\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cn, Object.assign({}, props, {\n            elTag: \"a\",\n            elClasses: [\n                \"fc-daygrid-event\",\n                \"fc-daygrid-dot-event\"\n            ],\n            elAttrs: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bU)(props.seg, context),\n            defaultGenerator: renderInnerContent,\n            timeText: timeText,\n            isResizing: false,\n            isDateSelecting: false\n        }));\n    }\n}\nfunction renderInnerContent(renderProps) {\n    return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-daygrid-event-dot\",\n        style: {\n            borderColor: renderProps.borderColor || renderProps.backgroundColor\n        }\n    }), renderProps.timeText && (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-event-time\"\n    }, renderProps.timeText), (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-event-title\"\n    }, renderProps.event.title || (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, \"\\xa0\")));\n}\nclass TableCellMoreLink extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    constructor(){\n        super(...arguments);\n        this.compileSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(compileSegs);\n    }\n    render() {\n        let { props } = this;\n        let { allSegs, invisibleSegs } = this.compileSegs(props.singlePlacements);\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cr, {\n            elClasses: [\n                \"fc-daygrid-more-link\"\n            ],\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            allDayDate: props.allDayDate,\n            moreCnt: props.moreCnt,\n            allSegs: allSegs,\n            hiddenSegs: invisibleSegs,\n            alignmentElRef: props.alignmentElRef,\n            alignGridTop: props.alignGridTop,\n            extraDateSpan: props.extraDateSpan,\n            popoverContent: ()=>{\n                let isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};\n                return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, allSegs.map((seg)=>{\n                    let instanceId = seg.eventRange.instance.instanceId;\n                    return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                        className: \"fc-daygrid-event-harness\",\n                        key: instanceId,\n                        style: {\n                            visibility: isForcedInvisible[instanceId] ? \"hidden\" : \"\"\n                        }\n                    }, hasListItemDisplay(seg) ? (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableListItemEvent, Object.assign({\n                        seg: seg,\n                        isDragging: false,\n                        isSelected: instanceId === props.eventSelection,\n                        defaultDisplayEventEnd: false\n                    }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bS)(seg, props.todayRange))) : (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableBlockEvent, Object.assign({\n                        seg: seg,\n                        isDragging: false,\n                        isResizing: false,\n                        isDateSelecting: false,\n                        isSelected: instanceId === props.eventSelection,\n                        defaultDisplayEventEnd: false\n                    }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bS)(seg, props.todayRange))));\n                }));\n            }\n        });\n    }\n}\nfunction compileSegs(singlePlacements) {\n    let allSegs = [];\n    let invisibleSegs = [];\n    for (let placement of singlePlacements){\n        allSegs.push(placement.seg);\n        if (!placement.isVisible) {\n            invisibleSegs.push(placement.seg);\n        }\n    }\n    return {\n        allSegs,\n        invisibleSegs\n    };\n}\nconst DEFAULT_WEEK_NUM_FORMAT = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.x)({\n    week: \"narrow\"\n});\nclass TableCell extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be {\n    constructor(){\n        super(...arguments);\n        this.rootElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.state = {\n            dayNumberId: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.a5)()\n        };\n        this.handleRootEl = (el)=>{\n            (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.Y)(this.rootElRef, el);\n            (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.Y)(this.props.elRef, el);\n        };\n    }\n    render() {\n        let { context, props, state, rootElRef } = this;\n        let { options, dateEnv } = context;\n        let { date, dateProfile } = props;\n        // TODO: memoize this?\n        const isMonthStart = props.showDayNumber && shouldDisplayMonthStart(date, dateProfile.currentRange, dateEnv);\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cl, {\n            elTag: \"td\",\n            elRef: this.handleRootEl,\n            elClasses: [\n                \"fc-daygrid-day\",\n                ...props.extraClassNames || []\n            ],\n            elAttrs: Object.assign(Object.assign(Object.assign({}, props.extraDataAttrs), props.showDayNumber ? {\n                \"aria-labelledby\": state.dayNumberId\n            } : {}), {\n                role: \"gridcell\"\n            }),\n            defaultGenerator: renderTopInner,\n            date: date,\n            dateProfile: dateProfile,\n            todayRange: props.todayRange,\n            showDayNumber: props.showDayNumber,\n            isMonthStart: isMonthStart,\n            extraRenderProps: props.extraRenderProps\n        }, (InnerContent, renderProps)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                ref: props.innerElRef,\n                className: \"fc-daygrid-day-frame fc-scrollgrid-sync-inner\",\n                style: {\n                    minHeight: props.minHeight\n                }\n            }, props.showWeekNumber && (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cq, {\n                elTag: \"a\",\n                elClasses: [\n                    \"fc-daygrid-week-number\"\n                ],\n                elAttrs: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b0)(context, date, \"week\"),\n                date: date,\n                defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n            }), !renderProps.isDisabled && (props.showDayNumber || (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cm)(options) || props.forceDayTop) ? (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-daygrid-day-top\"\n            }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(InnerContent, {\n                elTag: \"a\",\n                elClasses: [\n                    \"fc-daygrid-day-number\",\n                    isMonthStart && \"fc-daygrid-month-start\"\n                ],\n                elAttrs: Object.assign(Object.assign({}, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b0)(context, date)), {\n                    id: state.dayNumberId\n                })\n            })) : props.showDayNumber ? // for creating correct amount of space (see issue #7162)\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-daygrid-day-top\",\n                style: {\n                    visibility: \"hidden\"\n                }\n            }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", {\n                className: \"fc-daygrid-day-number\"\n            }, \"\\xa0\")) : undefined, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-daygrid-day-events\",\n                ref: props.fgContentElRef\n            }, props.fgContent, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-daygrid-day-bottom\",\n                style: {\n                    marginTop: props.moreMarginTop\n                }\n            }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableCellMoreLink, {\n                allDayDate: date,\n                singlePlacements: props.singlePlacements,\n                moreCnt: props.moreCnt,\n                alignmentElRef: rootElRef,\n                alignGridTop: !props.showDayNumber,\n                extraDateSpan: props.extraDateSpan,\n                dateProfile: props.dateProfile,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                todayRange: props.todayRange\n            }))), (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-daygrid-day-bg\"\n            }, props.bgContent)));\n    }\n}\nfunction renderTopInner(props) {\n    return props.dayNumberText || (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, \"\\xa0\");\n}\nfunction shouldDisplayMonthStart(date, currentRange, dateEnv) {\n    const { start: currentStart, end: currentEnd } = currentRange;\n    const currentEndIncl = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bg)(currentEnd, -1);\n    const currentFirstYear = dateEnv.getYear(currentStart);\n    const currentFirstMonth = dateEnv.getMonth(currentStart);\n    const currentLastYear = dateEnv.getYear(currentEndIncl);\n    const currentLastMonth = dateEnv.getMonth(currentEndIncl);\n    // spans more than one month?\n    return !(currentFirstYear === currentLastYear && currentFirstMonth === currentLastMonth) && Boolean(// first date in current view?\n    date.valueOf() === currentStart.valueOf() || // a month-start that's within the current range?\n    dateEnv.getDay(date) === 1 && date.valueOf() < currentEnd.valueOf());\n}\nfunction generateSegKey(seg) {\n    return seg.eventRange.instance.instanceId + \":\" + seg.firstCol;\n}\nfunction generateSegUid(seg) {\n    return generateSegKey(seg) + \":\" + seg.lastCol;\n}\nfunction computeFgSegPlacement(segs, dayMaxEvents, dayMaxEventRows, strictOrder, segHeights, maxContentHeight, cells) {\n    let hierarchy = new DayGridSegHierarchy((segEntry)=>{\n        // TODO: more DRY with generateSegUid\n        let segUid = segs[segEntry.index].eventRange.instance.instanceId + \":\" + segEntry.span.start + \":\" + (segEntry.span.end - 1);\n        return segHeights[segUid];\n    });\n    hierarchy.allowReslicing = true;\n    hierarchy.strictOrder = strictOrder;\n    if (dayMaxEvents === true || dayMaxEventRows === true) {\n        hierarchy.maxCoord = maxContentHeight;\n        hierarchy.hiddenConsumes = true;\n    } else if (typeof dayMaxEvents === \"number\") {\n        hierarchy.maxStackCnt = dayMaxEvents;\n    } else if (typeof dayMaxEventRows === \"number\") {\n        hierarchy.maxStackCnt = dayMaxEventRows;\n        hierarchy.hiddenConsumes = true;\n    }\n    // create segInputs only for segs with known heights\n    let segInputs = [];\n    let unknownHeightSegs = [];\n    for(let i = 0; i < segs.length; i += 1){\n        let seg = segs[i];\n        let segUid = generateSegUid(seg);\n        let eventHeight = segHeights[segUid];\n        if (eventHeight != null) {\n            segInputs.push({\n                index: i,\n                span: {\n                    start: seg.firstCol,\n                    end: seg.lastCol + 1\n                }\n            });\n        } else {\n            unknownHeightSegs.push(seg);\n        }\n    }\n    let hiddenEntries = hierarchy.addSegs(segInputs);\n    let segRects = hierarchy.toRects();\n    let { singleColPlacements, multiColPlacements, leftoverMargins } = placeRects(segRects, segs, cells);\n    let moreCnts = [];\n    let moreMarginTops = [];\n    // add segs with unknown heights\n    for (let seg of unknownHeightSegs){\n        multiColPlacements[seg.firstCol].push({\n            seg,\n            isVisible: false,\n            isAbsolute: true,\n            absoluteTop: 0,\n            marginTop: 0\n        });\n        for(let col = seg.firstCol; col <= seg.lastCol; col += 1){\n            singleColPlacements[col].push({\n                seg: resliceSeg(seg, col, col + 1, cells),\n                isVisible: false,\n                isAbsolute: false,\n                absoluteTop: 0,\n                marginTop: 0\n            });\n        }\n    }\n    // add the hidden entries\n    for(let col = 0; col < cells.length; col += 1){\n        moreCnts.push(0);\n    }\n    for (let hiddenEntry of hiddenEntries){\n        let seg = segs[hiddenEntry.index];\n        let hiddenSpan = hiddenEntry.span;\n        multiColPlacements[hiddenSpan.start].push({\n            seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),\n            isVisible: false,\n            isAbsolute: true,\n            absoluteTop: 0,\n            marginTop: 0\n        });\n        for(let col = hiddenSpan.start; col < hiddenSpan.end; col += 1){\n            moreCnts[col] += 1;\n            singleColPlacements[col].push({\n                seg: resliceSeg(seg, col, col + 1, cells),\n                isVisible: false,\n                isAbsolute: false,\n                absoluteTop: 0,\n                marginTop: 0\n            });\n        }\n    }\n    // deal with leftover margins\n    for(let col = 0; col < cells.length; col += 1){\n        moreMarginTops.push(leftoverMargins[col]);\n    }\n    return {\n        singleColPlacements,\n        multiColPlacements,\n        moreCnts,\n        moreMarginTops\n    };\n}\n// rects ordered by top coord, then left\nfunction placeRects(allRects, segs, cells) {\n    let rectsByEachCol = groupRectsByEachCol(allRects, cells.length);\n    let singleColPlacements = [];\n    let multiColPlacements = [];\n    let leftoverMargins = [];\n    for(let col = 0; col < cells.length; col += 1){\n        let rects = rectsByEachCol[col];\n        // compute all static segs in singlePlacements\n        let singlePlacements = [];\n        let currentHeight = 0;\n        let currentMarginTop = 0;\n        for (let rect of rects){\n            let seg = segs[rect.index];\n            singlePlacements.push({\n                seg: resliceSeg(seg, col, col + 1, cells),\n                isVisible: true,\n                isAbsolute: false,\n                absoluteTop: rect.levelCoord,\n                marginTop: rect.levelCoord - currentHeight\n            });\n            currentHeight = rect.levelCoord + rect.thickness;\n        }\n        // compute mixed static/absolute segs in multiPlacements\n        let multiPlacements = [];\n        currentHeight = 0;\n        currentMarginTop = 0;\n        for (let rect of rects){\n            let seg = segs[rect.index];\n            let isAbsolute = rect.span.end - rect.span.start > 1; // multi-column?\n            let isFirstCol = rect.span.start === col;\n            currentMarginTop += rect.levelCoord - currentHeight; // amount of space since bottom of previous seg\n            currentHeight = rect.levelCoord + rect.thickness; // height will now be bottom of current seg\n            if (isAbsolute) {\n                currentMarginTop += rect.thickness;\n                if (isFirstCol) {\n                    multiPlacements.push({\n                        seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n                        isVisible: true,\n                        isAbsolute: true,\n                        absoluteTop: rect.levelCoord,\n                        marginTop: 0\n                    });\n                }\n            } else if (isFirstCol) {\n                multiPlacements.push({\n                    seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n                    isVisible: true,\n                    isAbsolute: false,\n                    absoluteTop: rect.levelCoord,\n                    marginTop: currentMarginTop\n                });\n                currentMarginTop = 0;\n            }\n        }\n        singleColPlacements.push(singlePlacements);\n        multiColPlacements.push(multiPlacements);\n        leftoverMargins.push(currentMarginTop);\n    }\n    return {\n        singleColPlacements,\n        multiColPlacements,\n        leftoverMargins\n    };\n}\nfunction groupRectsByEachCol(rects, colCnt) {\n    let rectsByEachCol = [];\n    for(let col = 0; col < colCnt; col += 1){\n        rectsByEachCol.push([]);\n    }\n    for (let rect of rects){\n        for(let col = rect.span.start; col < rect.span.end; col += 1){\n            rectsByEachCol[col].push(rect);\n        }\n    }\n    return rectsByEachCol;\n}\nfunction resliceSeg(seg, spanStart, spanEnd, cells) {\n    if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {\n        return seg;\n    }\n    let eventRange = seg.eventRange;\n    let origRange = eventRange.range;\n    let slicedRange = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.o)(origRange, {\n        start: cells[spanStart].date,\n        end: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.t)(cells[spanEnd - 1].date, 1)\n    });\n    return Object.assign(Object.assign({}, seg), {\n        firstCol: spanStart,\n        lastCol: spanEnd - 1,\n        eventRange: {\n            def: eventRange.def,\n            ui: Object.assign(Object.assign({}, eventRange.ui), {\n                durationEditable: false\n            }),\n            instance: eventRange.instance,\n            range: slicedRange\n        },\n        isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),\n        isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()\n    });\n}\nclass DayGridSegHierarchy extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bA {\n    constructor(){\n        super(...arguments);\n        // config\n        this.hiddenConsumes = false;\n        // allows us to keep hidden entries in the hierarchy so they take up space\n        this.forceHidden = {};\n    }\n    addSegs(segInputs) {\n        const hiddenSegs = super.addSegs(segInputs);\n        const { entriesByLevel } = this;\n        const excludeHidden = (entry)=>!this.forceHidden[(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bB)(entry)];\n        // remove the forced-hidden segs\n        for(let level = 0; level < entriesByLevel.length; level += 1){\n            entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);\n        }\n        return hiddenSegs;\n    }\n    handleInvalidInsertion(insertion, entry, hiddenEntries) {\n        const { entriesByLevel, forceHidden } = this;\n        const { touchingEntry, touchingLevel, touchingLateral } = insertion;\n        if (this.hiddenConsumes && touchingEntry) {\n            const touchingEntryId = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bB)(touchingEntry);\n            // if not already hidden\n            if (!forceHidden[touchingEntryId]) {\n                if (this.allowReslicing) {\n                    const placeholderEntry = Object.assign(Object.assign({}, touchingEntry), {\n                        span: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bF)(touchingEntry.span, entry.span)\n                    });\n                    const placeholderEntryId = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bB)(placeholderEntry);\n                    forceHidden[placeholderEntryId] = true;\n                    entriesByLevel[touchingLevel][touchingLateral] = placeholderEntry; // replace touchingEntry with our placeholder\n                    this.splitEntry(touchingEntry, entry, hiddenEntries); // split up the touchingEntry, reinsert it\n                } else {\n                    forceHidden[touchingEntryId] = true;\n                    hiddenEntries.push(touchingEntry);\n                }\n            }\n        }\n        return super.handleInvalidInsertion(insertion, entry, hiddenEntries);\n    }\n}\nclass TableRow extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be {\n    constructor(){\n        super(...arguments);\n        this.cellElRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cf(); // the <td>\n        this.frameElRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cf(); // the fc-daygrid-day-frame\n        this.fgElRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cf(); // the fc-daygrid-day-events\n        this.segHarnessRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cf(); // indexed by \"instanceId:firstCol\"\n        this.rootElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.state = {\n            framePositions: null,\n            maxContentHeight: null,\n            segHeights: {}\n        };\n        this.handleResize = (isForced)=>{\n            if (isForced) {\n                this.updateSizing(true); // isExternal=true\n            }\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let { options } = context;\n        let colCnt = props.cells.length;\n        let businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);\n        let bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);\n        let highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);\n        let mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);\n        let { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops } = computeFgSegPlacement((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bR)(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.segHeights, state.maxContentHeight, props.cells);\n        let isForcedInvisible = props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n            ref: this.rootElRef,\n            role: \"row\"\n        }, props.renderIntro && props.renderIntro(), props.cells.map((cell, col)=>{\n            let normalFgNodes = this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);\n            let mirrorFgNodes = this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);\n            return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableCell, {\n                key: cell.key,\n                elRef: this.cellElRefs.createRef(cell.key),\n                innerElRef: this.frameElRefs.createRef(cell.key),\n                dateProfile: props.dateProfile,\n                date: cell.date,\n                showDayNumber: props.showDayNumbers,\n                showWeekNumber: props.showWeekNumbers && col === 0,\n                forceDayTop: props.showWeekNumbers /* even displaying weeknum for row, not necessarily day */ ,\n                todayRange: props.todayRange,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                extraRenderProps: cell.extraRenderProps,\n                extraDataAttrs: cell.extraDataAttrs,\n                extraClassNames: cell.extraClassNames,\n                extraDateSpan: cell.extraDateSpan,\n                moreCnt: moreCnts[col],\n                moreMarginTop: moreMarginTops[col],\n                singlePlacements: singleColPlacements[col],\n                fgContentElRef: this.fgElRefs.createRef(cell.key),\n                fgContent: (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, normalFgNodes), (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, mirrorFgNodes)),\n                bgContent: (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, this.renderFillSegs(highlightSegsByCol[col], \"highlight\"), this.renderFillSegs(businessHoursByCol[col], \"non-business\"), this.renderFillSegs(bgEventSegsByCol[col], \"bg-event\")),\n                minHeight: props.cellMinHeight\n            });\n        }));\n    }\n    componentDidMount() {\n        this.updateSizing(true);\n        this.context.addResizeHandler(this.handleResize);\n    }\n    componentDidUpdate(prevProps, prevState) {\n        let currentProps = this.props;\n        this.updateSizing(!(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.E)(prevProps, currentProps));\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleResize);\n    }\n    getHighlightSegs() {\n        let { props } = this;\n        if (props.eventDrag && props.eventDrag.segs.length) {\n            return props.eventDrag.segs;\n        }\n        if (props.eventResize && props.eventResize.segs.length) {\n            return props.eventResize.segs;\n        }\n        return props.dateSelectionSegs;\n    }\n    getMirrorSegs() {\n        let { props } = this;\n        if (props.eventResize && props.eventResize.segs.length) {\n            return props.eventResize.segs;\n        }\n        return [];\n    }\n    renderFgSegs(col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\n        let { context } = this;\n        let { eventSelection } = this.props;\n        let { framePositions } = this.state;\n        let defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1\n        let isMirror = isDragging || isResizing || isDateSelecting;\n        let nodes = [];\n        if (framePositions) {\n            for (let placement of segPlacements){\n                let { seg } = placement;\n                let { instanceId } = seg.eventRange.instance;\n                let isVisible = placement.isVisible && !isForcedInvisible[instanceId];\n                let isAbsolute = placement.isAbsolute;\n                let left = \"\";\n                let right = \"\";\n                if (isAbsolute) {\n                    if (context.isRtl) {\n                        right = 0;\n                        left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];\n                    } else {\n                        left = 0;\n                        right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];\n                    }\n                }\n                /*\n                known bug: events that are force to be list-item but span multiple days still take up space in later columns\n                todo: in print view, for multi-day events, don't display title within non-start/end segs\n                */ nodes.push((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                    className: \"fc-daygrid-event-harness\" + (isAbsolute ? \" fc-daygrid-event-harness-abs\" : \"\"),\n                    key: generateSegKey(seg),\n                    ref: isMirror ? null : this.segHarnessRefs.createRef(generateSegUid(seg)),\n                    style: {\n                        visibility: isVisible ? \"\" : \"hidden\",\n                        marginTop: isAbsolute ? \"\" : placement.marginTop,\n                        top: isAbsolute ? placement.absoluteTop : \"\",\n                        left,\n                        right\n                    }\n                }, hasListItemDisplay(seg) ? (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableListItemEvent, Object.assign({\n                    seg: seg,\n                    isDragging: isDragging,\n                    isSelected: instanceId === eventSelection,\n                    defaultDisplayEventEnd: defaultDisplayEventEnd\n                }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bS)(seg, todayRange))) : (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableBlockEvent, Object.assign({\n                    seg: seg,\n                    isDragging: isDragging,\n                    isResizing: isResizing,\n                    isDateSelecting: isDateSelecting,\n                    isSelected: instanceId === eventSelection,\n                    defaultDisplayEventEnd: defaultDisplayEventEnd\n                }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bS)(seg, todayRange)))));\n            }\n        }\n        return nodes;\n    }\n    renderFillSegs(segs, fillType) {\n        let { isRtl } = this.context;\n        let { todayRange } = this.props;\n        let { framePositions } = this.state;\n        let nodes = [];\n        if (framePositions) {\n            for (let seg of segs){\n                let leftRightCss = isRtl ? {\n                    right: 0,\n                    left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]\n                } : {\n                    left: 0,\n                    right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]\n                };\n                nodes.push((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                    key: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bT)(seg.eventRange),\n                    className: \"fc-daygrid-bg-harness\",\n                    style: leftRightCss\n                }, fillType === \"bg-event\" ? (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cp, Object.assign({\n                    seg: seg\n                }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bS)(seg, todayRange))) : (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.co)(fillType)));\n            }\n        }\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, {}, ...nodes);\n    }\n    updateSizing(isExternalSizingChange) {\n        let { props, state, frameElRefs } = this;\n        if (!props.forPrint && props.clientWidth !== null // positioning ready?\n        ) {\n            if (isExternalSizingChange) {\n                let frameEls = props.cells.map((cell)=>frameElRefs.currentMap[cell.key]);\n                if (frameEls.length) {\n                    let originEl = this.rootElRef.current;\n                    let newPositionCache = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ba(originEl, frameEls, true, false);\n                    if (!state.framePositions || !state.framePositions.similarTo(newPositionCache)) {\n                        this.setState({\n                            framePositions: new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ba(originEl, frameEls, true, false)\n                        });\n                    }\n                }\n            }\n            const oldSegHeights = this.state.segHeights;\n            const newSegHeights = this.querySegHeights();\n            const limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;\n            this.safeSetState({\n                // HACK to prevent oscillations of events being shown/hidden from max-event-rows\n                // Essentially, once you compute an element's height, never null-out.\n                // TODO: always display all events, as visibility:hidden?\n                segHeights: Object.assign(Object.assign({}, oldSegHeights), newSegHeights),\n                maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null\n            });\n        }\n    }\n    querySegHeights() {\n        let segElMap = this.segHarnessRefs.currentMap;\n        let segHeights = {};\n        // get the max height amongst instance segs\n        for(let segUid in segElMap){\n            let height = Math.round(segElMap[segUid].getBoundingClientRect().height);\n            segHeights[segUid] = Math.max(segHeights[segUid] || 0, height);\n        }\n        return segHeights;\n    }\n    computeMaxContentHeight() {\n        let firstKey = this.props.cells[0].key;\n        let cellEl = this.cellElRefs.currentMap[firstKey];\n        let fcContainerEl = this.fgElRefs.currentMap[firstKey];\n        return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;\n    }\n    getCellEls() {\n        let elMap = this.cellElRefs.currentMap;\n        return this.props.cells.map((cell)=>elMap[cell.key]);\n    }\n}\nTableRow.addStateEquality({\n    segHeights: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.E\n});\nfunction buildMirrorPlacements(mirrorSegs, colPlacements) {\n    if (!mirrorSegs.length) {\n        return [];\n    }\n    let topsByInstanceId = buildAbsoluteTopHash(colPlacements); // TODO: cache this at first render?\n    return mirrorSegs.map((seg)=>({\n            seg,\n            isVisible: true,\n            isAbsolute: true,\n            absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],\n            marginTop: 0\n        }));\n}\nfunction buildAbsoluteTopHash(colPlacements) {\n    let topsByInstanceId = {};\n    for (let placements of colPlacements){\n        for (let placement of placements){\n            topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;\n        }\n    }\n    return topsByInstanceId;\n}\nclass TableRows extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be {\n    constructor(){\n        super(...arguments);\n        this.splitBusinessHourSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByRow);\n        this.splitBgEventSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByRow);\n        this.splitFgEventSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByRow);\n        this.splitDateSelectionSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByRow);\n        this.splitEventDrag = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitInteractionByRow);\n        this.splitEventResize = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitInteractionByRow);\n        this.rowRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cf();\n    }\n    render() {\n        let { props, context } = this;\n        let rowCnt = props.cells.length;\n        let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);\n        let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);\n        let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);\n        let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);\n        let eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);\n        let eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);\n        // for DayGrid view with many rows, force a min-height on cells so doesn't appear squished\n        // choose 7 because a month view will have max 6 rows\n        let cellMinHeight = rowCnt >= 7 && props.clientWidth ? props.clientWidth / context.options.aspectRatio / 6 : null;\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ch, {\n            unit: \"day\"\n        }, (nowDate, todayRange)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, props.cells.map((cells, row)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableRow, {\n                    ref: this.rowRefs.createRef(row),\n                    key: cells.length ? cells[0].date.toISOString() : row // in case there are no cells (like when resource view is loading)\n                    ,\n                    showDayNumbers: rowCnt > 1,\n                    showWeekNumbers: props.showWeekNumbers,\n                    todayRange: todayRange,\n                    dateProfile: props.dateProfile,\n                    cells: cells,\n                    renderIntro: props.renderRowIntro,\n                    businessHourSegs: businessHourSegsByRow[row],\n                    eventSelection: props.eventSelection,\n                    bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay),\n                    fgEventSegs: fgEventSegsByRow[row],\n                    dateSelectionSegs: dateSelectionSegsByRow[row],\n                    eventDrag: eventDragByRow[row],\n                    eventResize: eventResizeByRow[row],\n                    dayMaxEvents: props.dayMaxEvents,\n                    dayMaxEventRows: props.dayMaxEventRows,\n                    clientWidth: props.clientWidth,\n                    clientHeight: props.clientHeight,\n                    cellMinHeight: cellMinHeight,\n                    forPrint: props.forPrint\n                }))));\n    }\n    componentDidMount() {\n        this.registerInteractiveComponent();\n    }\n    componentDidUpdate() {\n        // for if started with zero cells\n        this.registerInteractiveComponent();\n    }\n    registerInteractiveComponent() {\n        if (!this.rootEl) {\n            // HACK: need a daygrid wrapper parent to do positioning\n            // NOTE: a daygrid resource view w/o resources can have zero cells\n            const firstCellEl = this.rowRefs.currentMap[0].getCellEls()[0];\n            const rootEl = firstCellEl ? firstCellEl.closest(\".fc-daygrid-body\") : null;\n            if (rootEl) {\n                this.rootEl = rootEl;\n                this.context.registerInteractiveComponent(this, {\n                    el: rootEl,\n                    isHitComboAllowed: this.props.isHitComboAllowed\n                });\n            }\n        }\n    }\n    componentWillUnmount() {\n        if (this.rootEl) {\n            this.context.unregisterInteractiveComponent(this);\n            this.rootEl = null;\n        }\n    }\n    // Hit System\n    // ----------------------------------------------------------------------------------------------------\n    prepareHits() {\n        this.rowPositions = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ba(this.rootEl, this.rowRefs.collect().map((rowObj)=>rowObj.getCellEls()[0]), false, true);\n        this.colPositions = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ba(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), true, false);\n    }\n    queryHit(positionLeft, positionTop) {\n        let { colPositions, rowPositions } = this;\n        let col = colPositions.leftToIndex(positionLeft);\n        let row = rowPositions.topToIndex(positionTop);\n        if (row != null && col != null) {\n            let cell = this.props.cells[row][col];\n            return {\n                dateProfile: this.props.dateProfile,\n                dateSpan: Object.assign({\n                    range: this.getCellRange(row, col),\n                    allDay: true\n                }, cell.extraDateSpan),\n                dayEl: this.getCellEl(row, col),\n                rect: {\n                    left: colPositions.lefts[col],\n                    right: colPositions.rights[col],\n                    top: rowPositions.tops[row],\n                    bottom: rowPositions.bottoms[row]\n                },\n                layer: 0\n            };\n        }\n        return null;\n    }\n    getCellEl(row, col) {\n        return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal\n    }\n    getCellRange(row, col) {\n        let start = this.props.cells[row][col].date;\n        let end = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.t)(start, 1);\n        return {\n            start,\n            end\n        };\n    }\n}\nfunction isSegAllDay(seg) {\n    return seg.eventRange.def.allDay;\n}\nclass Table extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be {\n    constructor(){\n        super(...arguments);\n        this.elRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.needsScrollReset = false;\n    }\n    render() {\n        let { props } = this;\n        let { dayMaxEventRows, dayMaxEvents, expandRows } = props;\n        let limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;\n        // if rows can't expand to fill fixed height, can't do balanced-height event limit\n        // TODO: best place to normalize these options?\n        if (limitViaBalanced && !expandRows) {\n            limitViaBalanced = false;\n            dayMaxEventRows = null;\n            dayMaxEvents = null;\n        }\n        let classNames = [\n            \"fc-daygrid-body\",\n            limitViaBalanced ? \"fc-daygrid-body-balanced\" : \"fc-daygrid-body-unbalanced\",\n            expandRows ? \"\" : \"fc-daygrid-body-natural\"\n        ];\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            ref: this.elRef,\n            className: classNames.join(\" \"),\n            style: {\n                // these props are important to give this wrapper correct dimensions for interactions\n                // TODO: if we set it here, can we avoid giving to inner tables?\n                width: props.clientWidth,\n                minWidth: props.tableMinWidth\n            }\n        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"table\", {\n            role: \"presentation\",\n            className: \"fc-scrollgrid-sync-table\",\n            style: {\n                width: props.clientWidth,\n                minWidth: props.tableMinWidth,\n                height: expandRows ? props.clientHeight : \"\"\n            }\n        }, props.colGroupNode, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tbody\", {\n            role: \"presentation\"\n        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableRows, {\n            dateProfile: props.dateProfile,\n            cells: props.cells,\n            renderRowIntro: props.renderRowIntro,\n            showWeekNumbers: props.showWeekNumbers,\n            clientWidth: props.clientWidth,\n            clientHeight: props.clientHeight,\n            businessHourSegs: props.businessHourSegs,\n            bgEventSegs: props.bgEventSegs,\n            fgEventSegs: props.fgEventSegs,\n            dateSelectionSegs: props.dateSelectionSegs,\n            eventSelection: props.eventSelection,\n            eventDrag: props.eventDrag,\n            eventResize: props.eventResize,\n            dayMaxEvents: dayMaxEvents,\n            dayMaxEventRows: dayMaxEventRows,\n            forPrint: props.forPrint,\n            isHitComboAllowed: props.isHitComboAllowed\n        }))));\n    }\n    componentDidMount() {\n        this.requestScrollReset();\n    }\n    componentDidUpdate(prevProps) {\n        if (prevProps.dateProfile !== this.props.dateProfile) {\n            this.requestScrollReset();\n        } else {\n            this.flushScrollReset();\n        }\n    }\n    requestScrollReset() {\n        this.needsScrollReset = true;\n        this.flushScrollReset();\n    }\n    flushScrollReset() {\n        if (this.needsScrollReset && this.props.clientWidth // sizes computed?\n        ) {\n            const subjectEl = getScrollSubjectEl(this.elRef.current, this.props.dateProfile);\n            if (subjectEl) {\n                const originEl = subjectEl.closest(\".fc-daygrid-body\");\n                const scrollEl = originEl.closest(\".fc-scroller\");\n                const scrollTop = subjectEl.getBoundingClientRect().top - originEl.getBoundingClientRect().top;\n                scrollEl.scrollTop = scrollTop ? scrollTop + 1 : 0; // overcome border\n            }\n            this.needsScrollReset = false;\n        }\n    }\n}\nfunction getScrollSubjectEl(containerEl, dateProfile) {\n    let el;\n    if (dateProfile.currentRangeUnit.match(/year|month/)) {\n        el = containerEl.querySelector(`[data-date=\"${(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bx)(dateProfile.currentDate)}-01\"]`);\n    // even if view is month-based, first-of-month might be hidden...\n    }\n    if (!el) {\n        el = containerEl.querySelector(`[data-date=\"${(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bv)(dateProfile.currentDate)}\"]`);\n    // could still be hidden if an interior-view hidden day\n    }\n    return el;\n}\nclass DayTableSlicer extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bW {\n    constructor(){\n        super(...arguments);\n        this.forceDayIfListItem = true;\n    }\n    sliceRange(dateRange, dayTableModel) {\n        return dayTableModel.sliceRange(dateRange);\n    }\n}\nclass DayTable extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be {\n    constructor(){\n        super(...arguments);\n        this.slicer = new DayTableSlicer();\n        this.tableRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    }\n    render() {\n        let { props, context } = this;\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(Table, Object.assign({\n            ref: this.tableRef\n        }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), {\n            dateProfile: props.dateProfile,\n            cells: props.dayTableModel.cells,\n            colGroupNode: props.colGroupNode,\n            tableMinWidth: props.tableMinWidth,\n            renderRowIntro: props.renderRowIntro,\n            dayMaxEvents: props.dayMaxEvents,\n            dayMaxEventRows: props.dayMaxEventRows,\n            showWeekNumbers: props.showWeekNumbers,\n            expandRows: props.expandRows,\n            headerAlignElRef: props.headerAlignElRef,\n            clientWidth: props.clientWidth,\n            clientHeight: props.clientHeight,\n            forPrint: props.forPrint\n        }));\n    }\n}\nclass DayTableView extends TableView {\n    constructor(){\n        super(...arguments);\n        this.buildDayTableModel = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildDayTableModel);\n        this.headerRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.tableRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    // can't override any lifecycle methods from parent\n    }\n    render() {\n        let { options, dateProfileGenerator } = this.context;\n        let { props } = this;\n        let dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);\n        let headerContent = options.dayHeaders && (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bK, {\n            ref: this.headerRef,\n            dateProfile: props.dateProfile,\n            dates: dayTableModel.headerDates,\n            datesRepDistinctDays: dayTableModel.rowCnt === 1\n        });\n        let bodyContent = (contentArg)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(DayTable, {\n                ref: this.tableRef,\n                dateProfile: props.dateProfile,\n                dayTableModel: dayTableModel,\n                businessHours: props.businessHours,\n                dateSelection: props.dateSelection,\n                eventStore: props.eventStore,\n                eventUiBases: props.eventUiBases,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                nextDayThreshold: options.nextDayThreshold,\n                colGroupNode: contentArg.tableColGroupNode,\n                tableMinWidth: contentArg.tableMinWidth,\n                dayMaxEvents: options.dayMaxEvents,\n                dayMaxEventRows: options.dayMaxEventRows,\n                showWeekNumbers: options.weekNumbers,\n                expandRows: !props.isHeightAuto,\n                headerAlignElRef: this.headerElRef,\n                clientWidth: contentArg.clientWidth,\n                clientHeight: contentArg.clientHeight,\n                forPrint: props.forPrint\n            });\n        return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);\n    }\n}\nfunction buildDayTableModel(dateProfile, dateProfileGenerator) {\n    let daySeries = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bO(dateProfile.renderRange, dateProfileGenerator);\n    return new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bV(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));\n}\nclass TableDateProfileGenerator extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.U {\n    // Computes the date range that will be rendered\n    buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {\n        let renderRange = super.buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay);\n        let { props } = this;\n        return buildDayTableRenderRange({\n            currentRange: renderRange,\n            snapToWeek: /^(year|month)$/.test(currentRangeUnit),\n            fixedWeekCount: props.fixedWeekCount,\n            dateEnv: props.dateEnv\n        });\n    }\n}\nfunction buildDayTableRenderRange(props) {\n    let { dateEnv, currentRange } = props;\n    let { start, end } = currentRange;\n    let endOfWeek;\n    // year and month views should be aligned with weeks. this is already done for week\n    if (props.snapToWeek) {\n        start = dateEnv.startOfWeek(start);\n        // make end-of-week if not already\n        endOfWeek = dateEnv.startOfWeek(end);\n        if (endOfWeek.valueOf() !== end.valueOf()) {\n            end = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bh)(endOfWeek, 1);\n        }\n    }\n    // ensure 6 weeks\n    if (props.fixedWeekCount) {\n        // TODO: instead of these date-math gymnastics (for multimonth view),\n        // compute dateprofiles of all months, then use start of first and end of last.\n        let lastMonthRenderStart = dateEnv.startOfWeek(dateEnv.startOfMonth((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.t)(currentRange.end, -1)));\n        let rowCnt = Math.ceil((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bi)(lastMonthRenderStart, end));\n        end = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bh)(end, 6 - rowCnt);\n    }\n    return {\n        start,\n        end\n    };\n}\nvar css_248z = ':root{--fc-daygrid-event-dot-width:8px}.fc-daygrid-day-events:after,.fc-daygrid-day-events:before,.fc-daygrid-day-frame:after,.fc-daygrid-day-frame:before,.fc-daygrid-event-harness:after,.fc-daygrid-event-harness:before{clear:both;content:\"\";display:table}.fc .fc-daygrid-body{position:relative;z-index:1}.fc .fc-daygrid-day.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-daygrid-day-frame{min-height:100%;position:relative}.fc .fc-daygrid-day-top{display:flex;flex-direction:row-reverse}.fc .fc-day-other .fc-daygrid-day-top{opacity:.3}.fc .fc-daygrid-day-number{padding:4px;position:relative;z-index:4}.fc .fc-daygrid-month-start{font-size:1.1em;font-weight:700}.fc .fc-daygrid-day-events{margin-top:1px}.fc .fc-daygrid-body-balanced .fc-daygrid-day-events{left:0;position:absolute;right:0}.fc .fc-daygrid-body-unbalanced .fc-daygrid-day-events{min-height:2em;position:relative}.fc .fc-daygrid-body-natural .fc-daygrid-day-events{margin-bottom:1em}.fc .fc-daygrid-event-harness{position:relative}.fc .fc-daygrid-event-harness-abs{left:0;position:absolute;right:0;top:0}.fc .fc-daygrid-bg-harness{bottom:0;position:absolute;top:0}.fc .fc-daygrid-day-bg .fc-non-business{z-index:1}.fc .fc-daygrid-day-bg .fc-bg-event{z-index:2}.fc .fc-daygrid-day-bg .fc-highlight{z-index:3}.fc .fc-daygrid-event{margin-top:1px;z-index:6}.fc .fc-daygrid-event.fc-event-mirror{z-index:7}.fc .fc-daygrid-day-bottom{font-size:.85em;margin:0 2px}.fc .fc-daygrid-day-bottom:after,.fc .fc-daygrid-day-bottom:before{clear:both;content:\"\";display:table}.fc .fc-daygrid-more-link{border-radius:3px;cursor:pointer;line-height:1;margin-top:1px;max-width:100%;overflow:hidden;padding:2px;position:relative;white-space:nowrap;z-index:4}.fc .fc-daygrid-more-link:hover{background-color:rgba(0,0,0,.1)}.fc .fc-daygrid-week-number{background-color:var(--fc-neutral-bg-color);color:var(--fc-neutral-text-color);min-width:1.5em;padding:2px;position:absolute;text-align:center;top:0;z-index:5}.fc .fc-more-popover .fc-popover-body{min-width:220px;padding:10px}.fc-direction-ltr .fc-daygrid-event.fc-event-start,.fc-direction-rtl .fc-daygrid-event.fc-event-end{margin-left:2px}.fc-direction-ltr .fc-daygrid-event.fc-event-end,.fc-direction-rtl .fc-daygrid-event.fc-event-start{margin-right:2px}.fc-direction-ltr .fc-daygrid-more-link{float:left}.fc-direction-ltr .fc-daygrid-week-number{border-radius:0 0 3px 0;left:0}.fc-direction-rtl .fc-daygrid-more-link{float:right}.fc-direction-rtl .fc-daygrid-week-number{border-radius:0 0 0 3px;right:0}.fc-liquid-hack .fc-daygrid-day-frame{position:static}.fc-daygrid-event{border-radius:3px;font-size:var(--fc-small-font-size);position:relative;white-space:nowrap}.fc-daygrid-block-event .fc-event-time{font-weight:700}.fc-daygrid-block-event .fc-event-time,.fc-daygrid-block-event .fc-event-title{padding:1px}.fc-daygrid-dot-event{align-items:center;display:flex;padding:2px 0}.fc-daygrid-dot-event .fc-event-title{flex-grow:1;flex-shrink:1;font-weight:700;min-width:0;overflow:hidden}.fc-daygrid-dot-event.fc-event-mirror,.fc-daygrid-dot-event:hover{background:rgba(0,0,0,.1)}.fc-daygrid-dot-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-daygrid-event-dot{border:calc(var(--fc-daygrid-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-daygrid-event-dot-width)/2);box-sizing:content-box;height:0;margin:0 4px;width:0}.fc-direction-ltr .fc-daygrid-event .fc-event-time{margin-right:3px}.fc-direction-rtl .fc-daygrid-event .fc-event-time{margin-left:3px}';\n(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cw)(css_248z);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL2ludGVybmFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQTZ0QjtBQUMzb0I7QUFFbEY7c0hBQ3NILEdBQ3RILGtGQUFrRjtBQUNsRiwrQ0FBK0M7QUFDL0MsTUFBTWdELGtCQUFrQmhELDhEQUFhQTtJQUNqQ2lELGFBQWM7UUFDVixLQUFLLElBQUlDO1FBQ1QsSUFBSSxDQUFDQyxXQUFXLEdBQUdOLHVFQUFTQTtJQUNoQztJQUNBTyxtQkFBbUJDLGdCQUFnQixFQUFFQyxXQUFXLEVBQUU7UUFDOUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLE9BQU8sRUFBRSxHQUFHLElBQUk7UUFDN0IsSUFBSUMsV0FBVyxFQUFFO1FBQ2pCLElBQUlDLG9CQUFvQnpELGtFQUFvQkEsQ0FBQ3VELFFBQVFHLE9BQU87UUFDNUQsSUFBSU4sa0JBQWtCO1lBQ2xCSSxTQUFTRyxJQUFJLENBQUM7Z0JBQ1ZDLE1BQU07Z0JBQ05DLEtBQUs7Z0JBQ0xDLFVBQVVMO2dCQUNWTSxPQUFPO29CQUNIQyxPQUFPLElBQUksQ0FBQ2QsV0FBVztvQkFDdkJlLGdCQUFnQjtvQkFDaEJDLFlBQVlkO2dCQUNoQjtZQUNKO1FBQ0o7UUFDQUksU0FBU0csSUFBSSxDQUFDO1lBQ1ZDLE1BQU07WUFDTkMsS0FBSztZQUNMTSxRQUFRO1lBQ1JKLE9BQU87Z0JBQUVLLFNBQVNmO1lBQVk7UUFDbEM7UUFDQSxPQUFRUiwyRUFBYUEsQ0FBQzVDLDhEQUFhQSxFQUFFO1lBQUVvRSxXQUFXO2dCQUFDO2FBQWE7WUFBRUMsVUFBVWYsUUFBUWUsUUFBUTtRQUFDLEdBQ3pGekIsMkVBQWFBLENBQUMzQyw4REFBZ0JBLEVBQUU7WUFBRWlFLFFBQVEsQ0FBQ2IsTUFBTWlCLFlBQVksSUFBSSxDQUFDakIsTUFBTWtCLFFBQVE7WUFBRUMsa0JBQWtCbkIsTUFBTWtCLFFBQVE7WUFBRUUsTUFBTSxFQUFFO1lBQTZCbEIsVUFBVUE7UUFB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SUFDaEMsSUFBSSxFQUFFaUosS0FBSyxFQUFFRSxHQUFHLEVBQUUsR0FBR3hCO0lBQ3JCLElBQUlpUztJQUNKLG1GQUFtRjtJQUNuRixJQUFJNVosTUFBTTBaLFVBQVUsRUFBRTtRQUNsQnpRLFFBQVEzQixRQUFRdVMsV0FBVyxDQUFDNVE7UUFDNUIsa0NBQWtDO1FBQ2xDMlEsWUFBWXRTLFFBQVF1UyxXQUFXLENBQUMxUTtRQUNoQyxJQUFJeVEsVUFBVS9QLE9BQU8sT0FBT1YsSUFBSVUsT0FBTyxJQUFJO1lBQ3ZDVixNQUFNaEssa0VBQVFBLENBQUN5YSxXQUFXO1FBQzlCO0lBQ0o7SUFDQSxpQkFBaUI7SUFDakIsSUFBSTVaLE1BQU0yWixjQUFjLEVBQUU7UUFDdEIscUVBQXFFO1FBQ3JFLCtFQUErRTtRQUMvRSxJQUFJRyx1QkFBdUJ4UyxRQUFRdVMsV0FBVyxDQUFDdlMsUUFBUXlTLFlBQVksQ0FBQy9iLGlFQUFPQSxDQUFDMkosYUFBYXdCLEdBQUcsRUFBRSxDQUFDO1FBQy9GLElBQUloSCxTQUFTcVEsS0FBS3dILElBQUksQ0FDdEI1YSxrRUFBU0EsQ0FBQzBhLHNCQUFzQjNRO1FBQ2hDQSxNQUFNaEssa0VBQVFBLENBQUNnSyxLQUFLLElBQUloSDtJQUM1QjtJQUNBLE9BQU87UUFBRThHO1FBQU9FO0lBQUk7QUFDeEI7QUFFQSxJQUFJOFEsV0FBVztBQUNmNWEsa0VBQVlBLENBQUM0YTtBQUUwSiIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvZGF5Z3JpZC9pbnRlcm5hbC5qcz85NTE1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERhdGVDb21wb25lbnQsIGdldFN0aWNreUhlYWRlckRhdGVzLCBWaWV3Q29udGFpbmVyLCBTaW1wbGVTY3JvbGxHcmlkLCBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIsIHJlbmRlclNjcm9sbFNoaW0sIGNyZWF0ZUZvcm1hdHRlciwgQmFzZUNvbXBvbmVudCwgU3RhbmRhcmRFdmVudCwgYnVpbGRTZWdUaW1lVGV4dCwgRXZlbnRDb250YWluZXIsIGdldFNlZ0FuY2hvckF0dHJzLCBtZW1vaXplLCBNb3JlTGlua0NvbnRhaW5lciwgZ2V0U2VnTWV0YSwgZ2V0VW5pcXVlRG9tSWQsIHNldFJlZiwgRGF5Q2VsbENvbnRhaW5lciwgV2Vla051bWJlckNvbnRhaW5lciwgYnVpbGROYXZMaW5rQXR0cnMsIGhhc0N1c3RvbURheUNlbGxDb250ZW50LCBhZGRNcywgaW50ZXJzZWN0UmFuZ2VzLCBhZGREYXlzLCBTZWdIaWVyYXJjaHksIGJ1aWxkRW50cnlLZXksIGludGVyc2VjdFNwYW5zLCBSZWZNYXAsIHNvcnRFdmVudFNlZ3MsIGlzUHJvcHNFcXVhbCwgYnVpbGRFdmVudFJhbmdlS2V5LCBCZ0V2ZW50LCByZW5kZXJGaWxsLCBQb3NpdGlvbkNhY2hlLCBOb3dUaW1lciwgZm9ybWF0SXNvTW9udGhTdHIsIGZvcm1hdERheVN0cmluZywgU2xpY2VyLCBEYXlIZWFkZXIsIERheVNlcmllc01vZGVsLCBEYXlUYWJsZU1vZGVsLCBEYXRlUHJvZmlsZUdlbmVyYXRvciwgYWRkV2Vla3MsIGRpZmZXZWVrcywgaW5qZWN0U3R5bGVzIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLmpzJztcbmltcG9ydCB7IGNyZWF0ZVJlZiwgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvcHJlYWN0LmpzJztcblxuLyogQW4gYWJzdHJhY3QgY2xhc3MgZm9yIHRoZSBkYXlncmlkIHZpZXdzLCBhcyB3ZWxsIGFzIG1vbnRoIHZpZXcuIFJlbmRlcnMgb25lIG9yIG1vcmUgcm93cyBvZiBkYXkgY2VsbHMuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIEl0IGlzIGEgbWFuYWdlciBmb3IgYSBUYWJsZSBzdWJjb21wb25lbnQsIHdoaWNoIGRvZXMgbW9zdCBvZiB0aGUgaGVhdnkgbGlmdGluZy5cbi8vIEl0IGlzIHJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyB3aWR0aC9oZWlnaHQuXG5jbGFzcyBUYWJsZVZpZXcgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5oZWFkZXJFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgIH1cbiAgICByZW5kZXJTaW1wbGVMYXlvdXQoaGVhZGVyUm93Q29udGVudCwgYm9keUNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgc3RpY2t5SGVhZGVyRGF0ZXMgPSBnZXRTdGlja3lIZWFkZXJEYXRlcyhjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICBpZiAoaGVhZGVyUm93Q29udGVudCkge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAga2V5OiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogc3RpY2t5SGVhZGVyRGF0ZXMsXG4gICAgICAgICAgICAgICAgY2h1bms6IHtcbiAgICAgICAgICAgICAgICAgICAgZWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3NOYW1lOiAnZmMtY29sLWhlYWRlcicsXG4gICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2JvZHknLFxuICAgICAgICAgICAga2V5OiAnYm9keScsXG4gICAgICAgICAgICBsaXF1aWQ6IHRydWUsXG4gICAgICAgICAgICBjaHVuazogeyBjb250ZW50OiBib2R5Q29udGVudCB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFZpZXdDb250YWluZXIsIHsgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQnXSwgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoU2ltcGxlU2Nyb2xsR3JpZCwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50LCBjb2xsYXBzaWJsZVdpZHRoOiBwcm9wcy5mb3JQcmludCwgY29sczogW10gLyogVE9ETzogbWFrZSBvcHRpb25hbD8gKi8sIHNlY3Rpb25zOiBzZWN0aW9ucyB9KSkpO1xuICAgIH1cbiAgICByZW5kZXJIU2Nyb2xsTGF5b3V0KGhlYWRlclJvd0NvbnRlbnQsIGJvZHlDb250ZW50LCBjb2xDbnQsIGRheU1pbldpZHRoKSB7XG4gICAgICAgIGxldCBTY3JvbGxHcmlkID0gdGhpcy5jb250ZXh0LnBsdWdpbkhvb2tzLnNjcm9sbEdyaWRJbXBsO1xuICAgICAgICBpZiAoIVNjcm9sbEdyaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gU2Nyb2xsR3JpZCBpbXBsZW1lbnRhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgc3RpY2t5SGVhZGVyRGF0ZXMgPSAhcHJvcHMuZm9yUHJpbnQgJiYgZ2V0U3RpY2t5SGVhZGVyRGF0ZXMoY29udGV4dC5vcHRpb25zKTtcbiAgICAgICAgbGV0IHN0aWNreUZvb3RlclNjcm9sbGJhciA9ICFwcm9wcy5mb3JQcmludCAmJiBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIoY29udGV4dC5vcHRpb25zKTtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW107XG4gICAgICAgIGlmIChoZWFkZXJSb3dDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiBzdGlja3lIZWFkZXJEYXRlcyxcbiAgICAgICAgICAgICAgICBjaHVua3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdtYWluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICBrZXk6ICdib2R5JyxcbiAgICAgICAgICAgIGxpcXVpZDogdHJ1ZSxcbiAgICAgICAgICAgIGNodW5rczogW3tcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnbWFpbicsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGJvZHlDb250ZW50LFxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN0aWNreUZvb3RlclNjcm9sbGJhcikge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Zvb3RlcicsXG4gICAgICAgICAgICAgICAga2V5OiAnZm9vdGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaHVua3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdtYWluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHJlbmRlclNjcm9sbFNoaW0sXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFZpZXdDb250YWluZXIsIHsgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQnXSwgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoU2Nyb2xsR3JpZCwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsIGNvbGxhcHNpYmxlV2lkdGg6IHByb3BzLmZvclByaW50LCBjb2xHcm91cHM6IFt7IGNvbHM6IFt7IHNwYW46IGNvbENudCwgbWluV2lkdGg6IGRheU1pbldpZHRoIH1dIH1dLCBzZWN0aW9uczogc2VjdGlvbnMgfSkpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNwbGl0U2Vnc0J5Um93KHNlZ3MsIHJvd0NudCkge1xuICAgIGxldCBieVJvdyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q250OyBpICs9IDEpIHtcbiAgICAgICAgYnlSb3dbaV0gPSBbXTtcbiAgICB9XG4gICAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICAgICAgYnlSb3dbc2VnLnJvd10ucHVzaChzZWcpO1xuICAgIH1cbiAgICByZXR1cm4gYnlSb3c7XG59XG5mdW5jdGlvbiBzcGxpdFNlZ3NCeUZpcnN0Q29sKHNlZ3MsIGNvbENudCkge1xuICAgIGxldCBieUNvbCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sQ250OyBpICs9IDEpIHtcbiAgICAgICAgYnlDb2xbaV0gPSBbXTtcbiAgICB9XG4gICAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICAgICAgYnlDb2xbc2VnLmZpcnN0Q29sXS5wdXNoKHNlZyk7XG4gICAgfVxuICAgIHJldHVybiBieUNvbDtcbn1cbmZ1bmN0aW9uIHNwbGl0SW50ZXJhY3Rpb25CeVJvdyh1aSwgcm93Q250KSB7XG4gICAgbGV0IGJ5Um93ID0gW107XG4gICAgaWYgKCF1aSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NudDsgaSArPSAxKSB7XG4gICAgICAgICAgICBieVJvd1tpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q250OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGJ5Um93W2ldID0ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkSW5zdGFuY2VzOiB1aS5hZmZlY3RlZEluc3RhbmNlcyxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiB1aS5pc0V2ZW50LFxuICAgICAgICAgICAgICAgIHNlZ3M6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBzZWcgb2YgdWkuc2Vncykge1xuICAgICAgICAgICAgYnlSb3dbc2VnLnJvd10uc2Vncy5wdXNoKHNlZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ5Um93O1xufVxuXG5jb25zdCBERUZBVUxUX1RBQkxFX0VWRU5UX1RJTUVfRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHtcbiAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgbWludXRlOiAnMi1kaWdpdCcsXG4gICAgb21pdFplcm9NaW51dGU6IHRydWUsXG4gICAgbWVyaWRpZW06ICduYXJyb3cnLFxufSk7XG5mdW5jdGlvbiBoYXNMaXN0SXRlbURpc3BsYXkoc2VnKSB7XG4gICAgbGV0IHsgZGlzcGxheSB9ID0gc2VnLmV2ZW50UmFuZ2UudWk7XG4gICAgcmV0dXJuIGRpc3BsYXkgPT09ICdsaXN0LWl0ZW0nIHx8IChkaXNwbGF5ID09PSAnYXV0bycgJiZcbiAgICAgICAgIXNlZy5ldmVudFJhbmdlLmRlZi5hbGxEYXkgJiZcbiAgICAgICAgc2VnLmZpcnN0Q29sID09PSBzZWcubGFzdENvbCAmJiAvLyBjYW4ndCBiZSBtdWx0aS1kYXlcbiAgICAgICAgc2VnLmlzU3RhcnQgJiYgLy8gXCJcbiAgICAgICAgc2VnLmlzRW5kIC8vIFwiXG4gICAgKTtcbn1cblxuY2xhc3MgVGFibGVCbG9ja0V2ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFN0YW5kYXJkRXZlbnQsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGVsQ2xhc3NlczogWydmYy1kYXlncmlkLWV2ZW50JywgJ2ZjLWRheWdyaWQtYmxvY2stZXZlbnQnLCAnZmMtaC1ldmVudCddLCBkZWZhdWx0VGltZUZvcm1hdDogREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudEVuZCwgZGlzYWJsZVJlc2l6aW5nOiAhcHJvcHMuc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheSB9KSkpO1xuICAgIH1cbn1cblxuY2xhc3MgVGFibGVMaXN0SXRlbUV2ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHsgc2VnIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IHRpbWVGb3JtYXQgPSBvcHRpb25zLmV2ZW50VGltZUZvcm1hdCB8fCBERUZBVUxUX1RBQkxFX0VWRU5UX1RJTUVfRk9STUFUO1xuICAgICAgICBsZXQgdGltZVRleHQgPSBidWlsZFNlZ1RpbWVUZXh0KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgdHJ1ZSwgcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudEVuZCk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChFdmVudENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHsgZWxUYWc6IFwiYVwiLCBlbENsYXNzZXM6IFsnZmMtZGF5Z3JpZC1ldmVudCcsICdmYy1kYXlncmlkLWRvdC1ldmVudCddLCBlbEF0dHJzOiBnZXRTZWdBbmNob3JBdHRycyhwcm9wcy5zZWcsIGNvbnRleHQpLCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lckNvbnRlbnQsIHRpbWVUZXh0OiB0aW1lVGV4dCwgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UgfSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQocmVuZGVyUHJvcHMpIHtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1ldmVudC1kb3RcIiwgc3R5bGU6IHsgYm9yZGVyQ29sb3I6IHJlbmRlclByb3BzLmJvcmRlckNvbG9yIHx8IHJlbmRlclByb3BzLmJhY2tncm91bmRDb2xvciB9IH0pLFxuICAgICAgICByZW5kZXJQcm9wcy50aW1lVGV4dCAmJiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aW1lXCIgfSwgcmVuZGVyUHJvcHMudGltZVRleHQpKSxcbiAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aXRsZVwiIH0sIHJlbmRlclByb3BzLmV2ZW50LnRpdGxlIHx8IGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIFwiXFx1MDBBMFwiKSkpKTtcbn1cblxuY2xhc3MgVGFibGVDZWxsTW9yZUxpbmsgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jb21waWxlU2VncyA9IG1lbW9pemUoY29tcGlsZVNlZ3MpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBhbGxTZWdzLCBpbnZpc2libGVTZWdzIH0gPSB0aGlzLmNvbXBpbGVTZWdzKHByb3BzLnNpbmdsZVBsYWNlbWVudHMpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTW9yZUxpbmtDb250YWluZXIsIHsgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQtbW9yZS1saW5rJ10sIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgYWxsRGF5RGF0ZTogcHJvcHMuYWxsRGF5RGF0ZSwgbW9yZUNudDogcHJvcHMubW9yZUNudCwgYWxsU2VnczogYWxsU2VncywgaGlkZGVuU2VnczogaW52aXNpYmxlU2VncywgYWxpZ25tZW50RWxSZWY6IHByb3BzLmFsaWdubWVudEVsUmVmLCBhbGlnbkdyaWRUb3A6IHByb3BzLmFsaWduR3JpZFRvcCwgZXh0cmFEYXRlU3BhbjogcHJvcHMuZXh0cmFEYXRlU3BhbiwgcG9wb3ZlckNvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaXNGb3JjZWRJbnZpc2libGUgPSAocHJvcHMuZXZlbnREcmFnID8gcHJvcHMuZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplID8gcHJvcHMuZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMgOiBudWxsKSB8fFxuICAgICAgICAgICAgICAgICAgICB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIGFsbFNlZ3MubWFwKChzZWcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluc3RhbmNlSWQgPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzXCIsIGtleTogaW5zdGFuY2VJZCwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBpc0ZvcmNlZEludmlzaWJsZVtpbnN0YW5jZUlkXSA/ICdoaWRkZW4nIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICB9IH0sIGhhc0xpc3RJdGVtRGlzcGxheShzZWcpID8gKGNyZWF0ZUVsZW1lbnQoVGFibGVMaXN0SXRlbUV2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZmFsc2UgfSwgZ2V0U2VnTWV0YShzZWcsIHByb3BzLnRvZGF5UmFuZ2UpKSkpIDogKGNyZWF0ZUVsZW1lbnQoVGFibGVCbG9ja0V2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGZhbHNlLCBpc1Jlc2l6aW5nOiBmYWxzZSwgaXNEYXRlU2VsZWN0aW5nOiBmYWxzZSwgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IGZhbHNlIH0sIGdldFNlZ01ldGEoc2VnLCBwcm9wcy50b2RheVJhbmdlKSkpKSkpO1xuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9IH0pKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21waWxlU2VncyhzaW5nbGVQbGFjZW1lbnRzKSB7XG4gICAgbGV0IGFsbFNlZ3MgPSBbXTtcbiAgICBsZXQgaW52aXNpYmxlU2VncyA9IFtdO1xuICAgIGZvciAobGV0IHBsYWNlbWVudCBvZiBzaW5nbGVQbGFjZW1lbnRzKSB7XG4gICAgICAgIGFsbFNlZ3MucHVzaChwbGFjZW1lbnQuc2VnKTtcbiAgICAgICAgaWYgKCFwbGFjZW1lbnQuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBpbnZpc2libGVTZWdzLnB1c2gocGxhY2VtZW50LnNlZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYWxsU2VncywgaW52aXNpYmxlU2VncyB9O1xufVxuXG5jb25zdCBERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IHdlZWs6ICduYXJyb3cnIH0pO1xuY2xhc3MgVGFibGVDZWxsIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucm9vdEVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBkYXlOdW1iZXJJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb290RWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIHNldFJlZih0aGlzLnJvb3RFbFJlZiwgZWwpO1xuICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBjb250ZXh0LCBwcm9wcywgc3RhdGUsIHJvb3RFbFJlZiB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucywgZGF0ZUVudiB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHsgZGF0ZSwgZGF0ZVByb2ZpbGUgfSA9IHByb3BzO1xuICAgICAgICAvLyBUT0RPOiBtZW1vaXplIHRoaXM/XG4gICAgICAgIGNvbnN0IGlzTW9udGhTdGFydCA9IHByb3BzLnNob3dEYXlOdW1iZXIgJiZcbiAgICAgICAgICAgIHNob3VsZERpc3BsYXlNb250aFN0YXJ0KGRhdGUsIGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgZGF0ZUVudik7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChEYXlDZWxsQ29udGFpbmVyLCB7IGVsVGFnOiBcInRkXCIsIGVsUmVmOiB0aGlzLmhhbmRsZVJvb3RFbCwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgJ2ZjLWRheWdyaWQtZGF5JyxcbiAgICAgICAgICAgICAgICAuLi4ocHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKSxcbiAgICAgICAgICAgIF0sIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5leHRyYURhdGFBdHRycyksIChwcm9wcy5zaG93RGF5TnVtYmVyID8geyAnYXJpYS1sYWJlbGxlZGJ5Jzogc3RhdGUuZGF5TnVtYmVySWQgfSA6IHt9KSksIHsgcm9sZTogJ2dyaWRjZWxsJyB9KSwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVyVG9wSW5uZXIsIGRhdGU6IGRhdGUsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlciwgaXNNb250aFN0YXJ0OiBpc01vbnRoU3RhcnQsIGV4dHJhUmVuZGVyUHJvcHM6IHByb3BzLmV4dHJhUmVuZGVyUHJvcHMgfSwgKElubmVyQ29udGVudCwgcmVuZGVyUHJvcHMpID0+IChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBwcm9wcy5pbm5lckVsUmVmLCBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktZnJhbWUgZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCIsIHN0eWxlOiB7IG1pbkhlaWdodDogcHJvcHMubWluSGVpZ2h0IH0gfSxcbiAgICAgICAgICAgIHByb3BzLnNob3dXZWVrTnVtYmVyICYmIChjcmVhdGVFbGVtZW50KFdlZWtOdW1iZXJDb250YWluZXIsIHsgZWxUYWc6IFwiYVwiLCBlbENsYXNzZXM6IFsnZmMtZGF5Z3JpZC13ZWVrLW51bWJlciddLCBlbEF0dHJzOiBidWlsZE5hdkxpbmtBdHRycyhjb250ZXh0LCBkYXRlLCAnd2VlaycpLCBkYXRlOiBkYXRlLCBkZWZhdWx0Rm9ybWF0OiBERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVCB9KSksXG4gICAgICAgICAgICAhcmVuZGVyUHJvcHMuaXNEaXNhYmxlZCAmJlxuICAgICAgICAgICAgICAgIChwcm9wcy5zaG93RGF5TnVtYmVyIHx8IGhhc0N1c3RvbURheUNlbGxDb250ZW50KG9wdGlvbnMpIHx8IHByb3BzLmZvcmNlRGF5VG9wKSA/IChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LXRvcFwiIH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiYVwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy1kYXlncmlkLWRheS1udW1iZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNNb250aFN0YXJ0ICYmICdmYy1kYXlncmlkLW1vbnRoLXN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgXSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZE5hdkxpbmtBdHRycyhjb250ZXh0LCBkYXRlKSksIHsgaWQ6IHN0YXRlLmRheU51bWJlcklkIH0pIH0pKSkgOiBwcm9wcy5zaG93RGF5TnVtYmVyID8gKFxuICAgICAgICAgICAgLy8gZm9yIGNyZWF0aW5nIGNvcnJlY3QgYW1vdW50IG9mIHNwYWNlIChzZWUgaXNzdWUgIzcxNjIpXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LXRvcFwiLCBzdHlsZTogeyB2aXNpYmlsaXR5OiAnaGlkZGVuJyB9IH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImFcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktbnVtYmVyXCIgfSwgXCJcXHUwMEEwXCIpKSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LWV2ZW50c1wiLCByZWY6IHByb3BzLmZnQ29udGVudEVsUmVmIH0sXG4gICAgICAgICAgICAgICAgcHJvcHMuZmdDb250ZW50LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktYm90dG9tXCIsIHN0eWxlOiB7IG1hcmdpblRvcDogcHJvcHMubW9yZU1hcmdpblRvcCB9IH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGFibGVDZWxsTW9yZUxpbmssIHsgYWxsRGF5RGF0ZTogZGF0ZSwgc2luZ2xlUGxhY2VtZW50czogcHJvcHMuc2luZ2xlUGxhY2VtZW50cywgbW9yZUNudDogcHJvcHMubW9yZUNudCwgYWxpZ25tZW50RWxSZWY6IHJvb3RFbFJlZiwgYWxpZ25HcmlkVG9wOiAhcHJvcHMuc2hvd0RheU51bWJlciwgZXh0cmFEYXRlU3BhbjogcHJvcHMuZXh0cmFEYXRlU3BhbiwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UgfSkpKSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktYmdcIiB9LCBwcm9wcy5iZ0NvbnRlbnQpKSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJUb3BJbm5lcihwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5kYXlOdW1iZXJUZXh0IHx8IGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIFwiXFx1MDBBMFwiKTtcbn1cbmZ1bmN0aW9uIHNob3VsZERpc3BsYXlNb250aFN0YXJ0KGRhdGUsIGN1cnJlbnRSYW5nZSwgZGF0ZUVudikge1xuICAgIGNvbnN0IHsgc3RhcnQ6IGN1cnJlbnRTdGFydCwgZW5kOiBjdXJyZW50RW5kIH0gPSBjdXJyZW50UmFuZ2U7XG4gICAgY29uc3QgY3VycmVudEVuZEluY2wgPSBhZGRNcyhjdXJyZW50RW5kLCAtMSk7XG4gICAgY29uc3QgY3VycmVudEZpcnN0WWVhciA9IGRhdGVFbnYuZ2V0WWVhcihjdXJyZW50U3RhcnQpO1xuICAgIGNvbnN0IGN1cnJlbnRGaXJzdE1vbnRoID0gZGF0ZUVudi5nZXRNb250aChjdXJyZW50U3RhcnQpO1xuICAgIGNvbnN0IGN1cnJlbnRMYXN0WWVhciA9IGRhdGVFbnYuZ2V0WWVhcihjdXJyZW50RW5kSW5jbCk7XG4gICAgY29uc3QgY3VycmVudExhc3RNb250aCA9IGRhdGVFbnYuZ2V0TW9udGgoY3VycmVudEVuZEluY2wpO1xuICAgIC8vIHNwYW5zIG1vcmUgdGhhbiBvbmUgbW9udGg/XG4gICAgcmV0dXJuICEoY3VycmVudEZpcnN0WWVhciA9PT0gY3VycmVudExhc3RZZWFyICYmIGN1cnJlbnRGaXJzdE1vbnRoID09PSBjdXJyZW50TGFzdE1vbnRoKSAmJlxuICAgICAgICBCb29sZWFuKFxuICAgICAgICAvLyBmaXJzdCBkYXRlIGluIGN1cnJlbnQgdmlldz9cbiAgICAgICAgZGF0ZS52YWx1ZU9mKCkgPT09IGN1cnJlbnRTdGFydC52YWx1ZU9mKCkgfHxcbiAgICAgICAgICAgIC8vIGEgbW9udGgtc3RhcnQgdGhhdCdzIHdpdGhpbiB0aGUgY3VycmVudCByYW5nZT9cbiAgICAgICAgICAgIChkYXRlRW52LmdldERheShkYXRlKSA9PT0gMSAmJiBkYXRlLnZhbHVlT2YoKSA8IGN1cnJlbnRFbmQudmFsdWVPZigpKSk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU2VnS2V5KHNlZykge1xuICAgIHJldHVybiBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkICsgJzonICsgc2VnLmZpcnN0Q29sO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVTZWdVaWQoc2VnKSB7XG4gICAgcmV0dXJuIGdlbmVyYXRlU2VnS2V5KHNlZykgKyAnOicgKyBzZWcubGFzdENvbDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVGZ1NlZ1BsYWNlbWVudChzZWdzLCAvLyBhc3N1bWVkIGFscmVhZHkgc29ydGVkXG5kYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93cywgc3RyaWN0T3JkZXIsIHNlZ0hlaWdodHMsIG1heENvbnRlbnRIZWlnaHQsIGNlbGxzKSB7XG4gICAgbGV0IGhpZXJhcmNoeSA9IG5ldyBEYXlHcmlkU2VnSGllcmFyY2h5KChzZWdFbnRyeSkgPT4ge1xuICAgICAgICAvLyBUT0RPOiBtb3JlIERSWSB3aXRoIGdlbmVyYXRlU2VnVWlkXG4gICAgICAgIGxldCBzZWdVaWQgPSBzZWdzW3NlZ0VudHJ5LmluZGV4XS5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQgK1xuICAgICAgICAgICAgJzonICsgc2VnRW50cnkuc3Bhbi5zdGFydCArXG4gICAgICAgICAgICAnOicgKyAoc2VnRW50cnkuc3Bhbi5lbmQgLSAxKTtcbiAgICAgICAgcmV0dXJuIHNlZ0hlaWdodHNbc2VnVWlkXTtcbiAgICB9KTtcbiAgICBoaWVyYXJjaHkuYWxsb3dSZXNsaWNpbmcgPSB0cnVlO1xuICAgIGhpZXJhcmNoeS5zdHJpY3RPcmRlciA9IHN0cmljdE9yZGVyO1xuICAgIGlmIChkYXlNYXhFdmVudHMgPT09IHRydWUgfHwgZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlKSB7XG4gICAgICAgIGhpZXJhcmNoeS5tYXhDb29yZCA9IG1heENvbnRlbnRIZWlnaHQ7XG4gICAgICAgIGhpZXJhcmNoeS5oaWRkZW5Db25zdW1lcyA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXlNYXhFdmVudHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGhpZXJhcmNoeS5tYXhTdGFja0NudCA9IGRheU1heEV2ZW50cztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRheU1heEV2ZW50Um93cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaGllcmFyY2h5Lm1heFN0YWNrQ250ID0gZGF5TWF4RXZlbnRSb3dzO1xuICAgICAgICBoaWVyYXJjaHkuaGlkZGVuQ29uc3VtZXMgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgc2VnSW5wdXRzIG9ubHkgZm9yIHNlZ3Mgd2l0aCBrbm93biBoZWlnaHRzXG4gICAgbGV0IHNlZ0lucHV0cyA9IFtdO1xuICAgIGxldCB1bmtub3duSGVpZ2h0U2VncyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBsZXQgc2VnID0gc2Vnc1tpXTtcbiAgICAgICAgbGV0IHNlZ1VpZCA9IGdlbmVyYXRlU2VnVWlkKHNlZyk7XG4gICAgICAgIGxldCBldmVudEhlaWdodCA9IHNlZ0hlaWdodHNbc2VnVWlkXTtcbiAgICAgICAgaWYgKGV2ZW50SGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNlZ0lucHV0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICBzcGFuOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzZWcuZmlyc3RDb2wsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogc2VnLmxhc3RDb2wgKyAxLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVua25vd25IZWlnaHRTZWdzLnB1c2goc2VnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgaGlkZGVuRW50cmllcyA9IGhpZXJhcmNoeS5hZGRTZWdzKHNlZ0lucHV0cyk7XG4gICAgbGV0IHNlZ1JlY3RzID0gaGllcmFyY2h5LnRvUmVjdHMoKTtcbiAgICBsZXQgeyBzaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHMsIGxlZnRvdmVyTWFyZ2lucyB9ID0gcGxhY2VSZWN0cyhzZWdSZWN0cywgc2VncywgY2VsbHMpO1xuICAgIGxldCBtb3JlQ250cyA9IFtdO1xuICAgIGxldCBtb3JlTWFyZ2luVG9wcyA9IFtdO1xuICAgIC8vIGFkZCBzZWdzIHdpdGggdW5rbm93biBoZWlnaHRzXG4gICAgZm9yIChsZXQgc2VnIG9mIHVua25vd25IZWlnaHRTZWdzKSB7XG4gICAgICAgIG11bHRpQ29sUGxhY2VtZW50c1tzZWcuZmlyc3RDb2xdLnB1c2goe1xuICAgICAgICAgICAgc2VnLFxuICAgICAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzQWJzb2x1dGU6IHRydWUsXG4gICAgICAgICAgICBhYnNvbHV0ZVRvcDogMCxcbiAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAobGV0IGNvbCA9IHNlZy5maXJzdENvbDsgY29sIDw9IHNlZy5sYXN0Q29sOyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgc2luZ2xlQ29sUGxhY2VtZW50c1tjb2xdLnB1c2goe1xuICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGNvbCwgY29sICsgMSwgY2VsbHMpLFxuICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IDAsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIHRoZSBoaWRkZW4gZW50cmllc1xuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNlbGxzLmxlbmd0aDsgY29sICs9IDEpIHtcbiAgICAgICAgbW9yZUNudHMucHVzaCgwKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaGlkZGVuRW50cnkgb2YgaGlkZGVuRW50cmllcykge1xuICAgICAgICBsZXQgc2VnID0gc2Vnc1toaWRkZW5FbnRyeS5pbmRleF07XG4gICAgICAgIGxldCBoaWRkZW5TcGFuID0gaGlkZGVuRW50cnkuc3BhbjtcbiAgICAgICAgbXVsdGlDb2xQbGFjZW1lbnRzW2hpZGRlblNwYW4uc3RhcnRdLnB1c2goe1xuICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgaGlkZGVuU3Bhbi5zdGFydCwgaGlkZGVuU3Bhbi5lbmQsIGNlbGxzKSxcbiAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxuICAgICAgICAgICAgYWJzb2x1dGVUb3A6IDAsXG4gICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCBjb2wgPSBoaWRkZW5TcGFuLnN0YXJ0OyBjb2wgPCBoaWRkZW5TcGFuLmVuZDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIG1vcmVDbnRzW2NvbF0gKz0gMTtcbiAgICAgICAgICAgIHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXS5wdXNoKHtcbiAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCBjb2wsIGNvbCArIDEsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGRlYWwgd2l0aCBsZWZ0b3ZlciBtYXJnaW5zXG4gICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY2VsbHMubGVuZ3RoOyBjb2wgKz0gMSkge1xuICAgICAgICBtb3JlTWFyZ2luVG9wcy5wdXNoKGxlZnRvdmVyTWFyZ2luc1tjb2xdKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzLCBtb3JlQ250cywgbW9yZU1hcmdpblRvcHMgfTtcbn1cbi8vIHJlY3RzIG9yZGVyZWQgYnkgdG9wIGNvb3JkLCB0aGVuIGxlZnRcbmZ1bmN0aW9uIHBsYWNlUmVjdHMoYWxsUmVjdHMsIHNlZ3MsIGNlbGxzKSB7XG4gICAgbGV0IHJlY3RzQnlFYWNoQ29sID0gZ3JvdXBSZWN0c0J5RWFjaENvbChhbGxSZWN0cywgY2VsbHMubGVuZ3RoKTtcbiAgICBsZXQgc2luZ2xlQ29sUGxhY2VtZW50cyA9IFtdO1xuICAgIGxldCBtdWx0aUNvbFBsYWNlbWVudHMgPSBbXTtcbiAgICBsZXQgbGVmdG92ZXJNYXJnaW5zID0gW107XG4gICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY2VsbHMubGVuZ3RoOyBjb2wgKz0gMSkge1xuICAgICAgICBsZXQgcmVjdHMgPSByZWN0c0J5RWFjaENvbFtjb2xdO1xuICAgICAgICAvLyBjb21wdXRlIGFsbCBzdGF0aWMgc2VncyBpbiBzaW5nbGVQbGFjZW1lbnRzXG4gICAgICAgIGxldCBzaW5nbGVQbGFjZW1lbnRzID0gW107XG4gICAgICAgIGxldCBjdXJyZW50SGVpZ2h0ID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnRNYXJnaW5Ub3AgPSAwO1xuICAgICAgICBmb3IgKGxldCByZWN0IG9mIHJlY3RzKSB7XG4gICAgICAgICAgICBsZXQgc2VnID0gc2Vnc1tyZWN0LmluZGV4XTtcbiAgICAgICAgICAgIHNpbmdsZVBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgY29sLCBjb2wgKyAxLCBjZWxscyksXG4gICAgICAgICAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiByZWN0LmxldmVsQ29vcmQsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiByZWN0LmxldmVsQ29vcmQgLSBjdXJyZW50SGVpZ2h0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50SGVpZ2h0ID0gcmVjdC5sZXZlbENvb3JkICsgcmVjdC50aGlja25lc3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcHV0ZSBtaXhlZCBzdGF0aWMvYWJzb2x1dGUgc2VncyBpbiBtdWx0aVBsYWNlbWVudHNcbiAgICAgICAgbGV0IG11bHRpUGxhY2VtZW50cyA9IFtdO1xuICAgICAgICBjdXJyZW50SGVpZ2h0ID0gMDtcbiAgICAgICAgY3VycmVudE1hcmdpblRvcCA9IDA7XG4gICAgICAgIGZvciAobGV0IHJlY3Qgb2YgcmVjdHMpIHtcbiAgICAgICAgICAgIGxldCBzZWcgPSBzZWdzW3JlY3QuaW5kZXhdO1xuICAgICAgICAgICAgbGV0IGlzQWJzb2x1dGUgPSByZWN0LnNwYW4uZW5kIC0gcmVjdC5zcGFuLnN0YXJ0ID4gMTsgLy8gbXVsdGktY29sdW1uP1xuICAgICAgICAgICAgbGV0IGlzRmlyc3RDb2wgPSByZWN0LnNwYW4uc3RhcnQgPT09IGNvbDtcbiAgICAgICAgICAgIGN1cnJlbnRNYXJnaW5Ub3AgKz0gcmVjdC5sZXZlbENvb3JkIC0gY3VycmVudEhlaWdodDsgLy8gYW1vdW50IG9mIHNwYWNlIHNpbmNlIGJvdHRvbSBvZiBwcmV2aW91cyBzZWdcbiAgICAgICAgICAgIGN1cnJlbnRIZWlnaHQgPSByZWN0LmxldmVsQ29vcmQgKyByZWN0LnRoaWNrbmVzczsgLy8gaGVpZ2h0IHdpbGwgbm93IGJlIGJvdHRvbSBvZiBjdXJyZW50IHNlZ1xuICAgICAgICAgICAgaWYgKGlzQWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWFyZ2luVG9wICs9IHJlY3QudGhpY2tuZXNzO1xuICAgICAgICAgICAgICAgIGlmIChpc0ZpcnN0Q29sKSB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpUGxhY2VtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIHJlY3Quc3Bhbi5zdGFydCwgcmVjdC5zcGFuLmVuZCwgY2VsbHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiByZWN0LmxldmVsQ29vcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRmlyc3RDb2wpIHtcbiAgICAgICAgICAgICAgICBtdWx0aVBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIHJlY3Quc3Bhbi5zdGFydCwgcmVjdC5zcGFuLmVuZCwgY2VsbHMpLFxuICAgICAgICAgICAgICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogcmVjdC5sZXZlbENvb3JkLFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IGN1cnJlbnRNYXJnaW5Ub3AsIC8vIGNsYWltIHRoZSBtYXJnaW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWFyZ2luVG9wID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaW5nbGVDb2xQbGFjZW1lbnRzLnB1c2goc2luZ2xlUGxhY2VtZW50cyk7XG4gICAgICAgIG11bHRpQ29sUGxhY2VtZW50cy5wdXNoKG11bHRpUGxhY2VtZW50cyk7XG4gICAgICAgIGxlZnRvdmVyTWFyZ2lucy5wdXNoKGN1cnJlbnRNYXJnaW5Ub3ApO1xuICAgIH1cbiAgICByZXR1cm4geyBzaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHMsIGxlZnRvdmVyTWFyZ2lucyB9O1xufVxuZnVuY3Rpb24gZ3JvdXBSZWN0c0J5RWFjaENvbChyZWN0cywgY29sQ250KSB7XG4gICAgbGV0IHJlY3RzQnlFYWNoQ29sID0gW107XG4gICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sQ250OyBjb2wgKz0gMSkge1xuICAgICAgICByZWN0c0J5RWFjaENvbC5wdXNoKFtdKTtcbiAgICB9XG4gICAgZm9yIChsZXQgcmVjdCBvZiByZWN0cykge1xuICAgICAgICBmb3IgKGxldCBjb2wgPSByZWN0LnNwYW4uc3RhcnQ7IGNvbCA8IHJlY3Quc3Bhbi5lbmQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICByZWN0c0J5RWFjaENvbFtjb2xdLnB1c2gocmVjdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlY3RzQnlFYWNoQ29sO1xufVxuZnVuY3Rpb24gcmVzbGljZVNlZyhzZWcsIHNwYW5TdGFydCwgc3BhbkVuZCwgY2VsbHMpIHtcbiAgICBpZiAoc2VnLmZpcnN0Q29sID09PSBzcGFuU3RhcnQgJiYgc2VnLmxhc3RDb2wgPT09IHNwYW5FbmQgLSAxKSB7XG4gICAgICAgIHJldHVybiBzZWc7XG4gICAgfVxuICAgIGxldCBldmVudFJhbmdlID0gc2VnLmV2ZW50UmFuZ2U7XG4gICAgbGV0IG9yaWdSYW5nZSA9IGV2ZW50UmFuZ2UucmFuZ2U7XG4gICAgbGV0IHNsaWNlZFJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKG9yaWdSYW5nZSwge1xuICAgICAgICBzdGFydDogY2VsbHNbc3BhblN0YXJ0XS5kYXRlLFxuICAgICAgICBlbmQ6IGFkZERheXMoY2VsbHNbc3BhbkVuZCAtIDFdLmRhdGUsIDEpLFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlZyksIHsgZmlyc3RDb2w6IHNwYW5TdGFydCwgbGFzdENvbDogc3BhbkVuZCAtIDEsIGV2ZW50UmFuZ2U6IHtcbiAgICAgICAgICAgIGRlZjogZXZlbnRSYW5nZS5kZWYsXG4gICAgICAgICAgICB1aTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudFJhbmdlLnVpKSwgeyBkdXJhdGlvbkVkaXRhYmxlOiBmYWxzZSB9KSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBldmVudFJhbmdlLmluc3RhbmNlLFxuICAgICAgICAgICAgcmFuZ2U6IHNsaWNlZFJhbmdlLFxuICAgICAgICB9LCBpc1N0YXJ0OiBzZWcuaXNTdGFydCAmJiBzbGljZWRSYW5nZS5zdGFydC52YWx1ZU9mKCkgPT09IG9yaWdSYW5nZS5zdGFydC52YWx1ZU9mKCksIGlzRW5kOiBzZWcuaXNFbmQgJiYgc2xpY2VkUmFuZ2UuZW5kLnZhbHVlT2YoKSA9PT0gb3JpZ1JhbmdlLmVuZC52YWx1ZU9mKCkgfSk7XG59XG5jbGFzcyBEYXlHcmlkU2VnSGllcmFyY2h5IGV4dGVuZHMgU2VnSGllcmFyY2h5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLy8gY29uZmlnXG4gICAgICAgIHRoaXMuaGlkZGVuQ29uc3VtZXMgPSBmYWxzZTtcbiAgICAgICAgLy8gYWxsb3dzIHVzIHRvIGtlZXAgaGlkZGVuIGVudHJpZXMgaW4gdGhlIGhpZXJhcmNoeSBzbyB0aGV5IHRha2UgdXAgc3BhY2VcbiAgICAgICAgdGhpcy5mb3JjZUhpZGRlbiA9IHt9O1xuICAgIH1cbiAgICBhZGRTZWdzKHNlZ0lucHV0cykge1xuICAgICAgICBjb25zdCBoaWRkZW5TZWdzID0gc3VwZXIuYWRkU2VncyhzZWdJbnB1dHMpO1xuICAgICAgICBjb25zdCB7IGVudHJpZXNCeUxldmVsIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBleGNsdWRlSGlkZGVuID0gKGVudHJ5KSA9PiAhdGhpcy5mb3JjZUhpZGRlbltidWlsZEVudHJ5S2V5KGVudHJ5KV07XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZm9yY2VkLWhpZGRlbiBzZWdzXG4gICAgICAgIGZvciAobGV0IGxldmVsID0gMDsgbGV2ZWwgPCBlbnRyaWVzQnlMZXZlbC5sZW5ndGg7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIGVudHJpZXNCeUxldmVsW2xldmVsXSA9IGVudHJpZXNCeUxldmVsW2xldmVsXS5maWx0ZXIoZXhjbHVkZUhpZGRlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZGRlblNlZ3M7XG4gICAgfVxuICAgIGhhbmRsZUludmFsaWRJbnNlcnRpb24oaW5zZXJ0aW9uLCBlbnRyeSwgaGlkZGVuRW50cmllcykge1xuICAgICAgICBjb25zdCB7IGVudHJpZXNCeUxldmVsLCBmb3JjZUhpZGRlbiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB0b3VjaGluZ0VudHJ5LCB0b3VjaGluZ0xldmVsLCB0b3VjaGluZ0xhdGVyYWwgfSA9IGluc2VydGlvbjtcbiAgICAgICAgaWYgKHRoaXMuaGlkZGVuQ29uc3VtZXMgJiYgdG91Y2hpbmdFbnRyeSkge1xuICAgICAgICAgICAgY29uc3QgdG91Y2hpbmdFbnRyeUlkID0gYnVpbGRFbnRyeUtleSh0b3VjaGluZ0VudHJ5KTtcbiAgICAgICAgICAgIC8vIGlmIG5vdCBhbHJlYWR5IGhpZGRlblxuICAgICAgICAgICAgaWYgKCFmb3JjZUhpZGRlblt0b3VjaGluZ0VudHJ5SWRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dSZXNsaWNpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJFbnRyeSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdG91Y2hpbmdFbnRyeSksIHsgc3BhbjogaW50ZXJzZWN0U3BhbnModG91Y2hpbmdFbnRyeS5zcGFuLCBlbnRyeS5zcGFuKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJFbnRyeUlkID0gYnVpbGRFbnRyeUtleShwbGFjZWhvbGRlckVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VIaWRkZW5bcGxhY2Vob2xkZXJFbnRyeUlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXNCeUxldmVsW3RvdWNoaW5nTGV2ZWxdW3RvdWNoaW5nTGF0ZXJhbF0gPSBwbGFjZWhvbGRlckVudHJ5OyAvLyByZXBsYWNlIHRvdWNoaW5nRW50cnkgd2l0aCBvdXIgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGxpdEVudHJ5KHRvdWNoaW5nRW50cnksIGVudHJ5LCBoaWRkZW5FbnRyaWVzKTsgLy8gc3BsaXQgdXAgdGhlIHRvdWNoaW5nRW50cnksIHJlaW5zZXJ0IGl0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3JjZUhpZGRlblt0b3VjaGluZ0VudHJ5SWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKHRvdWNoaW5nRW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuaGFuZGxlSW52YWxpZEluc2VydGlvbihpbnNlcnRpb24sIGVudHJ5LCBoaWRkZW5FbnRyaWVzKTtcbiAgICB9XG59XG5cbmNsYXNzIFRhYmxlUm93IGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY2VsbEVsUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gdGhlIDx0ZD5cbiAgICAgICAgdGhpcy5mcmFtZUVsUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gdGhlIGZjLWRheWdyaWQtZGF5LWZyYW1lXG4gICAgICAgIHRoaXMuZmdFbFJlZnMgPSBuZXcgUmVmTWFwKCk7IC8vIHRoZSBmYy1kYXlncmlkLWRheS1ldmVudHNcbiAgICAgICAgdGhpcy5zZWdIYXJuZXNzUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gaW5kZXhlZCBieSBcImluc3RhbmNlSWQ6Zmlyc3RDb2xcIlxuICAgICAgICB0aGlzLnJvb3RFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZnJhbWVQb3NpdGlvbnM6IG51bGwsXG4gICAgICAgICAgICBtYXhDb250ZW50SGVpZ2h0OiBudWxsLFxuICAgICAgICAgICAgc2VnSGVpZ2h0czoge30sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUmVzaXplID0gKGlzRm9yY2VkKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNGb3JjZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNpemluZyh0cnVlKTsgLy8gaXNFeHRlcm5hbD10cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgY29sQ250ID0gcHJvcHMuY2VsbHMubGVuZ3RoO1xuICAgICAgICBsZXQgYnVzaW5lc3NIb3Vyc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbChwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCBjb2xDbnQpO1xuICAgICAgICBsZXQgYmdFdmVudFNlZ3NCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wocHJvcHMuYmdFdmVudFNlZ3MsIGNvbENudCk7XG4gICAgICAgIGxldCBoaWdobGlnaHRTZWdzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHRoaXMuZ2V0SGlnaGxpZ2h0U2VncygpLCBjb2xDbnQpO1xuICAgICAgICBsZXQgbWlycm9yU2Vnc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbCh0aGlzLmdldE1pcnJvclNlZ3MoKSwgY29sQ250KTtcbiAgICAgICAgbGV0IHsgc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzLCBtb3JlQ250cywgbW9yZU1hcmdpblRvcHMgfSA9IGNvbXB1dGVGZ1NlZ1BsYWNlbWVudChzb3J0RXZlbnRTZWdzKHByb3BzLmZnRXZlbnRTZWdzLCBvcHRpb25zLmV2ZW50T3JkZXIpLCBwcm9wcy5kYXlNYXhFdmVudHMsIHByb3BzLmRheU1heEV2ZW50Um93cywgb3B0aW9ucy5ldmVudE9yZGVyU3RyaWN0LCBzdGF0ZS5zZWdIZWlnaHRzLCBzdGF0ZS5tYXhDb250ZW50SGVpZ2h0LCBwcm9wcy5jZWxscyk7XG4gICAgICAgIGxldCBpc0ZvcmNlZEludmlzaWJsZSA9IC8vIFRPRE86IG1lc3N5IHdheSB0byBjb21wdXRlIHRoaXNcbiAgICAgICAgIChwcm9wcy5ldmVudERyYWcgJiYgcHJvcHMuZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxuICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxuICAgICAgICAgICAge307XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcmVmOiB0aGlzLnJvb3RFbFJlZiwgcm9sZTogXCJyb3dcIiB9LFxuICAgICAgICAgICAgcHJvcHMucmVuZGVySW50cm8gJiYgcHJvcHMucmVuZGVySW50cm8oKSxcbiAgICAgICAgICAgIHByb3BzLmNlbGxzLm1hcCgoY2VsbCwgY29sKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG5vcm1hbEZnTm9kZXMgPSB0aGlzLnJlbmRlckZnU2Vncyhjb2wsIHByb3BzLmZvclByaW50ID8gc2luZ2xlQ29sUGxhY2VtZW50c1tjb2xdIDogbXVsdGlDb2xQbGFjZW1lbnRzW2NvbF0sIHByb3BzLnRvZGF5UmFuZ2UsIGlzRm9yY2VkSW52aXNpYmxlKTtcbiAgICAgICAgICAgICAgICBsZXQgbWlycm9yRmdOb2RlcyA9IHRoaXMucmVuZGVyRmdTZWdzKGNvbCwgYnVpbGRNaXJyb3JQbGFjZW1lbnRzKG1pcnJvclNlZ3NCeUNvbFtjb2xdLCBtdWx0aUNvbFBsYWNlbWVudHMpLCBwcm9wcy50b2RheVJhbmdlLCB7fSwgQm9vbGVhbihwcm9wcy5ldmVudERyYWcpLCBCb29sZWFuKHByb3BzLmV2ZW50UmVzaXplKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChUYWJsZUNlbGwsIHsga2V5OiBjZWxsLmtleSwgZWxSZWY6IHRoaXMuY2VsbEVsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpLCBpbm5lckVsUmVmOiB0aGlzLmZyYW1lRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSkgLyogRkYgPHRkPiBwcm9ibGVtLCBidXQgb2theSB0byB1c2UgZm9yIGxlZnQvcmlnaHQuIFRPRE86IHJlbmFtZSBwcm9wICovLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGRhdGU6IGNlbGwuZGF0ZSwgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlcnMsIHNob3dXZWVrTnVtYmVyOiBwcm9wcy5zaG93V2Vla051bWJlcnMgJiYgY29sID09PSAwLCBmb3JjZURheVRvcDogcHJvcHMuc2hvd1dlZWtOdW1iZXJzIC8qIGV2ZW4gZGlzcGxheWluZyB3ZWVrbnVtIGZvciByb3csIG5vdCBuZWNlc3NhcmlseSBkYXkgKi8sIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSwgZXh0cmFSZW5kZXJQcm9wczogY2VsbC5leHRyYVJlbmRlclByb3BzLCBleHRyYURhdGFBdHRyczogY2VsbC5leHRyYURhdGFBdHRycywgZXh0cmFDbGFzc05hbWVzOiBjZWxsLmV4dHJhQ2xhc3NOYW1lcywgZXh0cmFEYXRlU3BhbjogY2VsbC5leHRyYURhdGVTcGFuLCBtb3JlQ250OiBtb3JlQ250c1tjb2xdLCBtb3JlTWFyZ2luVG9wOiBtb3JlTWFyZ2luVG9wc1tjb2xdLCBzaW5nbGVQbGFjZW1lbnRzOiBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0sIGZnQ29udGVudEVsUmVmOiB0aGlzLmZnRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSksIGZnQ29udGVudDogKCAvLyBGcmFnbWVudCBzY29wZXMgdGhlIGtleXNcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIG5vcm1hbEZnTm9kZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgbWlycm9yRmdOb2RlcykpKSwgYmdDb250ZW50OiAoIC8vIEZyYWdtZW50IHNjb3BlcyB0aGUga2V5c1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2VncyhoaWdobGlnaHRTZWdzQnlDb2xbY29sXSwgJ2hpZ2hsaWdodCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2VncyhidXNpbmVzc0hvdXJzQnlDb2xbY29sXSwgJ25vbi1idXNpbmVzcycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2VncyhiZ0V2ZW50U2Vnc0J5Q29sW2NvbF0sICdiZy1ldmVudCcpKSksIG1pbkhlaWdodDogcHJvcHMuY2VsbE1pbkhlaWdodCB9KSk7XG4gICAgICAgICAgICB9KSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTaXppbmcodHJ1ZSk7XG4gICAgICAgIHRoaXMuY29udGV4dC5hZGRSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICAgIGxldCBjdXJyZW50UHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemluZyghaXNQcm9wc0VxdWFsKHByZXZQcm9wcywgY3VycmVudFByb3BzKSk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLmNvbnRleHQucmVtb3ZlUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgfVxuICAgIGdldEhpZ2hsaWdodFNlZ3MoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBpZiAocHJvcHMuZXZlbnREcmFnICYmIHByb3BzLmV2ZW50RHJhZy5zZWdzLmxlbmd0aCkgeyAvLyBtZXNzeSBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmV2ZW50RHJhZy5zZWdzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzLmxlbmd0aCkgeyAvLyBtZXNzeSBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmV2ZW50UmVzaXplLnNlZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzO1xuICAgIH1cbiAgICBnZXRNaXJyb3JTZWdzKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLnNlZ3MubGVuZ3RoKSB7IC8vIG1lc3N5IGNoZWNrXG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuZXZlbnRSZXNpemUuc2VncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJlbmRlckZnU2Vncyhjb2wsIHNlZ1BsYWNlbWVudHMsIHRvZGF5UmFuZ2UsIGlzRm9yY2VkSW52aXNpYmxlLCBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0RhdGVTZWxlY3RpbmcpIHtcbiAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgZXZlbnRTZWxlY3Rpb24gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCB7IGZyYW1lUG9zaXRpb25zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBsZXQgZGVmYXVsdERpc3BsYXlFdmVudEVuZCA9IHRoaXMucHJvcHMuY2VsbHMubGVuZ3RoID09PSAxOyAvLyBjb2xDbnQgPT09IDFcbiAgICAgICAgbGV0IGlzTWlycm9yID0gaXNEcmFnZ2luZyB8fCBpc1Jlc2l6aW5nIHx8IGlzRGF0ZVNlbGVjdGluZztcbiAgICAgICAgbGV0IG5vZGVzID0gW107XG4gICAgICAgIGlmIChmcmFtZVBvc2l0aW9ucykge1xuICAgICAgICAgICAgZm9yIChsZXQgcGxhY2VtZW50IG9mIHNlZ1BsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBzZWcgfSA9IHBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICBsZXQgeyBpbnN0YW5jZUlkIH0gPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBsZXQgaXNWaXNpYmxlID0gcGxhY2VtZW50LmlzVmlzaWJsZSAmJiAhaXNGb3JjZWRJbnZpc2libGVbaW5zdGFuY2VJZF07XG4gICAgICAgICAgICAgICAgbGV0IGlzQWJzb2x1dGUgPSBwbGFjZW1lbnQuaXNBYnNvbHV0ZTtcbiAgICAgICAgICAgICAgICBsZXQgbGVmdCA9ICcnO1xuICAgICAgICAgICAgICAgIGxldCByaWdodCA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmlzUnRsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmxhc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmZpcnN0Q29sXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmZpcnN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcubGFzdENvbF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBrbm93biBidWc6IGV2ZW50cyB0aGF0IGFyZSBmb3JjZSB0byBiZSBsaXN0LWl0ZW0gYnV0IHNwYW4gbXVsdGlwbGUgZGF5cyBzdGlsbCB0YWtlIHVwIHNwYWNlIGluIGxhdGVyIGNvbHVtbnNcbiAgICAgICAgICAgICAgICB0b2RvOiBpbiBwcmludCB2aWV3LCBmb3IgbXVsdGktZGF5IGV2ZW50cywgZG9uJ3QgZGlzcGxheSB0aXRsZSB3aXRoaW4gbm9uLXN0YXJ0L2VuZCBzZWdzXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy1kYXlncmlkLWV2ZW50LWhhcm5lc3MnICsgKGlzQWJzb2x1dGUgPyAnIGZjLWRheWdyaWQtZXZlbnQtaGFybmVzcy1hYnMnIDogJycpLCBrZXk6IGdlbmVyYXRlU2VnS2V5KHNlZyksIHJlZjogaXNNaXJyb3IgPyBudWxsIDogdGhpcy5zZWdIYXJuZXNzUmVmcy5jcmVhdGVSZWYoZ2VuZXJhdGVTZWdVaWQoc2VnKSksIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBpc1Zpc2libGUgPyAnJyA6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBpc0Fic29sdXRlID8gJycgOiBwbGFjZW1lbnQubWFyZ2luVG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBpc0Fic29sdXRlID8gcGxhY2VtZW50LmFic29sdXRlVG9wIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIH0gfSwgaGFzTGlzdEl0ZW1EaXNwbGF5KHNlZykgPyAoY3JlYXRlRWxlbWVudChUYWJsZUxpc3RJdGVtRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogaXNEcmFnZ2luZywgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gZXZlbnRTZWxlY3Rpb24sIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgfSwgZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UpKSkpIDogKGNyZWF0ZUVsZW1lbnQoVGFibGVCbG9ja0V2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGlzRHJhZ2dpbmcsIGlzUmVzaXppbmc6IGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZzogaXNEYXRlU2VsZWN0aW5nLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZGVmYXVsdERpc3BsYXlFdmVudEVuZCB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSkpKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHJlbmRlckZpbGxTZWdzKHNlZ3MsIGZpbGxUeXBlKSB7XG4gICAgICAgIGxldCB7IGlzUnRsIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCB7IHRvZGF5UmFuZ2UgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCB7IGZyYW1lUG9zaXRpb25zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBsZXQgbm9kZXMgPSBbXTtcbiAgICAgICAgaWYgKGZyYW1lUG9zaXRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0UmlnaHRDc3MgPSBpc1J0bCA/IHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5sYXN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5maXJzdENvbF0sXG4gICAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcuZmlyc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5sYXN0Q29sXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogYnVpbGRFdmVudFJhbmdlS2V5KHNlZy5ldmVudFJhbmdlKSwgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtYmctaGFybmVzc1wiLCBzdHlsZTogbGVmdFJpZ2h0Q3NzIH0sIGZpbGxUeXBlID09PSAnYmctZXZlbnQnID9cbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChCZ0V2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcgfSwgZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UpKSkgOlxuICAgICAgICAgICAgICAgICAgICByZW5kZXJGaWxsKGZpbGxUeXBlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7fSwgLi4ubm9kZXMpO1xuICAgIH1cbiAgICB1cGRhdGVTaXppbmcoaXNFeHRlcm5hbFNpemluZ0NoYW5nZSkge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUsIGZyYW1lRWxSZWZzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXByb3BzLmZvclByaW50ICYmXG4gICAgICAgICAgICBwcm9wcy5jbGllbnRXaWR0aCAhPT0gbnVsbCAvLyBwb3NpdGlvbmluZyByZWFkeT9cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoaXNFeHRlcm5hbFNpemluZ0NoYW5nZSkge1xuICAgICAgICAgICAgICAgIGxldCBmcmFtZUVscyA9IHByb3BzLmNlbGxzLm1hcCgoY2VsbCkgPT4gZnJhbWVFbFJlZnMuY3VycmVudE1hcFtjZWxsLmtleV0pO1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZUVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9yaWdpbkVsID0gdGhpcy5yb290RWxSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1Bvc2l0aW9uQ2FjaGUgPSBuZXcgUG9zaXRpb25DYWNoZShvcmlnaW5FbCwgZnJhbWVFbHMsIHRydWUsIC8vIGlzSG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuZnJhbWVQb3NpdGlvbnMgfHwgIXN0YXRlLmZyYW1lUG9zaXRpb25zLnNpbWlsYXJUbyhuZXdQb3NpdGlvbkNhY2hlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVQb3NpdGlvbnM6IG5ldyBQb3NpdGlvbkNhY2hlKG9yaWdpbkVsLCBmcmFtZUVscywgdHJ1ZSwgLy8gaXNIb3Jpem9udGFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvbGRTZWdIZWlnaHRzID0gdGhpcy5zdGF0ZS5zZWdIZWlnaHRzO1xuICAgICAgICAgICAgY29uc3QgbmV3U2VnSGVpZ2h0cyA9IHRoaXMucXVlcnlTZWdIZWlnaHRzKCk7XG4gICAgICAgICAgICBjb25zdCBsaW1pdEJ5Q29udGVudEhlaWdodCA9IHByb3BzLmRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBwcm9wcy5kYXlNYXhFdmVudFJvd3MgPT09IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgLy8gSEFDSyB0byBwcmV2ZW50IG9zY2lsbGF0aW9ucyBvZiBldmVudHMgYmVpbmcgc2hvd24vaGlkZGVuIGZyb20gbWF4LWV2ZW50LXJvd3NcbiAgICAgICAgICAgICAgICAvLyBFc3NlbnRpYWxseSwgb25jZSB5b3UgY29tcHV0ZSBhbiBlbGVtZW50J3MgaGVpZ2h0LCBuZXZlciBudWxsLW91dC5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhbHdheXMgZGlzcGxheSBhbGwgZXZlbnRzLCBhcyB2aXNpYmlsaXR5OmhpZGRlbj9cbiAgICAgICAgICAgICAgICBzZWdIZWlnaHRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9sZFNlZ0hlaWdodHMpLCBuZXdTZWdIZWlnaHRzKSxcbiAgICAgICAgICAgICAgICBtYXhDb250ZW50SGVpZ2h0OiBsaW1pdEJ5Q29udGVudEhlaWdodCA/IHRoaXMuY29tcHV0ZU1heENvbnRlbnRIZWlnaHQoKSA6IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWVyeVNlZ0hlaWdodHMoKSB7XG4gICAgICAgIGxldCBzZWdFbE1hcCA9IHRoaXMuc2VnSGFybmVzc1JlZnMuY3VycmVudE1hcDtcbiAgICAgICAgbGV0IHNlZ0hlaWdodHMgPSB7fTtcbiAgICAgICAgLy8gZ2V0IHRoZSBtYXggaGVpZ2h0IGFtb25nc3QgaW5zdGFuY2Ugc2Vnc1xuICAgICAgICBmb3IgKGxldCBzZWdVaWQgaW4gc2VnRWxNYXApIHtcbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSBNYXRoLnJvdW5kKHNlZ0VsTWFwW3NlZ1VpZF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KTtcbiAgICAgICAgICAgIHNlZ0hlaWdodHNbc2VnVWlkXSA9IE1hdGgubWF4KHNlZ0hlaWdodHNbc2VnVWlkXSB8fCAwLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdIZWlnaHRzO1xuICAgIH1cbiAgICBjb21wdXRlTWF4Q29udGVudEhlaWdodCgpIHtcbiAgICAgICAgbGV0IGZpcnN0S2V5ID0gdGhpcy5wcm9wcy5jZWxsc1swXS5rZXk7XG4gICAgICAgIGxldCBjZWxsRWwgPSB0aGlzLmNlbGxFbFJlZnMuY3VycmVudE1hcFtmaXJzdEtleV07XG4gICAgICAgIGxldCBmY0NvbnRhaW5lckVsID0gdGhpcy5mZ0VsUmVmcy5jdXJyZW50TWFwW2ZpcnN0S2V5XTtcbiAgICAgICAgcmV0dXJuIGNlbGxFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20gLSBmY0NvbnRhaW5lckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICB9XG4gICAgZ2V0Q2VsbEVscygpIHtcbiAgICAgICAgbGV0IGVsTWFwID0gdGhpcy5jZWxsRWxSZWZzLmN1cnJlbnRNYXA7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNlbGxzLm1hcCgoY2VsbCkgPT4gZWxNYXBbY2VsbC5rZXldKTtcbiAgICB9XG59XG5UYWJsZVJvdy5hZGRTdGF0ZUVxdWFsaXR5KHtcbiAgICBzZWdIZWlnaHRzOiBpc1Byb3BzRXF1YWwsXG59KTtcbmZ1bmN0aW9uIGJ1aWxkTWlycm9yUGxhY2VtZW50cyhtaXJyb3JTZWdzLCBjb2xQbGFjZW1lbnRzKSB7XG4gICAgaWYgKCFtaXJyb3JTZWdzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCB0b3BzQnlJbnN0YW5jZUlkID0gYnVpbGRBYnNvbHV0ZVRvcEhhc2goY29sUGxhY2VtZW50cyk7IC8vIFRPRE86IGNhY2hlIHRoaXMgYXQgZmlyc3QgcmVuZGVyP1xuICAgIHJldHVybiBtaXJyb3JTZWdzLm1hcCgoc2VnKSA9PiAoe1xuICAgICAgICBzZWcsXG4gICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgaXNBYnNvbHV0ZTogdHJ1ZSxcbiAgICAgICAgYWJzb2x1dGVUb3A6IHRvcHNCeUluc3RhbmNlSWRbc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZF0sXG4gICAgICAgIG1hcmdpblRvcDogMCxcbiAgICB9KSk7XG59XG5mdW5jdGlvbiBidWlsZEFic29sdXRlVG9wSGFzaChjb2xQbGFjZW1lbnRzKSB7XG4gICAgbGV0IHRvcHNCeUluc3RhbmNlSWQgPSB7fTtcbiAgICBmb3IgKGxldCBwbGFjZW1lbnRzIG9mIGNvbFBsYWNlbWVudHMpIHtcbiAgICAgICAgZm9yIChsZXQgcGxhY2VtZW50IG9mIHBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgIHRvcHNCeUluc3RhbmNlSWRbcGxhY2VtZW50LnNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWRdID0gcGxhY2VtZW50LmFic29sdXRlVG9wO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b3BzQnlJbnN0YW5jZUlkO1xufVxuXG5jbGFzcyBUYWJsZVJvd3MgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zcGxpdEJ1c2luZXNzSG91clNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Um93KTtcbiAgICAgICAgdGhpcy5zcGxpdEJnRXZlbnRTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeVJvdyk7XG4gICAgICAgIHRoaXMuc3BsaXRGZ0V2ZW50U2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlSb3cpO1xuICAgICAgICB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Um93KTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50RHJhZyA9IG1lbW9pemUoc3BsaXRJbnRlcmFjdGlvbkJ5Um93KTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50UmVzaXplID0gbWVtb2l6ZShzcGxpdEludGVyYWN0aW9uQnlSb3cpO1xuICAgICAgICB0aGlzLnJvd1JlZnMgPSBuZXcgUmVmTWFwKCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCByb3dDbnQgPSBwcm9wcy5jZWxscy5sZW5ndGg7XG4gICAgICAgIGxldCBidXNpbmVzc0hvdXJTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QnVzaW5lc3NIb3VyU2Vncyhwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCByb3dDbnQpO1xuICAgICAgICBsZXQgYmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCZ0V2ZW50U2Vncyhwcm9wcy5iZ0V2ZW50U2Vncywgcm93Q250KTtcbiAgICAgICAgbGV0IGZnRXZlbnRTZWdzQnlSb3cgPSB0aGlzLnNwbGl0RmdFdmVudFNlZ3MocHJvcHMuZmdFdmVudFNlZ3MsIHJvd0NudCk7XG4gICAgICAgIGxldCBkYXRlU2VsZWN0aW9uU2Vnc0J5Um93ID0gdGhpcy5zcGxpdERhdGVTZWxlY3Rpb25TZWdzKHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzLCByb3dDbnQpO1xuICAgICAgICBsZXQgZXZlbnREcmFnQnlSb3cgPSB0aGlzLnNwbGl0RXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZywgcm93Q250KTtcbiAgICAgICAgbGV0IGV2ZW50UmVzaXplQnlSb3cgPSB0aGlzLnNwbGl0RXZlbnRSZXNpemUocHJvcHMuZXZlbnRSZXNpemUsIHJvd0NudCk7XG4gICAgICAgIC8vIGZvciBEYXlHcmlkIHZpZXcgd2l0aCBtYW55IHJvd3MsIGZvcmNlIGEgbWluLWhlaWdodCBvbiBjZWxscyBzbyBkb2Vzbid0IGFwcGVhciBzcXVpc2hlZFxuICAgICAgICAvLyBjaG9vc2UgNyBiZWNhdXNlIGEgbW9udGggdmlldyB3aWxsIGhhdmUgbWF4IDYgcm93c1xuICAgICAgICBsZXQgY2VsbE1pbkhlaWdodCA9IChyb3dDbnQgPj0gNyAmJiBwcm9wcy5jbGllbnRXaWR0aCkgP1xuICAgICAgICAgICAgcHJvcHMuY2xpZW50V2lkdGggLyBjb250ZXh0Lm9wdGlvbnMuYXNwZWN0UmF0aW8gLyA2IDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChOb3dUaW1lciwgeyB1bml0OiBcImRheVwiIH0sIChub3dEYXRlLCB0b2RheVJhbmdlKSA9PiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgcHJvcHMuY2VsbHMubWFwKChjZWxscywgcm93KSA9PiAoY3JlYXRlRWxlbWVudChUYWJsZVJvdywgeyByZWY6IHRoaXMucm93UmVmcy5jcmVhdGVSZWYocm93KSwga2V5OiBjZWxscy5sZW5ndGhcbiAgICAgICAgICAgICAgICA/IGNlbGxzWzBdLmRhdGUudG9JU09TdHJpbmcoKSAvKiBiZXN0PyBvciBwdXQga2V5IG9uIGNlbGw/IG9yIHVzZSBkaWZmIGZvcm1hdHRlcj8gKi9cbiAgICAgICAgICAgICAgICA6IHJvdyAvLyBpbiBjYXNlIHRoZXJlIGFyZSBubyBjZWxscyAobGlrZSB3aGVuIHJlc291cmNlIHZpZXcgaXMgbG9hZGluZylcbiAgICAgICAgICAgICwgc2hvd0RheU51bWJlcnM6IHJvd0NudCA+IDEsIHNob3dXZWVrTnVtYmVyczogcHJvcHMuc2hvd1dlZWtOdW1iZXJzLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGNlbGxzOiBjZWxscywgcmVuZGVySW50cm86IHByb3BzLnJlbmRlclJvd0ludHJvLCBidXNpbmVzc0hvdXJTZWdzOiBidXNpbmVzc0hvdXJTZWdzQnlSb3dbcm93XSwgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBiZ0V2ZW50U2VnczogYmdFdmVudFNlZ3NCeVJvd1tyb3ddLmZpbHRlcihpc1NlZ0FsbERheSkgLyogaGFjayAqLywgZmdFdmVudFNlZ3M6IGZnRXZlbnRTZWdzQnlSb3dbcm93XSwgZGF0ZVNlbGVjdGlvblNlZ3M6IGRhdGVTZWxlY3Rpb25TZWdzQnlSb3dbcm93XSwgZXZlbnREcmFnOiBldmVudERyYWdCeVJvd1tyb3ddLCBldmVudFJlc2l6ZTogZXZlbnRSZXNpemVCeVJvd1tyb3ddLCBkYXlNYXhFdmVudHM6IHByb3BzLmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBwcm9wcy5kYXlNYXhFdmVudFJvd3MsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBwcm9wcy5jbGllbnRIZWlnaHQsIGNlbGxNaW5IZWlnaHQ6IGNlbGxNaW5IZWlnaHQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9KSkpKSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCgpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIC8vIGZvciBpZiBzdGFydGVkIHdpdGggemVybyBjZWxsc1xuICAgICAgICB0aGlzLnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQoKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJvb3RFbCkge1xuICAgICAgICAgICAgLy8gSEFDSzogbmVlZCBhIGRheWdyaWQgd3JhcHBlciBwYXJlbnQgdG8gZG8gcG9zaXRpb25pbmdcbiAgICAgICAgICAgIC8vIE5PVEU6IGEgZGF5Z3JpZCByZXNvdXJjZSB2aWV3IHcvbyByZXNvdXJjZXMgY2FuIGhhdmUgemVybyBjZWxsc1xuICAgICAgICAgICAgY29uc3QgZmlyc3RDZWxsRWwgPSB0aGlzLnJvd1JlZnMuY3VycmVudE1hcFswXS5nZXRDZWxsRWxzKClbMF07XG4gICAgICAgICAgICBjb25zdCByb290RWwgPSBmaXJzdENlbGxFbCA/IGZpcnN0Q2VsbEVsLmNsb3Nlc3QoJy5mYy1kYXlncmlkLWJvZHknKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAocm9vdEVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290RWwgPSByb290RWw7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcywge1xuICAgICAgICAgICAgICAgICAgICBlbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgICAgICBpc0hpdENvbWJvQWxsb3dlZDogdGhpcy5wcm9wcy5pc0hpdENvbWJvQWxsb3dlZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdEVsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5yb290RWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhpdCBTeXN0ZW1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcHJlcGFyZUhpdHMoKSB7XG4gICAgICAgIHRoaXMucm93UG9zaXRpb25zID0gbmV3IFBvc2l0aW9uQ2FjaGUodGhpcy5yb290RWwsIHRoaXMucm93UmVmcy5jb2xsZWN0KCkubWFwKChyb3dPYmopID0+IHJvd09iai5nZXRDZWxsRWxzKClbMF0pLCAvLyBmaXJzdCBjZWxsIGVsIGluIGVhY2ggcm93LiBUT0RPOiBub3Qgb3B0aW1hbFxuICAgICAgICBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuY29sUG9zaXRpb25zID0gbmV3IFBvc2l0aW9uQ2FjaGUodGhpcy5yb290RWwsIHRoaXMucm93UmVmcy5jdXJyZW50TWFwWzBdLmdldENlbGxFbHMoKSwgLy8gY2VsbCBlbHMgaW4gZmlyc3Qgcm93XG4gICAgICAgIHRydWUsIC8vIGhvcml6b250YWxcbiAgICAgICAgZmFsc2UpO1xuICAgIH1cbiAgICBxdWVyeUhpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wKSB7XG4gICAgICAgIGxldCB7IGNvbFBvc2l0aW9ucywgcm93UG9zaXRpb25zIH0gPSB0aGlzO1xuICAgICAgICBsZXQgY29sID0gY29sUG9zaXRpb25zLmxlZnRUb0luZGV4KHBvc2l0aW9uTGVmdCk7XG4gICAgICAgIGxldCByb3cgPSByb3dQb3NpdGlvbnMudG9wVG9JbmRleChwb3NpdGlvblRvcCk7XG4gICAgICAgIGlmIChyb3cgIT0gbnVsbCAmJiBjb2wgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGNlbGwgPSB0aGlzLnByb3BzLmNlbGxzW3Jvd11bY29sXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICAgICAgZGF0ZVNwYW46IE9iamVjdC5hc3NpZ24oeyByYW5nZTogdGhpcy5nZXRDZWxsUmFuZ2Uocm93LCBjb2wpLCBhbGxEYXk6IHRydWUgfSwgY2VsbC5leHRyYURhdGVTcGFuKSxcbiAgICAgICAgICAgICAgICBkYXlFbDogdGhpcy5nZXRDZWxsRWwocm93LCBjb2wpLFxuICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogY29sUG9zaXRpb25zLmxlZnRzW2NvbF0sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjb2xQb3NpdGlvbnMucmlnaHRzW2NvbF0sXG4gICAgICAgICAgICAgICAgICAgIHRvcDogcm93UG9zaXRpb25zLnRvcHNbcm93XSxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiByb3dQb3NpdGlvbnMuYm90dG9tc1tyb3ddLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGF5ZXI6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXRDZWxsRWwocm93LCBjb2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93UmVmcy5jdXJyZW50TWFwW3Jvd10uZ2V0Q2VsbEVscygpW2NvbF07IC8vIFRPRE86IG5vdCBvcHRpbWFsXG4gICAgfVxuICAgIGdldENlbGxSYW5nZShyb3csIGNvbCkge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnByb3BzLmNlbGxzW3Jvd11bY29sXS5kYXRlO1xuICAgICAgICBsZXQgZW5kID0gYWRkRGF5cyhzdGFydCwgMSk7XG4gICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1NlZ0FsbERheShzZWcpIHtcbiAgICByZXR1cm4gc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheTtcbn1cblxuY2xhc3MgVGFibGUgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5lbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLm5lZWRzU2Nyb2xsUmVzZXQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgZGF5TWF4RXZlbnRSb3dzLCBkYXlNYXhFdmVudHMsIGV4cGFuZFJvd3MgfSA9IHByb3BzO1xuICAgICAgICBsZXQgbGltaXRWaWFCYWxhbmNlZCA9IGRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBkYXlNYXhFdmVudFJvd3MgPT09IHRydWU7XG4gICAgICAgIC8vIGlmIHJvd3MgY2FuJ3QgZXhwYW5kIHRvIGZpbGwgZml4ZWQgaGVpZ2h0LCBjYW4ndCBkbyBiYWxhbmNlZC1oZWlnaHQgZXZlbnQgbGltaXRcbiAgICAgICAgLy8gVE9ETzogYmVzdCBwbGFjZSB0byBub3JtYWxpemUgdGhlc2Ugb3B0aW9ucz9cbiAgICAgICAgaWYgKGxpbWl0VmlhQmFsYW5jZWQgJiYgIWV4cGFuZFJvd3MpIHtcbiAgICAgICAgICAgIGxpbWl0VmlhQmFsYW5jZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGRheU1heEV2ZW50Um93cyA9IG51bGw7XG4gICAgICAgICAgICBkYXlNYXhFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgJ2ZjLWRheWdyaWQtYm9keScsXG4gICAgICAgICAgICBsaW1pdFZpYUJhbGFuY2VkID8gJ2ZjLWRheWdyaWQtYm9keS1iYWxhbmNlZCcgOiAnZmMtZGF5Z3JpZC1ib2R5LXVuYmFsYW5jZWQnLFxuICAgICAgICAgICAgZXhwYW5kUm93cyA/ICcnIDogJ2ZjLWRheWdyaWQtYm9keS1uYXR1cmFsJywgLy8gd2lsbCBoZWlnaHQgb2Ygb25lIHJvdyBkZXBlbmQgb24gdGhlIG90aGVycz9cbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLmVsUmVmLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIC8vIHRoZXNlIHByb3BzIGFyZSBpbXBvcnRhbnQgdG8gZ2l2ZSB0aGlzIHdyYXBwZXIgY29ycmVjdCBkaW1lbnNpb25zIGZvciBpbnRlcmFjdGlvbnNcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBpZiB3ZSBzZXQgaXQgaGVyZSwgY2FuIHdlIGF2b2lkIGdpdmluZyB0byBpbm5lciB0YWJsZXM/XG4gICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc3luYy10YWJsZVwiLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGV4cGFuZFJvd3MgPyBwcm9wcy5jbGllbnRIZWlnaHQgOiAnJyxcbiAgICAgICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICAgICAgcHJvcHMuY29sR3JvdXBOb2RlLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiLCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUYWJsZVJvd3MsIHsgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBjZWxsczogcHJvcHMuY2VsbHMsIHJlbmRlclJvd0ludHJvOiBwcm9wcy5yZW5kZXJSb3dJbnRybywgc2hvd1dlZWtOdW1iZXJzOiBwcm9wcy5zaG93V2Vla051bWJlcnMsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBwcm9wcy5jbGllbnRIZWlnaHQsIGJ1c2luZXNzSG91clNlZ3M6IHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIGJnRXZlbnRTZWdzOiBwcm9wcy5iZ0V2ZW50U2VncywgZmdFdmVudFNlZ3M6IHByb3BzLmZnRXZlbnRTZWdzLCBkYXRlU2VsZWN0aW9uU2VnczogcHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSwgZGF5TWF4RXZlbnRzOiBkYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93czogZGF5TWF4RXZlbnRSb3dzLCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsIGlzSGl0Q29tYm9BbGxvd2VkOiBwcm9wcy5pc0hpdENvbWJvQWxsb3dlZCB9KSkpKSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RTY3JvbGxSZXNldCgpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGlmIChwcmV2UHJvcHMuZGF0ZVByb2ZpbGUgIT09IHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFNjcm9sbFJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoU2Nyb2xsUmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXF1ZXN0U2Nyb2xsUmVzZXQoKSB7XG4gICAgICAgIHRoaXMubmVlZHNTY3JvbGxSZXNldCA9IHRydWU7XG4gICAgICAgIHRoaXMuZmx1c2hTY3JvbGxSZXNldCgpO1xuICAgIH1cbiAgICBmbHVzaFNjcm9sbFJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5uZWVkc1Njcm9sbFJlc2V0ICYmXG4gICAgICAgICAgICB0aGlzLnByb3BzLmNsaWVudFdpZHRoIC8vIHNpemVzIGNvbXB1dGVkP1xuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YmplY3RFbCA9IGdldFNjcm9sbFN1YmplY3RFbCh0aGlzLmVsUmVmLmN1cnJlbnQsIHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUpO1xuICAgICAgICAgICAgaWYgKHN1YmplY3RFbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbkVsID0gc3ViamVjdEVsLmNsb3Nlc3QoJy5mYy1kYXlncmlkLWJvZHknKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JvbGxFbCA9IG9yaWdpbkVsLmNsb3Nlc3QoJy5mYy1zY3JvbGxlcicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjcm9sbFRvcCA9IHN1YmplY3RFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgLVxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5FbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICAgICAgICAgICAgc2Nyb2xsRWwuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wID8gKHNjcm9sbFRvcCArIDEpIDogMDsgLy8gb3ZlcmNvbWUgYm9yZGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5lZWRzU2Nyb2xsUmVzZXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNjcm9sbFN1YmplY3RFbChjb250YWluZXJFbCwgZGF0ZVByb2ZpbGUpIHtcbiAgICBsZXQgZWw7XG4gICAgaWYgKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQubWF0Y2goL3llYXJ8bW9udGgvKSkge1xuICAgICAgICBlbCA9IGNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWRhdGU9XCIke2Zvcm1hdElzb01vbnRoU3RyKGRhdGVQcm9maWxlLmN1cnJlbnREYXRlKX0tMDFcIl1gKTtcbiAgICAgICAgLy8gZXZlbiBpZiB2aWV3IGlzIG1vbnRoLWJhc2VkLCBmaXJzdC1vZi1tb250aCBtaWdodCBiZSBoaWRkZW4uLi5cbiAgICB9XG4gICAgaWYgKCFlbCkge1xuICAgICAgICBlbCA9IGNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWRhdGU9XCIke2Zvcm1hdERheVN0cmluZyhkYXRlUHJvZmlsZS5jdXJyZW50RGF0ZSl9XCJdYCk7XG4gICAgICAgIC8vIGNvdWxkIHN0aWxsIGJlIGhpZGRlbiBpZiBhbiBpbnRlcmlvci12aWV3IGhpZGRlbiBkYXlcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xufVxuXG5jbGFzcyBEYXlUYWJsZVNsaWNlciBleHRlbmRzIFNsaWNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZm9yY2VEYXlJZkxpc3RJdGVtID0gdHJ1ZTtcbiAgICB9XG4gICAgc2xpY2VSYW5nZShkYXRlUmFuZ2UsIGRheVRhYmxlTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGRheVRhYmxlTW9kZWwuc2xpY2VSYW5nZShkYXRlUmFuZ2UpO1xuICAgIH1cbn1cblxuY2xhc3MgRGF5VGFibGUgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zbGljZXIgPSBuZXcgRGF5VGFibGVTbGljZXIoKTtcbiAgICAgICAgdGhpcy50YWJsZVJlZiA9IGNyZWF0ZVJlZigpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVGFibGUsIE9iamVjdC5hc3NpZ24oeyByZWY6IHRoaXMudGFibGVSZWYgfSwgdGhpcy5zbGljZXIuc2xpY2VQcm9wcyhwcm9wcywgcHJvcHMuZGF0ZVByb2ZpbGUsIHByb3BzLm5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIHByb3BzLmRheVRhYmxlTW9kZWwpLCB7IGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgY2VsbHM6IHByb3BzLmRheVRhYmxlTW9kZWwuY2VsbHMsIGNvbEdyb3VwTm9kZTogcHJvcHMuY29sR3JvdXBOb2RlLCB0YWJsZU1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLCByZW5kZXJSb3dJbnRybzogcHJvcHMucmVuZGVyUm93SW50cm8sIGRheU1heEV2ZW50czogcHJvcHMuZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3M6IHByb3BzLmRheU1heEV2ZW50Um93cywgc2hvd1dlZWtOdW1iZXJzOiBwcm9wcy5zaG93V2Vla051bWJlcnMsIGV4cGFuZFJvd3M6IHByb3BzLmV4cGFuZFJvd3MsIGhlYWRlckFsaWduRWxSZWY6IHByb3BzLmhlYWRlckFsaWduRWxSZWYsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBwcm9wcy5jbGllbnRIZWlnaHQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9KSkpO1xuICAgIH1cbn1cblxuY2xhc3MgRGF5VGFibGVWaWV3IGV4dGVuZHMgVGFibGVWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5idWlsZERheVRhYmxlTW9kZWwgPSBtZW1vaXplKGJ1aWxkRGF5VGFibGVNb2RlbCk7XG4gICAgICAgIHRoaXMuaGVhZGVyUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMudGFibGVSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgLy8gY2FuJ3Qgb3ZlcnJpZGUgYW55IGxpZmVjeWNsZSBtZXRob2RzIGZyb20gcGFyZW50XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgb3B0aW9ucywgZGF0ZVByb2ZpbGVHZW5lcmF0b3IgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBkYXlUYWJsZU1vZGVsID0gdGhpcy5idWlsZERheVRhYmxlTW9kZWwocHJvcHMuZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICAgICAgbGV0IGhlYWRlckNvbnRlbnQgPSBvcHRpb25zLmRheUhlYWRlcnMgJiYgKGNyZWF0ZUVsZW1lbnQoRGF5SGVhZGVyLCB7IHJlZjogdGhpcy5oZWFkZXJSZWYsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZXM6IGRheVRhYmxlTW9kZWwuaGVhZGVyRGF0ZXMsIGRhdGVzUmVwRGlzdGluY3REYXlzOiBkYXlUYWJsZU1vZGVsLnJvd0NudCA9PT0gMSB9KSk7XG4gICAgICAgIGxldCBib2R5Q29udGVudCA9IChjb250ZW50QXJnKSA9PiAoY3JlYXRlRWxlbWVudChEYXlUYWJsZSwgeyByZWY6IHRoaXMudGFibGVSZWYsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZGF5VGFibGVNb2RlbDogZGF5VGFibGVNb2RlbCwgYnVzaW5lc3NIb3VyczogcHJvcHMuYnVzaW5lc3NIb3VycywgZGF0ZVNlbGVjdGlvbjogcHJvcHMuZGF0ZVNlbGVjdGlvbiwgZXZlbnRTdG9yZTogcHJvcHMuZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzOiBwcm9wcy5ldmVudFVpQmFzZXMsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSwgbmV4dERheVRocmVzaG9sZDogb3B0aW9ucy5uZXh0RGF5VGhyZXNob2xkLCBjb2xHcm91cE5vZGU6IGNvbnRlbnRBcmcudGFibGVDb2xHcm91cE5vZGUsIHRhYmxlTWluV2lkdGg6IGNvbnRlbnRBcmcudGFibGVNaW5XaWR0aCwgZGF5TWF4RXZlbnRzOiBvcHRpb25zLmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBvcHRpb25zLmRheU1heEV2ZW50Um93cywgc2hvd1dlZWtOdW1iZXJzOiBvcHRpb25zLndlZWtOdW1iZXJzLCBleHBhbmRSb3dzOiAhcHJvcHMuaXNIZWlnaHRBdXRvLCBoZWFkZXJBbGlnbkVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLCBjbGllbnRXaWR0aDogY29udGVudEFyZy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBjb250ZW50QXJnLmNsaWVudEhlaWdodCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGF5TWluV2lkdGhcbiAgICAgICAgICAgID8gdGhpcy5yZW5kZXJIU2Nyb2xsTGF5b3V0KGhlYWRlckNvbnRlbnQsIGJvZHlDb250ZW50LCBkYXlUYWJsZU1vZGVsLmNvbENudCwgb3B0aW9ucy5kYXlNaW5XaWR0aClcbiAgICAgICAgICAgIDogdGhpcy5yZW5kZXJTaW1wbGVMYXlvdXQoaGVhZGVyQ29udGVudCwgYm9keUNvbnRlbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRGF5VGFibGVNb2RlbChkYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICBsZXQgZGF5U2VyaWVzID0gbmV3IERheVNlcmllc01vZGVsKGRhdGVQcm9maWxlLnJlbmRlclJhbmdlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgcmV0dXJuIG5ldyBEYXlUYWJsZU1vZGVsKGRheVNlcmllcywgL3llYXJ8bW9udGh8d2Vlay8udGVzdChkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSk7XG59XG5cbmNsYXNzIFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IgZXh0ZW5kcyBEYXRlUHJvZmlsZUdlbmVyYXRvciB7XG4gICAgLy8gQ29tcHV0ZXMgdGhlIGRhdGUgcmFuZ2UgdGhhdCB3aWxsIGJlIHJlbmRlcmVkXG4gICAgYnVpbGRSZW5kZXJSYW5nZShjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcbiAgICAgICAgbGV0IHJlbmRlclJhbmdlID0gc3VwZXIuYnVpbGRSZW5kZXJSYW5nZShjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpO1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGJ1aWxkRGF5VGFibGVSZW5kZXJSYW5nZSh7XG4gICAgICAgICAgICBjdXJyZW50UmFuZ2U6IHJlbmRlclJhbmdlLFxuICAgICAgICAgICAgc25hcFRvV2VlazogL14oeWVhcnxtb250aCkkLy50ZXN0KGN1cnJlbnRSYW5nZVVuaXQpLFxuICAgICAgICAgICAgZml4ZWRXZWVrQ291bnQ6IHByb3BzLmZpeGVkV2Vla0NvdW50LFxuICAgICAgICAgICAgZGF0ZUVudjogcHJvcHMuZGF0ZUVudixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGREYXlUYWJsZVJlbmRlclJhbmdlKHByb3BzKSB7XG4gICAgbGV0IHsgZGF0ZUVudiwgY3VycmVudFJhbmdlIH0gPSBwcm9wcztcbiAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBjdXJyZW50UmFuZ2U7XG4gICAgbGV0IGVuZE9mV2VlaztcbiAgICAvLyB5ZWFyIGFuZCBtb250aCB2aWV3cyBzaG91bGQgYmUgYWxpZ25lZCB3aXRoIHdlZWtzLiB0aGlzIGlzIGFscmVhZHkgZG9uZSBmb3Igd2Vla1xuICAgIGlmIChwcm9wcy5zbmFwVG9XZWVrKSB7XG4gICAgICAgIHN0YXJ0ID0gZGF0ZUVudi5zdGFydE9mV2VlayhzdGFydCk7XG4gICAgICAgIC8vIG1ha2UgZW5kLW9mLXdlZWsgaWYgbm90IGFscmVhZHlcbiAgICAgICAgZW5kT2ZXZWVrID0gZGF0ZUVudi5zdGFydE9mV2VlayhlbmQpO1xuICAgICAgICBpZiAoZW5kT2ZXZWVrLnZhbHVlT2YoKSAhPT0gZW5kLnZhbHVlT2YoKSkge1xuICAgICAgICAgICAgZW5kID0gYWRkV2Vla3MoZW5kT2ZXZWVrLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlbnN1cmUgNiB3ZWVrc1xuICAgIGlmIChwcm9wcy5maXhlZFdlZWtDb3VudCkge1xuICAgICAgICAvLyBUT0RPOiBpbnN0ZWFkIG9mIHRoZXNlIGRhdGUtbWF0aCBneW1uYXN0aWNzIChmb3IgbXVsdGltb250aCB2aWV3KSxcbiAgICAgICAgLy8gY29tcHV0ZSBkYXRlcHJvZmlsZXMgb2YgYWxsIG1vbnRocywgdGhlbiB1c2Ugc3RhcnQgb2YgZmlyc3QgYW5kIGVuZCBvZiBsYXN0LlxuICAgICAgICBsZXQgbGFzdE1vbnRoUmVuZGVyU3RhcnQgPSBkYXRlRW52LnN0YXJ0T2ZXZWVrKGRhdGVFbnYuc3RhcnRPZk1vbnRoKGFkZERheXMoY3VycmVudFJhbmdlLmVuZCwgLTEpKSk7XG4gICAgICAgIGxldCByb3dDbnQgPSBNYXRoLmNlaWwoLy8gY291bGQgYmUgcGFydGlhbCB3ZWVrcyBkdWUgdG8gaGlkZGVuRGF5c1xuICAgICAgICBkaWZmV2Vla3MobGFzdE1vbnRoUmVuZGVyU3RhcnQsIGVuZCkpO1xuICAgICAgICBlbmQgPSBhZGRXZWVrcyhlbmQsIDYgLSByb3dDbnQpO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG59XG5cbnZhciBjc3NfMjQ4eiA9IFwiOnJvb3R7LS1mYy1kYXlncmlkLWV2ZW50LWRvdC13aWR0aDo4cHh9LmZjLWRheWdyaWQtZGF5LWV2ZW50czphZnRlciwuZmMtZGF5Z3JpZC1kYXktZXZlbnRzOmJlZm9yZSwuZmMtZGF5Z3JpZC1kYXktZnJhbWU6YWZ0ZXIsLmZjLWRheWdyaWQtZGF5LWZyYW1lOmJlZm9yZSwuZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzOmFmdGVyLC5mYy1kYXlncmlkLWV2ZW50LWhhcm5lc3M6YmVmb3Jle2NsZWFyOmJvdGg7Y29udGVudDpcXFwiXFxcIjtkaXNwbGF5OnRhYmxlfS5mYyAuZmMtZGF5Z3JpZC1ib2R5e3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6MX0uZmMgLmZjLWRheWdyaWQtZGF5LmZjLWRheS10b2RheXtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLXRvZGF5LWJnLWNvbG9yKX0uZmMgLmZjLWRheWdyaWQtZGF5LWZyYW1le21pbi1oZWlnaHQ6MTAwJTtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLWRheWdyaWQtZGF5LXRvcHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246cm93LXJldmVyc2V9LmZjIC5mYy1kYXktb3RoZXIgLmZjLWRheWdyaWQtZGF5LXRvcHtvcGFjaXR5Oi4zfS5mYyAuZmMtZGF5Z3JpZC1kYXktbnVtYmVye3BhZGRpbmc6NHB4O3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6NH0uZmMgLmZjLWRheWdyaWQtbW9udGgtc3RhcnR7Zm9udC1zaXplOjEuMWVtO2ZvbnQtd2VpZ2h0OjcwMH0uZmMgLmZjLWRheWdyaWQtZGF5LWV2ZW50c3ttYXJnaW4tdG9wOjFweH0uZmMgLmZjLWRheWdyaWQtYm9keS1iYWxhbmNlZCAuZmMtZGF5Z3JpZC1kYXktZXZlbnRze2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowfS5mYyAuZmMtZGF5Z3JpZC1ib2R5LXVuYmFsYW5jZWQgLmZjLWRheWdyaWQtZGF5LWV2ZW50c3ttaW4taGVpZ2h0OjJlbTtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLWRheWdyaWQtYm9keS1uYXR1cmFsIC5mYy1kYXlncmlkLWRheS1ldmVudHN7bWFyZ2luLWJvdHRvbToxZW19LmZjIC5mYy1kYXlncmlkLWV2ZW50LWhhcm5lc3N7cG9zaXRpb246cmVsYXRpdmV9LmZjIC5mYy1kYXlncmlkLWV2ZW50LWhhcm5lc3MtYWJze2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYyAuZmMtZGF5Z3JpZC1iZy1oYXJuZXNze2JvdHRvbTowO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowfS5mYyAuZmMtZGF5Z3JpZC1kYXktYmcgLmZjLW5vbi1idXNpbmVzc3t6LWluZGV4OjF9LmZjIC5mYy1kYXlncmlkLWRheS1iZyAuZmMtYmctZXZlbnR7ei1pbmRleDoyfS5mYyAuZmMtZGF5Z3JpZC1kYXktYmcgLmZjLWhpZ2hsaWdodHt6LWluZGV4OjN9LmZjIC5mYy1kYXlncmlkLWV2ZW50e21hcmdpbi10b3A6MXB4O3otaW5kZXg6Nn0uZmMgLmZjLWRheWdyaWQtZXZlbnQuZmMtZXZlbnQtbWlycm9ye3otaW5kZXg6N30uZmMgLmZjLWRheWdyaWQtZGF5LWJvdHRvbXtmb250LXNpemU6Ljg1ZW07bWFyZ2luOjAgMnB4fS5mYyAuZmMtZGF5Z3JpZC1kYXktYm90dG9tOmFmdGVyLC5mYyAuZmMtZGF5Z3JpZC1kYXktYm90dG9tOmJlZm9yZXtjbGVhcjpib3RoO2NvbnRlbnQ6XFxcIlxcXCI7ZGlzcGxheTp0YWJsZX0uZmMgLmZjLWRheWdyaWQtbW9yZS1saW5re2JvcmRlci1yYWRpdXM6M3B4O2N1cnNvcjpwb2ludGVyO2xpbmUtaGVpZ2h0OjE7bWFyZ2luLXRvcDoxcHg7bWF4LXdpZHRoOjEwMCU7b3ZlcmZsb3c6aGlkZGVuO3BhZGRpbmc6MnB4O3Bvc2l0aW9uOnJlbGF0aXZlO3doaXRlLXNwYWNlOm5vd3JhcDt6LWluZGV4OjR9LmZjIC5mYy1kYXlncmlkLW1vcmUtbGluazpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsLjEpfS5mYyAuZmMtZGF5Z3JpZC13ZWVrLW51bWJlcntiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLW5ldXRyYWwtYmctY29sb3IpO2NvbG9yOnZhcigtLWZjLW5ldXRyYWwtdGV4dC1jb2xvcik7bWluLXdpZHRoOjEuNWVtO3BhZGRpbmc6MnB4O3Bvc2l0aW9uOmFic29sdXRlO3RleHQtYWxpZ246Y2VudGVyO3RvcDowO3otaW5kZXg6NX0uZmMgLmZjLW1vcmUtcG9wb3ZlciAuZmMtcG9wb3Zlci1ib2R5e21pbi13aWR0aDoyMjBweDtwYWRkaW5nOjEwcHh9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtZXZlbnQuZmMtZXZlbnQtc3RhcnQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtZXZlbnQuZmMtZXZlbnQtZW5ke21hcmdpbi1sZWZ0OjJweH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ldmVudC5mYy1ldmVudC1lbmQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtZXZlbnQuZmMtZXZlbnQtc3RhcnR7bWFyZ2luLXJpZ2h0OjJweH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1tb3JlLWxpbmt7ZmxvYXQ6bGVmdH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC13ZWVrLW51bWJlcntib3JkZXItcmFkaXVzOjAgMCAzcHggMDtsZWZ0OjB9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtbW9yZS1saW5re2Zsb2F0OnJpZ2h0fS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1kYXlncmlkLXdlZWstbnVtYmVye2JvcmRlci1yYWRpdXM6MCAwIDAgM3B4O3JpZ2h0OjB9LmZjLWxpcXVpZC1oYWNrIC5mYy1kYXlncmlkLWRheS1mcmFtZXtwb3NpdGlvbjpzdGF0aWN9LmZjLWRheWdyaWQtZXZlbnR7Ym9yZGVyLXJhZGl1czozcHg7Zm9udC1zaXplOnZhcigtLWZjLXNtYWxsLWZvbnQtc2l6ZSk7cG9zaXRpb246cmVsYXRpdmU7d2hpdGUtc3BhY2U6bm93cmFwfS5mYy1kYXlncmlkLWJsb2NrLWV2ZW50IC5mYy1ldmVudC10aW1le2ZvbnQtd2VpZ2h0OjcwMH0uZmMtZGF5Z3JpZC1ibG9jay1ldmVudCAuZmMtZXZlbnQtdGltZSwuZmMtZGF5Z3JpZC1ibG9jay1ldmVudCAuZmMtZXZlbnQtdGl0bGV7cGFkZGluZzoxcHh9LmZjLWRheWdyaWQtZG90LWV2ZW50e2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmZsZXg7cGFkZGluZzoycHggMH0uZmMtZGF5Z3JpZC1kb3QtZXZlbnQgLmZjLWV2ZW50LXRpdGxle2ZsZXgtZ3JvdzoxO2ZsZXgtc2hyaW5rOjE7Zm9udC13ZWlnaHQ6NzAwO21pbi13aWR0aDowO292ZXJmbG93OmhpZGRlbn0uZmMtZGF5Z3JpZC1kb3QtZXZlbnQuZmMtZXZlbnQtbWlycm9yLC5mYy1kYXlncmlkLWRvdC1ldmVudDpob3ZlcntiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsLjEpfS5mYy1kYXlncmlkLWRvdC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZDpiZWZvcmV7Ym90dG9tOi0xMHB4O3RvcDotMTBweH0uZmMtZGF5Z3JpZC1ldmVudC1kb3R7Ym9yZGVyOmNhbGModmFyKC0tZmMtZGF5Z3JpZC1ldmVudC1kb3Qtd2lkdGgpLzIpIHNvbGlkIHZhcigtLWZjLWV2ZW50LWJvcmRlci1jb2xvcik7Ym9yZGVyLXJhZGl1czpjYWxjKHZhcigtLWZjLWRheWdyaWQtZXZlbnQtZG90LXdpZHRoKS8yKTtib3gtc2l6aW5nOmNvbnRlbnQtYm94O2hlaWdodDowO21hcmdpbjowIDRweDt3aWR0aDowfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLWV2ZW50IC5mYy1ldmVudC10aW1le21hcmdpbi1yaWdodDozcHh9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtZXZlbnQgLmZjLWV2ZW50LXRpbWV7bWFyZ2luLWxlZnQ6M3B4fVwiO1xuaW5qZWN0U3R5bGVzKGNzc18yNDh6KTtcblxuZXhwb3J0IHsgRGF5VGFibGVWaWV3IGFzIERheUdyaWRWaWV3LCBEYXlUYWJsZSwgRGF5VGFibGVTbGljZXIsIFRhYmxlLCBUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yLCBUYWJsZVJvd3MsIFRhYmxlVmlldywgYnVpbGREYXlUYWJsZU1vZGVsLCBidWlsZERheVRhYmxlUmVuZGVyUmFuZ2UgfTtcbiJdLCJuYW1lcyI6WyJEYXRlQ29tcG9uZW50IiwiZ2V0U3RpY2t5SGVhZGVyRGF0ZXMiLCJWaWV3Q29udGFpbmVyIiwiU2ltcGxlU2Nyb2xsR3JpZCIsImdldFN0aWNreUZvb3RlclNjcm9sbGJhciIsInJlbmRlclNjcm9sbFNoaW0iLCJjcmVhdGVGb3JtYXR0ZXIiLCJCYXNlQ29tcG9uZW50IiwiU3RhbmRhcmRFdmVudCIsImJ1aWxkU2VnVGltZVRleHQiLCJFdmVudENvbnRhaW5lciIsImdldFNlZ0FuY2hvckF0dHJzIiwibWVtb2l6ZSIsIk1vcmVMaW5rQ29udGFpbmVyIiwiZ2V0U2VnTWV0YSIsImdldFVuaXF1ZURvbUlkIiwic2V0UmVmIiwiRGF5Q2VsbENvbnRhaW5lciIsIldlZWtOdW1iZXJDb250YWluZXIiLCJidWlsZE5hdkxpbmtBdHRycyIsImhhc0N1c3RvbURheUNlbGxDb250ZW50IiwiYWRkTXMiLCJpbnRlcnNlY3RSYW5nZXMiLCJhZGREYXlzIiwiU2VnSGllcmFyY2h5IiwiYnVpbGRFbnRyeUtleSIsImludGVyc2VjdFNwYW5zIiwiUmVmTWFwIiwic29ydEV2ZW50U2VncyIsImlzUHJvcHNFcXVhbCIsImJ1aWxkRXZlbnRSYW5nZUtleSIsIkJnRXZlbnQiLCJyZW5kZXJGaWxsIiwiUG9zaXRpb25DYWNoZSIsIk5vd1RpbWVyIiwiZm9ybWF0SXNvTW9udGhTdHIiLCJmb3JtYXREYXlTdHJpbmciLCJTbGljZXIiLCJEYXlIZWFkZXIiLCJEYXlTZXJpZXNNb2RlbCIsIkRheVRhYmxlTW9kZWwiLCJEYXRlUHJvZmlsZUdlbmVyYXRvciIsImFkZFdlZWtzIiwiZGlmZldlZWtzIiwiaW5qZWN0U3R5bGVzIiwiY3JlYXRlUmVmIiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwiVGFibGVWaWV3IiwiY29uc3RydWN0b3IiLCJhcmd1bWVudHMiLCJoZWFkZXJFbFJlZiIsInJlbmRlclNpbXBsZUxheW91dCIsImhlYWRlclJvd0NvbnRlbnQiLCJib2R5Q29udGVudCIsInByb3BzIiwiY29udGV4dCIsInNlY3Rpb25zIiwic3RpY2t5SGVhZGVyRGF0ZXMiLCJvcHRpb25zIiwicHVzaCIsInR5cGUiLCJrZXkiLCJpc1N0aWNreSIsImNodW5rIiwiZWxSZWYiLCJ0YWJsZUNsYXNzTmFtZSIsInJvd0NvbnRlbnQiLCJsaXF1aWQiLCJjb250ZW50IiwiZWxDbGFzc2VzIiwidmlld1NwZWMiLCJpc0hlaWdodEF1dG8iLCJmb3JQcmludCIsImNvbGxhcHNpYmxlV2lkdGgiLCJjb2xzIiwicmVuZGVySFNjcm9sbExheW91dCIsImNvbENudCIsImRheU1pbldpZHRoIiwiU2Nyb2xsR3JpZCIsInBsdWdpbkhvb2tzIiwic2Nyb2xsR3JpZEltcGwiLCJFcnJvciIsInN0aWNreUZvb3RlclNjcm9sbGJhciIsImNodW5rcyIsImNvbEdyb3VwcyIsInNwYW4iLCJtaW5XaWR0aCIsInNwbGl0U2Vnc0J5Um93Iiwic2VncyIsInJvd0NudCIsImJ5Um93IiwiaSIsInNlZyIsInJvdyIsInNwbGl0U2Vnc0J5Rmlyc3RDb2wiLCJieUNvbCIsImZpcnN0Q29sIiwic3BsaXRJbnRlcmFjdGlvbkJ5Um93IiwidWkiLCJhZmZlY3RlZEluc3RhbmNlcyIsImlzRXZlbnQiLCJERUZBVUxUX1RBQkxFX0VWRU5UX1RJTUVfRk9STUFUIiwiaG91ciIsIm1pbnV0ZSIsIm9taXRaZXJvTWludXRlIiwibWVyaWRpZW0iLCJoYXNMaXN0SXRlbURpc3BsYXkiLCJkaXNwbGF5IiwiZXZlbnRSYW5nZSIsImRlZiIsImFsbERheSIsImxhc3RDb2wiLCJpc1N0YXJ0IiwiaXNFbmQiLCJUYWJsZUJsb2NrRXZlbnQiLCJyZW5kZXIiLCJPYmplY3QiLCJhc3NpZ24iLCJkZWZhdWx0VGltZUZvcm1hdCIsImRlZmF1bHREaXNwbGF5RXZlbnRFbmQiLCJkaXNhYmxlUmVzaXppbmciLCJUYWJsZUxpc3RJdGVtRXZlbnQiLCJ0aW1lRm9ybWF0IiwiZXZlbnRUaW1lRm9ybWF0IiwidGltZVRleHQiLCJlbFRhZyIsImVsQXR0cnMiLCJkZWZhdWx0R2VuZXJhdG9yIiwicmVuZGVySW5uZXJDb250ZW50IiwiaXNSZXNpemluZyIsImlzRGF0ZVNlbGVjdGluZyIsInJlbmRlclByb3BzIiwiY2xhc3NOYW1lIiwic3R5bGUiLCJib3JkZXJDb2xvciIsImJhY2tncm91bmRDb2xvciIsImV2ZW50IiwidGl0bGUiLCJUYWJsZUNlbGxNb3JlTGluayIsImNvbXBpbGVTZWdzIiwiYWxsU2VncyIsImludmlzaWJsZVNlZ3MiLCJzaW5nbGVQbGFjZW1lbnRzIiwiZGF0ZVByb2ZpbGUiLCJ0b2RheVJhbmdlIiwiYWxsRGF5RGF0ZSIsIm1vcmVDbnQiLCJoaWRkZW5TZWdzIiwiYWxpZ25tZW50RWxSZWYiLCJhbGlnbkdyaWRUb3AiLCJleHRyYURhdGVTcGFuIiwicG9wb3ZlckNvbnRlbnQiLCJpc0ZvcmNlZEludmlzaWJsZSIsImV2ZW50RHJhZyIsImV2ZW50UmVzaXplIiwibWFwIiwiaW5zdGFuY2VJZCIsImluc3RhbmNlIiwidmlzaWJpbGl0eSIsImlzRHJhZ2dpbmciLCJpc1NlbGVjdGVkIiwiZXZlbnRTZWxlY3Rpb24iLCJwbGFjZW1lbnQiLCJpc1Zpc2libGUiLCJERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVCIsIndlZWsiLCJUYWJsZUNlbGwiLCJyb290RWxSZWYiLCJzdGF0ZSIsImRheU51bWJlcklkIiwiaGFuZGxlUm9vdEVsIiwiZWwiLCJkYXRlRW52IiwiZGF0ZSIsImlzTW9udGhTdGFydCIsInNob3dEYXlOdW1iZXIiLCJzaG91bGREaXNwbGF5TW9udGhTdGFydCIsImN1cnJlbnRSYW5nZSIsImV4dHJhQ2xhc3NOYW1lcyIsImV4dHJhRGF0YUF0dHJzIiwicm9sZSIsInJlbmRlclRvcElubmVyIiwiZXh0cmFSZW5kZXJQcm9wcyIsIklubmVyQ29udGVudCIsInJlZiIsImlubmVyRWxSZWYiLCJtaW5IZWlnaHQiLCJzaG93V2Vla051bWJlciIsImRlZmF1bHRGb3JtYXQiLCJpc0Rpc2FibGVkIiwiZm9yY2VEYXlUb3AiLCJpZCIsInVuZGVmaW5lZCIsImZnQ29udGVudEVsUmVmIiwiZmdDb250ZW50IiwibWFyZ2luVG9wIiwibW9yZU1hcmdpblRvcCIsImJnQ29udGVudCIsImRheU51bWJlclRleHQiLCJzdGFydCIsImN1cnJlbnRTdGFydCIsImVuZCIsImN1cnJlbnRFbmQiLCJjdXJyZW50RW5kSW5jbCIsImN1cnJlbnRGaXJzdFllYXIiLCJnZXRZZWFyIiwiY3VycmVudEZpcnN0TW9udGgiLCJnZXRNb250aCIsImN1cnJlbnRMYXN0WWVhciIsImN1cnJlbnRMYXN0TW9udGgiLCJCb29sZWFuIiwidmFsdWVPZiIsImdldERheSIsImdlbmVyYXRlU2VnS2V5IiwiZ2VuZXJhdGVTZWdVaWQiLCJjb21wdXRlRmdTZWdQbGFjZW1lbnQiLCJkYXlNYXhFdmVudHMiLCJkYXlNYXhFdmVudFJvd3MiLCJzdHJpY3RPcmRlciIsInNlZ0hlaWdodHMiLCJtYXhDb250ZW50SGVpZ2h0IiwiY2VsbHMiLCJoaWVyYXJjaHkiLCJEYXlHcmlkU2VnSGllcmFyY2h5Iiwic2VnRW50cnkiLCJzZWdVaWQiLCJpbmRleCIsImFsbG93UmVzbGljaW5nIiwibWF4Q29vcmQiLCJoaWRkZW5Db25zdW1lcyIsIm1heFN0YWNrQ250Iiwic2VnSW5wdXRzIiwidW5rbm93bkhlaWdodFNlZ3MiLCJsZW5ndGgiLCJldmVudEhlaWdodCIsImhpZGRlbkVudHJpZXMiLCJhZGRTZWdzIiwic2VnUmVjdHMiLCJ0b1JlY3RzIiwic2luZ2xlQ29sUGxhY2VtZW50cyIsIm11bHRpQ29sUGxhY2VtZW50cyIsImxlZnRvdmVyTWFyZ2lucyIsInBsYWNlUmVjdHMiLCJtb3JlQ250cyIsIm1vcmVNYXJnaW5Ub3BzIiwiaXNBYnNvbHV0ZSIsImFic29sdXRlVG9wIiwiY29sIiwicmVzbGljZVNlZyIsImhpZGRlbkVudHJ5IiwiaGlkZGVuU3BhbiIsImFsbFJlY3RzIiwicmVjdHNCeUVhY2hDb2wiLCJncm91cFJlY3RzQnlFYWNoQ29sIiwicmVjdHMiLCJjdXJyZW50SGVpZ2h0IiwiY3VycmVudE1hcmdpblRvcCIsInJlY3QiLCJsZXZlbENvb3JkIiwidGhpY2tuZXNzIiwibXVsdGlQbGFjZW1lbnRzIiwiaXNGaXJzdENvbCIsInNwYW5TdGFydCIsInNwYW5FbmQiLCJvcmlnUmFuZ2UiLCJyYW5nZSIsInNsaWNlZFJhbmdlIiwiZHVyYXRpb25FZGl0YWJsZSIsImZvcmNlSGlkZGVuIiwiZW50cmllc0J5TGV2ZWwiLCJleGNsdWRlSGlkZGVuIiwiZW50cnkiLCJsZXZlbCIsImZpbHRlciIsImhhbmRsZUludmFsaWRJbnNlcnRpb24iLCJpbnNlcnRpb24iLCJ0b3VjaGluZ0VudHJ5IiwidG91Y2hpbmdMZXZlbCIsInRvdWNoaW5nTGF0ZXJhbCIsInRvdWNoaW5nRW50cnlJZCIsInBsYWNlaG9sZGVyRW50cnkiLCJwbGFjZWhvbGRlckVudHJ5SWQiLCJzcGxpdEVudHJ5IiwiVGFibGVSb3ciLCJjZWxsRWxSZWZzIiwiZnJhbWVFbFJlZnMiLCJmZ0VsUmVmcyIsInNlZ0hhcm5lc3NSZWZzIiwiZnJhbWVQb3NpdGlvbnMiLCJoYW5kbGVSZXNpemUiLCJpc0ZvcmNlZCIsInVwZGF0ZVNpemluZyIsImJ1c2luZXNzSG91cnNCeUNvbCIsImJ1c2luZXNzSG91clNlZ3MiLCJiZ0V2ZW50U2Vnc0J5Q29sIiwiYmdFdmVudFNlZ3MiLCJoaWdobGlnaHRTZWdzQnlDb2wiLCJnZXRIaWdobGlnaHRTZWdzIiwibWlycm9yU2Vnc0J5Q29sIiwiZ2V0TWlycm9yU2VncyIsImZnRXZlbnRTZWdzIiwiZXZlbnRPcmRlciIsImV2ZW50T3JkZXJTdHJpY3QiLCJyZW5kZXJJbnRybyIsImNlbGwiLCJub3JtYWxGZ05vZGVzIiwicmVuZGVyRmdTZWdzIiwibWlycm9yRmdOb2RlcyIsImJ1aWxkTWlycm9yUGxhY2VtZW50cyIsInNob3dEYXlOdW1iZXJzIiwic2hvd1dlZWtOdW1iZXJzIiwicmVuZGVyRmlsbFNlZ3MiLCJjZWxsTWluSGVpZ2h0IiwiY29tcG9uZW50RGlkTW91bnQiLCJhZGRSZXNpemVIYW5kbGVyIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwicHJldlN0YXRlIiwiY3VycmVudFByb3BzIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJyZW1vdmVSZXNpemVIYW5kbGVyIiwiZGF0ZVNlbGVjdGlvblNlZ3MiLCJzZWdQbGFjZW1lbnRzIiwiaXNNaXJyb3IiLCJub2RlcyIsImxlZnQiLCJyaWdodCIsImlzUnRsIiwibGVmdHMiLCJyaWdodHMiLCJ0b3AiLCJmaWxsVHlwZSIsImxlZnRSaWdodENzcyIsImlzRXh0ZXJuYWxTaXppbmdDaGFuZ2UiLCJjbGllbnRXaWR0aCIsImZyYW1lRWxzIiwiY3VycmVudE1hcCIsIm9yaWdpbkVsIiwiY3VycmVudCIsIm5ld1Bvc2l0aW9uQ2FjaGUiLCJzaW1pbGFyVG8iLCJzZXRTdGF0ZSIsIm9sZFNlZ0hlaWdodHMiLCJuZXdTZWdIZWlnaHRzIiwicXVlcnlTZWdIZWlnaHRzIiwibGltaXRCeUNvbnRlbnRIZWlnaHQiLCJzYWZlU2V0U3RhdGUiLCJjb21wdXRlTWF4Q29udGVudEhlaWdodCIsInNlZ0VsTWFwIiwiaGVpZ2h0IiwiTWF0aCIsInJvdW5kIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwibWF4IiwiZmlyc3RLZXkiLCJjZWxsRWwiLCJmY0NvbnRhaW5lckVsIiwiYm90dG9tIiwiZ2V0Q2VsbEVscyIsImVsTWFwIiwiYWRkU3RhdGVFcXVhbGl0eSIsIm1pcnJvclNlZ3MiLCJjb2xQbGFjZW1lbnRzIiwidG9wc0J5SW5zdGFuY2VJZCIsImJ1aWxkQWJzb2x1dGVUb3BIYXNoIiwicGxhY2VtZW50cyIsIlRhYmxlUm93cyIsInNwbGl0QnVzaW5lc3NIb3VyU2VncyIsInNwbGl0QmdFdmVudFNlZ3MiLCJzcGxpdEZnRXZlbnRTZWdzIiwic3BsaXREYXRlU2VsZWN0aW9uU2VncyIsInNwbGl0RXZlbnREcmFnIiwic3BsaXRFdmVudFJlc2l6ZSIsInJvd1JlZnMiLCJidXNpbmVzc0hvdXJTZWdzQnlSb3ciLCJiZ0V2ZW50U2Vnc0J5Um93IiwiZmdFdmVudFNlZ3NCeVJvdyIsImRhdGVTZWxlY3Rpb25TZWdzQnlSb3ciLCJldmVudERyYWdCeVJvdyIsImV2ZW50UmVzaXplQnlSb3ciLCJhc3BlY3RSYXRpbyIsInVuaXQiLCJub3dEYXRlIiwidG9JU09TdHJpbmciLCJyZW5kZXJSb3dJbnRybyIsImlzU2VnQWxsRGF5IiwiY2xpZW50SGVpZ2h0IiwicmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCIsInJvb3RFbCIsImZpcnN0Q2VsbEVsIiwiY2xvc2VzdCIsImlzSGl0Q29tYm9BbGxvd2VkIiwidW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50IiwicHJlcGFyZUhpdHMiLCJyb3dQb3NpdGlvbnMiLCJjb2xsZWN0Iiwicm93T2JqIiwiY29sUG9zaXRpb25zIiwicXVlcnlIaXQiLCJwb3NpdGlvbkxlZnQiLCJwb3NpdGlvblRvcCIsImxlZnRUb0luZGV4IiwidG9wVG9JbmRleCIsImRhdGVTcGFuIiwiZ2V0Q2VsbFJhbmdlIiwiZGF5RWwiLCJnZXRDZWxsRWwiLCJ0b3BzIiwiYm90dG9tcyIsImxheWVyIiwiVGFibGUiLCJuZWVkc1Njcm9sbFJlc2V0IiwiZXhwYW5kUm93cyIsImxpbWl0VmlhQmFsYW5jZWQiLCJjbGFzc05hbWVzIiwiam9pbiIsIndpZHRoIiwidGFibGVNaW5XaWR0aCIsImNvbEdyb3VwTm9kZSIsInJlcXVlc3RTY3JvbGxSZXNldCIsImZsdXNoU2Nyb2xsUmVzZXQiLCJzdWJqZWN0RWwiLCJnZXRTY3JvbGxTdWJqZWN0RWwiLCJzY3JvbGxFbCIsInNjcm9sbFRvcCIsImNvbnRhaW5lckVsIiwiY3VycmVudFJhbmdlVW5pdCIsIm1hdGNoIiwicXVlcnlTZWxlY3RvciIsImN1cnJlbnREYXRlIiwiRGF5VGFibGVTbGljZXIiLCJmb3JjZURheUlmTGlzdEl0ZW0iLCJzbGljZVJhbmdlIiwiZGF0ZVJhbmdlIiwiZGF5VGFibGVNb2RlbCIsIkRheVRhYmxlIiwic2xpY2VyIiwidGFibGVSZWYiLCJzbGljZVByb3BzIiwibmV4dERheVRocmVzaG9sZCIsImhlYWRlckFsaWduRWxSZWYiLCJEYXlUYWJsZVZpZXciLCJidWlsZERheVRhYmxlTW9kZWwiLCJoZWFkZXJSZWYiLCJkYXRlUHJvZmlsZUdlbmVyYXRvciIsImhlYWRlckNvbnRlbnQiLCJkYXlIZWFkZXJzIiwiZGF0ZXMiLCJoZWFkZXJEYXRlcyIsImRhdGVzUmVwRGlzdGluY3REYXlzIiwiY29udGVudEFyZyIsImJ1c2luZXNzSG91cnMiLCJkYXRlU2VsZWN0aW9uIiwiZXZlbnRTdG9yZSIsImV2ZW50VWlCYXNlcyIsInRhYmxlQ29sR3JvdXBOb2RlIiwid2Vla051bWJlcnMiLCJkYXlTZXJpZXMiLCJyZW5kZXJSYW5nZSIsInRlc3QiLCJUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yIiwiYnVpbGRSZW5kZXJSYW5nZSIsImlzUmFuZ2VBbGxEYXkiLCJidWlsZERheVRhYmxlUmVuZGVyUmFuZ2UiLCJzbmFwVG9XZWVrIiwiZml4ZWRXZWVrQ291bnQiLCJlbmRPZldlZWsiLCJzdGFydE9mV2VlayIsImxhc3RNb250aFJlbmRlclN0YXJ0Iiwic3RhcnRPZk1vbnRoIiwiY2VpbCIsImNzc18yNDh6IiwiRGF5R3JpZFZpZXciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/daygrid/internal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@fullcalendar/react/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@fullcalendar/react/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FullCalendar)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var _fullcalendar_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fullcalendar/core */ \"(ssr)/./node_modules/@fullcalendar/core/index.js\");\n/* harmony import */ var _fullcalendar_core_internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fullcalendar/core/internal */ \"(ssr)/./node_modules/@fullcalendar/core/internal-common.js\");\n/* eslint-disable @typescript-eslint/no-explicit-any */ \n\n\n\nconst reactMajorVersion = parseInt(String(react__WEBPACK_IMPORTED_MODULE_0__.version).split(\".\")[0]);\nconst syncRenderingByDefault = reactMajorVersion < 18;\nclass FullCalendar extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(){\n        super(...arguments);\n        this.elRef = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n        this.isUpdating = false;\n        this.isUnmounting = false;\n        this.state = {\n            customRenderingMap: new Map()\n        };\n        this.requestResize = ()=>{\n            if (!this.isUnmounting) {\n                this.cancelResize();\n                this.resizeId = requestAnimationFrame(()=>{\n                    this.doResize();\n                });\n            }\n        };\n    }\n    render() {\n        const customRenderingNodes = [];\n        for (const customRendering of this.state.customRenderingMap.values()){\n            customRenderingNodes.push(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CustomRenderingComponent, {\n                key: customRendering.id,\n                customRendering: customRendering\n            }));\n        }\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            ref: this.elRef\n        }, customRenderingNodes);\n    }\n    componentDidMount() {\n        const customRenderingStore = new _fullcalendar_core_internal__WEBPACK_IMPORTED_MODULE_2__.cy();\n        this.handleCustomRendering = customRenderingStore.handle.bind(customRenderingStore);\n        this.calendar = new _fullcalendar_core__WEBPACK_IMPORTED_MODULE_3__.Calendar(this.elRef.current, Object.assign(Object.assign({}, this.props), {\n            handleCustomRendering: this.handleCustomRendering\n        }));\n        this.calendar.render();\n        let lastRequestTimestamp;\n        customRenderingStore.subscribe((customRenderingMap)=>{\n            const requestTimestamp = Date.now();\n            const isMounting = !lastRequestTimestamp;\n            const runFunc = // don't call flushSync if React version already does sync rendering by default\n            // guards against fatal errors:\n            // https://github.com/fullcalendar/fullcalendar/issues/7448\n            syncRenderingByDefault || //\n            isMounting || this.isUpdating || this.isUnmounting || requestTimestamp - lastRequestTimestamp < 100 // rerendering frequently\n             ? runNow // either sync rendering (first-time or React 16/17) or async (React 18)\n             : react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync; // guaranteed sync rendering\n            runFunc(()=>{\n                this.setState({\n                    customRenderingMap\n                }, ()=>{\n                    lastRequestTimestamp = requestTimestamp;\n                    if (isMounting) {\n                        this.doResize();\n                    } else {\n                        this.requestResize();\n                    }\n                });\n            });\n        });\n    }\n    componentDidUpdate() {\n        this.isUpdating = true;\n        this.calendar.resetOptions(Object.assign(Object.assign({}, this.props), {\n            handleCustomRendering: this.handleCustomRendering\n        }));\n        this.isUpdating = false;\n    }\n    componentWillUnmount() {\n        this.isUnmounting = true;\n        this.cancelResize();\n        this.calendar.destroy();\n    }\n    doResize() {\n        this.calendar.updateSize();\n    }\n    cancelResize() {\n        if (this.resizeId !== undefined) {\n            cancelAnimationFrame(this.resizeId);\n            this.resizeId = undefined;\n        }\n    }\n    getApi() {\n        return this.calendar;\n    }\n}\nFullCalendar.act = runNow; // DEPRECATED. Not leveraged anymore\nclass CustomRenderingComponent extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    render() {\n        const { customRendering } = this.props;\n        const { generatorMeta } = customRendering;\n        const vnode = typeof generatorMeta === \"function\" ? generatorMeta(customRendering.renderProps) : generatorMeta;\n        return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(vnode, customRendering.containerEl);\n    }\n}\n// Util\n// -------------------------------------------------------------------------------------------------\nfunction runNow(f) {\n    f();\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEscURBQXFELEdBQ2M7QUFDZjtBQUNMO0FBQ3FCO0FBQ3BFLE1BQU1RLG9CQUFvQkMsU0FBU0MsT0FBT1YsMENBQWEsRUFBRVksS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ3RFLE1BQU1DLHlCQUF5Qkwsb0JBQW9CO0FBQ3BDLE1BQU1NLHFCQUFxQmIsNENBQVNBO0lBQy9DYyxhQUFjO1FBQ1YsS0FBSyxJQUFJQztRQUNULElBQUksQ0FBQ0MsS0FBSyxpQkFBR2YsZ0RBQVNBO1FBQ3RCLElBQUksQ0FBQ2dCLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLEtBQUssR0FBRztZQUNUQyxvQkFBb0IsSUFBSUM7UUFDNUI7UUFDQSxJQUFJLENBQUNDLGFBQWEsR0FBRztZQUNqQixJQUFJLENBQUMsSUFBSSxDQUFDSixZQUFZLEVBQUU7Z0JBQ3BCLElBQUksQ0FBQ0ssWUFBWTtnQkFDakIsSUFBSSxDQUFDQyxRQUFRLEdBQUdDLHNCQUFzQjtvQkFDbEMsSUFBSSxDQUFDQyxRQUFRO2dCQUNqQjtZQUNKO1FBQ0o7SUFDSjtJQUNBQyxTQUFTO1FBQ0wsTUFBTUMsdUJBQXVCLEVBQUU7UUFDL0IsS0FBSyxNQUFNQyxtQkFBbUIsSUFBSSxDQUFDVixLQUFLLENBQUNDLGtCQUFrQixDQUFDVSxNQUFNLEdBQUk7WUFDbEVGLHFCQUFxQkcsSUFBSSxlQUFDaEMsZ0RBQW1CLENBQUNrQywwQkFBMEI7Z0JBQUVDLEtBQUtMLGdCQUFnQk0sRUFBRTtnQkFBRU4saUJBQWlCQTtZQUFnQjtRQUN4STtRQUNBLHFCQUFROUIsZ0RBQW1CLENBQUMsT0FBTztZQUFFcUMsS0FBSyxJQUFJLENBQUNwQixLQUFLO1FBQUMsR0FBR1k7SUFDNUQ7SUFDQVMsb0JBQW9CO1FBQ2hCLE1BQU1DLHVCQUF1QixJQUFJaEMsMkRBQW9CQTtRQUNyRCxJQUFJLENBQUNpQyxxQkFBcUIsR0FBR0QscUJBQXFCRSxNQUFNLENBQUNDLElBQUksQ0FBQ0g7UUFDOUQsSUFBSSxDQUFDSSxRQUFRLEdBQUcsSUFBSXJDLHdEQUFRQSxDQUFDLElBQUksQ0FBQ1csS0FBSyxDQUFDMkIsT0FBTyxFQUFFQyxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDQyxLQUFLLEdBQUc7WUFBRVAsdUJBQXVCLElBQUksQ0FBQ0EscUJBQXFCO1FBQUM7UUFDbEosSUFBSSxDQUFDRyxRQUFRLENBQUNmLE1BQU07UUFDcEIsSUFBSW9CO1FBQ0pULHFCQUFxQlUsU0FBUyxDQUFDLENBQUM1QjtZQUM1QixNQUFNNkIsbUJBQW1CQyxLQUFLQyxHQUFHO1lBQ2pDLE1BQU1DLGFBQWEsQ0FBQ0w7WUFDcEIsTUFBTU0sVUFBVSwrRUFDK0Q7WUFDL0UsK0JBQStCO1lBQy9CLDJEQUEyRDtZQUMzRHpDLDBCQUNJLEVBQUU7WUFDRndDLGNBQ0EsSUFBSSxDQUFDbkMsVUFBVSxJQUNmLElBQUksQ0FBQ0MsWUFBWSxJQUNqQixtQkFBb0I2Qix1QkFBd0IsSUFBSSx5QkFBeUI7ZUFDekVPLE9BQU8sd0VBQXdFO2VBQzdFbEQsZ0RBQVNBLEVBQUUsNEJBQTRCO1lBQzdDaUQsUUFBUTtnQkFDSixJQUFJLENBQUNFLFFBQVEsQ0FBQztvQkFBRW5DO2dCQUFtQixHQUFHO29CQUNsQzJCLHVCQUF1QkU7b0JBQ3ZCLElBQUlHLFlBQVk7d0JBQ1osSUFBSSxDQUFDMUIsUUFBUTtvQkFDakIsT0FDSzt3QkFDRCxJQUFJLENBQUNKLGFBQWE7b0JBQ3RCO2dCQUNKO1lBQ0o7UUFDSjtJQUNKO0lBQ0FrQyxxQkFBcUI7UUFDakIsSUFBSSxDQUFDdkMsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ3lCLFFBQVEsQ0FBQ2UsWUFBWSxDQUFDYixPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDQyxLQUFLLEdBQUc7WUFBRVAsdUJBQXVCLElBQUksQ0FBQ0EscUJBQXFCO1FBQUM7UUFDNUgsSUFBSSxDQUFDdEIsVUFBVSxHQUFHO0lBQ3RCO0lBQ0F5Qyx1QkFBdUI7UUFDbkIsSUFBSSxDQUFDeEMsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0ssWUFBWTtRQUNqQixJQUFJLENBQUNtQixRQUFRLENBQUNpQixPQUFPO0lBQ3pCO0lBQ0FqQyxXQUFXO1FBQ1AsSUFBSSxDQUFDZ0IsUUFBUSxDQUFDa0IsVUFBVTtJQUM1QjtJQUNBckMsZUFBZTtRQUNYLElBQUksSUFBSSxDQUFDQyxRQUFRLEtBQUtxQyxXQUFXO1lBQzdCQyxxQkFBcUIsSUFBSSxDQUFDdEMsUUFBUTtZQUNsQyxJQUFJLENBQUNBLFFBQVEsR0FBR3FDO1FBQ3BCO0lBQ0o7SUFDQUUsU0FBUztRQUNMLE9BQU8sSUFBSSxDQUFDckIsUUFBUTtJQUN4QjtBQUNKO0FBQ0E3QixhQUFhbUQsR0FBRyxHQUFHVixRQUFRLG9DQUFvQztBQUMvRCxNQUFNckIsaUNBQWlDL0IsZ0RBQWFBO0lBQ2hEeUIsU0FBUztRQUNMLE1BQU0sRUFBRUUsZUFBZSxFQUFFLEdBQUcsSUFBSSxDQUFDaUIsS0FBSztRQUN0QyxNQUFNLEVBQUVtQixhQUFhLEVBQUUsR0FBR3BDO1FBQzFCLE1BQU1xQyxRQUFRLE9BQU9ELGtCQUFrQixhQUNuQ0EsY0FBY3BDLGdCQUFnQnNDLFdBQVcsSUFDekNGO1FBQ0oscUJBQU85RCx1REFBWUEsQ0FBQytELE9BQU9yQyxnQkFBZ0J1QyxXQUFXO0lBQzFEO0FBQ0o7QUFDQSxPQUFPO0FBQ1Asb0dBQW9HO0FBQ3BHLFNBQVNkLE9BQU9lLENBQUM7SUFDYkE7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvcmVhY3QvZGlzdC9pbmRleC5qcz9kN2I5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIGNyZWF0ZVJlZiwgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCwgZmx1c2hTeW5jIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IENhbGVuZGFyLCB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZSc7XG5pbXBvcnQgeyBDdXN0b21SZW5kZXJpbmdTdG9yZSwgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW50ZXJuYWwnO1xuY29uc3QgcmVhY3RNYWpvclZlcnNpb24gPSBwYXJzZUludChTdHJpbmcoUmVhY3QudmVyc2lvbikuc3BsaXQoJy4nKVswXSk7XG5jb25zdCBzeW5jUmVuZGVyaW5nQnlEZWZhdWx0ID0gcmVhY3RNYWpvclZlcnNpb24gPCAxODtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZ1bGxDYWxlbmRhciBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNVbm1vdW50aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjdXN0b21SZW5kZXJpbmdNYXA6IG5ldyBNYXAoKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlcXVlc3RSZXNpemUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNVbm1vdW50aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxSZXNpemUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1Jlc2l6ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IGN1c3RvbVJlbmRlcmluZ05vZGVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgY3VzdG9tUmVuZGVyaW5nIG9mIHRoaXMuc3RhdGUuY3VzdG9tUmVuZGVyaW5nTWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBjdXN0b21SZW5kZXJpbmdOb2Rlcy5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ3VzdG9tUmVuZGVyaW5nQ29tcG9uZW50LCB7IGtleTogY3VzdG9tUmVuZGVyaW5nLmlkLCBjdXN0b21SZW5kZXJpbmc6IGN1c3RvbVJlbmRlcmluZyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLmVsUmVmIH0sIGN1c3RvbVJlbmRlcmluZ05vZGVzKSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCBjdXN0b21SZW5kZXJpbmdTdG9yZSA9IG5ldyBDdXN0b21SZW5kZXJpbmdTdG9yZSgpO1xuICAgICAgICB0aGlzLmhhbmRsZUN1c3RvbVJlbmRlcmluZyA9IGN1c3RvbVJlbmRlcmluZ1N0b3JlLmhhbmRsZS5iaW5kKGN1c3RvbVJlbmRlcmluZ1N0b3JlKTtcbiAgICAgICAgdGhpcy5jYWxlbmRhciA9IG5ldyBDYWxlbmRhcih0aGlzLmVsUmVmLmN1cnJlbnQsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcyksIHsgaGFuZGxlQ3VzdG9tUmVuZGVyaW5nOiB0aGlzLmhhbmRsZUN1c3RvbVJlbmRlcmluZyB9KSk7XG4gICAgICAgIHRoaXMuY2FsZW5kYXIucmVuZGVyKCk7XG4gICAgICAgIGxldCBsYXN0UmVxdWVzdFRpbWVzdGFtcDtcbiAgICAgICAgY3VzdG9tUmVuZGVyaW5nU3RvcmUuc3Vic2NyaWJlKChjdXN0b21SZW5kZXJpbmdNYXApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgY29uc3QgaXNNb3VudGluZyA9ICFsYXN0UmVxdWVzdFRpbWVzdGFtcDtcbiAgICAgICAgICAgIGNvbnN0IHJ1bkZ1bmMgPSAoXG4gICAgICAgICAgICAvLyBkb24ndCBjYWxsIGZsdXNoU3luYyBpZiBSZWFjdCB2ZXJzaW9uIGFscmVhZHkgZG9lcyBzeW5jIHJlbmRlcmluZyBieSBkZWZhdWx0XG4gICAgICAgICAgICAvLyBndWFyZHMgYWdhaW5zdCBmYXRhbCBlcnJvcnM6XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZnVsbGNhbGVuZGFyL2Z1bGxjYWxlbmRhci9pc3N1ZXMvNzQ0OFxuICAgICAgICAgICAgc3luY1JlbmRlcmluZ0J5RGVmYXVsdCB8fFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgaXNNb3VudGluZyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuaXNVcGRhdGluZyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuaXNVbm1vdW50aW5nIHx8XG4gICAgICAgICAgICAgICAgKHJlcXVlc3RUaW1lc3RhbXAgLSBsYXN0UmVxdWVzdFRpbWVzdGFtcCkgPCAxMDAgLy8gcmVyZW5kZXJpbmcgZnJlcXVlbnRseVxuICAgICAgICAgICAgKSA/IHJ1bk5vdyAvLyBlaXRoZXIgc3luYyByZW5kZXJpbmcgKGZpcnN0LXRpbWUgb3IgUmVhY3QgMTYvMTcpIG9yIGFzeW5jIChSZWFjdCAxOClcbiAgICAgICAgICAgICAgICA6IGZsdXNoU3luYzsgLy8gZ3VhcmFudGVlZCBzeW5jIHJlbmRlcmluZ1xuICAgICAgICAgICAgcnVuRnVuYygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGN1c3RvbVJlbmRlcmluZ01hcCB9LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RSZXF1ZXN0VGltZXN0YW1wID0gcmVxdWVzdFRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTW91bnRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9SZXNpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFJlc2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5pc1VwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYWxlbmRhci5yZXNldE9wdGlvbnMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzKSwgeyBoYW5kbGVDdXN0b21SZW5kZXJpbmc6IHRoaXMuaGFuZGxlQ3VzdG9tUmVuZGVyaW5nIH0pKTtcbiAgICAgICAgdGhpcy5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLmlzVW5tb3VudGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FuY2VsUmVzaXplKCk7XG4gICAgICAgIHRoaXMuY2FsZW5kYXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkb1Jlc2l6ZSgpIHtcbiAgICAgICAgdGhpcy5jYWxlbmRhci51cGRhdGVTaXplKCk7XG4gICAgfVxuICAgIGNhbmNlbFJlc2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzaXplSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXNpemVJZCk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZUlkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEFwaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXI7XG4gICAgfVxufVxuRnVsbENhbGVuZGFyLmFjdCA9IHJ1bk5vdzsgLy8gREVQUkVDQVRFRC4gTm90IGxldmVyYWdlZCBhbnltb3JlXG5jbGFzcyBDdXN0b21SZW5kZXJpbmdDb21wb25lbnQgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY3VzdG9tUmVuZGVyaW5nIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IGdlbmVyYXRvck1ldGEgfSA9IGN1c3RvbVJlbmRlcmluZztcbiAgICAgICAgY29uc3Qgdm5vZGUgPSB0eXBlb2YgZ2VuZXJhdG9yTWV0YSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICBnZW5lcmF0b3JNZXRhKGN1c3RvbVJlbmRlcmluZy5yZW5kZXJQcm9wcykgOlxuICAgICAgICAgICAgZ2VuZXJhdG9yTWV0YTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBvcnRhbCh2bm9kZSwgY3VzdG9tUmVuZGVyaW5nLmNvbnRhaW5lckVsKTtcbiAgICB9XG59XG4vLyBVdGlsXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBydW5Ob3coZikge1xuICAgIGYoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJSZWFjdCIsIkNvbXBvbmVudCIsImNyZWF0ZVJlZiIsIlB1cmVDb21wb25lbnQiLCJjcmVhdGVQb3J0YWwiLCJmbHVzaFN5bmMiLCJDYWxlbmRhciIsIkN1c3RvbVJlbmRlcmluZ1N0b3JlIiwicmVhY3RNYWpvclZlcnNpb24iLCJwYXJzZUludCIsIlN0cmluZyIsInZlcnNpb24iLCJzcGxpdCIsInN5bmNSZW5kZXJpbmdCeURlZmF1bHQiLCJGdWxsQ2FsZW5kYXIiLCJjb25zdHJ1Y3RvciIsImFyZ3VtZW50cyIsImVsUmVmIiwiaXNVcGRhdGluZyIsImlzVW5tb3VudGluZyIsInN0YXRlIiwiY3VzdG9tUmVuZGVyaW5nTWFwIiwiTWFwIiwicmVxdWVzdFJlc2l6ZSIsImNhbmNlbFJlc2l6ZSIsInJlc2l6ZUlkIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZG9SZXNpemUiLCJyZW5kZXIiLCJjdXN0b21SZW5kZXJpbmdOb2RlcyIsImN1c3RvbVJlbmRlcmluZyIsInZhbHVlcyIsInB1c2giLCJjcmVhdGVFbGVtZW50IiwiQ3VzdG9tUmVuZGVyaW5nQ29tcG9uZW50Iiwia2V5IiwiaWQiLCJyZWYiLCJjb21wb25lbnREaWRNb3VudCIsImN1c3RvbVJlbmRlcmluZ1N0b3JlIiwiaGFuZGxlQ3VzdG9tUmVuZGVyaW5nIiwiaGFuZGxlIiwiYmluZCIsImNhbGVuZGFyIiwiY3VycmVudCIsIk9iamVjdCIsImFzc2lnbiIsInByb3BzIiwibGFzdFJlcXVlc3RUaW1lc3RhbXAiLCJzdWJzY3JpYmUiLCJyZXF1ZXN0VGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsImlzTW91bnRpbmciLCJydW5GdW5jIiwicnVuTm93Iiwic2V0U3RhdGUiLCJjb21wb25lbnREaWRVcGRhdGUiLCJyZXNldE9wdGlvbnMiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImRlc3Ryb3kiLCJ1cGRhdGVTaXplIiwidW5kZWZpbmVkIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJnZXRBcGkiLCJhY3QiLCJnZW5lcmF0b3JNZXRhIiwidm5vZGUiLCJyZW5kZXJQcm9wcyIsImNvbnRhaW5lckVsIiwiZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/react/dist/index.js\n");

/***/ })

};
;