"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cliui";
exports.ids = ["vendor-chunks/cliui"];
exports.modules = {

/***/ "(rsc)/./node_modules/cliui/build/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/cliui/build/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UI: () => (/* binding */ UI),\n/* harmony export */   cliui: () => (/* binding */ cliui)\n/* harmony export */ });\n\nconst align = {\n    right: alignRight,\n    center: alignCenter\n};\nconst top = 0;\nconst right = 1;\nconst bottom = 2;\nconst left = 3;\nclass UI {\n    constructor(opts){\n        var _a;\n        this.width = opts.width;\n        this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;\n        this.rows = [];\n    }\n    span(...args) {\n        const cols = this.div(...args);\n        cols.span = true;\n    }\n    resetOutput() {\n        this.rows = [];\n    }\n    div(...args) {\n        if (args.length === 0) {\n            this.div(\"\");\n        }\n        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === \"string\") {\n            return this.applyLayoutDSL(args[0]);\n        }\n        const cols = args.map((arg)=>{\n            if (typeof arg === \"string\") {\n                return this.colFromString(arg);\n            }\n            return arg;\n        });\n        this.rows.push(cols);\n        return cols;\n    }\n    shouldApplyLayoutDSL(...args) {\n        return args.length === 1 && typeof args[0] === \"string\" && /[\\t\\n]/.test(args[0]);\n    }\n    applyLayoutDSL(str) {\n        const rows = str.split(\"\\n\").map((row)=>row.split(\"\t\"));\n        let leftColumnWidth = 0;\n        // simple heuristic for layout, make sure the\n        // second column lines up along the left-hand.\n        // don't allow the first column to take up more\n        // than 50% of the screen.\n        rows.forEach((columns)=>{\n            if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {\n                leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));\n            }\n        });\n        // generate a table:\n        //  replacing ' ' with padding calculations.\n        //  using the algorithmically generated width.\n        rows.forEach((columns)=>{\n            this.div(...columns.map((r, i)=>{\n                return {\n                    text: r.trim(),\n                    padding: this.measurePadding(r),\n                    width: i === 0 && columns.length > 1 ? leftColumnWidth : undefined\n                };\n            }));\n        });\n        return this.rows[this.rows.length - 1];\n    }\n    colFromString(text) {\n        return {\n            text,\n            padding: this.measurePadding(text)\n        };\n    }\n    measurePadding(str) {\n        // measure padding without ansi escape codes\n        const noAnsi = mixin.stripAnsi(str);\n        return [\n            0,\n            noAnsi.match(/\\s*$/)[0].length,\n            0,\n            noAnsi.match(/^\\s*/)[0].length\n        ];\n    }\n    toString() {\n        const lines = [];\n        this.rows.forEach((row)=>{\n            this.rowToString(row, lines);\n        });\n        // don't display any lines with the\n        // hidden flag set.\n        return lines.filter((line)=>!line.hidden).map((line)=>line.text).join(\"\\n\");\n    }\n    rowToString(row, lines) {\n        this.rasterize(row).forEach((rrow, r)=>{\n            let str = \"\";\n            rrow.forEach((col, c)=>{\n                const { width } = row[c]; // the width with padding.\n                const wrapWidth = this.negatePadding(row[c]); // the width without padding.\n                let ts = col; // temporary string used during alignment/padding.\n                if (wrapWidth > mixin.stringWidth(col)) {\n                    ts += \" \".repeat(wrapWidth - mixin.stringWidth(col));\n                }\n                // align the string within its column.\n                if (row[c].align && row[c].align !== \"left\" && this.wrap) {\n                    const fn = align[row[c].align];\n                    ts = fn(ts, wrapWidth);\n                    if (mixin.stringWidth(ts) < wrapWidth) {\n                        ts += \" \".repeat((width || 0) - mixin.stringWidth(ts) - 1);\n                    }\n                }\n                // apply border and padding to string.\n                const padding = row[c].padding || [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n                if (padding[left]) {\n                    str += \" \".repeat(padding[left]);\n                }\n                str += addBorder(row[c], ts, \"| \");\n                str += ts;\n                str += addBorder(row[c], ts, \" |\");\n                if (padding[right]) {\n                    str += \" \".repeat(padding[right]);\n                }\n                // if prior row is span, try to render the\n                // current row on the prior line.\n                if (r === 0 && lines.length > 0) {\n                    str = this.renderInline(str, lines[lines.length - 1]);\n                }\n            });\n            // remove trailing whitespace.\n            lines.push({\n                text: str.replace(/ +$/, \"\"),\n                span: row.span\n            });\n        });\n        return lines;\n    }\n    // if the full 'source' can render in\n    // the target line, do so.\n    renderInline(source, previousLine) {\n        const match = source.match(/^ */);\n        const leadingWhitespace = match ? match[0].length : 0;\n        const target = previousLine.text;\n        const targetTextWidth = mixin.stringWidth(target.trimRight());\n        if (!previousLine.span) {\n            return source;\n        }\n        // if we're not applying wrapping logic,\n        // just always append to the span.\n        if (!this.wrap) {\n            previousLine.hidden = true;\n            return target + source;\n        }\n        if (leadingWhitespace < targetTextWidth) {\n            return source;\n        }\n        previousLine.hidden = true;\n        return target.trimRight() + \" \".repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();\n    }\n    rasterize(row) {\n        const rrows = [];\n        const widths = this.columnWidths(row);\n        let wrapped;\n        // word wrap all columns, and create\n        // a data-structure that is easy to rasterize.\n        row.forEach((col, c)=>{\n            // leave room for left and right padding.\n            col.width = widths[c];\n            if (this.wrap) {\n                wrapped = mixin.wrap(col.text, this.negatePadding(col), {\n                    hard: true\n                }).split(\"\\n\");\n            } else {\n                wrapped = col.text.split(\"\\n\");\n            }\n            if (col.border) {\n                wrapped.unshift(\".\" + \"-\".repeat(this.negatePadding(col) + 2) + \".\");\n                wrapped.push(\"'\" + \"-\".repeat(this.negatePadding(col) + 2) + \"'\");\n            }\n            // add top and bottom padding.\n            if (col.padding) {\n                wrapped.unshift(...new Array(col.padding[top] || 0).fill(\"\"));\n                wrapped.push(...new Array(col.padding[bottom] || 0).fill(\"\"));\n            }\n            wrapped.forEach((str, r)=>{\n                if (!rrows[r]) {\n                    rrows.push([]);\n                }\n                const rrow = rrows[r];\n                for(let i = 0; i < c; i++){\n                    if (rrow[i] === undefined) {\n                        rrow.push(\"\");\n                    }\n                }\n                rrow.push(str);\n            });\n        });\n        return rrows;\n    }\n    negatePadding(col) {\n        let wrapWidth = col.width || 0;\n        if (col.padding) {\n            wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);\n        }\n        if (col.border) {\n            wrapWidth -= 4;\n        }\n        return wrapWidth;\n    }\n    columnWidths(row) {\n        if (!this.wrap) {\n            return row.map((col)=>{\n                return col.width || mixin.stringWidth(col.text);\n            });\n        }\n        let unset = row.length;\n        let remainingWidth = this.width;\n        // column widths can be set in config.\n        const widths = row.map((col)=>{\n            if (col.width) {\n                unset--;\n                remainingWidth -= col.width;\n                return col.width;\n            }\n            return undefined;\n        });\n        // any unset widths should be calculated.\n        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;\n        return widths.map((w, i)=>{\n            if (w === undefined) {\n                return Math.max(unsetWidth, _minWidth(row[i]));\n            }\n            return w;\n        });\n    }\n}\nfunction addBorder(col, ts, style) {\n    if (col.border) {\n        if (/[.']-+[.']/.test(ts)) {\n            return \"\";\n        }\n        if (ts.trim().length !== 0) {\n            return style;\n        }\n        return \"  \";\n    }\n    return \"\";\n}\n// calculates the minimum width of\n// a column, based on padding preferences.\nfunction _minWidth(col) {\n    const padding = col.padding || [];\n    const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);\n    if (col.border) {\n        return minWidth + 4;\n    }\n    return minWidth;\n}\nfunction getWindowWidth() {\n    /* istanbul ignore next: depends on terminal */ if (typeof process === \"object\" && process.stdout && process.stdout.columns) {\n        return process.stdout.columns;\n    }\n    return 80;\n}\nfunction alignRight(str, width) {\n    str = str.trim();\n    const strWidth = mixin.stringWidth(str);\n    if (strWidth < width) {\n        return \" \".repeat(width - strWidth) + str;\n    }\n    return str;\n}\nfunction alignCenter(str, width) {\n    str = str.trim();\n    const strWidth = mixin.stringWidth(str);\n    /* istanbul ignore next */ if (strWidth >= width) {\n        return str;\n    }\n    return \" \".repeat(width - strWidth >> 1) + str;\n}\nlet mixin;\nfunction cliui(opts, _mixin) {\n    mixin = _mixin;\n    return new UI({\n        width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),\n        wrap: opts === null || opts === void 0 ? void 0 : opts.wrap\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xpdWkvYnVpbGQvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQSxNQUFNQSxRQUFRO0lBQ1ZDLE9BQU9DO0lBQ1BDLFFBQVFDO0FBQ1o7QUFDQSxNQUFNQyxNQUFNO0FBQ1osTUFBTUosUUFBUTtBQUNkLE1BQU1LLFNBQVM7QUFDZixNQUFNQyxPQUFPO0FBQ04sTUFBTUM7SUFDVEMsWUFBWUMsSUFBSSxDQUFFO1FBQ2QsSUFBSUM7UUFDSixJQUFJLENBQUNDLEtBQUssR0FBR0YsS0FBS0UsS0FBSztRQUN2QixJQUFJLENBQUNDLElBQUksR0FBRyxDQUFDRixLQUFLRCxLQUFLRyxJQUFJLE1BQU0sUUFBUUYsT0FBTyxLQUFLLElBQUlBLEtBQUs7UUFDOUQsSUFBSSxDQUFDRyxJQUFJLEdBQUcsRUFBRTtJQUNsQjtJQUNBQyxLQUFLLEdBQUdDLElBQUksRUFBRTtRQUNWLE1BQU1DLE9BQU8sSUFBSSxDQUFDQyxHQUFHLElBQUlGO1FBQ3pCQyxLQUFLRixJQUFJLEdBQUc7SUFDaEI7SUFDQUksY0FBYztRQUNWLElBQUksQ0FBQ0wsSUFBSSxHQUFHLEVBQUU7SUFDbEI7SUFDQUksSUFBSSxHQUFHRixJQUFJLEVBQUU7UUFDVCxJQUFJQSxLQUFLSSxNQUFNLEtBQUssR0FBRztZQUNuQixJQUFJLENBQUNGLEdBQUcsQ0FBQztRQUNiO1FBQ0EsSUFBSSxJQUFJLENBQUNMLElBQUksSUFBSSxJQUFJLENBQUNRLG9CQUFvQixJQUFJTCxTQUFTLE9BQU9BLElBQUksQ0FBQyxFQUFFLEtBQUssVUFBVTtZQUNoRixPQUFPLElBQUksQ0FBQ00sY0FBYyxDQUFDTixJQUFJLENBQUMsRUFBRTtRQUN0QztRQUNBLE1BQU1DLE9BQU9ELEtBQUtPLEdBQUcsQ0FBQ0MsQ0FBQUE7WUFDbEIsSUFBSSxPQUFPQSxRQUFRLFVBQVU7Z0JBQ3pCLE9BQU8sSUFBSSxDQUFDQyxhQUFhLENBQUNEO1lBQzlCO1lBQ0EsT0FBT0E7UUFD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WW5FO0lBQzFDO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVN4QixZQUFZd0IsR0FBRyxFQUFFaEIsS0FBSztJQUMzQmdCLE1BQU1BLElBQUljLElBQUk7SUFDZCxNQUFNcUQsV0FBVzdELE1BQU1DLFdBQVcsQ0FBQ1A7SUFDbkMsd0JBQXdCLEdBQ3hCLElBQUltRSxZQUFZbkYsT0FBTztRQUNuQixPQUFPZ0I7SUFDWDtJQUNBLE9BQU8sSUFBSW1DLE1BQU0sQ0FBQyxRQUFTZ0MsWUFBYSxLQUFLbkU7QUFDakQ7QUFDQSxJQUFJTTtBQUNHLFNBQVM4RCxNQUFNdEYsSUFBSSxFQUFFdUYsTUFBTTtJQUM5Qi9ELFFBQVErRDtJQUNSLE9BQU8sSUFBSXpGLEdBQUc7UUFDVkksT0FBTyxDQUFDRixTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBS0UsS0FBSyxLQUFLZ0Y7UUFDbkUvRSxNQUFNSCxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBS0csSUFBSTtJQUMvRDtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvY2xpdWkvYnVpbGQvbGliL2luZGV4LmpzPzM0NzUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgYWxpZ24gPSB7XG4gICAgcmlnaHQ6IGFsaWduUmlnaHQsXG4gICAgY2VudGVyOiBhbGlnbkNlbnRlclxufTtcbmNvbnN0IHRvcCA9IDA7XG5jb25zdCByaWdodCA9IDE7XG5jb25zdCBib3R0b20gPSAyO1xuY29uc3QgbGVmdCA9IDM7XG5leHBvcnQgY2xhc3MgVUkge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLndpZHRoID0gb3B0cy53aWR0aDtcbiAgICAgICAgdGhpcy53cmFwID0gKF9hID0gb3B0cy53cmFwKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlO1xuICAgICAgICB0aGlzLnJvd3MgPSBbXTtcbiAgICB9XG4gICAgc3BhbiguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGNvbHMgPSB0aGlzLmRpdiguLi5hcmdzKTtcbiAgICAgICAgY29scy5zcGFuID0gdHJ1ZTtcbiAgICB9XG4gICAgcmVzZXRPdXRwdXQoKSB7XG4gICAgICAgIHRoaXMucm93cyA9IFtdO1xuICAgIH1cbiAgICBkaXYoLi4uYXJncykge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGl2KCcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy53cmFwICYmIHRoaXMuc2hvdWxkQXBwbHlMYXlvdXREU0woLi4uYXJncykgJiYgdHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseUxheW91dERTTChhcmdzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2xzID0gYXJncy5tYXAoYXJnID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbEZyb21TdHJpbmcoYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJvd3MucHVzaChjb2xzKTtcbiAgICAgICAgcmV0dXJuIGNvbHM7XG4gICAgfVxuICAgIHNob3VsZEFwcGx5TGF5b3V0RFNMKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgL1tcXHRcXG5dLy50ZXN0KGFyZ3NbMF0pO1xuICAgIH1cbiAgICBhcHBseUxheW91dERTTChzdHIpIHtcbiAgICAgICAgY29uc3Qgcm93cyA9IHN0ci5zcGxpdCgnXFxuJykubWFwKHJvdyA9PiByb3cuc3BsaXQoJ1xcdCcpKTtcbiAgICAgICAgbGV0IGxlZnRDb2x1bW5XaWR0aCA9IDA7XG4gICAgICAgIC8vIHNpbXBsZSBoZXVyaXN0aWMgZm9yIGxheW91dCwgbWFrZSBzdXJlIHRoZVxuICAgICAgICAvLyBzZWNvbmQgY29sdW1uIGxpbmVzIHVwIGFsb25nIHRoZSBsZWZ0LWhhbmQuXG4gICAgICAgIC8vIGRvbid0IGFsbG93IHRoZSBmaXJzdCBjb2x1bW4gdG8gdGFrZSB1cCBtb3JlXG4gICAgICAgIC8vIHRoYW4gNTAlIG9mIHRoZSBzY3JlZW4uXG4gICAgICAgIHJvd3MuZm9yRWFjaChjb2x1bW5zID0+IHtcbiAgICAgICAgICAgIGlmIChjb2x1bW5zLmxlbmd0aCA+IDEgJiYgbWl4aW4uc3RyaW5nV2lkdGgoY29sdW1uc1swXSkgPiBsZWZ0Q29sdW1uV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBsZWZ0Q29sdW1uV2lkdGggPSBNYXRoLm1pbihNYXRoLmZsb29yKHRoaXMud2lkdGggKiAwLjUpLCBtaXhpbi5zdHJpbmdXaWR0aChjb2x1bW5zWzBdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBnZW5lcmF0ZSBhIHRhYmxlOlxuICAgICAgICAvLyAgcmVwbGFjaW5nICcgJyB3aXRoIHBhZGRpbmcgY2FsY3VsYXRpb25zLlxuICAgICAgICAvLyAgdXNpbmcgdGhlIGFsZ29yaXRobWljYWxseSBnZW5lcmF0ZWQgd2lkdGguXG4gICAgICAgIHJvd3MuZm9yRWFjaChjb2x1bW5zID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGl2KC4uLmNvbHVtbnMubWFwKChyLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogci50cmltKCksXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHRoaXMubWVhc3VyZVBhZGRpbmcociksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAoaSA9PT0gMCAmJiBjb2x1bW5zLmxlbmd0aCA+IDEpID8gbGVmdENvbHVtbldpZHRoIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd3NbdGhpcy5yb3dzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBjb2xGcm9tU3RyaW5nKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICBwYWRkaW5nOiB0aGlzLm1lYXN1cmVQYWRkaW5nKHRleHQpXG4gICAgICAgIH07XG4gICAgfVxuICAgIG1lYXN1cmVQYWRkaW5nKHN0cikge1xuICAgICAgICAvLyBtZWFzdXJlIHBhZGRpbmcgd2l0aG91dCBhbnNpIGVzY2FwZSBjb2Rlc1xuICAgICAgICBjb25zdCBub0Fuc2kgPSBtaXhpbi5zdHJpcEFuc2koc3RyKTtcbiAgICAgICAgcmV0dXJuIFswLCBub0Fuc2kubWF0Y2goL1xccyokLylbMF0ubGVuZ3RoLCAwLCBub0Fuc2kubWF0Y2goL15cXHMqLylbMF0ubGVuZ3RoXTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgICAgIHRoaXMucm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgICB0aGlzLnJvd1RvU3RyaW5nKHJvdywgbGluZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZG9uJ3QgZGlzcGxheSBhbnkgbGluZXMgd2l0aCB0aGVcbiAgICAgICAgLy8gaGlkZGVuIGZsYWcgc2V0LlxuICAgICAgICByZXR1cm4gbGluZXNcbiAgICAgICAgICAgIC5maWx0ZXIobGluZSA9PiAhbGluZS5oaWRkZW4pXG4gICAgICAgICAgICAubWFwKGxpbmUgPT4gbGluZS50ZXh0KVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgICByb3dUb1N0cmluZyhyb3csIGxpbmVzKSB7XG4gICAgICAgIHRoaXMucmFzdGVyaXplKHJvdykuZm9yRWFjaCgocnJvdywgcikgPT4ge1xuICAgICAgICAgICAgbGV0IHN0ciA9ICcnO1xuICAgICAgICAgICAgcnJvdy5mb3JFYWNoKChjb2wsIGMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHdpZHRoIH0gPSByb3dbY107IC8vIHRoZSB3aWR0aCB3aXRoIHBhZGRpbmcuXG4gICAgICAgICAgICAgICAgY29uc3Qgd3JhcFdpZHRoID0gdGhpcy5uZWdhdGVQYWRkaW5nKHJvd1tjXSk7IC8vIHRoZSB3aWR0aCB3aXRob3V0IHBhZGRpbmcuXG4gICAgICAgICAgICAgICAgbGV0IHRzID0gY29sOyAvLyB0ZW1wb3Jhcnkgc3RyaW5nIHVzZWQgZHVyaW5nIGFsaWdubWVudC9wYWRkaW5nLlxuICAgICAgICAgICAgICAgIGlmICh3cmFwV2lkdGggPiBtaXhpbi5zdHJpbmdXaWR0aChjb2wpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRzICs9ICcgJy5yZXBlYXQod3JhcFdpZHRoIC0gbWl4aW4uc3RyaW5nV2lkdGgoY29sKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFsaWduIHRoZSBzdHJpbmcgd2l0aGluIGl0cyBjb2x1bW4uXG4gICAgICAgICAgICAgICAgaWYgKHJvd1tjXS5hbGlnbiAmJiByb3dbY10uYWxpZ24gIT09ICdsZWZ0JyAmJiB0aGlzLndyYXApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm4gPSBhbGlnbltyb3dbY10uYWxpZ25dO1xuICAgICAgICAgICAgICAgICAgICB0cyA9IGZuKHRzLCB3cmFwV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWl4aW4uc3RyaW5nV2lkdGgodHMpIDwgd3JhcFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cyArPSAnICcucmVwZWF0KCh3aWR0aCB8fCAwKSAtIG1peGluLnN0cmluZ1dpZHRoKHRzKSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFwcGx5IGJvcmRlciBhbmQgcGFkZGluZyB0byBzdHJpbmcuXG4gICAgICAgICAgICAgICAgY29uc3QgcGFkZGluZyA9IHJvd1tjXS5wYWRkaW5nIHx8IFswLCAwLCAwLCAwXTtcbiAgICAgICAgICAgICAgICBpZiAocGFkZGluZ1tsZWZ0XSkge1xuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJyAnLnJlcGVhdChwYWRkaW5nW2xlZnRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyICs9IGFkZEJvcmRlcihyb3dbY10sIHRzLCAnfCAnKTtcbiAgICAgICAgICAgICAgICBzdHIgKz0gdHM7XG4gICAgICAgICAgICAgICAgc3RyICs9IGFkZEJvcmRlcihyb3dbY10sIHRzLCAnIHwnKTtcbiAgICAgICAgICAgICAgICBpZiAocGFkZGluZ1tyaWdodF0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9ICcgJy5yZXBlYXQocGFkZGluZ1tyaWdodF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiBwcmlvciByb3cgaXMgc3BhbiwgdHJ5IHRvIHJlbmRlciB0aGVcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IHJvdyBvbiB0aGUgcHJpb3IgbGluZS5cbiAgICAgICAgICAgICAgICBpZiAociA9PT0gMCAmJiBsaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IHRoaXMucmVuZGVySW5saW5lKHN0ciwgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2UuXG4gICAgICAgICAgICBsaW5lcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBzdHIucmVwbGFjZSgvICskLywgJycpLFxuICAgICAgICAgICAgICAgIHNwYW46IHJvdy5zcGFuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsaW5lcztcbiAgICB9XG4gICAgLy8gaWYgdGhlIGZ1bGwgJ3NvdXJjZScgY2FuIHJlbmRlciBpblxuICAgIC8vIHRoZSB0YXJnZXQgbGluZSwgZG8gc28uXG4gICAgcmVuZGVySW5saW5lKHNvdXJjZSwgcHJldmlvdXNMaW5lKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gc291cmNlLm1hdGNoKC9eICovKTtcbiAgICAgICAgY29uc3QgbGVhZGluZ1doaXRlc3BhY2UgPSBtYXRjaCA/IG1hdGNoWzBdLmxlbmd0aCA6IDA7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHByZXZpb3VzTGluZS50ZXh0O1xuICAgICAgICBjb25zdCB0YXJnZXRUZXh0V2lkdGggPSBtaXhpbi5zdHJpbmdXaWR0aCh0YXJnZXQudHJpbVJpZ2h0KCkpO1xuICAgICAgICBpZiAoIXByZXZpb3VzTGluZS5zcGFuKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlJ3JlIG5vdCBhcHBseWluZyB3cmFwcGluZyBsb2dpYyxcbiAgICAgICAgLy8ganVzdCBhbHdheXMgYXBwZW5kIHRvIHRoZSBzcGFuLlxuICAgICAgICBpZiAoIXRoaXMud3JhcCkge1xuICAgICAgICAgICAgcHJldmlvdXNMaW5lLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0ICsgc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWFkaW5nV2hpdGVzcGFjZSA8IHRhcmdldFRleHRXaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c0xpbmUuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRhcmdldC50cmltUmlnaHQoKSArICcgJy5yZXBlYXQobGVhZGluZ1doaXRlc3BhY2UgLSB0YXJnZXRUZXh0V2lkdGgpICsgc291cmNlLnRyaW1MZWZ0KCk7XG4gICAgfVxuICAgIHJhc3Rlcml6ZShyb3cpIHtcbiAgICAgICAgY29uc3QgcnJvd3MgPSBbXTtcbiAgICAgICAgY29uc3Qgd2lkdGhzID0gdGhpcy5jb2x1bW5XaWR0aHMocm93KTtcbiAgICAgICAgbGV0IHdyYXBwZWQ7XG4gICAgICAgIC8vIHdvcmQgd3JhcCBhbGwgY29sdW1ucywgYW5kIGNyZWF0ZVxuICAgICAgICAvLyBhIGRhdGEtc3RydWN0dXJlIHRoYXQgaXMgZWFzeSB0byByYXN0ZXJpemUuXG4gICAgICAgIHJvdy5mb3JFYWNoKChjb2wsIGMpID0+IHtcbiAgICAgICAgICAgIC8vIGxlYXZlIHJvb20gZm9yIGxlZnQgYW5kIHJpZ2h0IHBhZGRpbmcuXG4gICAgICAgICAgICBjb2wud2lkdGggPSB3aWR0aHNbY107XG4gICAgICAgICAgICBpZiAodGhpcy53cmFwKSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlZCA9IG1peGluLndyYXAoY29sLnRleHQsIHRoaXMubmVnYXRlUGFkZGluZyhjb2wpLCB7IGhhcmQ6IHRydWUgfSkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlZCA9IGNvbC50ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2wuYm9yZGVyKSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlZC51bnNoaWZ0KCcuJyArICctJy5yZXBlYXQodGhpcy5uZWdhdGVQYWRkaW5nKGNvbCkgKyAyKSArICcuJyk7XG4gICAgICAgICAgICAgICAgd3JhcHBlZC5wdXNoKFwiJ1wiICsgJy0nLnJlcGVhdCh0aGlzLm5lZ2F0ZVBhZGRpbmcoY29sKSArIDIpICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIHRvcCBhbmQgYm90dG9tIHBhZGRpbmcuXG4gICAgICAgICAgICBpZiAoY29sLnBhZGRpbmcpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVkLnVuc2hpZnQoLi4ubmV3IEFycmF5KGNvbC5wYWRkaW5nW3RvcF0gfHwgMCkuZmlsbCgnJykpO1xuICAgICAgICAgICAgICAgIHdyYXBwZWQucHVzaCguLi5uZXcgQXJyYXkoY29sLnBhZGRpbmdbYm90dG9tXSB8fCAwKS5maWxsKCcnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cmFwcGVkLmZvckVhY2goKHN0ciwgcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcnJvd3Nbcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgcnJvd3MucHVzaChbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJyb3cgPSBycm93c1tyXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocnJvd1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBycm93LnB1c2goJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJyb3cucHVzaChzdHIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcnJvd3M7XG4gICAgfVxuICAgIG5lZ2F0ZVBhZGRpbmcoY29sKSB7XG4gICAgICAgIGxldCB3cmFwV2lkdGggPSBjb2wud2lkdGggfHwgMDtcbiAgICAgICAgaWYgKGNvbC5wYWRkaW5nKSB7XG4gICAgICAgICAgICB3cmFwV2lkdGggLT0gKGNvbC5wYWRkaW5nW2xlZnRdIHx8IDApICsgKGNvbC5wYWRkaW5nW3JpZ2h0XSB8fCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sLmJvcmRlcikge1xuICAgICAgICAgICAgd3JhcFdpZHRoIC09IDQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyYXBXaWR0aDtcbiAgICB9XG4gICAgY29sdW1uV2lkdGhzKHJvdykge1xuICAgICAgICBpZiAoIXRoaXMud3JhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdy5tYXAoY29sID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sLndpZHRoIHx8IG1peGluLnN0cmluZ1dpZHRoKGNvbC50ZXh0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCB1bnNldCA9IHJvdy5sZW5ndGg7XG4gICAgICAgIGxldCByZW1haW5pbmdXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIC8vIGNvbHVtbiB3aWR0aHMgY2FuIGJlIHNldCBpbiBjb25maWcuXG4gICAgICAgIGNvbnN0IHdpZHRocyA9IHJvdy5tYXAoY29sID0+IHtcbiAgICAgICAgICAgIGlmIChjb2wud2lkdGgpIHtcbiAgICAgICAgICAgICAgICB1bnNldC0tO1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZ1dpZHRoIC09IGNvbC53aWR0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGFueSB1bnNldCB3aWR0aHMgc2hvdWxkIGJlIGNhbGN1bGF0ZWQuXG4gICAgICAgIGNvbnN0IHVuc2V0V2lkdGggPSB1bnNldCA/IE1hdGguZmxvb3IocmVtYWluaW5nV2lkdGggLyB1bnNldCkgOiAwO1xuICAgICAgICByZXR1cm4gd2lkdGhzLm1hcCgodywgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKHcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh1bnNldFdpZHRoLCBfbWluV2lkdGgocm93W2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkQm9yZGVyKGNvbCwgdHMsIHN0eWxlKSB7XG4gICAgaWYgKGNvbC5ib3JkZXIpIHtcbiAgICAgICAgaWYgKC9bLiddLStbLiddLy50ZXN0KHRzKSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cy50cmltKCkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcgICc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cbi8vIGNhbGN1bGF0ZXMgdGhlIG1pbmltdW0gd2lkdGggb2Zcbi8vIGEgY29sdW1uLCBiYXNlZCBvbiBwYWRkaW5nIHByZWZlcmVuY2VzLlxuZnVuY3Rpb24gX21pbldpZHRoKGNvbCkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSBjb2wucGFkZGluZyB8fCBbXTtcbiAgICBjb25zdCBtaW5XaWR0aCA9IDEgKyAocGFkZGluZ1tsZWZ0XSB8fCAwKSArIChwYWRkaW5nW3JpZ2h0XSB8fCAwKTtcbiAgICBpZiAoY29sLmJvcmRlcikge1xuICAgICAgICByZXR1cm4gbWluV2lkdGggKyA0O1xuICAgIH1cbiAgICByZXR1cm4gbWluV2lkdGg7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3dXaWR0aCgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGVwZW5kcyBvbiB0ZXJtaW5hbCAqL1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzcy5zdGRvdXQgJiYgcHJvY2Vzcy5zdGRvdXQuY29sdW1ucykge1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5zdGRvdXQuY29sdW1ucztcbiAgICB9XG4gICAgcmV0dXJuIDgwO1xufVxuZnVuY3Rpb24gYWxpZ25SaWdodChzdHIsIHdpZHRoKSB7XG4gICAgc3RyID0gc3RyLnRyaW0oKTtcbiAgICBjb25zdCBzdHJXaWR0aCA9IG1peGluLnN0cmluZ1dpZHRoKHN0cik7XG4gICAgaWYgKHN0cldpZHRoIDwgd2lkdGgpIHtcbiAgICAgICAgcmV0dXJuICcgJy5yZXBlYXQod2lkdGggLSBzdHJXaWR0aCkgKyBzdHI7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBhbGlnbkNlbnRlcihzdHIsIHdpZHRoKSB7XG4gICAgc3RyID0gc3RyLnRyaW0oKTtcbiAgICBjb25zdCBzdHJXaWR0aCA9IG1peGluLnN0cmluZ1dpZHRoKHN0cik7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoc3RyV2lkdGggPj0gd2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuICcgJy5yZXBlYXQoKHdpZHRoIC0gc3RyV2lkdGgpID4+IDEpICsgc3RyO1xufVxubGV0IG1peGluO1xuZXhwb3J0IGZ1bmN0aW9uIGNsaXVpKG9wdHMsIF9taXhpbikge1xuICAgIG1peGluID0gX21peGluO1xuICAgIHJldHVybiBuZXcgVUkoe1xuICAgICAgICB3aWR0aDogKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy53aWR0aCkgfHwgZ2V0V2luZG93V2lkdGgoKSxcbiAgICAgICAgd3JhcDogb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLndyYXBcbiAgICB9KTtcbn1cbiJdLCJuYW1lcyI6WyJhbGlnbiIsInJpZ2h0IiwiYWxpZ25SaWdodCIsImNlbnRlciIsImFsaWduQ2VudGVyIiwidG9wIiwiYm90dG9tIiwibGVmdCIsIlVJIiwiY29uc3RydWN0b3IiLCJvcHRzIiwiX2EiLCJ3aWR0aCIsIndyYXAiLCJyb3dzIiwic3BhbiIsImFyZ3MiLCJjb2xzIiwiZGl2IiwicmVzZXRPdXRwdXQiLCJsZW5ndGgiLCJzaG91bGRBcHBseUxheW91dERTTCIsImFwcGx5TGF5b3V0RFNMIiwibWFwIiwiYXJnIiwiY29sRnJvbVN0cmluZyIsInB1c2giLCJ0ZXN0Iiwic3RyIiwic3BsaXQiLCJyb3ciLCJsZWZ0Q29sdW1uV2lkdGgiLCJmb3JFYWNoIiwiY29sdW1ucyIsIm1peGluIiwic3RyaW5nV2lkdGgiLCJNYXRoIiwibWluIiwiZmxvb3IiLCJyIiwiaSIsInRleHQiLCJ0cmltIiwicGFkZGluZyIsIm1lYXN1cmVQYWRkaW5nIiwidW5kZWZpbmVkIiwibm9BbnNpIiwic3RyaXBBbnNpIiwibWF0Y2giLCJ0b1N0cmluZyIsImxpbmVzIiwicm93VG9TdHJpbmciLCJmaWx0ZXIiLCJsaW5lIiwiaGlkZGVuIiwiam9pbiIsInJhc3Rlcml6ZSIsInJyb3ciLCJjb2wiLCJjIiwid3JhcFdpZHRoIiwibmVnYXRlUGFkZGluZyIsInRzIiwicmVwZWF0IiwiZm4iLCJhZGRCb3JkZXIiLCJyZW5kZXJJbmxpbmUiLCJyZXBsYWNlIiwic291cmNlIiwicHJldmlvdXNMaW5lIiwibGVhZGluZ1doaXRlc3BhY2UiLCJ0YXJnZXQiLCJ0YXJnZXRUZXh0V2lkdGgiLCJ0cmltUmlnaHQiLCJ0cmltTGVmdCIsInJyb3dzIiwid2lkdGhzIiwiY29sdW1uV2lkdGhzIiwid3JhcHBlZCIsImhhcmQiLCJib3JkZXIiLCJ1bnNoaWZ0IiwiQXJyYXkiLCJmaWxsIiwidW5zZXQiLCJyZW1haW5pbmdXaWR0aCIsInVuc2V0V2lkdGgiLCJ3IiwibWF4IiwiX21pbldpZHRoIiwic3R5bGUiLCJtaW5XaWR0aCIsImdldFdpbmRvd1dpZHRoIiwicHJvY2VzcyIsInN0ZG91dCIsInN0cldpZHRoIiwiY2xpdWkiLCJfbWl4aW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cliui/build/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/cliui/build/lib/string-utils.js":
/*!******************************************************!*\
  !*** ./node_modules/cliui/build/lib/string-utils.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   stripAnsi: () => (/* binding */ stripAnsi),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n// Minimal replacement for ansi string helpers \"wrap-ansi\" and \"strip-ansi\".\n// to facilitate ESM and Deno modules.\n// TODO: look at porting https://www.npmjs.com/package/wrap-ansi to ESM.\n// The npm application\n// Copyright (c) npm, Inc. and Contributors\n// Licensed on the terms of The Artistic License 2.0\n// See: https://github.com/npm/cli/blob/4c65cd952bc8627811735bea76b9b110cc4fc80e/lib/utils/ansi-trim.js\nconst ansi = new RegExp(\"\\x1b(?:\\\\[(?:\\\\d+[ABCDEFGJKSTm]|\\\\d+;\\\\d+[Hfm]|\" + \"\\\\d+;\\\\d+;\\\\d+m|6n|s|u|\\\\?25[lh])|\\\\w)\", \"g\");\nfunction stripAnsi(str) {\n    return str.replace(ansi, \"\");\n}\nfunction wrap(str, width) {\n    const [start, end] = str.match(ansi) || [\n        \"\",\n        \"\"\n    ];\n    str = stripAnsi(str);\n    let wrapped = \"\";\n    for(let i = 0; i < str.length; i++){\n        if (i !== 0 && i % width === 0) {\n            wrapped += \"\\n\";\n        }\n        wrapped += str.charAt(i);\n    }\n    if (start && end) {\n        wrapped = `${start}${wrapped}${end}`;\n    }\n    return wrapped;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xpdWkvYnVpbGQvbGliL3N0cmluZy11dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDRFQUE0RTtBQUM1RSxzQ0FBc0M7QUFDdEMsd0VBQXdFO0FBQ3hFLHNCQUFzQjtBQUN0QiwyQ0FBMkM7QUFDM0Msb0RBQW9EO0FBQ3BELHVHQUF1RztBQUN2RyxNQUFNQSxPQUFPLElBQUlDLE9BQU8sb0RBQ3BCLDBDQUEwQztBQUN2QyxTQUFTQyxVQUFVQyxHQUFHO0lBQ3pCLE9BQU9BLElBQUlDLE9BQU8sQ0FBQ0osTUFBTTtBQUM3QjtBQUNPLFNBQVNLLEtBQUtGLEdBQUcsRUFBRUcsS0FBSztJQUMzQixNQUFNLENBQUNDLE9BQU9DLElBQUksR0FBR0wsSUFBSU0sS0FBSyxDQUFDVCxTQUFTO1FBQUM7UUFBSTtLQUFHO0lBQ2hERyxNQUFNRCxVQUFVQztJQUNoQixJQUFJTyxVQUFVO0lBQ2QsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlSLElBQUlTLE1BQU0sRUFBRUQsSUFBSztRQUNqQyxJQUFJQSxNQUFNLEtBQUssSUFBS0wsVUFBVyxHQUFHO1lBQzlCSSxXQUFXO1FBQ2Y7UUFDQUEsV0FBV1AsSUFBSVUsTUFBTSxDQUFDRjtJQUMxQjtJQUNBLElBQUlKLFNBQVNDLEtBQUs7UUFDZEUsVUFBVSxDQUFDLEVBQUVILE1BQU0sRUFBRUcsUUFBUSxFQUFFRixJQUFJLENBQUM7SUFDeEM7SUFDQSxPQUFPRTtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvY2xpdWkvYnVpbGQvbGliL3N0cmluZy11dGlscy5qcz9mMWVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE1pbmltYWwgcmVwbGFjZW1lbnQgZm9yIGFuc2kgc3RyaW5nIGhlbHBlcnMgXCJ3cmFwLWFuc2lcIiBhbmQgXCJzdHJpcC1hbnNpXCIuXG4vLyB0byBmYWNpbGl0YXRlIEVTTSBhbmQgRGVubyBtb2R1bGVzLlxuLy8gVE9ETzogbG9vayBhdCBwb3J0aW5nIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3dyYXAtYW5zaSB0byBFU00uXG4vLyBUaGUgbnBtIGFwcGxpY2F0aW9uXG4vLyBDb3B5cmlnaHQgKGMpIG5wbSwgSW5jLiBhbmQgQ29udHJpYnV0b3JzXG4vLyBMaWNlbnNlZCBvbiB0aGUgdGVybXMgb2YgVGhlIEFydGlzdGljIExpY2Vuc2UgMi4wXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ucG0vY2xpL2Jsb2IvNGM2NWNkOTUyYmM4NjI3ODExNzM1YmVhNzZiOWIxMTBjYzRmYzgwZS9saWIvdXRpbHMvYW5zaS10cmltLmpzXG5jb25zdCBhbnNpID0gbmV3IFJlZ0V4cCgnXFx4MWIoPzpcXFxcWyg/OlxcXFxkK1tBQkNERUZHSktTVG1dfFxcXFxkKztcXFxcZCtbSGZtXXwnICtcbiAgICAnXFxcXGQrO1xcXFxkKztcXFxcZCttfDZufHN8dXxcXFxcPzI1W2xoXSl8XFxcXHcpJywgJ2cnKTtcbmV4cG9ydCBmdW5jdGlvbiBzdHJpcEFuc2koc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGFuc2ksICcnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwKHN0ciwgd2lkdGgpIHtcbiAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBzdHIubWF0Y2goYW5zaSkgfHwgWycnLCAnJ107XG4gICAgc3RyID0gc3RyaXBBbnNpKHN0cik7XG4gICAgbGV0IHdyYXBwZWQgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSAhPT0gMCAmJiAoaSAlIHdpZHRoKSA9PT0gMCkge1xuICAgICAgICAgICAgd3JhcHBlZCArPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICB3cmFwcGVkICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgfVxuICAgIGlmIChzdGFydCAmJiBlbmQpIHtcbiAgICAgICAgd3JhcHBlZCA9IGAke3N0YXJ0fSR7d3JhcHBlZH0ke2VuZH1gO1xuICAgIH1cbiAgICByZXR1cm4gd3JhcHBlZDtcbn1cbiJdLCJuYW1lcyI6WyJhbnNpIiwiUmVnRXhwIiwic3RyaXBBbnNpIiwic3RyIiwicmVwbGFjZSIsIndyYXAiLCJ3aWR0aCIsInN0YXJ0IiwiZW5kIiwibWF0Y2giLCJ3cmFwcGVkIiwiaSIsImxlbmd0aCIsImNoYXJBdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cliui/build/lib/string-utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/cliui/index.mjs":
/*!**************************************!*\
  !*** ./node_modules/cliui/index.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ui)\n/* harmony export */ });\n/* harmony import */ var _build_lib_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./build/lib/index.js */ \"(rsc)/./node_modules/cliui/build/lib/index.js\");\n/* harmony import */ var _build_lib_string_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./build/lib/string-utils.js */ \"(rsc)/./node_modules/cliui/build/lib/string-utils.js\");\n// Bootstrap cliui with CommonJS dependencies:\n\n\nfunction ui(opts) {\n    return (0,_build_lib_index_js__WEBPACK_IMPORTED_MODULE_0__.cliui)(opts, {\n        stringWidth: (str)=>{\n            return [\n                ...str\n            ].length;\n        },\n        stripAnsi: _build_lib_string_utils_js__WEBPACK_IMPORTED_MODULE_1__.stripAnsi,\n        wrap: _build_lib_string_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrap\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xpdWkvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDhDQUE4QztBQUNGO0FBQ2lCO0FBRTlDLFNBQVNHLEdBQUlDLElBQUk7SUFDOUIsT0FBT0osMERBQUtBLENBQUNJLE1BQU07UUFDakJDLGFBQWEsQ0FBQ0M7WUFDWixPQUFPO21CQUFJQTthQUFJLENBQUNDLE1BQU07UUFDeEI7UUFDQUwsU0FBU0EsbUVBQUFBO1FBQ1RELElBQUlBLDhEQUFBQTtJQUNOO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9jbGl1aS9pbmRleC5tanM/OTI0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBCb290c3RyYXAgY2xpdWkgd2l0aCBDb21tb25KUyBkZXBlbmRlbmNpZXM6XG5pbXBvcnQgeyBjbGl1aSB9IGZyb20gJy4vYnVpbGQvbGliL2luZGV4LmpzJ1xuaW1wb3J0IHsgd3JhcCwgc3RyaXBBbnNpIH0gZnJvbSAnLi9idWlsZC9saWIvc3RyaW5nLXV0aWxzLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1aSAob3B0cykge1xuICByZXR1cm4gY2xpdWkob3B0cywge1xuICAgIHN0cmluZ1dpZHRoOiAoc3RyKSA9PiB7XG4gICAgICByZXR1cm4gWy4uLnN0cl0ubGVuZ3RoXG4gICAgfSxcbiAgICBzdHJpcEFuc2ksXG4gICAgd3JhcFxuICB9KVxufVxuIl0sIm5hbWVzIjpbImNsaXVpIiwid3JhcCIsInN0cmlwQW5zaSIsInVpIiwib3B0cyIsInN0cmluZ1dpZHRoIiwic3RyIiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cliui/index.mjs\n");

/***/ })

};
;