"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/yargs-parser";
exports.ids = ["vendor-chunks/yargs-parser"];
exports.modules = {

/***/ "(rsc)/./node_modules/yargs-parser/build/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/yargs-parser/build/lib/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var _string_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./string-utils.js */ \"(rsc)/./node_modules/yargs-parser/build/lib/string-utils.js\");\n/* harmony import */ var _yargs_parser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./yargs-parser.js */ \"(rsc)/./node_modules/yargs-parser/build/lib/yargs-parser.js\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fs */ \"fs\");\n/**\n * @fileoverview Main entrypoint for libraries using yargs-parser in Node.js\n * CJS and ESM environments.\n *\n * @license\n * Copyright (c) 2016, Contributors\n * SPDX-License-Identifier: ISC\n */ var _a, _b, _c;\n\n\n\n\n\n// See https://github.com/yargs/yargs-parser#supported-nodejs-versions for our\n// version support policy. The YARGS_MIN_NODE_VERSION is used for testing only.\nconst minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;\nconst nodeVersion = (_b = (_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) !== null && _b !== void 0 ? _b : (_c = process === null || process === void 0 ? void 0 : process.version) === null || _c === void 0 ? void 0 : _c.slice(1);\nif (nodeVersion) {\n    const major = Number(nodeVersion.match(/^([^.]+)/)[1]);\n    if (major < minNodeVersion) {\n        throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);\n    }\n}\n// Creates a yargs-parser instance using Node.js standard libraries:\nconst env = process ? process.env : {};\nconst parser = new _yargs_parser_js__WEBPACK_IMPORTED_MODULE_3__.YargsParser({\n    cwd: process.cwd,\n    env: ()=>{\n        return env;\n    },\n    format: util__WEBPACK_IMPORTED_MODULE_0__.format,\n    normalize: path__WEBPACK_IMPORTED_MODULE_1__.normalize,\n    resolve: path__WEBPACK_IMPORTED_MODULE_1__.resolve,\n    // TODO: figure  out a  way to combine ESM and CJS coverage, such  that\n    // we can exercise all the lines below:\n    require: (path)=>{\n        if (typeof require !== \"undefined\") {\n            return require(path);\n        } else if (path.match(/\\.json$/)) {\n            // Addresses: https://github.com/yargs/yargs/issues/2040\n            return JSON.parse((0,fs__WEBPACK_IMPORTED_MODULE_4__.readFileSync)(path, \"utf8\"));\n        } else {\n            throw Error(\"only .json config files are supported in ESM\");\n        }\n    }\n});\nconst yargsParser = function Parser(args, opts) {\n    const result = parser.parse(args.slice(), opts);\n    return result.argv;\n};\nyargsParser.detailed = function(args, opts) {\n    return parser.parse(args.slice(), opts);\n};\nyargsParser.camelCase = _string_utils_js__WEBPACK_IMPORTED_MODULE_2__.camelCase;\nyargsParser.decamelize = _string_utils_js__WEBPACK_IMPORTED_MODULE_2__.decamelize;\nyargsParser.looksLikeNumber = _string_utils_js__WEBPACK_IMPORTED_MODULE_2__.looksLikeNumber;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (yargsParser);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveWFyZ3MtcGFyc2VyL2J1aWxkL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7Ozs7OztDQU9DLEdBQ0QsSUFBSUEsSUFBSUMsSUFBSUM7QUFDa0I7QUFDWTtBQUNpQztBQUMzQjtBQUNkO0FBQ2xDLDhFQUE4RTtBQUM5RSwrRUFBK0U7QUFDL0UsTUFBTVMsaUJBQWlCLFdBQVlDLFFBQVFDLEdBQUcsSUFBSUQsUUFBUUMsR0FBRyxDQUFDQyxzQkFBc0IsR0FDOUVDLE9BQU9ILFFBQVFDLEdBQUcsQ0FBQ0Msc0JBQXNCLElBQ3pDO0FBQ04sTUFBTUUsY0FBYyxDQUFDZixLQUFLLENBQUNELEtBQUtZLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRSyxRQUFRLE1BQU0sUUFBUWpCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tCLElBQUksTUFBTSxRQUFRakIsT0FBTyxLQUFLLElBQUlBLEtBQUssQ0FBQ0MsS0FBS1UsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFPLE9BQU8sTUFBTSxRQUFRakIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa0IsS0FBSyxDQUFDO0FBQzFTLElBQUlKLGFBQWE7SUFDYixNQUFNSyxRQUFRTixPQUFPQyxZQUFZTSxLQUFLLENBQUMsV0FBVyxDQUFDLEVBQUU7SUFDckQsSUFBSUQsUUFBUVYsZ0JBQWdCO1FBQ3hCLE1BQU1ZLE1BQU0sQ0FBQyxtREFBbUQsRUFBRVosZUFBZSxrR0FBa0csQ0FBQztJQUN4TDtBQUNKO0FBQ0Esb0VBQW9FO0FBQ3BFLE1BQU1FLE1BQU1ELFVBQVVBLFFBQVFDLEdBQUcsR0FBRyxDQUFDO0FBQ3JDLE1BQU1XLFNBQVMsSUFBSWYseURBQVdBLENBQUM7SUFDM0JnQixLQUFLYixRQUFRYSxHQUFHO0lBQ2hCWixLQUFLO1FBQ0QsT0FBT0E7SUFDWDtJQUNBVixNQUFNQSwwQ0FBQUE7SUFDTkMsU0FBU0EsNkNBQUFBO0lBQ1RDLE9BQU9BLDJDQUFBQTtJQUNQLHVFQUF1RTtJQUN2RSx1Q0FBdUM7SUFDdkNxQixTQUFTLENBQUNDO1FBQ04sSUFBSSxPQUFPRCxZQUFZLGFBQWE7WUFDaEMsT0FBT0EsUUFBUUM7UUFDbkIsT0FDSyxJQUFJQSxLQUFLTCxLQUFLLENBQUMsWUFBWTtZQUM1Qix3REFBd0Q7WUFDeEQsT0FBT00sS0FBS0MsS0FBSyxDQUFDbkIsZ0RBQVlBLENBQUNpQixNQUFNO1FBQ3pDLE9BQ0s7WUFDRCxNQUFNSixNQUFNO1FBQ2hCO0lBQ0o7QUFDSjtBQUNBLE1BQU1PLGNBQWMsU0FBU0MsT0FBT0MsSUFBSSxFQUFFQyxJQUFJO0lBQzFDLE1BQU1DLFNBQVNWLE9BQU9LLEtBQUssQ0FBQ0csS0FBS1osS0FBSyxJQUFJYTtJQUMxQyxPQUFPQyxPQUFPQyxJQUFJO0FBQ3RCO0FBQ0FMLFlBQVlNLFFBQVEsR0FBRyxTQUFVSixJQUFJLEVBQUVDLElBQUk7SUFDdkMsT0FBT1QsT0FBT0ssS0FBSyxDQUFDRyxLQUFLWixLQUFLLElBQUlhO0FBQ3RDO0FBQ0FILFlBQVl4QixTQUFTLEdBQUdBLHVEQUFTQTtBQUNqQ3dCLFlBQVl2QixVQUFVLEdBQUdBLHdEQUFVQTtBQUNuQ3VCLFlBQVl0QixlQUFlLEdBQUdBLDZEQUFlQTtBQUM3QyxpRUFBZXNCLFdBQVdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy95YXJncy1wYXJzZXIvYnVpbGQvbGliL2luZGV4LmpzP2Y2Y2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1haW4gZW50cnlwb2ludCBmb3IgbGlicmFyaWVzIHVzaW5nIHlhcmdzLXBhcnNlciBpbiBOb2RlLmpzXG4gKiBDSlMgYW5kIEVTTSBlbnZpcm9ubWVudHMuXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiwgQ29udHJpYnV0b3JzXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogSVNDXG4gKi9cbnZhciBfYSwgX2IsIF9jO1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgeyBub3JtYWxpemUsIHJlc29sdmUgfSBmcm9tICdwYXRoJztcbmltcG9ydCB7IGNhbWVsQ2FzZSwgZGVjYW1lbGl6ZSwgbG9va3NMaWtlTnVtYmVyIH0gZnJvbSAnLi9zdHJpbmctdXRpbHMuanMnO1xuaW1wb3J0IHsgWWFyZ3NQYXJzZXIgfSBmcm9tICcuL3lhcmdzLXBhcnNlci5qcyc7XG5pbXBvcnQgeyByZWFkRmlsZVN5bmMgfSBmcm9tICdmcyc7XG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3lhcmdzL3lhcmdzLXBhcnNlciNzdXBwb3J0ZWQtbm9kZWpzLXZlcnNpb25zIGZvciBvdXJcbi8vIHZlcnNpb24gc3VwcG9ydCBwb2xpY3kuIFRoZSBZQVJHU19NSU5fTk9ERV9WRVJTSU9OIGlzIHVzZWQgZm9yIHRlc3Rpbmcgb25seS5cbmNvbnN0IG1pbk5vZGVWZXJzaW9uID0gKHByb2Nlc3MgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuWUFSR1NfTUlOX05PREVfVkVSU0lPTilcbiAgICA/IE51bWJlcihwcm9jZXNzLmVudi5ZQVJHU19NSU5fTk9ERV9WRVJTSU9OKVxuICAgIDogMTI7XG5jb25zdCBub2RlVmVyc2lvbiA9IChfYiA9IChfYSA9IHByb2Nlc3MgPT09IG51bGwgfHwgcHJvY2VzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvY2Vzcy52ZXJzaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vZGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChfYyA9IHByb2Nlc3MgPT09IG51bGwgfHwgcHJvY2VzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvY2Vzcy52ZXJzaW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc2xpY2UoMSk7XG5pZiAobm9kZVZlcnNpb24pIHtcbiAgICBjb25zdCBtYWpvciA9IE51bWJlcihub2RlVmVyc2lvbi5tYXRjaCgvXihbXi5dKykvKVsxXSk7XG4gICAgaWYgKG1ham9yIDwgbWluTm9kZVZlcnNpb24pIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYHlhcmdzIHBhcnNlciBzdXBwb3J0cyBhIG1pbmltdW0gTm9kZS5qcyB2ZXJzaW9uIG9mICR7bWluTm9kZVZlcnNpb259LiBSZWFkIG91ciB2ZXJzaW9uIHN1cHBvcnQgcG9saWN5OiBodHRwczovL2dpdGh1Yi5jb20veWFyZ3MveWFyZ3MtcGFyc2VyI3N1cHBvcnRlZC1ub2RlanMtdmVyc2lvbnNgKTtcbiAgICB9XG59XG4vLyBDcmVhdGVzIGEgeWFyZ3MtcGFyc2VyIGluc3RhbmNlIHVzaW5nIE5vZGUuanMgc3RhbmRhcmQgbGlicmFyaWVzOlxuY29uc3QgZW52ID0gcHJvY2VzcyA/IHByb2Nlc3MuZW52IDoge307XG5jb25zdCBwYXJzZXIgPSBuZXcgWWFyZ3NQYXJzZXIoe1xuICAgIGN3ZDogcHJvY2Vzcy5jd2QsXG4gICAgZW52OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBlbnY7XG4gICAgfSxcbiAgICBmb3JtYXQsXG4gICAgbm9ybWFsaXplLFxuICAgIHJlc29sdmUsXG4gICAgLy8gVE9ETzogZmlndXJlICBvdXQgYSAgd2F5IHRvIGNvbWJpbmUgRVNNIGFuZCBDSlMgY292ZXJhZ2UsIHN1Y2ggIHRoYXRcbiAgICAvLyB3ZSBjYW4gZXhlcmNpc2UgYWxsIHRoZSBsaW5lcyBiZWxvdzpcbiAgICByZXF1aXJlOiAocGF0aCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWlyZShwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXRoLm1hdGNoKC9cXC5qc29uJC8pKSB7XG4gICAgICAgICAgICAvLyBBZGRyZXNzZXM6IGh0dHBzOi8vZ2l0aHViLmNvbS95YXJncy95YXJncy9pc3N1ZXMvMjA0MFxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVhZEZpbGVTeW5jKHBhdGgsICd1dGY4JykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ29ubHkgLmpzb24gY29uZmlnIGZpbGVzIGFyZSBzdXBwb3J0ZWQgaW4gRVNNJyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbmNvbnN0IHlhcmdzUGFyc2VyID0gZnVuY3Rpb24gUGFyc2VyKGFyZ3MsIG9wdHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIucGFyc2UoYXJncy5zbGljZSgpLCBvcHRzKTtcbiAgICByZXR1cm4gcmVzdWx0LmFyZ3Y7XG59O1xueWFyZ3NQYXJzZXIuZGV0YWlsZWQgPSBmdW5jdGlvbiAoYXJncywgb3B0cykge1xuICAgIHJldHVybiBwYXJzZXIucGFyc2UoYXJncy5zbGljZSgpLCBvcHRzKTtcbn07XG55YXJnc1BhcnNlci5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG55YXJnc1BhcnNlci5kZWNhbWVsaXplID0gZGVjYW1lbGl6ZTtcbnlhcmdzUGFyc2VyLmxvb2tzTGlrZU51bWJlciA9IGxvb2tzTGlrZU51bWJlcjtcbmV4cG9ydCBkZWZhdWx0IHlhcmdzUGFyc2VyO1xuIl0sIm5hbWVzIjpbIl9hIiwiX2IiLCJfYyIsImZvcm1hdCIsIm5vcm1hbGl6ZSIsInJlc29sdmUiLCJjYW1lbENhc2UiLCJkZWNhbWVsaXplIiwibG9va3NMaWtlTnVtYmVyIiwiWWFyZ3NQYXJzZXIiLCJyZWFkRmlsZVN5bmMiLCJtaW5Ob2RlVmVyc2lvbiIsInByb2Nlc3MiLCJlbnYiLCJZQVJHU19NSU5fTk9ERV9WRVJTSU9OIiwiTnVtYmVyIiwibm9kZVZlcnNpb24iLCJ2ZXJzaW9ucyIsIm5vZGUiLCJ2ZXJzaW9uIiwic2xpY2UiLCJtYWpvciIsIm1hdGNoIiwiRXJyb3IiLCJwYXJzZXIiLCJjd2QiLCJyZXF1aXJlIiwicGF0aCIsIkpTT04iLCJwYXJzZSIsInlhcmdzUGFyc2VyIiwiUGFyc2VyIiwiYXJncyIsIm9wdHMiLCJyZXN1bHQiLCJhcmd2IiwiZGV0YWlsZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/yargs-parser/build/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/yargs-parser/build/lib/string-utils.js":
/*!*************************************************************!*\
  !*** ./node_modules/yargs-parser/build/lib/string-utils.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   camelCase: () => (/* binding */ camelCase),\n/* harmony export */   decamelize: () => (/* binding */ decamelize),\n/* harmony export */   looksLikeNumber: () => (/* binding */ looksLikeNumber)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2016, Contributors\n * SPDX-License-Identifier: ISC\n */ function camelCase(str) {\n    // Handle the case where an argument is provided as camel case, e.g., fooBar.\n    // by ensuring that the string isn't already mixed case:\n    const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();\n    if (!isCamelCase) {\n        str = str.toLowerCase();\n    }\n    if (str.indexOf(\"-\") === -1 && str.indexOf(\"_\") === -1) {\n        return str;\n    } else {\n        let camelcase = \"\";\n        let nextChrUpper = false;\n        const leadingHyphens = str.match(/^-+/);\n        for(let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++){\n            let chr = str.charAt(i);\n            if (nextChrUpper) {\n                nextChrUpper = false;\n                chr = chr.toUpperCase();\n            }\n            if (i !== 0 && (chr === \"-\" || chr === \"_\")) {\n                nextChrUpper = true;\n            } else if (chr !== \"-\" && chr !== \"_\") {\n                camelcase += chr;\n            }\n        }\n        return camelcase;\n    }\n}\nfunction decamelize(str, joinString) {\n    const lowercase = str.toLowerCase();\n    joinString = joinString || \"-\";\n    let notCamelcase = \"\";\n    for(let i = 0; i < str.length; i++){\n        const chrLower = lowercase.charAt(i);\n        const chrString = str.charAt(i);\n        if (chrLower !== chrString && i > 0) {\n            notCamelcase += `${joinString}${lowercase.charAt(i)}`;\n        } else {\n            notCamelcase += chrString;\n        }\n    }\n    return notCamelcase;\n}\nfunction looksLikeNumber(x) {\n    if (x === null || x === undefined) return false;\n    // if loaded from config, may already be a number.\n    if (typeof x === \"number\") return true;\n    // hexadecimal.\n    if (/^0x[0-9a-f]+$/i.test(x)) return true;\n    // don't treat 0123 as a number; as it drops the leading '0'.\n    if (/^0[^.]/.test(x)) return false;\n    return /^[-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveWFyZ3MtcGFyc2VyL2J1aWxkL2xpYi9zdHJpbmctdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUNNLFNBQVNBLFVBQVVDLEdBQUc7SUFDekIsNkVBQTZFO0lBQzdFLHdEQUF3RDtJQUN4RCxNQUFNQyxjQUFjRCxRQUFRQSxJQUFJRSxXQUFXLE1BQU1GLFFBQVFBLElBQUlHLFdBQVc7SUFDeEUsSUFBSSxDQUFDRixhQUFhO1FBQ2RELE1BQU1BLElBQUlFLFdBQVc7SUFDekI7SUFDQSxJQUFJRixJQUFJSSxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUtKLElBQUlJLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRztRQUNwRCxPQUFPSjtJQUNYLE9BQ0s7UUFDRCxJQUFJSyxZQUFZO1FBQ2hCLElBQUlDLGVBQWU7UUFDbkIsTUFBTUMsaUJBQWlCUCxJQUFJUSxLQUFLLENBQUM7UUFDakMsSUFBSyxJQUFJQyxJQUFJRixpQkFBaUJBLGNBQWMsQ0FBQyxFQUFFLENBQUNHLE1BQU0sR0FBRyxHQUFHRCxJQUFJVCxJQUFJVSxNQUFNLEVBQUVELElBQUs7WUFDN0UsSUFBSUUsTUFBTVgsSUFBSVksTUFBTSxDQUFDSDtZQUNyQixJQUFJSCxjQUFjO2dCQUNkQSxlQUFlO2dCQUNmSyxNQUFNQSxJQUFJUixXQUFXO1lBQ3pCO1lBQ0EsSUFBSU0sTUFBTSxLQUFNRSxDQUFBQSxRQUFRLE9BQU9BLFFBQVEsR0FBRSxHQUFJO2dCQUN6Q0wsZUFBZTtZQUNuQixPQUNLLElBQUlLLFFBQVEsT0FBT0EsUUFBUSxLQUFLO2dCQUNqQ04sYUFBYU07WUFDakI7UUFDSjtRQUNBLE9BQU9OO0lBQ1g7QUFDSjtBQUNPLFNBQVNRLFdBQVdiLEdBQUcsRUFBRWMsVUFBVTtJQUN0QyxNQUFNQyxZQUFZZixJQUFJRSxXQUFXO0lBQ2pDWSxhQUFhQSxjQUFjO0lBQzNCLElBQUlFLGVBQWU7SUFDbkIsSUFBSyxJQUFJUCxJQUFJLEdBQUdBLElBQUlULElBQUlVLE1BQU0sRUFBRUQsSUFBSztRQUNqQyxNQUFNUSxXQUFXRixVQUFVSCxNQUFNLENBQUNIO1FBQ2xDLE1BQU1TLFlBQVlsQixJQUFJWSxNQUFNLENBQUNIO1FBQzdCLElBQUlRLGFBQWFDLGFBQWFULElBQUksR0FBRztZQUNqQ08sZ0JBQWdCLENBQUMsRUFBRUYsV0FBVyxFQUFFQyxVQUFVSCxNQUFNLENBQUNILEdBQUcsQ0FBQztRQUN6RCxPQUNLO1lBQ0RPLGdCQUFnQkU7UUFDcEI7SUFDSjtJQUNBLE9BQU9GO0FBQ1g7QUFDTyxTQUFTRyxnQkFBZ0JDLENBQUM7SUFDN0IsSUFBSUEsTUFBTSxRQUFRQSxNQUFNQyxXQUNwQixPQUFPO0lBQ1gsa0RBQWtEO0lBQ2xELElBQUksT0FBT0QsTUFBTSxVQUNiLE9BQU87SUFDWCxlQUFlO0lBQ2YsSUFBSSxpQkFBaUJFLElBQUksQ0FBQ0YsSUFDdEIsT0FBTztJQUNYLDZEQUE2RDtJQUM3RCxJQUFJLFNBQVNFLElBQUksQ0FBQ0YsSUFDZCxPQUFPO0lBQ1gsT0FBTyw0Q0FBNENFLElBQUksQ0FBQ0Y7QUFDNUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy95YXJncy1wYXJzZXIvYnVpbGQvbGliL3N0cmluZy11dGlscy5qcz9kMjkwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiwgQ29udHJpYnV0b3JzXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogSVNDXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYW1lbENhc2Uoc3RyKSB7XG4gICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIGFuIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGFzIGNhbWVsIGNhc2UsIGUuZy4sIGZvb0Jhci5cbiAgICAvLyBieSBlbnN1cmluZyB0aGF0IHRoZSBzdHJpbmcgaXNuJ3QgYWxyZWFkeSBtaXhlZCBjYXNlOlxuICAgIGNvbnN0IGlzQ2FtZWxDYXNlID0gc3RyICE9PSBzdHIudG9Mb3dlckNhc2UoKSAmJiBzdHIgIT09IHN0ci50b1VwcGVyQ2FzZSgpO1xuICAgIGlmICghaXNDYW1lbENhc2UpIHtcbiAgICAgICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGlmIChzdHIuaW5kZXhPZignLScpID09PSAtMSAmJiBzdHIuaW5kZXhPZignXycpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGNhbWVsY2FzZSA9ICcnO1xuICAgICAgICBsZXQgbmV4dENoclVwcGVyID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGxlYWRpbmdIeXBoZW5zID0gc3RyLm1hdGNoKC9eLSsvKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGxlYWRpbmdIeXBoZW5zID8gbGVhZGluZ0h5cGhlbnNbMF0ubGVuZ3RoIDogMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNociA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpZiAobmV4dENoclVwcGVyKSB7XG4gICAgICAgICAgICAgICAgbmV4dENoclVwcGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2hyID0gY2hyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSAhPT0gMCAmJiAoY2hyID09PSAnLScgfHwgY2hyID09PSAnXycpKSB7XG4gICAgICAgICAgICAgICAgbmV4dENoclVwcGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNociAhPT0gJy0nICYmIGNociAhPT0gJ18nKSB7XG4gICAgICAgICAgICAgICAgY2FtZWxjYXNlICs9IGNocjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FtZWxjYXNlO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNhbWVsaXplKHN0ciwgam9pblN0cmluZykge1xuICAgIGNvbnN0IGxvd2VyY2FzZSA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgIGpvaW5TdHJpbmcgPSBqb2luU3RyaW5nIHx8ICctJztcbiAgICBsZXQgbm90Q2FtZWxjYXNlID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hyTG93ZXIgPSBsb3dlcmNhc2UuY2hhckF0KGkpO1xuICAgICAgICBjb25zdCBjaHJTdHJpbmcgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICBpZiAoY2hyTG93ZXIgIT09IGNoclN0cmluZyAmJiBpID4gMCkge1xuICAgICAgICAgICAgbm90Q2FtZWxjYXNlICs9IGAke2pvaW5TdHJpbmd9JHtsb3dlcmNhc2UuY2hhckF0KGkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub3RDYW1lbGNhc2UgKz0gY2hyU3RyaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub3RDYW1lbGNhc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gbG9va3NMaWtlTnVtYmVyKHgpIHtcbiAgICBpZiAoeCA9PT0gbnVsbCB8fCB4ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBpZiBsb2FkZWQgZnJvbSBjb25maWcsIG1heSBhbHJlYWR5IGJlIGEgbnVtYmVyLlxuICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIGhleGFkZWNpbWFsLlxuICAgIGlmICgvXjB4WzAtOWEtZl0rJC9pLnRlc3QoeCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIGRvbid0IHRyZWF0IDAxMjMgYXMgYSBudW1iZXI7IGFzIGl0IGRyb3BzIHRoZSBsZWFkaW5nICcwJy5cbiAgICBpZiAoL14wW14uXS8udGVzdCh4KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAvXlstXT8oPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKGVbLStdP1xcZCspPyQvLnRlc3QoeCk7XG59XG4iXSwibmFtZXMiOlsiY2FtZWxDYXNlIiwic3RyIiwiaXNDYW1lbENhc2UiLCJ0b0xvd2VyQ2FzZSIsInRvVXBwZXJDYXNlIiwiaW5kZXhPZiIsImNhbWVsY2FzZSIsIm5leHRDaHJVcHBlciIsImxlYWRpbmdIeXBoZW5zIiwibWF0Y2giLCJpIiwibGVuZ3RoIiwiY2hyIiwiY2hhckF0IiwiZGVjYW1lbGl6ZSIsImpvaW5TdHJpbmciLCJsb3dlcmNhc2UiLCJub3RDYW1lbGNhc2UiLCJjaHJMb3dlciIsImNoclN0cmluZyIsImxvb2tzTGlrZU51bWJlciIsIngiLCJ1bmRlZmluZWQiLCJ0ZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/yargs-parser/build/lib/string-utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/yargs-parser/build/lib/tokenize-arg-string.js":
/*!********************************************************************!*\
  !*** ./node_modules/yargs-parser/build/lib/tokenize-arg-string.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   tokenizeArgString: () => (/* binding */ tokenizeArgString)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2016, Contributors\n * SPDX-License-Identifier: ISC\n */ // take an un-split argv string and tokenize it.\nfunction tokenizeArgString(argString) {\n    if (Array.isArray(argString)) {\n        return argString.map((e)=>typeof e !== \"string\" ? e + \"\" : e);\n    }\n    argString = argString.trim();\n    let i = 0;\n    let prevC = null;\n    let c = null;\n    let opening = null;\n    const args = [];\n    for(let ii = 0; ii < argString.length; ii++){\n        prevC = c;\n        c = argString.charAt(ii);\n        // split on spaces unless we're in quotes.\n        if (c === \" \" && !opening) {\n            if (!(prevC === \" \")) {\n                i++;\n            }\n            continue;\n        }\n        // don't split the string if we're in matching\n        // opening or closing single and double quotes.\n        if (c === opening) {\n            opening = null;\n        } else if ((c === \"'\" || c === '\"') && !opening) {\n            opening = c;\n        }\n        if (!args[i]) args[i] = \"\";\n        args[i] += c;\n    }\n    return args;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveWFyZ3MtcGFyc2VyL2J1aWxkL2xpYi90b2tlbml6ZS1hcmctc3RyaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7OztDQUlDLEdBQ0QsZ0RBQWdEO0FBQ3pDLFNBQVNBLGtCQUFrQkMsU0FBUztJQUN2QyxJQUFJQyxNQUFNQyxPQUFPLENBQUNGLFlBQVk7UUFDMUIsT0FBT0EsVUFBVUcsR0FBRyxDQUFDQyxDQUFBQSxJQUFLLE9BQU9BLE1BQU0sV0FBV0EsSUFBSSxLQUFLQTtJQUMvRDtJQUNBSixZQUFZQSxVQUFVSyxJQUFJO0lBQzFCLElBQUlDLElBQUk7SUFDUixJQUFJQyxRQUFRO0lBQ1osSUFBSUMsSUFBSTtJQUNSLElBQUlDLFVBQVU7SUFDZCxNQUFNQyxPQUFPLEVBQUU7SUFDZixJQUFLLElBQUlDLEtBQUssR0FBR0EsS0FBS1gsVUFBVVksTUFBTSxFQUFFRCxLQUFNO1FBQzFDSixRQUFRQztRQUNSQSxJQUFJUixVQUFVYSxNQUFNLENBQUNGO1FBQ3JCLDBDQUEwQztRQUMxQyxJQUFJSCxNQUFNLE9BQU8sQ0FBQ0MsU0FBUztZQUN2QixJQUFJLENBQUVGLENBQUFBLFVBQVUsR0FBRSxHQUFJO2dCQUNsQkQ7WUFDSjtZQUNBO1FBQ0o7UUFDQSw4Q0FBOEM7UUFDOUMsK0NBQStDO1FBQy9DLElBQUlFLE1BQU1DLFNBQVM7WUFDZkEsVUFBVTtRQUNkLE9BQ0ssSUFBSSxDQUFDRCxNQUFNLE9BQU9BLE1BQU0sR0FBRSxLQUFNLENBQUNDLFNBQVM7WUFDM0NBLFVBQVVEO1FBQ2Q7UUFDQSxJQUFJLENBQUNFLElBQUksQ0FBQ0osRUFBRSxFQUNSSSxJQUFJLENBQUNKLEVBQUUsR0FBRztRQUNkSSxJQUFJLENBQUNKLEVBQUUsSUFBSUU7SUFDZjtJQUNBLE9BQU9FO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy95YXJncy1wYXJzZXIvYnVpbGQvbGliL3Rva2VuaXplLWFyZy1zdHJpbmcuanM/MmZhZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYsIENvbnRyaWJ1dG9yc1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IElTQ1xuICovXG4vLyB0YWtlIGFuIHVuLXNwbGl0IGFyZ3Ygc3RyaW5nIGFuZCB0b2tlbml6ZSBpdC5cbmV4cG9ydCBmdW5jdGlvbiB0b2tlbml6ZUFyZ1N0cmluZyhhcmdTdHJpbmcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBhcmdTdHJpbmcubWFwKGUgPT4gdHlwZW9mIGUgIT09ICdzdHJpbmcnID8gZSArICcnIDogZSk7XG4gICAgfVxuICAgIGFyZ1N0cmluZyA9IGFyZ1N0cmluZy50cmltKCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBwcmV2QyA9IG51bGw7XG4gICAgbGV0IGMgPSBudWxsO1xuICAgIGxldCBvcGVuaW5nID0gbnVsbDtcbiAgICBjb25zdCBhcmdzID0gW107XG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IGFyZ1N0cmluZy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgcHJldkMgPSBjO1xuICAgICAgICBjID0gYXJnU3RyaW5nLmNoYXJBdChpaSk7XG4gICAgICAgIC8vIHNwbGl0IG9uIHNwYWNlcyB1bmxlc3Mgd2UncmUgaW4gcXVvdGVzLlxuICAgICAgICBpZiAoYyA9PT0gJyAnICYmICFvcGVuaW5nKSB7XG4gICAgICAgICAgICBpZiAoIShwcmV2QyA9PT0gJyAnKSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvbid0IHNwbGl0IHRoZSBzdHJpbmcgaWYgd2UncmUgaW4gbWF0Y2hpbmdcbiAgICAgICAgLy8gb3BlbmluZyBvciBjbG9zaW5nIHNpbmdsZSBhbmQgZG91YmxlIHF1b3Rlcy5cbiAgICAgICAgaWYgKGMgPT09IG9wZW5pbmcpIHtcbiAgICAgICAgICAgIG9wZW5pbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjID09PSBcIidcIiB8fCBjID09PSAnXCInKSAmJiAhb3BlbmluZykge1xuICAgICAgICAgICAgb3BlbmluZyA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhcmdzW2ldKVxuICAgICAgICAgICAgYXJnc1tpXSA9ICcnO1xuICAgICAgICBhcmdzW2ldICs9IGM7XG4gICAgfVxuICAgIHJldHVybiBhcmdzO1xufVxuIl0sIm5hbWVzIjpbInRva2VuaXplQXJnU3RyaW5nIiwiYXJnU3RyaW5nIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwiZSIsInRyaW0iLCJpIiwicHJldkMiLCJjIiwib3BlbmluZyIsImFyZ3MiLCJpaSIsImxlbmd0aCIsImNoYXJBdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/yargs-parser/build/lib/tokenize-arg-string.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/yargs-parser/build/lib/yargs-parser-types.js":
/*!*******************************************************************!*\
  !*** ./node_modules/yargs-parser/build/lib/yargs-parser-types.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultValuesForTypeKey: () => (/* binding */ DefaultValuesForTypeKey)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2016, Contributors\n * SPDX-License-Identifier: ISC\n */ var DefaultValuesForTypeKey;\n(function(DefaultValuesForTypeKey) {\n    DefaultValuesForTypeKey[\"BOOLEAN\"] = \"boolean\";\n    DefaultValuesForTypeKey[\"STRING\"] = \"string\";\n    DefaultValuesForTypeKey[\"NUMBER\"] = \"number\";\n    DefaultValuesForTypeKey[\"ARRAY\"] = \"array\";\n})(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveWFyZ3MtcGFyc2VyL2J1aWxkL2xpYi95YXJncy1wYXJzZXItdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7O0NBSUMsR0FDTSxJQUFJQSx3QkFBd0I7QUFDbEMsVUFBVUEsdUJBQXVCO0lBQzlCQSx1QkFBdUIsQ0FBQyxVQUFVLEdBQUc7SUFDckNBLHVCQUF1QixDQUFDLFNBQVMsR0FBRztJQUNwQ0EsdUJBQXVCLENBQUMsU0FBUyxHQUFHO0lBQ3BDQSx1QkFBdUIsQ0FBQyxRQUFRLEdBQUc7QUFDdkMsR0FBR0EsMkJBQTRCQSxDQUFBQSwwQkFBMEIsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL3lhcmdzLXBhcnNlci9idWlsZC9saWIveWFyZ3MtcGFyc2VyLXR5cGVzLmpzPzE5NTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2LCBDb250cmlidXRvcnNcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBJU0NcbiAqL1xuZXhwb3J0IHZhciBEZWZhdWx0VmFsdWVzRm9yVHlwZUtleTtcbihmdW5jdGlvbiAoRGVmYXVsdFZhbHVlc0ZvclR5cGVLZXkpIHtcbiAgICBEZWZhdWx0VmFsdWVzRm9yVHlwZUtleVtcIkJPT0xFQU5cIl0gPSBcImJvb2xlYW5cIjtcbiAgICBEZWZhdWx0VmFsdWVzRm9yVHlwZUtleVtcIlNUUklOR1wiXSA9IFwic3RyaW5nXCI7XG4gICAgRGVmYXVsdFZhbHVlc0ZvclR5cGVLZXlbXCJOVU1CRVJcIl0gPSBcIm51bWJlclwiO1xuICAgIERlZmF1bHRWYWx1ZXNGb3JUeXBlS2V5W1wiQVJSQVlcIl0gPSBcImFycmF5XCI7XG59KShEZWZhdWx0VmFsdWVzRm9yVHlwZUtleSB8fCAoRGVmYXVsdFZhbHVlc0ZvclR5cGVLZXkgPSB7fSkpO1xuIl0sIm5hbWVzIjpbIkRlZmF1bHRWYWx1ZXNGb3JUeXBlS2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/yargs-parser/build/lib/yargs-parser-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/yargs-parser/build/lib/yargs-parser.js":
/*!*************************************************************!*\
  !*** ./node_modules/yargs-parser/build/lib/yargs-parser.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   YargsParser: () => (/* binding */ YargsParser)\n/* harmony export */ });\n/* harmony import */ var _tokenize_arg_string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tokenize-arg-string.js */ \"(rsc)/./node_modules/yargs-parser/build/lib/tokenize-arg-string.js\");\n/* harmony import */ var _yargs_parser_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./yargs-parser-types.js */ \"(rsc)/./node_modules/yargs-parser/build/lib/yargs-parser-types.js\");\n/* harmony import */ var _string_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./string-utils.js */ \"(rsc)/./node_modules/yargs-parser/build/lib/string-utils.js\");\n/**\n * @license\n * Copyright (c) 2016, Contributors\n * SPDX-License-Identifier: ISC\n */ \n\n\nlet mixin;\nclass YargsParser {\n    constructor(_mixin){\n        mixin = _mixin;\n    }\n    parse(argsInput, options) {\n        const opts = Object.assign({\n            alias: undefined,\n            array: undefined,\n            boolean: undefined,\n            config: undefined,\n            configObjects: undefined,\n            configuration: undefined,\n            coerce: undefined,\n            count: undefined,\n            default: undefined,\n            envPrefix: undefined,\n            narg: undefined,\n            normalize: undefined,\n            string: undefined,\n            number: undefined,\n            __: undefined,\n            key: undefined\n        }, options);\n        // allow a string argument to be passed in rather\n        // than an argv array.\n        const args = (0,_tokenize_arg_string_js__WEBPACK_IMPORTED_MODULE_0__.tokenizeArgString)(argsInput);\n        // tokenizeArgString adds extra quotes to args if argsInput is a string\n        // only strip those extra quotes in processValue if argsInput is a string\n        const inputIsString = typeof argsInput === \"string\";\n        // aliases might have transitive relationships, normalize this.\n        const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));\n        const configuration = Object.assign({\n            \"boolean-negation\": true,\n            \"camel-case-expansion\": true,\n            \"combine-arrays\": false,\n            \"dot-notation\": true,\n            \"duplicate-arguments-array\": true,\n            \"flatten-duplicate-arrays\": true,\n            \"greedy-arrays\": true,\n            \"halt-at-non-option\": false,\n            \"nargs-eats-options\": false,\n            \"negation-prefix\": \"no-\",\n            \"parse-numbers\": true,\n            \"parse-positional-numbers\": true,\n            \"populate--\": false,\n            \"set-placeholder-key\": false,\n            \"short-option-groups\": true,\n            \"strip-aliased\": false,\n            \"strip-dashed\": false,\n            \"unknown-options-as-args\": false\n        }, opts.configuration);\n        const defaults = Object.assign(Object.create(null), opts.default);\n        const configObjects = opts.configObjects || [];\n        const envPrefix = opts.envPrefix;\n        const notFlagsOption = configuration[\"populate--\"];\n        const notFlagsArgv = notFlagsOption ? \"--\" : \"_\";\n        const newAliases = Object.create(null);\n        const defaulted = Object.create(null);\n        // allow a i18n handler to be passed in, default to a fake one (util.format).\n        const __ = opts.__ || mixin.format;\n        const flags = {\n            aliases: Object.create(null),\n            arrays: Object.create(null),\n            bools: Object.create(null),\n            strings: Object.create(null),\n            numbers: Object.create(null),\n            counts: Object.create(null),\n            normalize: Object.create(null),\n            configs: Object.create(null),\n            nargs: Object.create(null),\n            coercions: Object.create(null),\n            keys: []\n        };\n        const negative = /^-([0-9]+(\\.[0-9]+)?|\\.[0-9]+)$/;\n        const negatedBoolean = new RegExp(\"^--\" + configuration[\"negation-prefix\"] + \"(.+)\");\n        [].concat(opts.array || []).filter(Boolean).forEach(function(opt) {\n            const key = typeof opt === \"object\" ? opt.key : opt;\n            // assign to flags[bools|strings|numbers]\n            const assignment = Object.keys(opt).map(function(key) {\n                const arrayFlagKeys = {\n                    boolean: \"bools\",\n                    string: \"strings\",\n                    number: \"numbers\"\n                };\n                return arrayFlagKeys[key];\n            }).filter(Boolean).pop();\n            // assign key to be coerced\n            if (assignment) {\n                flags[assignment][key] = true;\n            }\n            flags.arrays[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.boolean || []).filter(Boolean).forEach(function(key) {\n            flags.bools[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.string || []).filter(Boolean).forEach(function(key) {\n            flags.strings[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.number || []).filter(Boolean).forEach(function(key) {\n            flags.numbers[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.count || []).filter(Boolean).forEach(function(key) {\n            flags.counts[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.normalize || []).filter(Boolean).forEach(function(key) {\n            flags.normalize[key] = true;\n            flags.keys.push(key);\n        });\n        if (typeof opts.narg === \"object\") {\n            Object.entries(opts.narg).forEach(([key, value])=>{\n                if (typeof value === \"number\") {\n                    flags.nargs[key] = value;\n                    flags.keys.push(key);\n                }\n            });\n        }\n        if (typeof opts.coerce === \"object\") {\n            Object.entries(opts.coerce).forEach(([key, value])=>{\n                if (typeof value === \"function\") {\n                    flags.coercions[key] = value;\n                    flags.keys.push(key);\n                }\n            });\n        }\n        if (typeof opts.config !== \"undefined\") {\n            if (Array.isArray(opts.config) || typeof opts.config === \"string\") {\n                ;\n                [].concat(opts.config).filter(Boolean).forEach(function(key) {\n                    flags.configs[key] = true;\n                });\n            } else if (typeof opts.config === \"object\") {\n                Object.entries(opts.config).forEach(([key, value])=>{\n                    if (typeof value === \"boolean\" || typeof value === \"function\") {\n                        flags.configs[key] = value;\n                    }\n                });\n            }\n        }\n        // create a lookup table that takes into account all\n        // combinations of aliases: {f: ['foo'], foo: ['f']}\n        extendAliases(opts.key, aliases, opts.default, flags.arrays);\n        // apply default values to all aliases.\n        Object.keys(defaults).forEach(function(key) {\n            (flags.aliases[key] || []).forEach(function(alias) {\n                defaults[alias] = defaults[key];\n            });\n        });\n        let error = null;\n        checkConfiguration();\n        let notFlags = [];\n        const argv = Object.assign(Object.create(null), {\n            _: []\n        });\n        // TODO(bcoe): for the first pass at removing object prototype  we didn't\n        // remove all prototypes from objects returned by this API, we might want\n        // to gradually move towards doing so.\n        const argvReturn = {};\n        for(let i = 0; i < args.length; i++){\n            const arg = args[i];\n            const truncatedArg = arg.replace(/^-{3,}/, \"---\");\n            let broken;\n            let key;\n            let letters;\n            let m;\n            let next;\n            let value;\n            // any unknown option (except for end-of-options, \"--\")\n            if (arg !== \"--\" && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {\n                pushPositional(arg);\n            // ---, ---=, ----, etc,\n            } else if (truncatedArg.match(/^---+(=|$)/)) {\n                // options without key name are invalid.\n                pushPositional(arg);\n                continue;\n            // -- separated by =\n            } else if (arg.match(/^--.+=/) || !configuration[\"short-option-groups\"] && arg.match(/^-.+=/)) {\n                // Using [\\s\\S] instead of . because js doesn't support the\n                // 'dotall' regex modifier. See:\n                // http://stackoverflow.com/a/1068308/13216\n                m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/);\n                // arrays format = '--f=a b c'\n                if (m !== null && Array.isArray(m) && m.length >= 3) {\n                    if (checkAllAliases(m[1], flags.arrays)) {\n                        i = eatArray(i, m[1], args, m[2]);\n                    } else if (checkAllAliases(m[1], flags.nargs) !== false) {\n                        // nargs format = '--f=monkey washing cat'\n                        i = eatNargs(i, m[1], args, m[2]);\n                    } else {\n                        setArg(m[1], m[2], true);\n                    }\n                }\n            } else if (arg.match(negatedBoolean) && configuration[\"boolean-negation\"]) {\n                m = arg.match(negatedBoolean);\n                if (m !== null && Array.isArray(m) && m.length >= 2) {\n                    key = m[1];\n                    setArg(key, checkAllAliases(key, flags.arrays) ? [\n                        false\n                    ] : false);\n                }\n            // -- separated by space.\n            } else if (arg.match(/^--.+/) || !configuration[\"short-option-groups\"] && arg.match(/^-[^-]+/)) {\n                m = arg.match(/^--?(.+)/);\n                if (m !== null && Array.isArray(m) && m.length >= 2) {\n                    key = m[1];\n                    if (checkAllAliases(key, flags.arrays)) {\n                        // array format = '--foo a b c'\n                        i = eatArray(i, key, args);\n                    } else if (checkAllAliases(key, flags.nargs) !== false) {\n                        // nargs format = '--foo a b c'\n                        // should be truthy even if: flags.nargs[key] === 0\n                        i = eatNargs(i, key, args);\n                    } else {\n                        next = args[i + 1];\n                        if (next !== undefined && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n                            setArg(key, next);\n                            i++;\n                        } else if (/^(true|false)$/.test(next)) {\n                            setArg(key, next);\n                            i++;\n                        } else {\n                            setArg(key, defaultValue(key));\n                        }\n                    }\n                }\n            // dot-notation flag separated by '='.\n            } else if (arg.match(/^-.\\..+=/)) {\n                m = arg.match(/^-([^=]+)=([\\s\\S]*)$/);\n                if (m !== null && Array.isArray(m) && m.length >= 3) {\n                    setArg(m[1], m[2]);\n                }\n            // dot-notation flag separated by space.\n            } else if (arg.match(/^-.\\..+/) && !arg.match(negative)) {\n                next = args[i + 1];\n                m = arg.match(/^-(.\\..+)/);\n                if (m !== null && Array.isArray(m) && m.length >= 2) {\n                    key = m[1];\n                    if (next !== undefined && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n                        setArg(key, next);\n                        i++;\n                    } else {\n                        setArg(key, defaultValue(key));\n                    }\n                }\n            } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n                letters = arg.slice(1, -1).split(\"\");\n                broken = false;\n                for(let j = 0; j < letters.length; j++){\n                    next = arg.slice(j + 2);\n                    if (letters[j + 1] && letters[j + 1] === \"=\") {\n                        value = arg.slice(j + 3);\n                        key = letters[j];\n                        if (checkAllAliases(key, flags.arrays)) {\n                            // array format = '-f=a b c'\n                            i = eatArray(i, key, args, value);\n                        } else if (checkAllAliases(key, flags.nargs) !== false) {\n                            // nargs format = '-f=monkey washing cat'\n                            i = eatNargs(i, key, args, value);\n                        } else {\n                            setArg(key, value);\n                        }\n                        broken = true;\n                        break;\n                    }\n                    if (next === \"-\") {\n                        setArg(letters[j], next);\n                        continue;\n                    }\n                    // current letter is an alphabetic character and next value is a number\n                    if (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {\n                        setArg(letters[j], next);\n                        broken = true;\n                        break;\n                    }\n                    if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n                        setArg(letters[j], next);\n                        broken = true;\n                        break;\n                    } else {\n                        setArg(letters[j], defaultValue(letters[j]));\n                    }\n                }\n                key = arg.slice(-1)[0];\n                if (!broken && key !== \"-\") {\n                    if (checkAllAliases(key, flags.arrays)) {\n                        // array format = '-f a b c'\n                        i = eatArray(i, key, args);\n                    } else if (checkAllAliases(key, flags.nargs) !== false) {\n                        // nargs format = '-f a b c'\n                        // should be truthy even if: flags.nargs[key] === 0\n                        i = eatNargs(i, key, args);\n                    } else {\n                        next = args[i + 1];\n                        if (next !== undefined && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n                            setArg(key, next);\n                            i++;\n                        } else if (/^(true|false)$/.test(next)) {\n                            setArg(key, next);\n                            i++;\n                        } else {\n                            setArg(key, defaultValue(key));\n                        }\n                    }\n                }\n            } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {\n                // single-digit boolean alias, e.g: xargs -0\n                key = arg.slice(1);\n                setArg(key, defaultValue(key));\n            } else if (arg === \"--\") {\n                notFlags = args.slice(i + 1);\n                break;\n            } else if (configuration[\"halt-at-non-option\"]) {\n                notFlags = args.slice(i);\n                break;\n            } else {\n                pushPositional(arg);\n            }\n        }\n        // order of precedence:\n        // 1. command line arg\n        // 2. value from env var\n        // 3. value from config file\n        // 4. value from config objects\n        // 5. configured default value\n        applyEnvVars(argv, true); // special case: check env vars that point to config file\n        applyEnvVars(argv, false);\n        setConfig(argv);\n        setConfigObjects();\n        applyDefaultsAndAliases(argv, flags.aliases, defaults, true);\n        applyCoercions(argv);\n        if (configuration[\"set-placeholder-key\"]) setPlaceholderKeys(argv);\n        // for any counts either not in args or without an explicit default, set to 0\n        Object.keys(flags.counts).forEach(function(key) {\n            if (!hasKey(argv, key.split(\".\"))) setArg(key, 0);\n        });\n        // '--' defaults to undefined.\n        if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = [];\n        notFlags.forEach(function(key) {\n            argv[notFlagsArgv].push(key);\n        });\n        if (configuration[\"camel-case-expansion\"] && configuration[\"strip-dashed\"]) {\n            Object.keys(argv).filter((key)=>key !== \"--\" && key.includes(\"-\")).forEach((key)=>{\n                delete argv[key];\n            });\n        }\n        if (configuration[\"strip-aliased\"]) {\n            ;\n            [].concat(...Object.keys(aliases).map((k)=>aliases[k])).forEach((alias)=>{\n                if (configuration[\"camel-case-expansion\"] && alias.includes(\"-\")) {\n                    delete argv[alias.split(\".\").map((prop)=>(0,_string_utils_js__WEBPACK_IMPORTED_MODULE_2__.camelCase)(prop)).join(\".\")];\n                }\n                delete argv[alias];\n            });\n        }\n        // Push argument into positional array, applying numeric coercion:\n        function pushPositional(arg) {\n            const maybeCoercedNumber = maybeCoerceNumber(\"_\", arg);\n            if (typeof maybeCoercedNumber === \"string\" || typeof maybeCoercedNumber === \"number\") {\n                argv._.push(maybeCoercedNumber);\n            }\n        }\n        // how many arguments should we consume, based\n        // on the nargs option?\n        function eatNargs(i, key, args, argAfterEqualSign) {\n            let ii;\n            let toEat = checkAllAliases(key, flags.nargs);\n            // NaN has a special meaning for the array type, indicating that one or\n            // more values are expected.\n            toEat = typeof toEat !== \"number\" || isNaN(toEat) ? 1 : toEat;\n            if (toEat === 0) {\n                if (!isUndefined(argAfterEqualSign)) {\n                    error = Error(__(\"Argument unexpected for: %s\", key));\n                }\n                setArg(key, defaultValue(key));\n                return i;\n            }\n            let available = isUndefined(argAfterEqualSign) ? 0 : 1;\n            if (configuration[\"nargs-eats-options\"]) {\n                // classic behavior, yargs eats positional and dash arguments.\n                if (args.length - (i + 1) + available < toEat) {\n                    error = Error(__(\"Not enough arguments following: %s\", key));\n                }\n                available = toEat;\n            } else {\n                // nargs will not consume flag arguments, e.g., -abc, --foo,\n                // and terminates when one is observed.\n                for(ii = i + 1; ii < args.length; ii++){\n                    if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii])) available++;\n                    else break;\n                }\n                if (available < toEat) error = Error(__(\"Not enough arguments following: %s\", key));\n            }\n            let consumed = Math.min(available, toEat);\n            if (!isUndefined(argAfterEqualSign) && consumed > 0) {\n                setArg(key, argAfterEqualSign);\n                consumed--;\n            }\n            for(ii = i + 1; ii < consumed + i + 1; ii++){\n                setArg(key, args[ii]);\n            }\n            return i + consumed;\n        }\n        // if an option is an array, eat all non-hyphenated arguments\n        // following it... YUM!\n        // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n        function eatArray(i, key, args, argAfterEqualSign) {\n            let argsToSet = [];\n            let next = argAfterEqualSign || args[i + 1];\n            // If both array and nargs are configured, enforce the nargs count:\n            const nargsCount = checkAllAliases(key, flags.nargs);\n            if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {\n                argsToSet.push(true);\n            } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {\n                // for keys without value ==> argsToSet remains an empty []\n                // set user default value, if available\n                if (defaults[key] !== undefined) {\n                    const defVal = defaults[key];\n                    argsToSet = Array.isArray(defVal) ? defVal : [\n                        defVal\n                    ];\n                }\n            } else {\n                // value in --option=value is eaten as is\n                if (!isUndefined(argAfterEqualSign)) {\n                    argsToSet.push(processValue(key, argAfterEqualSign, true));\n                }\n                for(let ii = i + 1; ii < args.length; ii++){\n                    if (!configuration[\"greedy-arrays\"] && argsToSet.length > 0 || nargsCount && typeof nargsCount === \"number\" && argsToSet.length >= nargsCount) break;\n                    next = args[ii];\n                    if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break;\n                    i = ii;\n                    argsToSet.push(processValue(key, next, inputIsString));\n                }\n            }\n            // If both array and nargs are configured, create an error if less than\n            // nargs positionals were found. NaN has special meaning, indicating\n            // that at least one value is required (more are okay).\n            if (typeof nargsCount === \"number\" && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {\n                error = Error(__(\"Not enough arguments following: %s\", key));\n            }\n            setArg(key, argsToSet);\n            return i;\n        }\n        function setArg(key, val, shouldStripQuotes = inputIsString) {\n            if (/-/.test(key) && configuration[\"camel-case-expansion\"]) {\n                const alias = key.split(\".\").map(function(prop) {\n                    return (0,_string_utils_js__WEBPACK_IMPORTED_MODULE_2__.camelCase)(prop);\n                }).join(\".\");\n                addNewAlias(key, alias);\n            }\n            const value = processValue(key, val, shouldStripQuotes);\n            const splitKey = key.split(\".\");\n            setKey(argv, splitKey, value);\n            // handle populating aliases of the full key\n            if (flags.aliases[key]) {\n                flags.aliases[key].forEach(function(x) {\n                    const keyProperties = x.split(\".\");\n                    setKey(argv, keyProperties, value);\n                });\n            }\n            // handle populating aliases of the first element of the dot-notation key\n            if (splitKey.length > 1 && configuration[\"dot-notation\"]) {\n                ;\n                (flags.aliases[splitKey[0]] || []).forEach(function(x) {\n                    let keyProperties = x.split(\".\");\n                    // expand alias with nested objects in key\n                    const a = [].concat(splitKey);\n                    a.shift(); // nuke the old key.\n                    keyProperties = keyProperties.concat(a);\n                    // populate alias only if is not already an alias of the full key\n                    // (already populated above)\n                    if (!(flags.aliases[key] || []).includes(keyProperties.join(\".\"))) {\n                        setKey(argv, keyProperties, value);\n                    }\n                });\n            }\n            // Set normalize getter and setter when key is in 'normalize' but isn't an array\n            if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n                const keys = [\n                    key\n                ].concat(flags.aliases[key] || []);\n                keys.forEach(function(key) {\n                    Object.defineProperty(argvReturn, key, {\n                        enumerable: true,\n                        get () {\n                            return val;\n                        },\n                        set (value) {\n                            val = typeof value === \"string\" ? mixin.normalize(value) : value;\n                        }\n                    });\n                });\n            }\n        }\n        function addNewAlias(key, alias) {\n            if (!(flags.aliases[key] && flags.aliases[key].length)) {\n                flags.aliases[key] = [\n                    alias\n                ];\n                newAliases[alias] = true;\n            }\n            if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\n                addNewAlias(alias, key);\n            }\n        }\n        function processValue(key, val, shouldStripQuotes) {\n            // strings may be quoted, clean this up as we assign values.\n            if (shouldStripQuotes) {\n                val = stripQuotes(val);\n            }\n            // handle parsing boolean arguments --foo=true --bar false.\n            if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n                if (typeof val === \"string\") val = val === \"true\";\n            }\n            let value = Array.isArray(val) ? val.map(function(v) {\n                return maybeCoerceNumber(key, v);\n            }) : maybeCoerceNumber(key, val);\n            // increment a count given as arg (either no value or value parsed as boolean)\n            if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === \"boolean\")) {\n                value = increment();\n            }\n            // Set normalized value when key is in 'normalize' and in 'arrays'\n            if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n                if (Array.isArray(val)) value = val.map((val)=>{\n                    return mixin.normalize(val);\n                });\n                else value = mixin.normalize(val);\n            }\n            return value;\n        }\n        function maybeCoerceNumber(key, value) {\n            if (!configuration[\"parse-positional-numbers\"] && key === \"_\") return value;\n            if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {\n                const shouldCoerceNumber = (0,_string_utils_js__WEBPACK_IMPORTED_MODULE_2__.looksLikeNumber)(value) && configuration[\"parse-numbers\"] && Number.isSafeInteger(Math.floor(parseFloat(`${value}`)));\n                if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) {\n                    value = Number(value);\n                }\n            }\n            return value;\n        }\n        // set args from config.json file, this should be\n        // applied last so that defaults can be applied.\n        function setConfig(argv) {\n            const configLookup = Object.create(null);\n            // expand defaults/aliases, in-case any happen to reference\n            // the config.json file.\n            applyDefaultsAndAliases(configLookup, flags.aliases, defaults);\n            Object.keys(flags.configs).forEach(function(configKey) {\n                const configPath = argv[configKey] || configLookup[configKey];\n                if (configPath) {\n                    try {\n                        let config = null;\n                        const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);\n                        const resolveConfig = flags.configs[configKey];\n                        if (typeof resolveConfig === \"function\") {\n                            try {\n                                config = resolveConfig(resolvedConfigPath);\n                            } catch (e) {\n                                config = e;\n                            }\n                            if (config instanceof Error) {\n                                error = config;\n                                return;\n                            }\n                        } else {\n                            config = mixin.require(resolvedConfigPath);\n                        }\n                        setConfigObject(config);\n                    } catch (ex) {\n                        // Deno will receive a PermissionDenied error if an attempt is\n                        // made to load config without the --allow-read flag:\n                        if (ex.name === \"PermissionDenied\") error = ex;\n                        else if (argv[configKey]) error = Error(__(\"Invalid JSON config file: %s\", configPath));\n                    }\n                }\n            });\n        }\n        // set args from config object.\n        // it recursively checks nested objects.\n        function setConfigObject(config, prev) {\n            Object.keys(config).forEach(function(key) {\n                const value = config[key];\n                const fullKey = prev ? prev + \".\" + key : key;\n                // if the value is an inner object and we have dot-notation\n                // enabled, treat inner objects in config the same as\n                // heavily nested dot notations (foo.bar.apple).\n                if (typeof value === \"object\" && value !== null && !Array.isArray(value) && configuration[\"dot-notation\"]) {\n                    // if the value is an object but not an array, check nested object\n                    setConfigObject(value, fullKey);\n                } else {\n                    // setting arguments via CLI takes precedence over\n                    // values within the config file.\n                    if (!hasKey(argv, fullKey.split(\".\")) || checkAllAliases(fullKey, flags.arrays) && configuration[\"combine-arrays\"]) {\n                        setArg(fullKey, value);\n                    }\n                }\n            });\n        }\n        // set all config objects passed in opts\n        function setConfigObjects() {\n            if (typeof configObjects !== \"undefined\") {\n                configObjects.forEach(function(configObject) {\n                    setConfigObject(configObject);\n                });\n            }\n        }\n        function applyEnvVars(argv, configOnly) {\n            if (typeof envPrefix === \"undefined\") return;\n            const prefix = typeof envPrefix === \"string\" ? envPrefix : \"\";\n            const env = mixin.env();\n            Object.keys(env).forEach(function(envVar) {\n                if (prefix === \"\" || envVar.lastIndexOf(prefix, 0) === 0) {\n                    // get array of nested keys and convert them to camel case\n                    const keys = envVar.split(\"__\").map(function(key, i) {\n                        if (i === 0) {\n                            key = key.substring(prefix.length);\n                        }\n                        return (0,_string_utils_js__WEBPACK_IMPORTED_MODULE_2__.camelCase)(key);\n                    });\n                    if ((configOnly && flags.configs[keys.join(\".\")] || !configOnly) && !hasKey(argv, keys)) {\n                        setArg(keys.join(\".\"), env[envVar]);\n                    }\n                }\n            });\n        }\n        function applyCoercions(argv) {\n            let coerce;\n            const applied = new Set();\n            Object.keys(argv).forEach(function(key) {\n                if (!applied.has(key)) {\n                    coerce = checkAllAliases(key, flags.coercions);\n                    if (typeof coerce === \"function\") {\n                        try {\n                            const value = maybeCoerceNumber(key, coerce(argv[key]));\n                            [].concat(flags.aliases[key] || [], key).forEach((ali)=>{\n                                applied.add(ali);\n                                argv[ali] = value;\n                            });\n                        } catch (err) {\n                            error = err;\n                        }\n                    }\n                }\n            });\n        }\n        function setPlaceholderKeys(argv) {\n            flags.keys.forEach((key)=>{\n                // don't set placeholder keys for dot notation options 'foo.bar'.\n                if (~key.indexOf(\".\")) return;\n                if (typeof argv[key] === \"undefined\") argv[key] = undefined;\n            });\n            return argv;\n        }\n        function applyDefaultsAndAliases(obj, aliases, defaults, canLog = false) {\n            Object.keys(defaults).forEach(function(key) {\n                if (!hasKey(obj, key.split(\".\"))) {\n                    setKey(obj, key.split(\".\"), defaults[key]);\n                    if (canLog) defaulted[key] = true;\n                    (aliases[key] || []).forEach(function(x) {\n                        if (hasKey(obj, x.split(\".\"))) return;\n                        setKey(obj, x.split(\".\"), defaults[key]);\n                    });\n                }\n            });\n        }\n        function hasKey(obj, keys) {\n            let o = obj;\n            if (!configuration[\"dot-notation\"]) keys = [\n                keys.join(\".\")\n            ];\n            keys.slice(0, -1).forEach(function(key) {\n                o = o[key] || {};\n            });\n            const key = keys[keys.length - 1];\n            if (typeof o !== \"object\") return false;\n            else return key in o;\n        }\n        function setKey(obj, keys, value) {\n            let o = obj;\n            if (!configuration[\"dot-notation\"]) keys = [\n                keys.join(\".\")\n            ];\n            keys.slice(0, -1).forEach(function(key) {\n                // TODO(bcoe): in the next major version of yargs, switch to\n                // Object.create(null) for dot notation:\n                key = sanitizeKey(key);\n                if (typeof o === \"object\" && o[key] === undefined) {\n                    o[key] = {};\n                }\n                if (typeof o[key] !== \"object\" || Array.isArray(o[key])) {\n                    // ensure that o[key] is an array, and that the last item is an empty object.\n                    if (Array.isArray(o[key])) {\n                        o[key].push({});\n                    } else {\n                        o[key] = [\n                            o[key],\n                            {}\n                        ];\n                    }\n                    // we want to update the empty object at the end of the o[key] array, so set o to that object\n                    o = o[key][o[key].length - 1];\n                } else {\n                    o = o[key];\n                }\n            });\n            // TODO(bcoe): in the next major version of yargs, switch to\n            // Object.create(null) for dot notation:\n            const key = sanitizeKey(keys[keys.length - 1]);\n            const isTypeArray = checkAllAliases(keys.join(\".\"), flags.arrays);\n            const isValueArray = Array.isArray(value);\n            let duplicate = configuration[\"duplicate-arguments-array\"];\n            // nargs has higher priority than duplicate\n            if (!duplicate && checkAllAliases(key, flags.nargs)) {\n                duplicate = true;\n                if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {\n                    o[key] = undefined;\n                }\n            }\n            if (value === increment()) {\n                o[key] = increment(o[key]);\n            } else if (Array.isArray(o[key])) {\n                if (duplicate && isTypeArray && isValueArray) {\n                    o[key] = configuration[\"flatten-duplicate-arrays\"] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [\n                        o[key]\n                    ]).concat([\n                        value\n                    ]);\n                } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n                    o[key] = value;\n                } else {\n                    o[key] = o[key].concat([\n                        value\n                    ]);\n                }\n            } else if (o[key] === undefined && isTypeArray) {\n                o[key] = isValueArray ? value : [\n                    value\n                ];\n            } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {\n                o[key] = [\n                    o[key],\n                    value\n                ];\n            } else {\n                o[key] = value;\n            }\n        }\n        // extend the aliases list with inferred aliases.\n        function extendAliases(...args) {\n            args.forEach(function(obj) {\n                Object.keys(obj || {}).forEach(function(key) {\n                    // short-circuit if we've already added a key\n                    // to the aliases array, for example it might\n                    // exist in both 'opts.default' and 'opts.key'.\n                    if (flags.aliases[key]) return;\n                    flags.aliases[key] = [].concat(aliases[key] || []);\n                    // For \"--option-name\", also set argv.optionName\n                    flags.aliases[key].concat(key).forEach(function(x) {\n                        if (/-/.test(x) && configuration[\"camel-case-expansion\"]) {\n                            const c = (0,_string_utils_js__WEBPACK_IMPORTED_MODULE_2__.camelCase)(x);\n                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                                flags.aliases[key].push(c);\n                                newAliases[c] = true;\n                            }\n                        }\n                    });\n                    // For \"--optionName\", also set argv['option-name']\n                    flags.aliases[key].concat(key).forEach(function(x) {\n                        if (x.length > 1 && /[A-Z]/.test(x) && configuration[\"camel-case-expansion\"]) {\n                            const c = (0,_string_utils_js__WEBPACK_IMPORTED_MODULE_2__.decamelize)(x, \"-\");\n                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                                flags.aliases[key].push(c);\n                                newAliases[c] = true;\n                            }\n                        }\n                    });\n                    flags.aliases[key].forEach(function(x) {\n                        flags.aliases[x] = [\n                            key\n                        ].concat(flags.aliases[key].filter(function(y) {\n                            return x !== y;\n                        }));\n                    });\n                });\n            });\n        }\n        function checkAllAliases(key, flag) {\n            const toCheck = [].concat(flags.aliases[key] || [], key);\n            const keys = Object.keys(flag);\n            const setAlias = toCheck.find((key)=>keys.includes(key));\n            return setAlias ? flag[setAlias] : false;\n        }\n        function hasAnyFlag(key) {\n            const flagsKeys = Object.keys(flags);\n            const toCheck = [].concat(flagsKeys.map((k)=>flags[k]));\n            return toCheck.some(function(flag) {\n                return Array.isArray(flag) ? flag.includes(key) : flag[key];\n            });\n        }\n        function hasFlagsMatching(arg, ...patterns) {\n            const toCheck = [].concat(...patterns);\n            return toCheck.some(function(pattern) {\n                const match = arg.match(pattern);\n                return match && hasAnyFlag(match[1]);\n            });\n        }\n        // based on a simplified version of the short flag group parsing logic\n        function hasAllShortFlags(arg) {\n            // if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group\n            if (arg.match(negative) || !arg.match(/^-[^-]+/)) {\n                return false;\n            }\n            let hasAllFlags = true;\n            let next;\n            const letters = arg.slice(1).split(\"\");\n            for(let j = 0; j < letters.length; j++){\n                next = arg.slice(j + 2);\n                if (!hasAnyFlag(letters[j])) {\n                    hasAllFlags = false;\n                    break;\n                }\n                if (letters[j + 1] && letters[j + 1] === \"=\" || next === \"-\" || /[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\\W/)) {\n                    break;\n                }\n            }\n            return hasAllFlags;\n        }\n        function isUnknownOptionAsArg(arg) {\n            return configuration[\"unknown-options-as-args\"] && isUnknownOption(arg);\n        }\n        function isUnknownOption(arg) {\n            arg = arg.replace(/^-{3,}/, \"--\");\n            // ignore negative numbers\n            if (arg.match(negative)) {\n                return false;\n            }\n            // if this is a short option group and all of them are configured, it isn't unknown\n            if (hasAllShortFlags(arg)) {\n                return false;\n            }\n            // e.g. '--count=2'\n            const flagWithEquals = /^-+([^=]+?)=[\\s\\S]*$/;\n            // e.g. '-a' or '--arg'\n            const normalFlag = /^-+([^=]+?)$/;\n            // e.g. '-a-'\n            const flagEndingInHyphen = /^-+([^=]+?)-$/;\n            // e.g. '-abc123'\n            const flagEndingInDigits = /^-+([^=]+?\\d+)$/;\n            // e.g. '-a/usr/local'\n            const flagEndingInNonWordCharacters = /^-+([^=]+?)\\W+.*$/;\n            // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method\n            return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);\n        }\n        // make a best effort to pick a default value\n        // for an option based on name and type.\n        function defaultValue(key) {\n            if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {\n                return defaults[key];\n            } else {\n                return defaultForType(guessType(key));\n            }\n        }\n        // return a default value, given the type of a flag.,\n        function defaultForType(type) {\n            const def = {\n                [_yargs_parser_types_js__WEBPACK_IMPORTED_MODULE_1__.DefaultValuesForTypeKey.BOOLEAN]: true,\n                [_yargs_parser_types_js__WEBPACK_IMPORTED_MODULE_1__.DefaultValuesForTypeKey.STRING]: \"\",\n                [_yargs_parser_types_js__WEBPACK_IMPORTED_MODULE_1__.DefaultValuesForTypeKey.NUMBER]: undefined,\n                [_yargs_parser_types_js__WEBPACK_IMPORTED_MODULE_1__.DefaultValuesForTypeKey.ARRAY]: []\n            };\n            return def[type];\n        }\n        // given a flag, enforce a default type.\n        function guessType(key) {\n            let type = _yargs_parser_types_js__WEBPACK_IMPORTED_MODULE_1__.DefaultValuesForTypeKey.BOOLEAN;\n            if (checkAllAliases(key, flags.strings)) type = _yargs_parser_types_js__WEBPACK_IMPORTED_MODULE_1__.DefaultValuesForTypeKey.STRING;\n            else if (checkAllAliases(key, flags.numbers)) type = _yargs_parser_types_js__WEBPACK_IMPORTED_MODULE_1__.DefaultValuesForTypeKey.NUMBER;\n            else if (checkAllAliases(key, flags.bools)) type = _yargs_parser_types_js__WEBPACK_IMPORTED_MODULE_1__.DefaultValuesForTypeKey.BOOLEAN;\n            else if (checkAllAliases(key, flags.arrays)) type = _yargs_parser_types_js__WEBPACK_IMPORTED_MODULE_1__.DefaultValuesForTypeKey.ARRAY;\n            return type;\n        }\n        function isUndefined(num) {\n            return num === undefined;\n        }\n        // check user configuration settings for inconsistencies\n        function checkConfiguration() {\n            // count keys should not be set as array/narg\n            Object.keys(flags.counts).find((key)=>{\n                if (checkAllAliases(key, flags.arrays)) {\n                    error = Error(__(\"Invalid configuration: %s, opts.count excludes opts.array.\", key));\n                    return true;\n                } else if (checkAllAliases(key, flags.nargs)) {\n                    error = Error(__(\"Invalid configuration: %s, opts.count excludes opts.narg.\", key));\n                    return true;\n                }\n                return false;\n            });\n        }\n        return {\n            aliases: Object.assign({}, flags.aliases),\n            argv: Object.assign(argvReturn, argv),\n            configuration: configuration,\n            defaulted: Object.assign({}, defaulted),\n            error: error,\n            newAliases: Object.assign({}, newAliases)\n        };\n    }\n}\n// if any aliases reference each other, we should\n// merge them together.\nfunction combineAliases(aliases) {\n    const aliasArrays = [];\n    const combined = Object.create(null);\n    let change = true;\n    // turn alias lookup hash {key: ['alias1', 'alias2']} into\n    // a simple array ['key', 'alias1', 'alias2']\n    Object.keys(aliases).forEach(function(key) {\n        aliasArrays.push([].concat(aliases[key], key));\n    });\n    // combine arrays until zero changes are\n    // made in an iteration.\n    while(change){\n        change = false;\n        for(let i = 0; i < aliasArrays.length; i++){\n            for(let ii = i + 1; ii < aliasArrays.length; ii++){\n                const intersect = aliasArrays[i].filter(function(v) {\n                    return aliasArrays[ii].indexOf(v) !== -1;\n                });\n                if (intersect.length) {\n                    aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);\n                    aliasArrays.splice(ii, 1);\n                    change = true;\n                    break;\n                }\n            }\n        }\n    }\n    // map arrays back to the hash-lookup (de-dupe while\n    // we're at it).\n    aliasArrays.forEach(function(aliasArray) {\n        aliasArray = aliasArray.filter(function(v, i, self) {\n            return self.indexOf(v) === i;\n        });\n        const lastAlias = aliasArray.pop();\n        if (lastAlias !== undefined && typeof lastAlias === \"string\") {\n            combined[lastAlias] = aliasArray;\n        }\n    });\n    return combined;\n}\n// this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\nfunction increment(orig) {\n    return orig !== undefined ? orig + 1 : 1;\n}\n// TODO(bcoe): in the next major version of yargs, switch to\n// Object.create(null) for dot notation:\nfunction sanitizeKey(key) {\n    if (key === \"__proto__\") return \"___proto___\";\n    return key;\n}\nfunction stripQuotes(val) {\n    return typeof val === \"string\" && (val[0] === \"'\" || val[0] === '\"') && val[val.length - 1] === val[0] ? val.substring(1, val.length - 1) : val;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveWFyZ3MtcGFyc2VyL2J1aWxkL2xpYi95YXJncy1wYXJzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7O0NBSUMsR0FDNEQ7QUFDSztBQUNTO0FBQzNFLElBQUlLO0FBQ0csTUFBTUM7SUFDVEMsWUFBWUMsTUFBTSxDQUFFO1FBQ2hCSCxRQUFRRztJQUNaO0lBQ0FDLE1BQU1DLFNBQVMsRUFBRUMsT0FBTyxFQUFFO1FBQ3RCLE1BQU1DLE9BQU9DLE9BQU9DLE1BQU0sQ0FBQztZQUN2QkMsT0FBT0M7WUFDUEMsT0FBT0Q7WUFDUEUsU0FBU0Y7WUFDVEcsUUFBUUg7WUFDUkksZUFBZUo7WUFDZkssZUFBZUw7WUFDZk0sUUFBUU47WUFDUk8sT0FBT1A7WUFDUFEsU0FBU1I7WUFDVFMsV0FBV1Q7WUFDWFUsTUFBTVY7WUFDTlcsV0FBV1g7WUFDWFksUUFBUVo7WUFDUmEsUUFBUWI7WUFDUmMsSUFBSWQ7WUFDSmUsS0FBS2Y7UUFDVCxHQUFHTDtRQUNILGlEQUFpRDtRQUNqRCxzQkFBc0I7UUFDdEIsTUFBTXFCLE9BQU9oQywwRUFBaUJBLENBQUNVO1FBQy9CLHVFQUF1RTtRQUN2RSx5RUFBeUU7UUFDekUsTUFBTXVCLGdCQUFnQixPQUFPdkIsY0FBYztRQUMzQywrREFBK0Q7UUFDL0QsTUFBTXdCLFVBQVVDLGVBQWV0QixPQUFPQyxNQUFNLENBQUNELE9BQU91QixNQUFNLENBQUMsT0FBT3hCLEtBQUtHLEtBQUs7UUFDNUUsTUFBTU0sZ0JBQWdCUixPQUFPQyxNQUFNLENBQUM7WUFDaEMsb0JBQW9CO1lBQ3BCLHdCQUF3QjtZQUN4QixrQkFBa0I7WUFDbEIsZ0JBQWdCO1lBQ2hCLDZCQUE2QjtZQUM3Qiw0QkFBNEI7WUFDNUIsaUJBQWlCO1lBQ2pCLHNCQUFzQjtZQUN0QixzQkFBc0I7WUFDdEIsbUJBQW1CO1lBQ25CLGlCQUFpQjtZQUNqQiw0QkFBNEI7WUFDNUIsY0FBYztZQUNkLHVCQUF1QjtZQUN2Qix1QkFBdUI7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QUFZRixXQUFXdkosR0FBRztRQUNoQyxJQUFJeUosY0FBY3pNLGFBQWEsT0FBT3lNLGNBQWMsVUFBVTtZQUMxRE4sUUFBUSxDQUFDTSxVQUFVLEdBQUdGO1FBQzFCO0lBQ0o7SUFDQSxPQUFPSjtBQUNYO0FBQ0Esc0VBQXNFO0FBQ3RFLDBDQUEwQztBQUMxQyxnREFBZ0Q7QUFDaEQsU0FBU3ZFLFVBQVU4RSxJQUFJO0lBQ25CLE9BQU9BLFNBQVMxTSxZQUFZME0sT0FBTyxJQUFJO0FBQzNDO0FBQ0EsNERBQTREO0FBQzVELHdDQUF3QztBQUN4QyxTQUFTekMsWUFBWWxKLEdBQUc7SUFDcEIsSUFBSUEsUUFBUSxhQUNSLE9BQU87SUFDWCxPQUFPQTtBQUNYO0FBQ0EsU0FBUzJHLFlBQVliLEdBQUc7SUFDcEIsT0FBTyxPQUFRQSxRQUFRLFlBQ2xCQSxDQUFBQSxHQUFHLENBQUMsRUFBRSxLQUFLLE9BQU9BLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRSxLQUNoQ0EsR0FBRyxDQUFDQSxJQUFJL0MsTUFBTSxHQUFHLEVBQUUsS0FBSytDLEdBQUcsQ0FBQyxFQUFFLEdBQzVCQSxJQUFJeUMsU0FBUyxDQUFDLEdBQUd6QyxJQUFJL0MsTUFBTSxHQUFHLEtBQzlCK0M7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL215YXBwLy4vbm9kZV9tb2R1bGVzL3lhcmdzLXBhcnNlci9idWlsZC9saWIveWFyZ3MtcGFyc2VyLmpzPzQ0MTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2LCBDb250cmlidXRvcnNcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBJU0NcbiAqL1xuaW1wb3J0IHsgdG9rZW5pemVBcmdTdHJpbmcgfSBmcm9tICcuL3Rva2VuaXplLWFyZy1zdHJpbmcuanMnO1xuaW1wb3J0IHsgRGVmYXVsdFZhbHVlc0ZvclR5cGVLZXkgfSBmcm9tICcuL3lhcmdzLXBhcnNlci10eXBlcy5qcyc7XG5pbXBvcnQgeyBjYW1lbENhc2UsIGRlY2FtZWxpemUsIGxvb2tzTGlrZU51bWJlciB9IGZyb20gJy4vc3RyaW5nLXV0aWxzLmpzJztcbmxldCBtaXhpbjtcbmV4cG9ydCBjbGFzcyBZYXJnc1BhcnNlciB7XG4gICAgY29uc3RydWN0b3IoX21peGluKSB7XG4gICAgICAgIG1peGluID0gX21peGluO1xuICAgIH1cbiAgICBwYXJzZShhcmdzSW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgYWxpYXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFycmF5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBib29sZWFuOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb25maWc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbmZpZ09iamVjdHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvZXJjZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY291bnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGVudlByZWZpeDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbmFyZzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbm9ybWFsaXplOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdHJpbmc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG51bWJlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX186IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGtleTogdW5kZWZpbmVkXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICAvLyBhbGxvdyBhIHN0cmluZyBhcmd1bWVudCB0byBiZSBwYXNzZWQgaW4gcmF0aGVyXG4gICAgICAgIC8vIHRoYW4gYW4gYXJndiBhcnJheS5cbiAgICAgICAgY29uc3QgYXJncyA9IHRva2VuaXplQXJnU3RyaW5nKGFyZ3NJbnB1dCk7XG4gICAgICAgIC8vIHRva2VuaXplQXJnU3RyaW5nIGFkZHMgZXh0cmEgcXVvdGVzIHRvIGFyZ3MgaWYgYXJnc0lucHV0IGlzIGEgc3RyaW5nXG4gICAgICAgIC8vIG9ubHkgc3RyaXAgdGhvc2UgZXh0cmEgcXVvdGVzIGluIHByb2Nlc3NWYWx1ZSBpZiBhcmdzSW5wdXQgaXMgYSBzdHJpbmdcbiAgICAgICAgY29uc3QgaW5wdXRJc1N0cmluZyA9IHR5cGVvZiBhcmdzSW5wdXQgPT09ICdzdHJpbmcnO1xuICAgICAgICAvLyBhbGlhc2VzIG1pZ2h0IGhhdmUgdHJhbnNpdGl2ZSByZWxhdGlvbnNoaXBzLCBub3JtYWxpemUgdGhpcy5cbiAgICAgICAgY29uc3QgYWxpYXNlcyA9IGNvbWJpbmVBbGlhc2VzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgb3B0cy5hbGlhcykpO1xuICAgICAgICBjb25zdCBjb25maWd1cmF0aW9uID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAnYm9vbGVhbi1uZWdhdGlvbic6IHRydWUsXG4gICAgICAgICAgICAnY2FtZWwtY2FzZS1leHBhbnNpb24nOiB0cnVlLFxuICAgICAgICAgICAgJ2NvbWJpbmUtYXJyYXlzJzogZmFsc2UsXG4gICAgICAgICAgICAnZG90LW5vdGF0aW9uJzogdHJ1ZSxcbiAgICAgICAgICAgICdkdXBsaWNhdGUtYXJndW1lbnRzLWFycmF5JzogdHJ1ZSxcbiAgICAgICAgICAgICdmbGF0dGVuLWR1cGxpY2F0ZS1hcnJheXMnOiB0cnVlLFxuICAgICAgICAgICAgJ2dyZWVkeS1hcnJheXMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhbHQtYXQtbm9uLW9wdGlvbic6IGZhbHNlLFxuICAgICAgICAgICAgJ25hcmdzLWVhdHMtb3B0aW9ucyc6IGZhbHNlLFxuICAgICAgICAgICAgJ25lZ2F0aW9uLXByZWZpeCc6ICduby0nLFxuICAgICAgICAgICAgJ3BhcnNlLW51bWJlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ3BhcnNlLXBvc2l0aW9uYWwtbnVtYmVycyc6IHRydWUsXG4gICAgICAgICAgICAncG9wdWxhdGUtLSc6IGZhbHNlLFxuICAgICAgICAgICAgJ3NldC1wbGFjZWhvbGRlci1rZXknOiBmYWxzZSxcbiAgICAgICAgICAgICdzaG9ydC1vcHRpb24tZ3JvdXBzJzogdHJ1ZSxcbiAgICAgICAgICAgICdzdHJpcC1hbGlhc2VkJzogZmFsc2UsXG4gICAgICAgICAgICAnc3RyaXAtZGFzaGVkJzogZmFsc2UsXG4gICAgICAgICAgICAndW5rbm93bi1vcHRpb25zLWFzLWFyZ3MnOiBmYWxzZVxuICAgICAgICB9LCBvcHRzLmNvbmZpZ3VyYXRpb24pO1xuICAgICAgICBjb25zdCBkZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgb3B0cy5kZWZhdWx0KTtcbiAgICAgICAgY29uc3QgY29uZmlnT2JqZWN0cyA9IG9wdHMuY29uZmlnT2JqZWN0cyB8fCBbXTtcbiAgICAgICAgY29uc3QgZW52UHJlZml4ID0gb3B0cy5lbnZQcmVmaXg7XG4gICAgICAgIGNvbnN0IG5vdEZsYWdzT3B0aW9uID0gY29uZmlndXJhdGlvblsncG9wdWxhdGUtLSddO1xuICAgICAgICBjb25zdCBub3RGbGFnc0FyZ3YgPSBub3RGbGFnc09wdGlvbiA/ICctLScgOiAnXyc7XG4gICAgICAgIGNvbnN0IG5ld0FsaWFzZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBjb25zdCBkZWZhdWx0ZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAvLyBhbGxvdyBhIGkxOG4gaGFuZGxlciB0byBiZSBwYXNzZWQgaW4sIGRlZmF1bHQgdG8gYSBmYWtlIG9uZSAodXRpbC5mb3JtYXQpLlxuICAgICAgICBjb25zdCBfXyA9IG9wdHMuX18gfHwgbWl4aW4uZm9ybWF0O1xuICAgICAgICBjb25zdCBmbGFncyA9IHtcbiAgICAgICAgICAgIGFsaWFzZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICBhcnJheXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICBib29sczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgIHN0cmluZ3M6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICBudW1iZXJzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgY291bnRzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgbm9ybWFsaXplOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgY29uZmlnczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgIG5hcmdzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgY29lcmNpb25zOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAga2V5czogW11cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbmVnYXRpdmUgPSAvXi0oWzAtOV0rKFxcLlswLTldKyk/fFxcLlswLTldKykkLztcbiAgICAgICAgY29uc3QgbmVnYXRlZEJvb2xlYW4gPSBuZXcgUmVnRXhwKCdeLS0nICsgY29uZmlndXJhdGlvblsnbmVnYXRpb24tcHJlZml4J10gKyAnKC4rKScpO1xuICAgICAgICBbXS5jb25jYXQob3B0cy5hcnJheSB8fCBbXSkuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdHlwZW9mIG9wdCA9PT0gJ29iamVjdCcgPyBvcHQua2V5IDogb3B0O1xuICAgICAgICAgICAgLy8gYXNzaWduIHRvIGZsYWdzW2Jvb2xzfHN0cmluZ3N8bnVtYmVyc11cbiAgICAgICAgICAgIGNvbnN0IGFzc2lnbm1lbnQgPSBPYmplY3Qua2V5cyhvcHQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyYXlGbGFnS2V5cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogJ2Jvb2xzJyxcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nOiAnc3RyaW5ncycsXG4gICAgICAgICAgICAgICAgICAgIG51bWJlcjogJ251bWJlcnMnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlGbGFnS2V5c1trZXldO1xuICAgICAgICAgICAgfSkuZmlsdGVyKEJvb2xlYW4pLnBvcCgpO1xuICAgICAgICAgICAgLy8gYXNzaWduIGtleSB0byBiZSBjb2VyY2VkXG4gICAgICAgICAgICBpZiAoYXNzaWdubWVudCkge1xuICAgICAgICAgICAgICAgIGZsYWdzW2Fzc2lnbm1lbnRdW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmxhZ3MuYXJyYXlzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgZmxhZ3Mua2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBbXS5jb25jYXQob3B0cy5ib29sZWFuIHx8IFtdKS5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBmbGFncy5ib29sc1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIGZsYWdzLmtleXMucHVzaChrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgW10uY29uY2F0KG9wdHMuc3RyaW5nIHx8IFtdKS5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBmbGFncy5zdHJpbmdzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgZmxhZ3Mua2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBbXS5jb25jYXQob3B0cy5udW1iZXIgfHwgW10pLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGZsYWdzLm51bWJlcnNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICBmbGFncy5rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIFtdLmNvbmNhdChvcHRzLmNvdW50IHx8IFtdKS5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBmbGFncy5jb3VudHNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICBmbGFncy5rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIFtdLmNvbmNhdChvcHRzLm5vcm1hbGl6ZSB8fCBbXSkuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgZmxhZ3Mubm9ybWFsaXplW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgZmxhZ3Mua2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMubmFyZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG9wdHMubmFyZykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MubmFyZ3Nba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBmbGFncy5rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdHMuY29lcmNlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMob3B0cy5jb2VyY2UpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY29lcmNpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3Mua2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmNvbmZpZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdHMuY29uZmlnKSB8fCB0eXBlb2Ygb3B0cy5jb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIFtdLmNvbmNhdChvcHRzLmNvbmZpZykuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFncy5jb25maWdzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdHMuY29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG9wdHMuY29uZmlnKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY29uZmlnc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgYSBsb29rdXAgdGFibGUgdGhhdCB0YWtlcyBpbnRvIGFjY291bnQgYWxsXG4gICAgICAgIC8vIGNvbWJpbmF0aW9ucyBvZiBhbGlhc2VzOiB7ZjogWydmb28nXSwgZm9vOiBbJ2YnXX1cbiAgICAgICAgZXh0ZW5kQWxpYXNlcyhvcHRzLmtleSwgYWxpYXNlcywgb3B0cy5kZWZhdWx0LCBmbGFncy5hcnJheXMpO1xuICAgICAgICAvLyBhcHBseSBkZWZhdWx0IHZhbHVlcyB0byBhbGwgYWxpYXNlcy5cbiAgICAgICAgT2JqZWN0LmtleXMoZGVmYXVsdHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgKGZsYWdzLmFsaWFzZXNba2V5XSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0c1thbGlhc10gPSBkZWZhdWx0c1trZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgICAgICBjaGVja0NvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgbGV0IG5vdEZsYWdzID0gW107XG4gICAgICAgIGNvbnN0IGFyZ3YgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHsgXzogW10gfSk7XG4gICAgICAgIC8vIFRPRE8oYmNvZSk6IGZvciB0aGUgZmlyc3QgcGFzcyBhdCByZW1vdmluZyBvYmplY3QgcHJvdG90eXBlICB3ZSBkaWRuJ3RcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBwcm90b3R5cGVzIGZyb20gb2JqZWN0cyByZXR1cm5lZCBieSB0aGlzIEFQSSwgd2UgbWlnaHQgd2FudFxuICAgICAgICAvLyB0byBncmFkdWFsbHkgbW92ZSB0b3dhcmRzIGRvaW5nIHNvLlxuICAgICAgICBjb25zdCBhcmd2UmV0dXJuID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYXJnID0gYXJnc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHRydW5jYXRlZEFyZyA9IGFyZy5yZXBsYWNlKC9eLXszLH0vLCAnLS0tJyk7XG4gICAgICAgICAgICBsZXQgYnJva2VuO1xuICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgIGxldCBsZXR0ZXJzO1xuICAgICAgICAgICAgbGV0IG07XG4gICAgICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgICAgIC8vIGFueSB1bmtub3duIG9wdGlvbiAoZXhjZXB0IGZvciBlbmQtb2Ytb3B0aW9ucywgXCItLVwiKVxuICAgICAgICAgICAgaWYgKGFyZyAhPT0gJy0tJyAmJiAvXi0vLnRlc3QoYXJnKSAmJiBpc1Vua25vd25PcHRpb25Bc0FyZyhhcmcpKSB7XG4gICAgICAgICAgICAgICAgcHVzaFBvc2l0aW9uYWwoYXJnKTtcbiAgICAgICAgICAgICAgICAvLyAtLS0sIC0tLT0sIC0tLS0sIGV0YyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRydW5jYXRlZEFyZy5tYXRjaCgvXi0tLSsoPXwkKS8pKSB7XG4gICAgICAgICAgICAgICAgLy8gb3B0aW9ucyB3aXRob3V0IGtleSBuYW1lIGFyZSBpbnZhbGlkLlxuICAgICAgICAgICAgICAgIHB1c2hQb3NpdGlvbmFsKGFyZyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgLy8gLS0gc2VwYXJhdGVkIGJ5ID1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZy5tYXRjaCgvXi0tLis9LykgfHwgKCFjb25maWd1cmF0aW9uWydzaG9ydC1vcHRpb24tZ3JvdXBzJ10gJiYgYXJnLm1hdGNoKC9eLS4rPS8pKSkge1xuICAgICAgICAgICAgICAgIC8vIFVzaW5nIFtcXHNcXFNdIGluc3RlYWQgb2YgLiBiZWNhdXNlIGpzIGRvZXNuJ3Qgc3VwcG9ydCB0aGVcbiAgICAgICAgICAgICAgICAvLyAnZG90YWxsJyByZWdleCBtb2RpZmllci4gU2VlOlxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEwNjgzMDgvMTMyMTZcbiAgICAgICAgICAgICAgICBtID0gYXJnLm1hdGNoKC9eLS0/KFtePV0rKT0oW1xcc1xcU10qKSQvKTtcbiAgICAgICAgICAgICAgICAvLyBhcnJheXMgZm9ybWF0ID0gJy0tZj1hIGIgYydcbiAgICAgICAgICAgICAgICBpZiAobSAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KG0pICYmIG0ubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrQWxsQWxpYXNlcyhtWzFdLCBmbGFncy5hcnJheXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gZWF0QXJyYXkoaSwgbVsxXSwgYXJncywgbVsyXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2tBbGxBbGlhc2VzKG1bMV0sIGZsYWdzLm5hcmdzKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5hcmdzIGZvcm1hdCA9ICctLWY9bW9ua2V5IHdhc2hpbmcgY2F0J1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGVhdE5hcmdzKGksIG1bMV0sIGFyZ3MsIG1bMl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXJnKG1bMV0sIG1bMl0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXJnLm1hdGNoKG5lZ2F0ZWRCb29sZWFuKSAmJiBjb25maWd1cmF0aW9uWydib29sZWFuLW5lZ2F0aW9uJ10pIHtcbiAgICAgICAgICAgICAgICBtID0gYXJnLm1hdGNoKG5lZ2F0ZWRCb29sZWFuKTtcbiAgICAgICAgICAgICAgICBpZiAobSAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KG0pICYmIG0ubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gbVsxXTtcbiAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYXJyYXlzKSA/IFtmYWxzZV0gOiBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIC0tIHNlcGFyYXRlZCBieSBzcGFjZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZy5tYXRjaCgvXi0tLisvKSB8fCAoIWNvbmZpZ3VyYXRpb25bJ3Nob3J0LW9wdGlvbi1ncm91cHMnXSAmJiBhcmcubWF0Y2goL14tW14tXSsvKSkpIHtcbiAgICAgICAgICAgICAgICBtID0gYXJnLm1hdGNoKC9eLS0/KC4rKS8pO1xuICAgICAgICAgICAgICAgIGlmIChtICE9PSBudWxsICYmIEFycmF5LmlzQXJyYXkobSkgJiYgbS5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBtWzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYXJyYXlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgZm9ybWF0ID0gJy0tZm9vIGEgYiBjJ1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGVhdEFycmF5KGksIGtleSwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MubmFyZ3MpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmFyZ3MgZm9ybWF0ID0gJy0tZm9vIGEgYiBjJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHRydXRoeSBldmVuIGlmOiBmbGFncy5uYXJnc1trZXldID09PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gZWF0TmFyZ3MoaSwga2V5LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBhcmdzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQgJiYgKCFuZXh0Lm1hdGNoKC9eLS8pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5tYXRjaChuZWdhdGl2ZSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmJvb2xzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5jb3VudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoL14odHJ1ZXxmYWxzZSkkLy50ZXN0KG5leHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgZGVmYXVsdFZhbHVlKGtleSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRvdC1ub3RhdGlvbiBmbGFnIHNlcGFyYXRlZCBieSAnPScuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmcubWF0Y2goL14tLlxcLi4rPS8pKSB7XG4gICAgICAgICAgICAgICAgbSA9IGFyZy5tYXRjaCgvXi0oW149XSspPShbXFxzXFxTXSopJC8pO1xuICAgICAgICAgICAgICAgIGlmIChtICE9PSBudWxsICYmIEFycmF5LmlzQXJyYXkobSkgJiYgbS5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgICAgICAgICBzZXRBcmcobVsxXSwgbVsyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRvdC1ub3RhdGlvbiBmbGFnIHNlcGFyYXRlZCBieSBzcGFjZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZy5tYXRjaCgvXi0uXFwuLisvKSAmJiAhYXJnLm1hdGNoKG5lZ2F0aXZlKSkge1xuICAgICAgICAgICAgICAgIG5leHQgPSBhcmdzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBtID0gYXJnLm1hdGNoKC9eLSguXFwuLispLyk7XG4gICAgICAgICAgICAgICAgaWYgKG0gIT09IG51bGwgJiYgQXJyYXkuaXNBcnJheShtKSAmJiBtLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG1bMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQgJiYgIW5leHQubWF0Y2goL14tLykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5ib29scykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5jb3VudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEFyZyhrZXksIGRlZmF1bHRWYWx1ZShrZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZy5tYXRjaCgvXi1bXi1dKy8pICYmICFhcmcubWF0Y2gobmVnYXRpdmUpKSB7XG4gICAgICAgICAgICAgICAgbGV0dGVycyA9IGFyZy5zbGljZSgxLCAtMSkuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIGJyb2tlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGV0dGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gYXJnLnNsaWNlKGogKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxldHRlcnNbaiArIDFdICYmIGxldHRlcnNbaiArIDFdID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXJnLnNsaWNlKGogKyAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGxldHRlcnNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYXJyYXlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IGZvcm1hdCA9ICctZj1hIGIgYydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gZWF0QXJyYXkoaSwga2V5LCBhcmdzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5uYXJncykgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmFyZ3MgZm9ybWF0ID0gJy1mPW1vbmtleSB3YXNoaW5nIGNhdCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gZWF0TmFyZ3MoaSwga2V5LCBhcmdzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicm9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGxldHRlcnNbal0sIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBsZXR0ZXIgaXMgYW4gYWxwaGFiZXRpYyBjaGFyYWN0ZXIgYW5kIG5leHQgdmFsdWUgaXMgYSBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9bQS1aYS16XS8udGVzdChsZXR0ZXJzW2pdKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgL14tP1xcZCsoXFwuXFxkKik/KGUtP1xcZCspPyQvLnRlc3QobmV4dCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrQWxsQWxpYXNlcyhuZXh0LCBmbGFncy5ib29scykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcobGV0dGVyc1tqXSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicm9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxldHRlcnNbaiArIDFdICYmIGxldHRlcnNbaiArIDFdLm1hdGNoKC9cXFcvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGxldHRlcnNbal0sIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGxldHRlcnNbal0sIGRlZmF1bHRWYWx1ZShsZXR0ZXJzW2pdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2V5ID0gYXJnLnNsaWNlKC0xKVswXTtcbiAgICAgICAgICAgICAgICBpZiAoIWJyb2tlbiAmJiBrZXkgIT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYXJyYXlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgZm9ybWF0ID0gJy1mIGEgYiBjJ1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGVhdEFycmF5KGksIGtleSwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MubmFyZ3MpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmFyZ3MgZm9ybWF0ID0gJy1mIGEgYiBjJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHRydXRoeSBldmVuIGlmOiBmbGFncy5uYXJnc1trZXldID09PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gZWF0TmFyZ3MoaSwga2V5LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBhcmdzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQgJiYgKCEvXigtfC0tKVteLV0vLnRlc3QobmV4dCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Lm1hdGNoKG5lZ2F0aXZlKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYm9vbHMpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmNvdW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvXih0cnVlfGZhbHNlKSQvLnRlc3QobmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBkZWZhdWx0VmFsdWUoa2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmcubWF0Y2goL14tWzAtOV0kLykgJiZcbiAgICAgICAgICAgICAgICBhcmcubWF0Y2gobmVnYXRpdmUpICYmXG4gICAgICAgICAgICAgICAgY2hlY2tBbGxBbGlhc2VzKGFyZy5zbGljZSgxKSwgZmxhZ3MuYm9vbHMpKSB7XG4gICAgICAgICAgICAgICAgLy8gc2luZ2xlLWRpZ2l0IGJvb2xlYW4gYWxpYXMsIGUuZzogeGFyZ3MgLTBcbiAgICAgICAgICAgICAgICBrZXkgPSBhcmcuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgZGVmYXVsdFZhbHVlKGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXJnID09PSAnLS0nKSB7XG4gICAgICAgICAgICAgICAgbm90RmxhZ3MgPSBhcmdzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZ3VyYXRpb25bJ2hhbHQtYXQtbm9uLW9wdGlvbiddKSB7XG4gICAgICAgICAgICAgICAgbm90RmxhZ3MgPSBhcmdzLnNsaWNlKGkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHVzaFBvc2l0aW9uYWwoYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBvcmRlciBvZiBwcmVjZWRlbmNlOlxuICAgICAgICAvLyAxLiBjb21tYW5kIGxpbmUgYXJnXG4gICAgICAgIC8vIDIuIHZhbHVlIGZyb20gZW52IHZhclxuICAgICAgICAvLyAzLiB2YWx1ZSBmcm9tIGNvbmZpZyBmaWxlXG4gICAgICAgIC8vIDQuIHZhbHVlIGZyb20gY29uZmlnIG9iamVjdHNcbiAgICAgICAgLy8gNS4gY29uZmlndXJlZCBkZWZhdWx0IHZhbHVlXG4gICAgICAgIGFwcGx5RW52VmFycyhhcmd2LCB0cnVlKTsgLy8gc3BlY2lhbCBjYXNlOiBjaGVjayBlbnYgdmFycyB0aGF0IHBvaW50IHRvIGNvbmZpZyBmaWxlXG4gICAgICAgIGFwcGx5RW52VmFycyhhcmd2LCBmYWxzZSk7XG4gICAgICAgIHNldENvbmZpZyhhcmd2KTtcbiAgICAgICAgc2V0Q29uZmlnT2JqZWN0cygpO1xuICAgICAgICBhcHBseURlZmF1bHRzQW5kQWxpYXNlcyhhcmd2LCBmbGFncy5hbGlhc2VzLCBkZWZhdWx0cywgdHJ1ZSk7XG4gICAgICAgIGFwcGx5Q29lcmNpb25zKGFyZ3YpO1xuICAgICAgICBpZiAoY29uZmlndXJhdGlvblsnc2V0LXBsYWNlaG9sZGVyLWtleSddKVxuICAgICAgICAgICAgc2V0UGxhY2Vob2xkZXJLZXlzKGFyZ3YpO1xuICAgICAgICAvLyBmb3IgYW55IGNvdW50cyBlaXRoZXIgbm90IGluIGFyZ3Mgb3Igd2l0aG91dCBhbiBleHBsaWNpdCBkZWZhdWx0LCBzZXQgdG8gMFxuICAgICAgICBPYmplY3Qua2V5cyhmbGFncy5jb3VudHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKCFoYXNLZXkoYXJndiwga2V5LnNwbGl0KCcuJykpKVxuICAgICAgICAgICAgICAgIHNldEFyZyhrZXksIDApO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gJy0tJyBkZWZhdWx0cyB0byB1bmRlZmluZWQuXG4gICAgICAgIGlmIChub3RGbGFnc09wdGlvbiAmJiBub3RGbGFncy5sZW5ndGgpXG4gICAgICAgICAgICBhcmd2W25vdEZsYWdzQXJndl0gPSBbXTtcbiAgICAgICAgbm90RmxhZ3MuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBhcmd2W25vdEZsYWdzQXJndl0ucHVzaChrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb25bJ2NhbWVsLWNhc2UtZXhwYW5zaW9uJ10gJiYgY29uZmlndXJhdGlvblsnc3RyaXAtZGFzaGVkJ10pIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGFyZ3YpLmZpbHRlcihrZXkgPT4ga2V5ICE9PSAnLS0nICYmIGtleS5pbmNsdWRlcygnLScpKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGFyZ3Zba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWd1cmF0aW9uWydzdHJpcC1hbGlhc2VkJ10pIHtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIFtdLmNvbmNhdCguLi5PYmplY3Qua2V5cyhhbGlhc2VzKS5tYXAoayA9PiBhbGlhc2VzW2tdKSkuZm9yRWFjaChhbGlhcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb25bJ2NhbWVsLWNhc2UtZXhwYW5zaW9uJ10gJiYgYWxpYXMuaW5jbHVkZXMoJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXJndlthbGlhcy5zcGxpdCgnLicpLm1hcChwcm9wID0+IGNhbWVsQ2FzZShwcm9wKSkuam9pbignLicpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIGFyZ3ZbYWxpYXNdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHVzaCBhcmd1bWVudCBpbnRvIHBvc2l0aW9uYWwgYXJyYXksIGFwcGx5aW5nIG51bWVyaWMgY29lcmNpb246XG4gICAgICAgIGZ1bmN0aW9uIHB1c2hQb3NpdGlvbmFsKGFyZykge1xuICAgICAgICAgICAgY29uc3QgbWF5YmVDb2VyY2VkTnVtYmVyID0gbWF5YmVDb2VyY2VOdW1iZXIoJ18nLCBhcmcpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtYXliZUNvZXJjZWROdW1iZXIgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBtYXliZUNvZXJjZWROdW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgYXJndi5fLnB1c2gobWF5YmVDb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBob3cgbWFueSBhcmd1bWVudHMgc2hvdWxkIHdlIGNvbnN1bWUsIGJhc2VkXG4gICAgICAgIC8vIG9uIHRoZSBuYXJncyBvcHRpb24/XG4gICAgICAgIGZ1bmN0aW9uIGVhdE5hcmdzKGksIGtleSwgYXJncywgYXJnQWZ0ZXJFcXVhbFNpZ24pIHtcbiAgICAgICAgICAgIGxldCBpaTtcbiAgICAgICAgICAgIGxldCB0b0VhdCA9IGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLm5hcmdzKTtcbiAgICAgICAgICAgIC8vIE5hTiBoYXMgYSBzcGVjaWFsIG1lYW5pbmcgZm9yIHRoZSBhcnJheSB0eXBlLCBpbmRpY2F0aW5nIHRoYXQgb25lIG9yXG4gICAgICAgICAgICAvLyBtb3JlIHZhbHVlcyBhcmUgZXhwZWN0ZWQuXG4gICAgICAgICAgICB0b0VhdCA9IHR5cGVvZiB0b0VhdCAhPT0gJ251bWJlcicgfHwgaXNOYU4odG9FYXQpID8gMSA6IHRvRWF0O1xuICAgICAgICAgICAgaWYgKHRvRWF0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChhcmdBZnRlckVxdWFsU2lnbikpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBFcnJvcihfXygnQXJndW1lbnQgdW5leHBlY3RlZCBmb3I6ICVzJywga2V5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldEFyZyhrZXksIGRlZmF1bHRWYWx1ZShrZXkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhdmFpbGFibGUgPSBpc1VuZGVmaW5lZChhcmdBZnRlckVxdWFsU2lnbikgPyAwIDogMTtcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uWyduYXJncy1lYXRzLW9wdGlvbnMnXSkge1xuICAgICAgICAgICAgICAgIC8vIGNsYXNzaWMgYmVoYXZpb3IsIHlhcmdzIGVhdHMgcG9zaXRpb25hbCBhbmQgZGFzaCBhcmd1bWVudHMuXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIC0gKGkgKyAxKSArIGF2YWlsYWJsZSA8IHRvRWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gRXJyb3IoX18oJ05vdCBlbm91Z2ggYXJndW1lbnRzIGZvbGxvd2luZzogJXMnLCBrZXkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlID0gdG9FYXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBuYXJncyB3aWxsIG5vdCBjb25zdW1lIGZsYWcgYXJndW1lbnRzLCBlLmcuLCAtYWJjLCAtLWZvbyxcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGVybWluYXRlcyB3aGVuIG9uZSBpcyBvYnNlcnZlZC5cbiAgICAgICAgICAgICAgICBmb3IgKGlpID0gaSArIDE7IGlpIDwgYXJncy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmdzW2lpXS5tYXRjaCgvXi1bXjAtOV0vKSB8fCBhcmdzW2lpXS5tYXRjaChuZWdhdGl2ZSkgfHwgaXNVbmtub3duT3B0aW9uQXNBcmcoYXJnc1tpaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlKys7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXZhaWxhYmxlIDwgdG9FYXQpXG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gRXJyb3IoX18oJ05vdCBlbm91Z2ggYXJndW1lbnRzIGZvbGxvd2luZzogJXMnLCBrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb25zdW1lZCA9IE1hdGgubWluKGF2YWlsYWJsZSwgdG9FYXQpO1xuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChhcmdBZnRlckVxdWFsU2lnbikgJiYgY29uc3VtZWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgYXJnQWZ0ZXJFcXVhbFNpZ24pO1xuICAgICAgICAgICAgICAgIGNvbnN1bWVkLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGlpID0gaSArIDE7IGlpIDwgKGNvbnN1bWVkICsgaSArIDEpOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgYXJnc1tpaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChpICsgY29uc3VtZWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGFuIG9wdGlvbiBpcyBhbiBhcnJheSwgZWF0IGFsbCBub24taHlwaGVuYXRlZCBhcmd1bWVudHNcbiAgICAgICAgLy8gZm9sbG93aW5nIGl0Li4uIFlVTSFcbiAgICAgICAgLy8gZS5nLiwgLS1mb28gYXBwbGUgYmFuYW5hIGNhdCBiZWNvbWVzIFtcImFwcGxlXCIsIFwiYmFuYW5hXCIsIFwiY2F0XCJdXG4gICAgICAgIGZ1bmN0aW9uIGVhdEFycmF5KGksIGtleSwgYXJncywgYXJnQWZ0ZXJFcXVhbFNpZ24pIHtcbiAgICAgICAgICAgIGxldCBhcmdzVG9TZXQgPSBbXTtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gYXJnQWZ0ZXJFcXVhbFNpZ24gfHwgYXJnc1tpICsgMV07XG4gICAgICAgICAgICAvLyBJZiBib3RoIGFycmF5IGFuZCBuYXJncyBhcmUgY29uZmlndXJlZCwgZW5mb3JjZSB0aGUgbmFyZ3MgY291bnQ6XG4gICAgICAgICAgICBjb25zdCBuYXJnc0NvdW50ID0gY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MubmFyZ3MpO1xuICAgICAgICAgICAgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmJvb2xzKSAmJiAhKC9eKHRydWV8ZmFsc2UpJC8udGVzdChuZXh0KSkpIHtcbiAgICAgICAgICAgICAgICBhcmdzVG9TZXQucHVzaCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVW5kZWZpbmVkKG5leHQpIHx8XG4gICAgICAgICAgICAgICAgKGlzVW5kZWZpbmVkKGFyZ0FmdGVyRXF1YWxTaWduKSAmJiAvXi0vLnRlc3QobmV4dCkgJiYgIW5lZ2F0aXZlLnRlc3QobmV4dCkgJiYgIWlzVW5rbm93bk9wdGlvbkFzQXJnKG5leHQpKSkge1xuICAgICAgICAgICAgICAgIC8vIGZvciBrZXlzIHdpdGhvdXQgdmFsdWUgPT0+IGFyZ3NUb1NldCByZW1haW5zIGFuIGVtcHR5IFtdXG4gICAgICAgICAgICAgICAgLy8gc2V0IHVzZXIgZGVmYXVsdCB2YWx1ZSwgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZWYWwgPSBkZWZhdWx0c1trZXldO1xuICAgICAgICAgICAgICAgICAgICBhcmdzVG9TZXQgPSBBcnJheS5pc0FycmF5KGRlZlZhbCkgPyBkZWZWYWwgOiBbZGVmVmFsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZSBpbiAtLW9wdGlvbj12YWx1ZSBpcyBlYXRlbiBhcyBpc1xuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoYXJnQWZ0ZXJFcXVhbFNpZ24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NUb1NldC5wdXNoKHByb2Nlc3NWYWx1ZShrZXksIGFyZ0FmdGVyRXF1YWxTaWduLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlpID0gaSArIDE7IGlpIDwgYXJncy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCghY29uZmlndXJhdGlvblsnZ3JlZWR5LWFycmF5cyddICYmIGFyZ3NUb1NldC5sZW5ndGggPiAwKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKG5hcmdzQ291bnQgJiYgdHlwZW9mIG5hcmdzQ291bnQgPT09ICdudW1iZXInICYmIGFyZ3NUb1NldC5sZW5ndGggPj0gbmFyZ3NDb3VudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGFyZ3NbaWldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoL14tLy50ZXN0KG5leHQpICYmICFuZWdhdGl2ZS50ZXN0KG5leHQpICYmICFpc1Vua25vd25PcHRpb25Bc0FyZyhuZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpID0gaWk7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NUb1NldC5wdXNoKHByb2Nlc3NWYWx1ZShrZXksIG5leHQsIGlucHV0SXNTdHJpbmcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBib3RoIGFycmF5IGFuZCBuYXJncyBhcmUgY29uZmlndXJlZCwgY3JlYXRlIGFuIGVycm9yIGlmIGxlc3MgdGhhblxuICAgICAgICAgICAgLy8gbmFyZ3MgcG9zaXRpb25hbHMgd2VyZSBmb3VuZC4gTmFOIGhhcyBzcGVjaWFsIG1lYW5pbmcsIGluZGljYXRpbmdcbiAgICAgICAgICAgIC8vIHRoYXQgYXQgbGVhc3Qgb25lIHZhbHVlIGlzIHJlcXVpcmVkIChtb3JlIGFyZSBva2F5KS5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFyZ3NDb3VudCA9PT0gJ251bWJlcicgJiYgKChuYXJnc0NvdW50ICYmIGFyZ3NUb1NldC5sZW5ndGggPCBuYXJnc0NvdW50KSB8fFxuICAgICAgICAgICAgICAgIChpc05hTihuYXJnc0NvdW50KSAmJiBhcmdzVG9TZXQubGVuZ3RoID09PSAwKSkpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IEVycm9yKF9fKCdOb3QgZW5vdWdoIGFyZ3VtZW50cyBmb2xsb3dpbmc6ICVzJywga2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRBcmcoa2V5LCBhcmdzVG9TZXQpO1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0QXJnKGtleSwgdmFsLCBzaG91bGRTdHJpcFF1b3RlcyA9IGlucHV0SXNTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmICgvLS8udGVzdChrZXkpICYmIGNvbmZpZ3VyYXRpb25bJ2NhbWVsLWNhc2UtZXhwYW5zaW9uJ10pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGlhcyA9IGtleS5zcGxpdCgnLicpLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FtZWxDYXNlKHByb3ApO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICBhZGROZXdBbGlhcyhrZXksIGFsaWFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvY2Vzc1ZhbHVlKGtleSwgdmFsLCBzaG91bGRTdHJpcFF1b3Rlcyk7XG4gICAgICAgICAgICBjb25zdCBzcGxpdEtleSA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgc2V0S2V5KGFyZ3YsIHNwbGl0S2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAvLyBoYW5kbGUgcG9wdWxhdGluZyBhbGlhc2VzIG9mIHRoZSBmdWxsIGtleVxuICAgICAgICAgICAgaWYgKGZsYWdzLmFsaWFzZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIGZsYWdzLmFsaWFzZXNba2V5XS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleVByb3BlcnRpZXMgPSB4LnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgICAgIHNldEtleShhcmd2LCBrZXlQcm9wZXJ0aWVzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYW5kbGUgcG9wdWxhdGluZyBhbGlhc2VzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBkb3Qtbm90YXRpb24ga2V5XG4gICAgICAgICAgICBpZiAoc3BsaXRLZXkubGVuZ3RoID4gMSAmJiBjb25maWd1cmF0aW9uWydkb3Qtbm90YXRpb24nXSkge1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAoZmxhZ3MuYWxpYXNlc1tzcGxpdEtleVswXV0gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGtleVByb3BlcnRpZXMgPSB4LnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGV4cGFuZCBhbGlhcyB3aXRoIG5lc3RlZCBvYmplY3RzIGluIGtleVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gW10uY29uY2F0KHNwbGl0S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgYS5zaGlmdCgpOyAvLyBudWtlIHRoZSBvbGQga2V5LlxuICAgICAgICAgICAgICAgICAgICBrZXlQcm9wZXJ0aWVzID0ga2V5UHJvcGVydGllcy5jb25jYXQoYSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBvcHVsYXRlIGFsaWFzIG9ubHkgaWYgaXMgbm90IGFscmVhZHkgYW4gYWxpYXMgb2YgdGhlIGZ1bGwga2V5XG4gICAgICAgICAgICAgICAgICAgIC8vIChhbHJlYWR5IHBvcHVsYXRlZCBhYm92ZSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZmxhZ3MuYWxpYXNlc1trZXldIHx8IFtdKS5pbmNsdWRlcyhrZXlQcm9wZXJ0aWVzLmpvaW4oJy4nKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEtleShhcmd2LCBrZXlQcm9wZXJ0aWVzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCBub3JtYWxpemUgZ2V0dGVyIGFuZCBzZXR0ZXIgd2hlbiBrZXkgaXMgaW4gJ25vcm1hbGl6ZScgYnV0IGlzbid0IGFuIGFycmF5XG4gICAgICAgICAgICBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3Mubm9ybWFsaXplKSAmJiAhY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYXJyYXlzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBba2V5XS5jb25jYXQoZmxhZ3MuYWxpYXNlc1trZXldIHx8IFtdKTtcbiAgICAgICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJndlJldHVybiwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IG1peGluLm5vcm1hbGl6ZSh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkTmV3QWxpYXMoa2V5LCBhbGlhcykge1xuICAgICAgICAgICAgaWYgKCEoZmxhZ3MuYWxpYXNlc1trZXldICYmIGZsYWdzLmFsaWFzZXNba2V5XS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MuYWxpYXNlc1trZXldID0gW2FsaWFzXTtcbiAgICAgICAgICAgICAgICBuZXdBbGlhc2VzW2FsaWFzXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShmbGFncy5hbGlhc2VzW2FsaWFzXSAmJiBmbGFncy5hbGlhc2VzW2FsaWFzXS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgYWRkTmV3QWxpYXMoYWxpYXMsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc1ZhbHVlKGtleSwgdmFsLCBzaG91bGRTdHJpcFF1b3Rlcykge1xuICAgICAgICAgICAgLy8gc3RyaW5ncyBtYXkgYmUgcXVvdGVkLCBjbGVhbiB0aGlzIHVwIGFzIHdlIGFzc2lnbiB2YWx1ZXMuXG4gICAgICAgICAgICBpZiAoc2hvdWxkU3RyaXBRdW90ZXMpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBzdHJpcFF1b3Rlcyh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGFuZGxlIHBhcnNpbmcgYm9vbGVhbiBhcmd1bWVudHMgLS1mb289dHJ1ZSAtLWJhciBmYWxzZS5cbiAgICAgICAgICAgIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5ib29scykgfHwgY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuY291bnRzKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsID09PSAndHJ1ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBBcnJheS5pc0FycmF5KHZhbClcbiAgICAgICAgICAgICAgICA/IHZhbC5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG1heWJlQ29lcmNlTnVtYmVyKGtleSwgdik7IH0pXG4gICAgICAgICAgICAgICAgOiBtYXliZUNvZXJjZU51bWJlcihrZXksIHZhbCk7XG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgYSBjb3VudCBnaXZlbiBhcyBhcmcgKGVpdGhlciBubyB2YWx1ZSBvciB2YWx1ZSBwYXJzZWQgYXMgYm9vbGVhbilcbiAgICAgICAgICAgIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5jb3VudHMpICYmIChpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpbmNyZW1lbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCBub3JtYWxpemVkIHZhbHVlIHdoZW4ga2V5IGlzIGluICdub3JtYWxpemUnIGFuZCBpbiAnYXJyYXlzJ1xuICAgICAgICAgICAgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLm5vcm1hbGl6ZSkgJiYgY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYXJyYXlzKSkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsLm1hcCgodmFsKSA9PiB7IHJldHVybiBtaXhpbi5ub3JtYWxpemUodmFsKTsgfSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1peGluLm5vcm1hbGl6ZSh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1heWJlQ29lcmNlTnVtYmVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghY29uZmlndXJhdGlvblsncGFyc2UtcG9zaXRpb25hbC1udW1iZXJzJ10gJiYga2V5ID09PSAnXycpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgaWYgKCFjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5zdHJpbmdzKSAmJiAhY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYm9vbHMpICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZENvZXJjZU51bWJlciA9IGxvb2tzTGlrZU51bWJlcih2YWx1ZSkgJiYgY29uZmlndXJhdGlvblsncGFyc2UtbnVtYmVycyddICYmIChOdW1iZXIuaXNTYWZlSW50ZWdlcihNYXRoLmZsb29yKHBhcnNlRmxvYXQoYCR7dmFsdWV9YCkpKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZENvZXJjZU51bWJlciB8fCAoIWlzVW5kZWZpbmVkKHZhbHVlKSAmJiBjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5udW1iZXJzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgYXJncyBmcm9tIGNvbmZpZy5qc29uIGZpbGUsIHRoaXMgc2hvdWxkIGJlXG4gICAgICAgIC8vIGFwcGxpZWQgbGFzdCBzbyB0aGF0IGRlZmF1bHRzIGNhbiBiZSBhcHBsaWVkLlxuICAgICAgICBmdW5jdGlvbiBzZXRDb25maWcoYXJndikge1xuICAgICAgICAgICAgY29uc3QgY29uZmlnTG9va3VwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIC8vIGV4cGFuZCBkZWZhdWx0cy9hbGlhc2VzLCBpbi1jYXNlIGFueSBoYXBwZW4gdG8gcmVmZXJlbmNlXG4gICAgICAgICAgICAvLyB0aGUgY29uZmlnLmpzb24gZmlsZS5cbiAgICAgICAgICAgIGFwcGx5RGVmYXVsdHNBbmRBbGlhc2VzKGNvbmZpZ0xvb2t1cCwgZmxhZ3MuYWxpYXNlcywgZGVmYXVsdHMpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZmxhZ3MuY29uZmlncykuZm9yRWFjaChmdW5jdGlvbiAoY29uZmlnS2V5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZmlnUGF0aCA9IGFyZ3ZbY29uZmlnS2V5XSB8fCBjb25maWdMb29rdXBbY29uZmlnS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbmZpZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZENvbmZpZ1BhdGggPSBtaXhpbi5yZXNvbHZlKG1peGluLmN3ZCgpLCBjb25maWdQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVDb25maWcgPSBmbGFncy5jb25maWdzW2NvbmZpZ0tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc29sdmVDb25maWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcgPSByZXNvbHZlQ29uZmlnKHJlc29sdmVkQ29uZmlnUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IG1peGluLnJlcXVpcmUocmVzb2x2ZWRDb25maWdQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbmZpZ09iamVjdChjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVubyB3aWxsIHJlY2VpdmUgYSBQZXJtaXNzaW9uRGVuaWVkIGVycm9yIGlmIGFuIGF0dGVtcHQgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hZGUgdG8gbG9hZCBjb25maWcgd2l0aG91dCB0aGUgLS1hbGxvdy1yZWFkIGZsYWc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXgubmFtZSA9PT0gJ1Blcm1pc3Npb25EZW5pZWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmd2W2NvbmZpZ0tleV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBFcnJvcihfXygnSW52YWxpZCBKU09OIGNvbmZpZyBmaWxlOiAlcycsIGNvbmZpZ1BhdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBhcmdzIGZyb20gY29uZmlnIG9iamVjdC5cbiAgICAgICAgLy8gaXQgcmVjdXJzaXZlbHkgY2hlY2tzIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICBmdW5jdGlvbiBzZXRDb25maWdPYmplY3QoY29uZmlnLCBwcmV2KSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjb25maWcpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY29uZmlnW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgZnVsbEtleSA9IHByZXYgPyBwcmV2ICsgJy4nICsga2V5IDoga2V5O1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB2YWx1ZSBpcyBhbiBpbm5lciBvYmplY3QgYW5kIHdlIGhhdmUgZG90LW5vdGF0aW9uXG4gICAgICAgICAgICAgICAgLy8gZW5hYmxlZCwgdHJlYXQgaW5uZXIgb2JqZWN0cyBpbiBjb25maWcgdGhlIHNhbWUgYXNcbiAgICAgICAgICAgICAgICAvLyBoZWF2aWx5IG5lc3RlZCBkb3Qgbm90YXRpb25zIChmb28uYmFyLmFwcGxlKS5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgY29uZmlndXJhdGlvblsnZG90LW5vdGF0aW9uJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCBidXQgbm90IGFuIGFycmF5LCBjaGVjayBuZXN0ZWQgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIHNldENvbmZpZ09iamVjdCh2YWx1ZSwgZnVsbEtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXR0aW5nIGFyZ3VtZW50cyB2aWEgQ0xJIHRha2VzIHByZWNlZGVuY2Ugb3ZlclxuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgd2l0aGluIHRoZSBjb25maWcgZmlsZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNLZXkoYXJndiwgZnVsbEtleS5zcGxpdCgnLicpKSB8fCAoY2hlY2tBbGxBbGlhc2VzKGZ1bGxLZXksIGZsYWdzLmFycmF5cykgJiYgY29uZmlndXJhdGlvblsnY29tYmluZS1hcnJheXMnXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEFyZyhmdWxsS2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgYWxsIGNvbmZpZyBvYmplY3RzIHBhc3NlZCBpbiBvcHRzXG4gICAgICAgIGZ1bmN0aW9uIHNldENvbmZpZ09iamVjdHMoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpZ09iamVjdHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnT2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChjb25maWdPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q29uZmlnT2JqZWN0KGNvbmZpZ09iamVjdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlFbnZWYXJzKGFyZ3YsIGNvbmZpZ09ubHkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW52UHJlZml4ID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSB0eXBlb2YgZW52UHJlZml4ID09PSAnc3RyaW5nJyA/IGVudlByZWZpeCA6ICcnO1xuICAgICAgICAgICAgY29uc3QgZW52ID0gbWl4aW4uZW52KCk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goZnVuY3Rpb24gKGVudlZhcikge1xuICAgICAgICAgICAgICAgIGlmIChwcmVmaXggPT09ICcnIHx8IGVudlZhci5sYXN0SW5kZXhPZihwcmVmaXgsIDApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCBhcnJheSBvZiBuZXN0ZWQga2V5cyBhbmQgY29udmVydCB0aGVtIHRvIGNhbWVsIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IGVudlZhci5zcGxpdCgnX18nKS5tYXAoZnVuY3Rpb24gKGtleSwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXkuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbWVsQ2FzZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgoY29uZmlnT25seSAmJiBmbGFncy5jb25maWdzW2tleXMuam9pbignLicpXSkgfHwgIWNvbmZpZ09ubHkpICYmICFoYXNLZXkoYXJndiwga2V5cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEFyZyhrZXlzLmpvaW4oJy4nKSwgZW52W2VudlZhcl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlDb2VyY2lvbnMoYXJndikge1xuICAgICAgICAgICAgbGV0IGNvZXJjZTtcbiAgICAgICAgICAgIGNvbnN0IGFwcGxpZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhcmd2KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFwcGxpZWQuaGFzKGtleSkpIHsgLy8gSWYgd2UgaGF2ZW4ndCBhbHJlYWR5IGNvZXJjZWQgdGhpcyBvcHRpb24gdmlhIG9uZSBvZiBpdHMgYWxpYXNlc1xuICAgICAgICAgICAgICAgICAgICBjb2VyY2UgPSBjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5jb2VyY2lvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvZXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG1heWJlQ29lcmNlTnVtYmVyKGtleSwgY29lcmNlKGFyZ3Zba2V5XSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChbXS5jb25jYXQoZmxhZ3MuYWxpYXNlc1trZXldIHx8IFtdLCBrZXkpKS5mb3JFYWNoKGFsaSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZWQuYWRkKGFsaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3ZbYWxpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0UGxhY2Vob2xkZXJLZXlzKGFyZ3YpIHtcbiAgICAgICAgICAgIGZsYWdzLmtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc2V0IHBsYWNlaG9sZGVyIGtleXMgZm9yIGRvdCBub3RhdGlvbiBvcHRpb25zICdmb28uYmFyJy5cbiAgICAgICAgICAgICAgICBpZiAofmtleS5pbmRleE9mKCcuJykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3Zba2V5XSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgICAgIGFyZ3Zba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3Y7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlEZWZhdWx0c0FuZEFsaWFzZXMob2JqLCBhbGlhc2VzLCBkZWZhdWx0cywgY2FuTG9nID0gZmFsc2UpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGRlZmF1bHRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0tleShvYmosIGtleS5zcGxpdCgnLicpKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRLZXkob2JqLCBrZXkuc3BsaXQoJy4nKSwgZGVmYXVsdHNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5Mb2cpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0ZWRba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIChhbGlhc2VzW2tleV0gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNLZXkob2JqLCB4LnNwbGl0KCcuJykpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEtleShvYmosIHguc3BsaXQoJy4nKSwgZGVmYXVsdHNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhc0tleShvYmosIGtleXMpIHtcbiAgICAgICAgICAgIGxldCBvID0gb2JqO1xuICAgICAgICAgICAgaWYgKCFjb25maWd1cmF0aW9uWydkb3Qtbm90YXRpb24nXSlcbiAgICAgICAgICAgICAgICBrZXlzID0gW2tleXMuam9pbignLicpXTtcbiAgICAgICAgICAgIGtleXMuc2xpY2UoMCwgLTEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIG8gPSAob1trZXldIHx8IHt9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1trZXlzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleSBpbiBvO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldEtleShvYmosIGtleXMsIHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbyA9IG9iajtcbiAgICAgICAgICAgIGlmICghY29uZmlndXJhdGlvblsnZG90LW5vdGF0aW9uJ10pXG4gICAgICAgICAgICAgICAga2V5cyA9IFtrZXlzLmpvaW4oJy4nKV07XG4gICAgICAgICAgICBrZXlzLnNsaWNlKDAsIC0xKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGJjb2UpOiBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIHlhcmdzLCBzd2l0Y2ggdG9cbiAgICAgICAgICAgICAgICAvLyBPYmplY3QuY3JlYXRlKG51bGwpIGZvciBkb3Qgbm90YXRpb246XG4gICAgICAgICAgICAgICAga2V5ID0gc2FuaXRpemVLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG8gPT09ICdvYmplY3QnICYmIG9ba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9ba2V5XSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IG9ba2V5XSBpcyBhbiBhcnJheSwgYW5kIHRoYXQgdGhlIGxhc3QgaXRlbSBpcyBhbiBlbXB0eSBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ba2V5XS5wdXNoKHt9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ba2V5XSA9IFtvW2tleV0sIHt9XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSB3YW50IHRvIHVwZGF0ZSB0aGUgZW1wdHkgb2JqZWN0IGF0IHRoZSBlbmQgb2YgdGhlIG9ba2V5XSBhcnJheSwgc28gc2V0IG8gdG8gdGhhdCBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgbyA9IG9ba2V5XVtvW2tleV0ubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvID0gb1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gVE9ETyhiY29lKTogaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiB5YXJncywgc3dpdGNoIHRvXG4gICAgICAgICAgICAvLyBPYmplY3QuY3JlYXRlKG51bGwpIGZvciBkb3Qgbm90YXRpb246XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBzYW5pdGl6ZUtleShrZXlzW2tleXMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgY29uc3QgaXNUeXBlQXJyYXkgPSBjaGVja0FsbEFsaWFzZXMoa2V5cy5qb2luKCcuJyksIGZsYWdzLmFycmF5cyk7XG4gICAgICAgICAgICBjb25zdCBpc1ZhbHVlQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICAgICAgICAgIGxldCBkdXBsaWNhdGUgPSBjb25maWd1cmF0aW9uWydkdXBsaWNhdGUtYXJndW1lbnRzLWFycmF5J107XG4gICAgICAgICAgICAvLyBuYXJncyBoYXMgaGlnaGVyIHByaW9yaXR5IHRoYW4gZHVwbGljYXRlXG4gICAgICAgICAgICBpZiAoIWR1cGxpY2F0ZSAmJiBjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5uYXJncykpIHtcbiAgICAgICAgICAgICAgICBkdXBsaWNhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICgoIWlzVW5kZWZpbmVkKG9ba2V5XSkgJiYgZmxhZ3MubmFyZ3Nba2V5XSA9PT0gMSkgfHwgKEFycmF5LmlzQXJyYXkob1trZXldKSAmJiBvW2tleV0ubGVuZ3RoID09PSBmbGFncy5uYXJnc1trZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBvW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBpbmNyZW1lbnQoKSkge1xuICAgICAgICAgICAgICAgIG9ba2V5XSA9IGluY3JlbWVudChvW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGR1cGxpY2F0ZSAmJiBpc1R5cGVBcnJheSAmJiBpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgb1trZXldID0gY29uZmlndXJhdGlvblsnZmxhdHRlbi1kdXBsaWNhdGUtYXJyYXlzJ10gPyBvW2tleV0uY29uY2F0KHZhbHVlKSA6IChBcnJheS5pc0FycmF5KG9ba2V5XVswXSkgPyBvW2tleV0gOiBbb1trZXldXSkuY29uY2F0KFt2YWx1ZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZHVwbGljYXRlICYmIEJvb2xlYW4oaXNUeXBlQXJyYXkpID09PSBCb29sZWFuKGlzVmFsdWVBcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvW2tleV0gPSBvW2tleV0uY29uY2F0KFt2YWx1ZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9ba2V5XSA9PT0gdW5kZWZpbmVkICYmIGlzVHlwZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgb1trZXldID0gaXNWYWx1ZUFycmF5ID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZHVwbGljYXRlICYmICEob1trZXldID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICBjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5jb3VudHMpIHx8XG4gICAgICAgICAgICAgICAgY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYm9vbHMpKSkge1xuICAgICAgICAgICAgICAgIG9ba2V5XSA9IFtvW2tleV0sIHZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGV4dGVuZCB0aGUgYWxpYXNlcyBsaXN0IHdpdGggaW5mZXJyZWQgYWxpYXNlcy5cbiAgICAgICAgZnVuY3Rpb24gZXh0ZW5kQWxpYXNlcyguLi5hcmdzKSB7XG4gICAgICAgICAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG9iaiB8fCB7fSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3J0LWNpcmN1aXQgaWYgd2UndmUgYWxyZWFkeSBhZGRlZCBhIGtleVxuICAgICAgICAgICAgICAgICAgICAvLyB0byB0aGUgYWxpYXNlcyBhcnJheSwgZm9yIGV4YW1wbGUgaXQgbWlnaHRcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhpc3QgaW4gYm90aCAnb3B0cy5kZWZhdWx0JyBhbmQgJ29wdHMua2V5Jy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzLmFsaWFzZXNba2V5XSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYWxpYXNlc1trZXldID0gW10uY29uY2F0KGFsaWFzZXNba2V5XSB8fCBbXSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBcIi0tb3B0aW9uLW5hbWVcIiwgYWxzbyBzZXQgYXJndi5vcHRpb25OYW1lXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmFsaWFzZXNba2V5XS5jb25jYXQoa2V5KS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLy0vLnRlc3QoeCkgJiYgY29uZmlndXJhdGlvblsnY2FtZWwtY2FzZS1leHBhbnNpb24nXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBjYW1lbENhc2UoeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgIT09IGtleSAmJiBmbGFncy5hbGlhc2VzW2tleV0uaW5kZXhPZihjKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYWxpYXNlc1trZXldLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0FsaWFzZXNbY10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBcIi0tb3B0aW9uTmFtZVwiLCBhbHNvIHNldCBhcmd2WydvcHRpb24tbmFtZSddXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmFsaWFzZXNba2V5XS5jb25jYXQoa2V5KS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeC5sZW5ndGggPiAxICYmIC9bQS1aXS8udGVzdCh4KSAmJiBjb25maWd1cmF0aW9uWydjYW1lbC1jYXNlLWV4cGFuc2lvbiddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYyA9IGRlY2FtZWxpemUoeCwgJy0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyAhPT0ga2V5ICYmIGZsYWdzLmFsaWFzZXNba2V5XS5pbmRleE9mKGMpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGFncy5hbGlhc2VzW2tleV0ucHVzaChjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3QWxpYXNlc1tjXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYWxpYXNlc1trZXldLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzLmFsaWFzZXNbeF0gPSBba2V5XS5jb25jYXQoZmxhZ3MuYWxpYXNlc1trZXldLmZpbHRlcihmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4ICE9PSB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWcpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvQ2hlY2sgPSBbXS5jb25jYXQoZmxhZ3MuYWxpYXNlc1trZXldIHx8IFtdLCBrZXkpO1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZsYWcpO1xuICAgICAgICAgICAgY29uc3Qgc2V0QWxpYXMgPSB0b0NoZWNrLmZpbmQoa2V5ID0+IGtleXMuaW5jbHVkZXMoa2V5KSk7XG4gICAgICAgICAgICByZXR1cm4gc2V0QWxpYXMgPyBmbGFnW3NldEFsaWFzXSA6IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhc0FueUZsYWcoa2V5KSB7XG4gICAgICAgICAgICBjb25zdCBmbGFnc0tleXMgPSBPYmplY3Qua2V5cyhmbGFncyk7XG4gICAgICAgICAgICBjb25zdCB0b0NoZWNrID0gW10uY29uY2F0KGZsYWdzS2V5cy5tYXAoayA9PiBmbGFnc1trXSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQ2hlY2suc29tZShmdW5jdGlvbiAoZmxhZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGZsYWcpID8gZmxhZy5pbmNsdWRlcyhrZXkpIDogZmxhZ1trZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFzRmxhZ3NNYXRjaGluZyhhcmcsIC4uLnBhdHRlcm5zKSB7XG4gICAgICAgICAgICBjb25zdCB0b0NoZWNrID0gW10uY29uY2F0KC4uLnBhdHRlcm5zKTtcbiAgICAgICAgICAgIHJldHVybiB0b0NoZWNrLnNvbWUoZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IGFyZy5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2ggJiYgaGFzQW55RmxhZyhtYXRjaFsxXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBiYXNlZCBvbiBhIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiB0aGUgc2hvcnQgZmxhZyBncm91cCBwYXJzaW5nIGxvZ2ljXG4gICAgICAgIGZ1bmN0aW9uIGhhc0FsbFNob3J0RmxhZ3MoYXJnKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEgbmVnYXRpdmUgbnVtYmVyLCBvciBkb2Vzbid0IHN0YXJ0IHdpdGggYSBzaW5nbGUgaHlwaGVuLCBpdCdzIG5vdCBhIHNob3J0IGZsYWcgZ3JvdXBcbiAgICAgICAgICAgIGlmIChhcmcubWF0Y2gobmVnYXRpdmUpIHx8ICFhcmcubWF0Y2goL14tW14tXSsvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBoYXNBbGxGbGFncyA9IHRydWU7XG4gICAgICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgICAgIGNvbnN0IGxldHRlcnMgPSBhcmcuc2xpY2UoMSkuc3BsaXQoJycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZXR0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IGFyZy5zbGljZShqICsgMik7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNBbnlGbGFnKGxldHRlcnNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0FsbEZsYWdzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKGxldHRlcnNbaiArIDFdICYmIGxldHRlcnNbaiArIDFdID09PSAnPScpIHx8XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPT09ICctJyB8fFxuICAgICAgICAgICAgICAgICAgICAoL1tBLVphLXpdLy50ZXN0KGxldHRlcnNbal0pICYmIC9eLT9cXGQrKFxcLlxcZCopPyhlLT9cXGQrKT8kLy50ZXN0KG5leHQpKSB8fFxuICAgICAgICAgICAgICAgICAgICAobGV0dGVyc1tqICsgMV0gJiYgbGV0dGVyc1tqICsgMV0ubWF0Y2goL1xcVy8pKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGFzQWxsRmxhZ3M7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNVbmtub3duT3B0aW9uQXNBcmcoYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlndXJhdGlvblsndW5rbm93bi1vcHRpb25zLWFzLWFyZ3MnXSAmJiBpc1Vua25vd25PcHRpb24oYXJnKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc1Vua25vd25PcHRpb24oYXJnKSB7XG4gICAgICAgICAgICBhcmcgPSBhcmcucmVwbGFjZSgvXi17Myx9LywgJy0tJyk7XG4gICAgICAgICAgICAvLyBpZ25vcmUgbmVnYXRpdmUgbnVtYmVyc1xuICAgICAgICAgICAgaWYgKGFyZy5tYXRjaChuZWdhdGl2ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEgc2hvcnQgb3B0aW9uIGdyb3VwIGFuZCBhbGwgb2YgdGhlbSBhcmUgY29uZmlndXJlZCwgaXQgaXNuJ3QgdW5rbm93blxuICAgICAgICAgICAgaWYgKGhhc0FsbFNob3J0RmxhZ3MoYXJnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGUuZy4gJy0tY291bnQ9MidcbiAgICAgICAgICAgIGNvbnN0IGZsYWdXaXRoRXF1YWxzID0gL14tKyhbXj1dKz8pPVtcXHNcXFNdKiQvO1xuICAgICAgICAgICAgLy8gZS5nLiAnLWEnIG9yICctLWFyZydcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbEZsYWcgPSAvXi0rKFtePV0rPykkLztcbiAgICAgICAgICAgIC8vIGUuZy4gJy1hLSdcbiAgICAgICAgICAgIGNvbnN0IGZsYWdFbmRpbmdJbkh5cGhlbiA9IC9eLSsoW149XSs/KS0kLztcbiAgICAgICAgICAgIC8vIGUuZy4gJy1hYmMxMjMnXG4gICAgICAgICAgICBjb25zdCBmbGFnRW5kaW5nSW5EaWdpdHMgPSAvXi0rKFtePV0rP1xcZCspJC87XG4gICAgICAgICAgICAvLyBlLmcuICctYS91c3IvbG9jYWwnXG4gICAgICAgICAgICBjb25zdCBmbGFnRW5kaW5nSW5Ob25Xb3JkQ2hhcmFjdGVycyA9IC9eLSsoW149XSs/KVxcVysuKiQvO1xuICAgICAgICAgICAgLy8gY2hlY2sgdGhlIGRpZmZlcmVudCB0eXBlcyBvZiBmbGFnIHN0eWxlcywgaW5jbHVkaW5nIG5lZ2F0ZWRCb29sZWFuLCBhIHBhdHRlcm4gZGVmaW5lZCBuZWFyIHRoZSBzdGFydCBvZiB0aGUgcGFyc2UgbWV0aG9kXG4gICAgICAgICAgICByZXR1cm4gIWhhc0ZsYWdzTWF0Y2hpbmcoYXJnLCBmbGFnV2l0aEVxdWFscywgbmVnYXRlZEJvb2xlYW4sIG5vcm1hbEZsYWcsIGZsYWdFbmRpbmdJbkh5cGhlbiwgZmxhZ0VuZGluZ0luRGlnaXRzLCBmbGFnRW5kaW5nSW5Ob25Xb3JkQ2hhcmFjdGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHBpY2sgYSBkZWZhdWx0IHZhbHVlXG4gICAgICAgIC8vIGZvciBhbiBvcHRpb24gYmFzZWQgb24gbmFtZSBhbmQgdHlwZS5cbiAgICAgICAgZnVuY3Rpb24gZGVmYXVsdFZhbHVlKGtleSkge1xuICAgICAgICAgICAgaWYgKCFjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5ib29scykgJiZcbiAgICAgICAgICAgICAgICAhY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuY291bnRzKSAmJlxuICAgICAgICAgICAgICAgIGAke2tleX1gIGluIGRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdEZvclR5cGUoZ3Vlc3NUeXBlKGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJldHVybiBhIGRlZmF1bHQgdmFsdWUsIGdpdmVuIHRoZSB0eXBlIG9mIGEgZmxhZy4sXG4gICAgICAgIGZ1bmN0aW9uIGRlZmF1bHRGb3JUeXBlKHR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZiA9IHtcbiAgICAgICAgICAgICAgICBbRGVmYXVsdFZhbHVlc0ZvclR5cGVLZXkuQk9PTEVBTl06IHRydWUsXG4gICAgICAgICAgICAgICAgW0RlZmF1bHRWYWx1ZXNGb3JUeXBlS2V5LlNUUklOR106ICcnLFxuICAgICAgICAgICAgICAgIFtEZWZhdWx0VmFsdWVzRm9yVHlwZUtleS5OVU1CRVJdOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgW0RlZmF1bHRWYWx1ZXNGb3JUeXBlS2V5LkFSUkFZXTogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZGVmW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdpdmVuIGEgZmxhZywgZW5mb3JjZSBhIGRlZmF1bHQgdHlwZS5cbiAgICAgICAgZnVuY3Rpb24gZ3Vlc3NUeXBlKGtleSkge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSBEZWZhdWx0VmFsdWVzRm9yVHlwZUtleS5CT09MRUFOO1xuICAgICAgICAgICAgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLnN0cmluZ3MpKVxuICAgICAgICAgICAgICAgIHR5cGUgPSBEZWZhdWx0VmFsdWVzRm9yVHlwZUtleS5TVFJJTkc7XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5udW1iZXJzKSlcbiAgICAgICAgICAgICAgICB0eXBlID0gRGVmYXVsdFZhbHVlc0ZvclR5cGVLZXkuTlVNQkVSO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYm9vbHMpKVxuICAgICAgICAgICAgICAgIHR5cGUgPSBEZWZhdWx0VmFsdWVzRm9yVHlwZUtleS5CT09MRUFOO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYXJyYXlzKSlcbiAgICAgICAgICAgICAgICB0eXBlID0gRGVmYXVsdFZhbHVlc0ZvclR5cGVLZXkuQVJSQVk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChudW0pIHtcbiAgICAgICAgICAgIHJldHVybiBudW0gPT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayB1c2VyIGNvbmZpZ3VyYXRpb24gc2V0dGluZ3MgZm9yIGluY29uc2lzdGVuY2llc1xuICAgICAgICBmdW5jdGlvbiBjaGVja0NvbmZpZ3VyYXRpb24oKSB7XG4gICAgICAgICAgICAvLyBjb3VudCBrZXlzIHNob3VsZCBub3QgYmUgc2V0IGFzIGFycmF5L25hcmdcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGZsYWdzLmNvdW50cykuZmluZChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5hcnJheXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gRXJyb3IoX18oJ0ludmFsaWQgY29uZmlndXJhdGlvbjogJXMsIG9wdHMuY291bnQgZXhjbHVkZXMgb3B0cy5hcnJheS4nLCBrZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLm5hcmdzKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IEVycm9yKF9fKCdJbnZhbGlkIGNvbmZpZ3VyYXRpb246ICVzLCBvcHRzLmNvdW50IGV4Y2x1ZGVzIG9wdHMubmFyZy4nLCBrZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbGlhc2VzOiBPYmplY3QuYXNzaWduKHt9LCBmbGFncy5hbGlhc2VzKSxcbiAgICAgICAgICAgIGFyZ3Y6IE9iamVjdC5hc3NpZ24oYXJndlJldHVybiwgYXJndiksXG4gICAgICAgICAgICBjb25maWd1cmF0aW9uOiBjb25maWd1cmF0aW9uLFxuICAgICAgICAgICAgZGVmYXVsdGVkOiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0ZWQpLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgbmV3QWxpYXNlczogT2JqZWN0LmFzc2lnbih7fSwgbmV3QWxpYXNlcylcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLyBpZiBhbnkgYWxpYXNlcyByZWZlcmVuY2UgZWFjaCBvdGhlciwgd2Ugc2hvdWxkXG4vLyBtZXJnZSB0aGVtIHRvZ2V0aGVyLlxuZnVuY3Rpb24gY29tYmluZUFsaWFzZXMoYWxpYXNlcykge1xuICAgIGNvbnN0IGFsaWFzQXJyYXlzID0gW107XG4gICAgY29uc3QgY29tYmluZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBjaGFuZ2UgPSB0cnVlO1xuICAgIC8vIHR1cm4gYWxpYXMgbG9va3VwIGhhc2gge2tleTogWydhbGlhczEnLCAnYWxpYXMyJ119IGludG9cbiAgICAvLyBhIHNpbXBsZSBhcnJheSBbJ2tleScsICdhbGlhczEnLCAnYWxpYXMyJ11cbiAgICBPYmplY3Qua2V5cyhhbGlhc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgYWxpYXNBcnJheXMucHVzaChbXS5jb25jYXQoYWxpYXNlc1trZXldLCBrZXkpKTtcbiAgICB9KTtcbiAgICAvLyBjb21iaW5lIGFycmF5cyB1bnRpbCB6ZXJvIGNoYW5nZXMgYXJlXG4gICAgLy8gbWFkZSBpbiBhbiBpdGVyYXRpb24uXG4gICAgd2hpbGUgKGNoYW5nZSkge1xuICAgICAgICBjaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGlhc0FycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaWkgPSBpICsgMTsgaWkgPCBhbGlhc0FycmF5cy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcnNlY3QgPSBhbGlhc0FycmF5c1tpXS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsaWFzQXJyYXlzW2lpXS5pbmRleE9mKHYpICE9PSAtMTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBhbGlhc0FycmF5c1tpXSA9IGFsaWFzQXJyYXlzW2ldLmNvbmNhdChhbGlhc0FycmF5c1tpaV0pO1xuICAgICAgICAgICAgICAgICAgICBhbGlhc0FycmF5cy5zcGxpY2UoaWksIDEpO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbWFwIGFycmF5cyBiYWNrIHRvIHRoZSBoYXNoLWxvb2t1cCAoZGUtZHVwZSB3aGlsZVxuICAgIC8vIHdlJ3JlIGF0IGl0KS5cbiAgICBhbGlhc0FycmF5cy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhc0FycmF5KSB7XG4gICAgICAgIGFsaWFzQXJyYXkgPSBhbGlhc0FycmF5LmZpbHRlcihmdW5jdGlvbiAodiwgaSwgc2VsZikge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaW5kZXhPZih2KSA9PT0gaTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGxhc3RBbGlhcyA9IGFsaWFzQXJyYXkucG9wKCk7XG4gICAgICAgIGlmIChsYXN0QWxpYXMgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgbGFzdEFsaWFzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29tYmluZWRbbGFzdEFsaWFzXSA9IGFsaWFzQXJyYXk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY29tYmluZWQ7XG59XG4vLyB0aGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuIGEgY291bnQgaXMgZ2l2ZW4gYXMgYW4gYXJnXG4vLyBpdCBpcyBOT1QgY2FsbGVkIHRvIHNldCBhIGRlZmF1bHQgdmFsdWVcbi8vIHRodXMgd2UgY2FuIHN0YXJ0IHRoZSBjb3VudCBhdCAxIGluc3RlYWQgb2YgMFxuZnVuY3Rpb24gaW5jcmVtZW50KG9yaWcpIHtcbiAgICByZXR1cm4gb3JpZyAhPT0gdW5kZWZpbmVkID8gb3JpZyArIDEgOiAxO1xufVxuLy8gVE9ETyhiY29lKTogaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiB5YXJncywgc3dpdGNoIHRvXG4vLyBPYmplY3QuY3JlYXRlKG51bGwpIGZvciBkb3Qgbm90YXRpb246XG5mdW5jdGlvbiBzYW5pdGl6ZUtleShrZXkpIHtcbiAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJylcbiAgICAgICAgcmV0dXJuICdfX19wcm90b19fXyc7XG4gICAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIHN0cmlwUXVvdGVzKHZhbCkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgKHZhbFswXSA9PT0gXCInXCIgfHwgdmFsWzBdID09PSAnXCInKSAmJlxuICAgICAgICB2YWxbdmFsLmxlbmd0aCAtIDFdID09PSB2YWxbMF0pXG4gICAgICAgID8gdmFsLnN1YnN0cmluZygxLCB2YWwubGVuZ3RoIC0gMSlcbiAgICAgICAgOiB2YWw7XG59XG4iXSwibmFtZXMiOlsidG9rZW5pemVBcmdTdHJpbmciLCJEZWZhdWx0VmFsdWVzRm9yVHlwZUtleSIsImNhbWVsQ2FzZSIsImRlY2FtZWxpemUiLCJsb29rc0xpa2VOdW1iZXIiLCJtaXhpbiIsIllhcmdzUGFyc2VyIiwiY29uc3RydWN0b3IiLCJfbWl4aW4iLCJwYXJzZSIsImFyZ3NJbnB1dCIsIm9wdGlvbnMiLCJvcHRzIiwiT2JqZWN0IiwiYXNzaWduIiwiYWxpYXMiLCJ1bmRlZmluZWQiLCJhcnJheSIsImJvb2xlYW4iLCJjb25maWciLCJjb25maWdPYmplY3RzIiwiY29uZmlndXJhdGlvbiIsImNvZXJjZSIsImNvdW50IiwiZGVmYXVsdCIsImVudlByZWZpeCIsIm5hcmciLCJub3JtYWxpemUiLCJzdHJpbmciLCJudW1iZXIiLCJfXyIsImtleSIsImFyZ3MiLCJpbnB1dElzU3RyaW5nIiwiYWxpYXNlcyIsImNvbWJpbmVBbGlhc2VzIiwiY3JlYXRlIiwiZGVmYXVsdHMiLCJub3RGbGFnc09wdGlvbiIsIm5vdEZsYWdzQXJndiIsIm5ld0FsaWFzZXMiLCJkZWZhdWx0ZWQiLCJmb3JtYXQiLCJmbGFncyIsImFycmF5cyIsImJvb2xzIiwic3RyaW5ncyIsIm51bWJlcnMiLCJjb3VudHMiLCJjb25maWdzIiwibmFyZ3MiLCJjb2VyY2lvbnMiLCJrZXlzIiwibmVnYXRpdmUiLCJuZWdhdGVkQm9vbGVhbiIsIlJlZ0V4cCIsImNvbmNhdCIsImZpbHRlciIsIkJvb2xlYW4iLCJmb3JFYWNoIiwib3B0IiwiYXNzaWdubWVudCIsIm1hcCIsImFycmF5RmxhZ0tleXMiLCJwb3AiLCJwdXNoIiwiZW50cmllcyIsInZhbHVlIiwiQXJyYXkiLCJpc0FycmF5IiwiZXh0ZW5kQWxpYXNlcyIsImVycm9yIiwiY2hlY2tDb25maWd1cmF0aW9uIiwibm90RmxhZ3MiLCJhcmd2IiwiXyIsImFyZ3ZSZXR1cm4iLCJpIiwibGVuZ3RoIiwiYXJnIiwidHJ1bmNhdGVkQXJnIiwicmVwbGFjZSIsImJyb2tlbiIsImxldHRlcnMiLCJtIiwibmV4dCIsInRlc3QiLCJpc1Vua25vd25PcHRpb25Bc0FyZyIsInB1c2hQb3NpdGlvbmFsIiwibWF0Y2giLCJjaGVja0FsbEFsaWFzZXMiLCJlYXRBcnJheSIsImVhdE5hcmdzIiwic2V0QXJnIiwiZGVmYXVsdFZhbHVlIiwic2xpY2UiLCJzcGxpdCIsImoiLCJhcHBseUVudlZhcnMiLCJzZXRDb25maWciLCJzZXRDb25maWdPYmplY3RzIiwiYXBwbHlEZWZhdWx0c0FuZEFsaWFzZXMiLCJhcHBseUNvZXJjaW9ucyIsInNldFBsYWNlaG9sZGVyS2V5cyIsImhhc0tleSIsImluY2x1ZGVzIiwiayIsInByb3AiLCJqb2luIiwibWF5YmVDb2VyY2VkTnVtYmVyIiwibWF5YmVDb2VyY2VOdW1iZXIiLCJhcmdBZnRlckVxdWFsU2lnbiIsImlpIiwidG9FYXQiLCJpc05hTiIsImlzVW5kZWZpbmVkIiwiRXJyb3IiLCJhdmFpbGFibGUiLCJjb25zdW1lZCIsIk1hdGgiLCJtaW4iLCJhcmdzVG9TZXQiLCJuYXJnc0NvdW50IiwiZGVmVmFsIiwicHJvY2Vzc1ZhbHVlIiwidmFsIiwic2hvdWxkU3RyaXBRdW90ZXMiLCJhZGROZXdBbGlhcyIsInNwbGl0S2V5Iiwic2V0S2V5IiwieCIsImtleVByb3BlcnRpZXMiLCJhIiwic2hpZnQiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJzZXQiLCJzdHJpcFF1b3RlcyIsInYiLCJpbmNyZW1lbnQiLCJzaG91bGRDb2VyY2VOdW1iZXIiLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiZmxvb3IiLCJwYXJzZUZsb2F0IiwiY29uZmlnTG9va3VwIiwiY29uZmlnS2V5IiwiY29uZmlnUGF0aCIsInJlc29sdmVkQ29uZmlnUGF0aCIsInJlc29sdmUiLCJjd2QiLCJyZXNvbHZlQ29uZmlnIiwiZSIsInJlcXVpcmUiLCJzZXRDb25maWdPYmplY3QiLCJleCIsIm5hbWUiLCJwcmV2IiwiZnVsbEtleSIsImNvbmZpZ09iamVjdCIsImNvbmZpZ09ubHkiLCJwcmVmaXgiLCJlbnYiLCJlbnZWYXIiLCJsYXN0SW5kZXhPZiIsInN1YnN0cmluZyIsImFwcGxpZWQiLCJTZXQiLCJoYXMiLCJhbGkiLCJhZGQiLCJlcnIiLCJpbmRleE9mIiwib2JqIiwiY2FuTG9nIiwibyIsInNhbml0aXplS2V5IiwiaXNUeXBlQXJyYXkiLCJpc1ZhbHVlQXJyYXkiLCJkdXBsaWNhdGUiLCJjIiwieSIsImZsYWciLCJ0b0NoZWNrIiwic2V0QWxpYXMiLCJmaW5kIiwiaGFzQW55RmxhZyIsImZsYWdzS2V5cyIsInNvbWUiLCJoYXNGbGFnc01hdGNoaW5nIiwicGF0dGVybnMiLCJwYXR0ZXJuIiwiaGFzQWxsU2hvcnRGbGFncyIsImhhc0FsbEZsYWdzIiwiaXNVbmtub3duT3B0aW9uIiwiZmxhZ1dpdGhFcXVhbHMiLCJub3JtYWxGbGFnIiwiZmxhZ0VuZGluZ0luSHlwaGVuIiwiZmxhZ0VuZGluZ0luRGlnaXRzIiwiZmxhZ0VuZGluZ0luTm9uV29yZENoYXJhY3RlcnMiLCJkZWZhdWx0Rm9yVHlwZSIsImd1ZXNzVHlwZSIsInR5cGUiLCJkZWYiLCJCT09MRUFOIiwiU1RSSU5HIiwiTlVNQkVSIiwiQVJSQVkiLCJudW0iLCJhbGlhc0FycmF5cyIsImNvbWJpbmVkIiwiY2hhbmdlIiwiaW50ZXJzZWN0Iiwic3BsaWNlIiwiYWxpYXNBcnJheSIsInNlbGYiLCJsYXN0QWxpYXMiLCJvcmlnIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/yargs-parser/build/lib/yargs-parser.js\n");

/***/ })

};
;